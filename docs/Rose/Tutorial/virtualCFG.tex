\chapter{Virtual CFG}

The ROSE virtual control flow graph interface provides a higher level of
detail than ROSE's other control flow graph interfaces.  It expresses
control flow even within expressions, and handles short-circuited logical
and conditional operators properly\footnote{It assumes operands of
expressions are computed in left-to-right order, unlike the actual language
semantics, however.}.  The interface is referred to as ``virtual'' because
no explicit graph is ever created: only the particular CFG nodes and edges
used in a given program ever exist.  CFG nodes and edges are value classes
(they are copied around by value, reducing the need for explicit memory
management).

A CFG node consists of two components: an AST node pointer, and an index of
a particular CFG node within that AST node.  There can be several CFG nodes
corresponding to a given AST node, and thus the AST node pointers cannot be
used to index CFG nodes.  The particular index values for the different AST
node types are explained in Section~\ref{cfg_index_values}.

\section{Important functions}

The main body of the virtual CFG interface is in \lstinline{virtualCFG.h};
the source code is in \lstinline{src/frontend/SageIII/virtualCFG/} and is
linked into \lstinline{librose}.  The filtered CFG interface explained
below is in \lstinline{filteredCFG.h}, and functions for converting the CFG
to a graph in Dot format are in \lstinline{cfgToDot.h}.

Two functions provide the basic way of converting from AST nodes to CFG
nodes.  Each \lstinline{SgNode} has two methods,
\lstinline{cfgForBeginning()} and \lstinline{cfgForEnd()}, to generate the
corresponding CFG nodes.  These functions require that the AST node is
either an expression, a statement, or a \lstinline{SgInitializedName}.  The
beginning node represents the point in the control flow immediately before
the construct starts to execute, and the ending node represents the point
immediately after the construct has finished executing.  Note that these
two nodes do not dominate the other CFG nodes in the construct due to
\lstinline{goto} statements and labels.

\subsection{Node methods}

\begin{itemize}
\item \lstinline{CFGNode(SgNode* node, unsigned int index)}: Build a CFG
node from the given AST node and index.  Valid index values are in
Section~\ref{cfg_index_values}.
\item \lstinline{toString()}: Produce a string representing the information
in the node.
\item \lstinline{toStringForDebugging()}: Similar, but with more internal
debugging information.
\item \lstinline{id()}: A C identifier representing the node.
\item \lstinline{getNode()}: Get the underlying AST node.
\item \lstinline{getIndex()}: Get the index (as explained in
Section~\ref{cfg_index_values}) for this CFG node within its underlying AST
node.
\item \lstinline{outEdges()}: Return a vector of outgoing CFG edges from
this node.
\item \lstinline{inEdges()}: Return a vector of CFG edges coming into this
node (note that the sources and targets of the edges are not reversed, and
so each in edge has its target as the current node).
\item \lstinline{isInteresting()}: See
Section~\ref{interesting_node_filter}.
\item Nodes are also comparable using the operators \lstinline{==},
\lstinline{!=}, and \lstinline{<}.
\end{itemize}

\subsection{Edge methods}

\begin{itemize}
\item \lstinline{toString()}: Produce a string representing the information
      in the node.
\item \lstinline{toStringForDebugging()}: Similar, but with more internal
      debugging information.
\item \lstinline{id()}: A C identifier representing the node.
\item \lstinline{source()}: The starting CFG node for this edge.
\item \lstinline{target()}: The ending CFG node for this edge.
\item \lstinline{condition()}: When there are multiple CFG edges from the
      same starting node, each of them is taken under certain conditions.  The
\lstinline{condition()} method returns the condition, of type
\lstinline{EdgeConditionKind}.  The possible return values are:
  \begin{itemize}
  \item \lstinline{eckUnconditional}: An edge that is always taken.
  \item \lstinline{eckTrue}: True case of a two-way branch (either an
                             \lstinline{if} statement or a loop
  \item \lstinline{eckFalse}: False case of a two-way branch
  \item \lstinline{eckCaseLabel}: Case label in a \lstinline{switch} statement (key is given by \lstinline{caseLabel()})
  \item \lstinline{eckDefault}: Default label of a \lstinline{switch} statement
  \item \lstinline{eckDoConditionPassed}: Enter Fortran \lstinline{do} loop body
  \item \lstinline{eckDoConditionFailed}: Fortran \lstinline{do} loop finished
  \item \lstinline{eckForallIndicesInRange}: Start testing \lstinline{forall} mask
  \item \lstinline{eckForallIndicesNotInRange}: End of \lstinline{forall} loop
  \item \lstinline{eckComputedGotoCaseLabel}: Case in computed \lstinline{goto} -- number needs to be computed separately
  \item \lstinline{eckArithmeticIfLess}: Edge for the arithmetic \lstinline{if} expression being less than zero
  \item \lstinline{eckArithmeticIfEqual}: Edge for the arithmetic \lstinline{if} expression being equal to zero
  \item \lstinline{eckArithmeticIfGreater}: Edge for the arithmetic \lstinline{if} expression being greater than zero
  \end{itemize}
\item \lstinline{caseLabel()}: For an edge with condition
      \lstinline{eckCaseLabel}, an expression representing the key for the case
      label.
\item \lstinline{computedGotoCaseIndex()}: The index of this edge's case
      within a Fortran computed \lstinline{goto} (an edge of kind
      \lstinline{eckComputedGotoCaseLabel}).
\item \lstinline{conditionBasedOn()}: The test expression or
      \lstinline{switch} expression that is tested by this edge.
\item \lstinline{scopesBeingExited()}, \lstinline{scopesBeingEntered()}:
      Variables leaving and entering scope during this edge.  This information
      has not been extensively verified, and should not be relied upon.
\item Edges can also be compared using the operators \lstinline{==} and
      \lstinline{!=}.  They are not ordered to avoid dependencies on pointer
      comparison on different computers.
\end{itemize}

\section{Drawing a graph of the CFG}

FIXME, add example from tutorial/virtualCFG.C

\includegraphics{\TutorialExampleBuildDirectory/vcfg.pdf}

\section{Index values}
\label{cfg_index_values}

FIXME

\section{Robustness to AST changes}

Control flow graph nodes and edges can be kept (i.e., are not invalidated)
in many cases when the underlying AST changes.  However, there are some
limitations to this capability.  Changing the AST node that is pointed to
by a given CFG node is not safe.  CFG nodes for deleted AST nodes are of
course invalid, as are those pointing to AST nodes whose parent pointers
become invalid.

\section{Limitations}

Although workable for intraprocedural analysis of C code, the virtual CFG
code has several limitations for other languages and uses.

\subsection{Fortran support}

The virtual control flow graph includes support for many Fortran
constructs, but that support is fairly limited and not well tested.  It is
not recommended for production use.

\subsection{Exception handling}

The virtual CFG interface does not support control flow due to exceptions
or the \lstinline{setjmp}/\lstinline{longjmp} constructs.
It does, however, support \lstinline{break}, \lstinline{continue},
\lstinline{goto}, and early returns from functions.

\subsection{Interprocedural control flow analysis}

A limited form of interprocedural control flow analysis is supported.  That
feature is enabled with a global variable named
\lstinline{interproceduralControlFlowGraph}.  Setting that variable to
\lstinline{true} changes the out edges of function calls and the in edges
of nodes just after function calls when the function references are known.
Although this causes interprocedural behavior, it also leads to a mismatch
between the in and out edges between certain pairs of nodes.  Solving this
problem would require a precomputed call graph for the program, which
defeats the goal of not requiring any precomputed or cached information to
traverse the control flow graph.

\section{Node filtering}

FIXME

\subsection{``Interesting'' node filter}
\label{interesting_node_filter}

\subsection{Arbitrary filtering}

% \section{Control flow graph on binaries}
