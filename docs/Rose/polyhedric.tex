\chapter{Dependence analysis and Polyhedric Model}

\label{polyhedric:polyhedric}

	This chapter reffers to the project PolyhedralDependenceAnalysis.

	\section{What can I find in this project ?}
	
	Each subsection is related to a subdirectory in the project.
	
		\subsection{RoseToFada}
	
	The project's subdirectory RoseToFada contains a translator from Rose IR (SageIII) to FadaLib IR.\\
	FADAlib \cite{FADAweb} is an implementation of Fuzzy Array Dependence Analysis \cite{FADA}. FADA is an 
analysis for non static control programs (or irregular programs).\\
	Here, we reduce the scope of the transformation to static control programs \cite{Feautrier} to fit with 
following part. It means that support of conditionals and while-loops is not implement (but can be).\\
	Also, the translation don't address structure and complex-types.\\
	
	So, the subset of C that is address by this analysis contains only:
\begin{itemize}
	\item for-loop: for (i = a; i <= b; i++)
	\item scalar variable
	\item array reference with index that are affine application: a[i + 2*j][3*i + 5]
\end{itemize}
	
		\subsection{PMDAtoMDA}
	
	Pseudo-multidimensional array are frequently used, but this representation is out of the scope of FADAlib
(array index are not an affine application: a[i * n + j]).\\
	The component PMDAtoMDA can traverse a function in Rose IR and add an attribute to all pseudo-multidimensional
array. This attribute can generate (in Rose IR) each component of the correspondant access vector.\\
	But, that no magic and highly constraint: we need tab[i * n * m + j * n + k] instead of tab[i][j][k] for an
array of dimension [X, m, n] (i, j, k can be any affine form of the iterators).
	
		\subsection{RoseToPPL}
		
	Parma Polyhedral Library \cite{PPL} is a C++, object-oriented polyhedron manipulation library.\\
	This component generate a polyhedral representation of dependences from FadaLib analysis.
	
		\subsection{Schedule}
		
	It's an experimental implementation of the Farkas Multipliers Method to obtains the space (polyhedron) of 
valid schedule with respect to the dependances found by the Fuzzy Array Dependence Analysis.

	\section{What I need to compile this project with Rose ?}

	Pseudo-multidimensional array related part has no extra-dependences.
	
		\subsection{RoseToFada}
	
	FadaLib \cite{FADAweb} is needed and depend from PipLib (Parametric Integer Programming Library)
\cite{PIP}.
	You need to add following options to configure script:
\begin{verbatim}
--with-pip=PATH
--with-fada=PATH
--enable-fadalib=yes
\end{verbatim}
	
		\subsection{RoseToPPL and Schedule}

	Theses components depend from RoseToFada.\\
	Both use Parma Polyhedral Library \cite{PPL} to represent polyhedrons.\\
	You need to add following options to configure script:
\begin{verbatim}
--with-ppl=PATH
--enable-ppl=yes
\end{verbatim}
		

	\section{And now a few maths !}

More about "polyhedral representation of dependences".

		\subsection{Integer Polyhedron}

A integer polyhedron (which would be the only polyhedron that we will consider) is a set of integers points.

$\forall n \in \mathbb{N}, \mathbb{P} = \{\bar{z} \in \mathbb{N}^{n} | \mathcal{P}(\bar{z}) \geq 0 \}$ where:
\begin{itemize}
	\item $n$ is the dimension of the polyhedron
	\item $\mathcal{P}: \mathbb{N}^{n} \rightarrow \mathbb{N}^{m}$ is an affine application
	\item $m$ is the number of intersected half-space
\end{itemize}
($\bar{z} \geq 0$ means $\forall i, z_{i} \geq 0$)

		\subsection{Program}

All considered programs are on the scope of Affine Control Loop (ACL), follow some notation:
\begin{itemize}
	\item $\mathbb{G}$ the set of Global variables: scalars from global scope (ex: array size).\\
	We will note $\bar{g}$ an element of $\mathbb{G}$.
	\item A set of statement $\mathbb{S}$, define by:
	\begin{itemize}
		\item An iteration domain: $\mathbb{D} = \{\bar{z} | f(\bar{z}, \bar{g}) \geq 0\}$ where f is an affine
				form $f: \mathbb{N}^{n} \times \mathbb{G} \rightarrow \mathbb{N}$ where n is the number
				of iterators.
		\item Two set of variables: read and write.\\
		A variable can be a scalar or an array element. In second case, the access vector to this element need to
		be an affine application $f: \mathbb{D} \times \mathbb{G} \rightarrow \mathbb{N}^{dim(array)}$
	\end{itemize}
\end{itemize}

		\subsection{Dependence Graph}

We consider the graph of dependence $\Gamma$, in this directed graph, nodes are statement and vertex are dependence.
Vertex are qualified with the conditions of the dependence.\\
Given two statements $S_{1}$ and $S_{2}$ with $\mathbb{D}_{1}$ and $\mathbb{D}_{2}$ theirs iterations domains.
A vertex from $S_{1}$ to $S_{2}$ will be qualified by:
\begin{itemize}
	\item a condition $q_{1 \rightarrow 2}(\bar{z}, \bar{g}) \geq 0$ where $q_{1 \rightarrow 2}$ is an affine application
		$q_{1 \rightarrow 2}: \mathbb{D}_{1} \times \mathbb{G} \rightarrow \mathbb{N}^{n}$ where is the number of
		sub-conditions.
	\item an affine application $f_{1 \rightarrow 2} : \mathbb{D}_{1} \rightarrow \mathbb{D}_{2}$
\end{itemize}
This mean that the statement $S_{1}$ at iteration point $\bar{z} \in \mathbb{D}_{1}$ depends on $S_{2}$ at iteration point
$f_{1 \rightarrow 2}(\bar{z}) \in \mathbb{D}_{1}$ if $q_{1 \rightarrow 2}(\bar{z}, \bar{g}) \geq 0$.\\

		\subsection{Polyhedron associate to a dependence}

An affine application $f: \mathbb{E}_{1} \rightarrow \mathbb{E}_{2}$ can be represent as a polyhedron
$\mathbb{P} \subset \mathbb{E}_{1} \times \mathbb{E}_{2}$.\\
Given $\mathbb{P}_{1 \rightarrow 2} \subset \mathbb{N}^{n_{1} + n_{2} + n_{g}}$ where $n_{1}$ and $n_{2}$ and $n_{g}$ are
respectively the number of iterators of $S_{1}$ and $S_{2}$, and the number of globals.\\

$\mathbb{P}_{1 \rightarrow 2}$ will be the polyhedron associate to the dependence between $S_{1}$ and $S_{2}$ iff:
%\begin{center}
%$\forall (\bar{z_{1}}, \bar{z_{2}}, \bar{g}) \in \mathbb{D}_{1} \times \mathbb{D}_{2} \times \mathbb{G}$
%
%( $q_{1 \rightarrow 2}(\bar{z_{1}}, \bar{g}) \geq 0 \wedge \bar{z_{2}} = f_{1 \rightarrow 2}(\bar{z_{1}})$ )
%
%$\Leftrightarrow$
%
%$(\bar{z_{1}}, \bar{z_{2}}, \bar{g}) \in \mathbb{P}_{1 \rightarrow 2}$
%\end{center}
%An other version of $\mathbb{P}_{1 \rightarrow 2}$, more restrictive, that consider also the domains (this one is use ):
\begin{center}
$\forall (\bar{z_{1}}, \bar{z_{2}}, \bar{g}) \in \mathbb{N}^{n_{1} + n_{2} + n_{g}}$

($\bar{z_{1}} \in \mathbb{D}_{1} \wedge \bar{z_{2}} \in \mathbb{D}_{2} \wedge \bar{g} \in \mathbb{G} \wedge q_{1 \rightarrow 2}(\bar{z_{1}}, \bar{g}) \geq 0 \wedge \bar{z_{2}} = f_{1 \rightarrow 2}(\bar{z_{1}})$ )

$\Leftrightarrow$

$(\bar{z_{1}}, \bar{z_{2}}, \bar{g}) \in \mathbb{P}_{1 \rightarrow 2}$
\end{center}

		\subsection{Example}

\begin{figure}[!h]	
\begin{lstlisting}[language=C, numbers=left]
for (i = 0; i < n; i++) {
    s[i] = 0
    for (j = 0; j < n; j++) {
        s[i] = s[i] + a[i][j] * x[j]
    }
}
\end{lstlisting}
\caption{A sample program}
\label{polyhedric:sampleprogram}
\end{figure}

			\subsubsection{Program}

Consider the small program of figure \ref{polyhedric:sampleprogram}. It contains a reference to one global variable
$\mathbb{G} = \{ n \}$ and we have two statement $S_{1}$ and $S_{2}$, respectively at line 2 and 4, with associated domains:

$\mathbb{D}_{1} = \{ i | 0 \leq i \leq n - 1 \}$ 

$\mathbb{D}_{2} = \{ i, j | 0 \leq i, j \leq n - 1 \}$

			\subsubsection{Dependences}

A dependence analysis (from FADAlib for example) would give us:
\begin{itemize}
	\item $S_{1}$ has no dependence (it never read a variable)
	\item $S_{2}$ has dependence at iteration point $( i, j )$:
	\begin{itemize}
		\item on $S_{1}$ at iteration point $( i )$: if $j = 0$ 
		\item on $S_{2}$ at iteration point $( i, j - 1 )$: if $j \geq 1$ 
	\end{itemize}
\end{itemize}

So, the dependence graph is composed from two nodes $\{S_{1}, S_{2}\}$ and two edges:
\begin{itemize}
	\item $S_{2} \rightarrow S_{1}$
	\begin{itemize}
		\item $q_{S_{2} \rightarrow S_{1}}(i, j, n) = (j, -j)$
		\item $f_{S_{2} \rightarrow S_{1}}(i, j) = (i)$
	\end{itemize}
	\item $S_{2} \rightarrow S_{2}$
	\begin{itemize}
		\item $q_{S_{2} \rightarrow S_{2}}(i, j, n) = j - 1$
		\item $f_{S_{2} \rightarrow S_{2}}(i, j) = (i, j - 1)$
	\end{itemize}
\end{itemize}

			\subsubsection{Polyhedron}

We have two dependances, then two polyhedrons 
\begin{itemize}
	\item $\mathbb{P}_{S_{2} \rightarrow S_{1}}$ associate with the following affine application:\\
	$\mathcal{P}_{S_{2} \rightarrow S_{1}}: \mathbb{N}^{2 + 1 + 1} \rightarrow  \mathbb{N}^{4 + 2 + 2 + 2} $\\
	$$\mathcal{P}_{S_{2} \rightarrow S_{1}}(i, j, i', n) = 
	\begin{array}{cccc}
		1  & 0  & 0  & 0 \\
		-1 & 0  & 0  & 1 \\
		0  & 1  & 0  & 0 \\
		0  & -1 & 0  & 1 \\
		0  & 0  & 1  & 0 \\
		0  & 0  & -1 & 1 \\
		0  & 1  & 0  & 0 \\
		0  & -1 & 0  & 0 \\
		1  & 0  & -1 & 0 \\
		-1 & 0  & 1  & 0 \\
	\end{array}
	\times
	\begin{array}{c}
		i  \\
		j  \\
		i' \\
		n  \\
	\end{array}
	+
	\begin{array}{c}
		0  \\
		-1 \\
		0  \\
		-1 \\
		0  \\
		-1 \\
		0  \\
		0  \\
		0  \\
		0  \\
	\end{array}$$
	\item $\mathbb{P}_{S_{2} \rightarrow S_{2}}$ associate with the following affine application:\\
	$\mathcal{P}_{S_{2} \rightarrow S_{2}}: \mathbb{N}^{2 + 2 + 1} \rightarrow  \mathbb{N}^{4 + 4 + 1 + 4} $\\
	$$\mathcal{P}_{S_{2} \rightarrow S_{2}}(i, j, i', j', n) = 
	\begin{array}{ccccc}
		1  & 0  & 0  & 0  & 0  \\
		-1 & 0  & 0  & 0  & 1  \\
		0  & 1  & 0  & 0  & 0  \\
		0  & -1 & 0  & 0  & 1  \\
		0  & 0  & 1  & 0  & 0  \\
		0  & 0  & -1 & 0  & 1  \\
		0  & 0  & 0  & 1  & 0  \\
		0  & 0  & 0  & -1 & 1  \\
		0  & 1  & 0  & 0  & 0  \\
		1  & 0  & -1 & 0  & 0  \\
		-1 & 0  & 1  & 0  & 0  \\
		0  & 1  & 0  & -1 & 0  \\
		0  & -1 & 0  & 1  & 0  \\
	\end{array}
	\times
	\begin{array}{c}
		i  \\
		j  \\
		i' \\
		j' \\
		n  \\
	\end{array}
	+
	\begin{array}{c}
		0  \\
		-1 \\
		0  \\
		-1 \\
		0  \\
		-1 \\
		0  \\
		-1 \\
		-1 \\
		0  \\
		0  \\
		1  \\
		-1 \\
	\end{array}$$
\end{itemize}


	\section{Generating affine schedule with polyhedric model}

		\subsection{What is this ?}

	Says  that an operation is the execution of statement $S \in \mathbb{S}$ at an iteration point 
$\bar{z} \in \mathbb{D}_{S}$, we will note it $\leq S, \bar{z} \geq$.\\
	A schedule $\omega$ will associate a date to an operation. An affine schedule is a set of affine applications
$\omega_{S}: \mathbb{D}_{S} \times \mathbb{G} \rightarrow \mathbb{N}^{n}$ where $n$ is the dimension of the schedule (date).

		\subsection{Currently in the project}

	We look for 1-dimensional schedules only.

			\subsubsection{Farkas algorithm}



			\subsubsection{Implementation}

