\chapter{ FAQ }

\label{faq:introduction}

This chapter accumulates frequently ask questions (FAQ) about ROSE. The questions are not
created by the authors (such FAQs are not particularly useful).

\begin{enumerate}

\item Is ROSE a preprocessor, a translator, or a compiler? \\
   Technically, no! ROSE is formally a meta-tool, a tool for building tools.
{\em ROSE is an object-oriented framework for building source-to-source translators.}
A preprocessor knows nothing of the syntax or semantics of the
language being preprocessed, typically it recognizes another embedded language
within the input file (or attempts to recognize subsets of source language).  In 
contrast, translators process the input language with precision identical to a
compiler.  Since ROSE helps build source-to-source translators, we resist calling
the translators compilers, since the output is not machine code.  This point is
not a required part of the definition of a compiler, many language compilers use
a particular language as an assembly language level (typically {\tt C}).  These
are no less a compiler.  But since we do source-to-source, we feel uncomfortable with
calling the translators compilers (the output language is typically the {\em same} 
as the input language).  The point is further muddled since it is
common in ROSE to have a translator hide the call to the vendor's compiler and thus
the translator can be considered to generate machine code. But this gives little
credit to the vendor's compiler.  So we prefer to refer to our work as a tool 
(or framework) for building source-to-source translators.

\item What does the output from a ROSE translator look like? \\
   A great deal of effort has been made to preserve the quality of your 
original code when regenerated by a translator built using ROSE.
ROSE preserves all formatting, comments, and preprocessor control 
structure.  There are examples in the ROSE Tutorial that make this point clear.

\item How do I debug my transformation? \\
   There are a couple of ways to debug your transformation, but in general
the process starts with knowing exactly what you want to accomplish.
An example of your transformation on a specific input code is particularly useful.
Depending on the type of transformation, there are different mechanisms within 
ROSE to support the development of a transformation.  Available mechanisms
include (in decreasing levels of abstractions):
\begin{enumerate}
   \item String-Based Specification. \\
      A transformation may specify new code to be inserted into the AST
      by specifying the new code as a source code string.  Functions are
      included to permit {\tt insert(), replace(), remove()}.
   \item Calling Predefined Transformations. \\
      There are a number of predefined optimizing transformations (loop optimizations) 
      that may be called directly within a translator built using ROSE.
   \item Explicit AST Manipulation. \\
      The lowest level is to manipulate the AST directly.  Numerous functions
      within SAGE III are provided to support this, but of course it is rather 
      tedious.
\end{enumerate}

\commentout{
\item How do I use the database? \\
   ROSE has a connection to MySQL, but you must run configure with the
correct command-line options to enable it.  Example scripts to configure
ROSE to use MySQL are in the {\tt ROSE/scripts} directory. Another detail 
is that MySQL development generally lags ROSE in the use of the newest 
versions of compilers. So you are likely to be forced to use an older 
version of your compiler (particularly with GNU g++).
}

\item How do I use the SQLite database? \\
   ROSE has a connection to SQLite, but you must run configure with the
correct command-line options to enable it.  Example scripts to configure
ROSE to use SQLite are in the {\tt ROSE/scripts} directory. Another detail 
is that SQLite development generally lags behind ROSE in the use of the newest 
versions of compilers. So you are likely to be forced to use an older 
version of your compiler (particularly with GNU g++).

\item What libraries and include paths do I need to build an application using ROSE. \\
      Run {\tt make installcheck} and observe the command lines used to
      compile the example applications.  These command lines will be what you will
      want to reproduce in your {\tt Makefile}.

\item Where is the {\tt SgTypedefSeq} used? \\
    Any type may be hidden behind a chain of {\em typedefs}. The typedef sequence is the
    list of typedefs that have been applied to any given type.

\item Why are there defining and non-defining declarations? \\

{\indent
{\mySmallFontSize
\begin{verbatim}
     class X;            // non-defining declaration
     X* foo();           // return type of function will refer to non-defining declaration
     X* xPointer = NULL; // Again, the type will refer to a pointer-to-a-type that will be the non-defining declaration.
     class X {};         // defining declaration
\end{verbatim}
}}

The traversal will visit the declarations, so you will, in this case, see the {\tt class X;}
class declaration and the {\tt class X {};} class declaration.  In general, all references to
the class X will use the non-defining declaration, and only the location were X is defined
will be a defining declaration.  This is discussed in great detail in the chapter on SAGE III of 
the ROSE User Manual and a bit in the Doxygen Web pages.

In general, while unparsing, we can't be sure where the definitions associated with
declarations are in the AST (without making the code generation significantly more
complex).
{\indent
{\mySmallFontSize
\begin{verbatim}
     class X;
     class X{};
\end{verbatim}
}}
could be unparsed as:
{\indent
{\mySmallFontSize
\begin{verbatim}
     class X {};  // should have been "class X;"
     class X;     // should have been "class X {};"
\end{verbatim}
}}
The previous example hardly communicates the importance of this concept, but perhaps this
one does:
{\indent
{\mySmallFontSize
\begin{verbatim}
     class X;
     class Y {};
     class X { Y y };
\end{verbatim}
}}
would not compile if unparsed as:
{\indent
{\mySmallFontSize
\begin{verbatim}
     class X { Y y };
     class Y {};
     class X
\end{verbatim}
}}
Note that we can't just make a declaration as being a defining declarations since they are
shared internally (types and symbols can reference them, etc.).



\item Why are comments and CPP directives following the statements being 
      removed and reinserted elsewhere?
      I have been working on a translator, based on the 
      {\tt ROSE/tutorial/CharmSupport.C} translator. If an include statement is in the 
      top of the input code, then the struct added to the top of the source 
      file will contain the include statements in an obviously bad place:
{\indent
{\mySmallFontSize
\begin{verbatim}
     struct AMPI_globals_t
        {
       // A Comment
     #include "stdio.h"
          int a_global_int;
        };
\end{verbatim}
}}
   I am specifying the end of construct for the SgClassDefinition to be 
{\tt Sg\_File\_Info::generateDefaultFileInfoForTransformationNode();} The class 
declaration is prepended into the global scope. How do I correctly 
insert the new definition and declaration into the top of a file(either 
before or after the include statements).

% Thanks,
% Isaac Dooley

The answer, for anyone interested, is found in a discussion relative to the ROSE Tutorial
example (Global Variable Handling, currently Chapter 30).  

The problem is that comments and preprocessor ({\tt cpp}) directives
are attached to the statements. When I wrote the tutorial example
showing how to collect the global variables and put them into a 
data structure, I was not careful to use the low level rewrite mechanism
to do the removal of the variable declarations from the global scope
and the insertion of the same variable declarations into the scope of
the class declaration (the struct that holds the previously global 
variables).  Since the comments and {\tt cpp} directives were attached to
the variable declaration, they got moved with the declaration into the 
new struct that holds them (see the example in the tutorial).

   I should have used the rewrite's mechanism for removing and
reinserting the variable declarations since it is careful to 
disassociate and reassociate comments and cpp directives.
In fact, it is quite incredible that I didn't use that 
slightly higher level interface, because I wrote all that stuff
several years ago and it was so much work to get it all correct.
I'm a big believer in using the highest level of interfaces
possible (which perhaps means I should document them better 
in the Web pages for the IR instead of just in the ROSE User Manual).

The AST Rewrite Mechanism functions to use are the 
{\indent
{\mySmallFontSize
\begin{verbatim}
     LowLevelRewrite::remove ( SgStatement* astNode )
\end{verbatim}
}}
and 
{\indent
{\mySmallFontSize
\begin{verbatim}
     LowLevelRewrite::insert ( SgStatement* targetStatement, SgStatementPtrList newStatementList, bool insertBeforeNode ).
\end{verbatim}
}}

These will automatically disassociate any {\tt cpp} directives and comments
from the surrounding statements and reattach them so that they don't
wander around with the statements being removed, inserted, or replaced.

I will try to get to fixing up the ROSE Tutorial example so use this
interface.  Rich and I have been spending a lot of time on the Tutorial 
lately (after finishing the ROSE User Manual two weeks ago).  We are getting
all the documentation ready for release on the web.  This will likely 
happen in a few weeks, though all the paperwork and approvals are already
in place.

So as it is, this is a wonderful example of just what a bad idea it is
to manipulate the AST at such a low level.
%; using the IR's insert, replace, and remove member functions. 
It is the reason we have the AST Rewrite Mechanism -- provide the highest level
of interface required to make manipulation generally more simple.

% OK, I guess I learned my lesson here :-), back to work, thanks,
% Dan

\end{enumerate}
