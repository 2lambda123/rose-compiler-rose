/*************************************************************************************************************************
 *                                         DWARF
 * These are a subset (but most of) the possible Dwarf Tags, I [DQ] have skipped some of the architecture specific tags
 * (except for GNU).  There are about 63 new IR nodes here. These are kinds of language constructs that are stored in the
 * ".debug_info" section when dwarf debug information is available (generated by the compiler) in the binary executable.
 *************************************************************************************************************************/

#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <sage3basic.h>

SgAsmDwarfConstructList*
SgAsmDwarfArrayType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }


SgAsmDwarfConstructList*
SgAsmDwarfClassType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfEnumerationType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfLexicalBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfCompilationUnit::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_language_constructs == NULL)
          p_language_constructs = new SgAsmDwarfConstructList();

     return p_language_constructs;
   }

SgAsmDwarfConstructList*
SgAsmDwarfStructureType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfSubroutineType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfUnionType::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfCommonBlock::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfInlinedSubroutine::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfSubprogram::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfNamespace::get_children()
   {
     ROSE_ASSERT(this != NULL);

     if (p_body == NULL)
          p_body = new SgAsmDwarfConstructList();

     return p_body;
   }

SgAsmDwarfConstructList*
SgAsmDwarfConstruct::get_children()
   {
     ROSE_ASSERT(this != NULL);

     printf ("Warning: base class of virtual function called by mistake: class_name = %s \n",class_name().c_str());
     return NULL;
   }

DwarfInstructionSourceMapReturnType
SgAsmDwarfLineList::buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu )
   {
  // SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
  // SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;

  // Build this as static local data
     static SgInstructionAddressSourcePositionMapPtrList* instruction_source_code_map = NULL;

     bool recomputeMap = false;
     if (instruction_source_code_map == NULL)
        {
          recomputeMap = true;
          instruction_source_code_map = new SgInstructionAddressSourcePositionMapPtrList;
        }

     ROSE_ASSERT(instruction_source_code_map != NULL);

     static SgSourcePositionInstructionAddressMapPtrList* source_code_instruction_map = NULL;
     if (source_code_instruction_map == NULL)
          source_code_instruction_map = new SgSourcePositionInstructionAddressMapPtrList;
     ROSE_ASSERT(source_code_instruction_map != NULL);

     if (recomputeMap == true)
        {
          ROSE_ASSERT(dwarf_cu != NULL);
          ROSE_ASSERT(dwarf_cu->get_line_info() != NULL);

          SgAsmDwarfLinePtrList & line_list = dwarf_cu->get_line_info()->get_line_list();

          int listSize = (int) line_list.size();
          for (int i = 0; i < listSize; i++)
             {
            // Loop over each of the entries in the Dwarf line section.
               uint64_t address = line_list[i]->get_address();

            // Note that file_id values are already in terms of the Sg_File_Info maps
            // between file name integers and file name strings.
               int file_id      = line_list[i]->get_file_id();

               int line         = line_list[i]->get_line();
               int column       = line_list[i]->get_column();

            // printf ("address = 0x%lx file_id = %d line = %d  column = %d \n",address,file_id,line,column);

               FileIdLineColumnFilePosition file_info(file_id,std::pair<int,int>(line,column));

            // This works for stp::map, but for std::multimap
            // instruction_source_code_map->operator[](address)   = file_info;
            // source_code_instruction_map->operator[](file_info) = address;

            // This is the std::multiset version ...
               instruction_source_code_map->insert(AddressFileIdLineColumnFilePositionPair(address,file_info));
               source_code_instruction_map->insert(FileIdLineColumnFilePositionAddressPair(file_info,address));
             }
        }
       else
        {
       // printf ("Maps were computed previously \n");
        }

     DwarfInstructionSourceMapReturnType returnValue(instruction_source_code_map,source_code_instruction_map);

     return returnValue;
   }

#endif
