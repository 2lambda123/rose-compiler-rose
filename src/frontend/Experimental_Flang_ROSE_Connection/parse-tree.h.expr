struct Expr {
  template <typename A, typename = common::NoLvalue<A>> Expr(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Expr(Expr &&) = default; Expr &operator=(Expr &&) = default; Expr(const Expr &) = delete; Expr &operator=(const Expr &) = delete; Expr() = delete;

  struct IntrinsicUnary { IntrinsicUnary(IntrinsicUnary &&) = default; IntrinsicUnary &operator=(IntrinsicUnary &&) = default; IntrinsicUnary(const IntrinsicUnary &) = delete; IntrinsicUnary &operator=(const IntrinsicUnary &) = delete; IntrinsicUnary() = delete; IntrinsicUnary(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Parentheses : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct UnaryPlus : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct Negate : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct NOT : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };

  struct PercentLoc { PercentLoc(PercentLoc &&) = default; PercentLoc &operator=(PercentLoc &&) = default; PercentLoc(const PercentLoc &) = delete; PercentLoc &operator=(const PercentLoc &) = delete; PercentLoc() = delete; PercentLoc(common::Indirection<Variable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Variable> v; };

  struct DefinedUnary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedUnary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedUnary(DefinedUnary &&) = default; DefinedUnary &operator=(DefinedUnary &&) = default; DefinedUnary(const DefinedUnary &) = delete; DefinedUnary &operator=(const DefinedUnary &) = delete; DefinedUnary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>> t;
  };

  struct IntrinsicBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntrinsicBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntrinsicBinary(IntrinsicBinary &&) = default; IntrinsicBinary &operator=(IntrinsicBinary &&) = default; IntrinsicBinary(const IntrinsicBinary &) = delete; IntrinsicBinary &operator=(const IntrinsicBinary &) = delete; IntrinsicBinary() = delete;
    std::tuple<common::Indirection<Expr>, common::Indirection<Expr>> t;
  };
  struct Power : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Multiply : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Divide : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Add : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Subtract : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Concat : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQ : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct AND : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct OR : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NEQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };


  struct ComplexConstructor : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };

  struct DefinedBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedBinary(DefinedBinary &&) = default; DefinedBinary &operator=(DefinedBinary &&) = default; DefinedBinary(const DefinedBinary &) = delete; DefinedBinary &operator=(const DefinedBinary &) = delete; DefinedBinary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>,
        common::Indirection<Expr>>
        t;
  };

  explicit Expr(Designator &&);
  explicit Expr(FunctionReference &&);

  mutable TypedExpr typedExpr;

  CharBlock source;

  std::variant<common::Indirection<CharLiteralConstantSubstring>,
      LiteralConstant, common::Indirection<Designator>, ArrayConstructor,
      StructureConstructor, common::Indirection<FunctionReference>, Parentheses,
      UnaryPlus, Negate, NOT, PercentLoc, DefinedUnary, Power, Multiply, Divide,
      Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, AND, OR, EQV, NEQV,
      DefinedBinary, ComplexConstructor, common::Indirection<SubstringInquiry>>
      u;
};


struct PartRef {
  PartRef(PartRef &&) = default; PartRef &operator=(PartRef &&) = default; PartRef(const PartRef &) = delete; PartRef &operator=(const PartRef &) = delete; PartRef() = delete;
  PartRef(Name &&n, std::list<SectionSubscript> &&ss,
      std::optional<ImageSelector> &&is)
      : name{std::move(n)},
        subscripts(std::move(ss)), imageSelector{std::move(is)} {}
  Name name;
  std::list<SectionSubscript> subscripts;
  std::optional<ImageSelector> imageSelector;
};


struct DataRef {
  template <typename A, typename = common::NoLvalue<A>> DataRef(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataRef(DataRef &&) = default; DataRef &operator=(DataRef &&) = default; DataRef(const DataRef &) = delete; DataRef &operator=(const DataRef &) = delete; DataRef() = delete;
  explicit DataRef(std::list<PartRef> &&);
  std::variant<Name, common::Indirection<StructureComponent>,
      common::Indirection<ArrayElement>,
      common::Indirection<CoindexedNamedObject>>
      u;
};
# 1801 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct Substring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Substring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Substring(Substring &&) = default; Substring &operator=(Substring &&) = default; Substring(const Substring &) = delete; Substring &operator=(const Substring &) = delete; Substring() = delete;
  std::tuple<DataRef, SubstringRange> t;
};

struct CharLiteralConstantSubstring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CharLiteralConstantSubstring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharLiteralConstantSubstring(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring &operator=(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring &operator=(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring() = delete;
  std::tuple<CharLiteralConstant, SubstringRange> t;
};





struct SubstringInquiry {
  CharBlock source;
  SubstringInquiry(SubstringInquiry &&) = default; SubstringInquiry &operator=(SubstringInquiry &&) = default; SubstringInquiry(const SubstringInquiry &) = delete; SubstringInquiry &operator=(const SubstringInquiry &) = delete; SubstringInquiry() = delete; SubstringInquiry(Substring &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Substring v;
};




struct Designator {
  template <typename A, typename = common::NoLvalue<A>> Designator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Designator(Designator &&) = default; Designator &operator=(Designator &&) = default; Designator(const Designator &) = delete; Designator &operator=(const Designator &) = delete; Designator() = delete;
  bool EndsInBareName() const;
  CharBlock source;
  std::variant<DataRef, Substring> u;
};


struct Variable {
  template <typename A, typename = common::NoLvalue<A>> Variable(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Variable(Variable &&) = default; Variable &operator=(Variable &&) = default; Variable(const Variable &) = delete; Variable &operator=(const Variable &) = delete; Variable() = delete;
  mutable TypedExpr typedExpr;
  CharBlock GetSource() const;
  std::variant<common::Indirection<Designator>,
      common::Indirection<FunctionReference>>
      u;
};



using ScalarLogicalVariable = Scalar<Logical<Variable>>;



using ScalarDefaultCharVariable = Scalar<DefaultChar<Variable>>;



using ScalarIntVariable = Scalar<Integer<Variable>>;


struct StructureComponent {
  StructureComponent(StructureComponent &&) = default; StructureComponent &operator=(StructureComponent &&) = default; StructureComponent(const StructureComponent &) = delete; StructureComponent &operator=(const StructureComponent &) = delete; StructureComponent() = delete;
  StructureComponent(DataRef &&dr, Name &&n)
      : base{std::move(dr)}, component(std::move(n)) {}
  DataRef base;
  Name component;
};



struct ProcComponentRef {
  ProcComponentRef(ProcComponentRef &&) = default; ProcComponentRef &operator=(ProcComponentRef &&) = default; ProcComponentRef(const ProcComponentRef &) = delete; ProcComponentRef &operator=(const ProcComponentRef &) = delete; ProcComponentRef() = delete; ProcComponentRef(Scalar<StructureComponent> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<StructureComponent> v;
};


struct CoindexedNamedObject {
  CoindexedNamedObject(CoindexedNamedObject &&) = default; CoindexedNamedObject &operator=(CoindexedNamedObject &&) = default; CoindexedNamedObject(const CoindexedNamedObject &) = delete; CoindexedNamedObject &operator=(const CoindexedNamedObject &) = delete; CoindexedNamedObject() = delete;
  CoindexedNamedObject(DataRef &&dr, ImageSelector &&is)
      : base{std::move(dr)}, imageSelector{std::move(is)} {}
  DataRef base;
  ImageSelector imageSelector;
};


struct ArrayElement {
  ArrayElement(ArrayElement &&) = default; ArrayElement &operator=(ArrayElement &&) = default; ArrayElement(const ArrayElement &) = delete; ArrayElement &operator=(const ArrayElement &) = delete; ArrayElement() = delete;
  ArrayElement(DataRef &&dr, std::list<SectionSubscript> &&ss)
      : base{std::move(dr)}, subscripts(std::move(ss)) {}
  Substring ConvertToSubstring();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
  DataRef base;
  std::list<SectionSubscript> subscripts;
};


struct AllocateObject {
  template <typename A, typename = common::NoLvalue<A>> AllocateObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocateObject(AllocateObject &&) = default; AllocateObject &operator=(AllocateObject &&) = default; AllocateObject(const AllocateObject &) = delete; AllocateObject &operator=(const AllocateObject &) = delete; AllocateObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};



using BoundExpr = ScalarIntExpr;



struct AllocateShapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateShapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateShapeSpec(AllocateShapeSpec &&) = default; AllocateShapeSpec &operator=(AllocateShapeSpec &&) = default; AllocateShapeSpec(const AllocateShapeSpec &) = delete; AllocateShapeSpec &operator=(const AllocateShapeSpec &) = delete; AllocateShapeSpec() = delete;
  std::tuple<std::optional<BoundExpr>, BoundExpr> t;
};

using AllocateCoshapeSpec = AllocateShapeSpec;



struct AllocateCoarraySpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateCoarraySpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateCoarraySpec(AllocateCoarraySpec &&) = default; AllocateCoarraySpec &operator=(AllocateCoarraySpec &&) = default; AllocateCoarraySpec(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec &operator=(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec() = delete;
  std::tuple<std::list<AllocateCoshapeSpec>, std::optional<BoundExpr>> t;
};




struct Allocation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Allocation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Allocation(Allocation &&) = default; Allocation &operator=(Allocation &&) = default; Allocation(const Allocation &) = delete; Allocation &operator=(const Allocation &) = delete; Allocation() = delete;
  std::tuple<AllocateObject, std::list<AllocateShapeSpec>,
      std::optional<AllocateCoarraySpec>>
      t;
};


struct StatVariable { StatVariable(StatVariable &&) = default; StatVariable &operator=(StatVariable &&) = default; StatVariable(const StatVariable &) = delete; StatVariable &operator=(const StatVariable &) = delete; StatVariable() = delete; StatVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };



struct MsgVariable { MsgVariable(MsgVariable &&) = default; MsgVariable &operator=(MsgVariable &&) = default; MsgVariable(const MsgVariable &) = delete; MsgVariable &operator=(const MsgVariable &) = delete; MsgVariable() = delete; MsgVariable(ScalarDefaultCharVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharVariable v; };



struct StatOrErrmsg {
  template <typename A, typename = common::NoLvalue<A>> StatOrErrmsg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StatOrErrmsg(StatOrErrmsg &&) = default; StatOrErrmsg &operator=(StatOrErrmsg &&) = default; StatOrErrmsg(const StatOrErrmsg &) = delete; StatOrErrmsg &operator=(const StatOrErrmsg &) = delete; StatOrErrmsg() = delete;
  std::variant<StatVariable, MsgVariable> u;
};







struct AllocOpt {
  template <typename A, typename = common::NoLvalue<A>> AllocOpt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocOpt(AllocOpt &&) = default; AllocOpt &operator=(AllocOpt &&) = default; AllocOpt(const AllocOpt &) = delete; AllocOpt &operator=(const AllocOpt &) = delete; AllocOpt() = delete;
  struct Mold { Mold(Mold &&) = default; Mold &operator=(Mold &&) = default; Mold(const Mold &) = delete; Mold &operator=(const Mold &) = delete; Mold() = delete; Mold(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Source { Source(Source &&) = default; Source &operator=(Source &&) = default; Source(const Source &) = delete; Source &operator=(const Source &) = delete; Source() = delete; Source(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Stream { Stream(Stream &&) = default; Stream &operator=(Stream &&) = default; Stream(const Stream &) = delete; Stream &operator=(const Stream &) = delete; Stream() = delete; Stream(common::Indirection<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarIntExpr> v; };
  struct Pinned { Pinned(Pinned &&) = default; Pinned &operator=(Pinned &&) = default; Pinned(const Pinned &) = delete; Pinned &operator=(const Pinned &) = delete; Pinned() = delete; Pinned(common::Indirection<ScalarLogicalVariable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarLogicalVariable> v; };
  std::variant<Mold, Source, StatOrErrmsg, Stream, Pinned> u;
};



struct AllocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateStmt(AllocateStmt &&) = default; AllocateStmt &operator=(AllocateStmt &&) = default; AllocateStmt(const AllocateStmt &) = delete; AllocateStmt &operator=(const AllocateStmt &) = delete; AllocateStmt() = delete;
  std::tuple<std::optional<TypeSpec>, std::list<Allocation>,
      std::list<AllocOpt>>
      t;
};



struct PointerObject {
  template <typename A, typename = common::NoLvalue<A>> PointerObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PointerObject(PointerObject &&) = default; PointerObject &operator=(PointerObject &&) = default; PointerObject(const PointerObject &) = delete; PointerObject &operator=(const PointerObject &) = delete; PointerObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};


struct NullifyStmt { NullifyStmt(NullifyStmt &&) = default; NullifyStmt &operator=(NullifyStmt &&) = default; NullifyStmt(const NullifyStmt &) = delete; NullifyStmt &operator=(const NullifyStmt &) = delete; NullifyStmt() = delete; NullifyStmt(std::list<PointerObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PointerObject> v; };



struct DeallocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DeallocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DeallocateStmt(DeallocateStmt &&) = default; DeallocateStmt &operator=(DeallocateStmt &&) = default; DeallocateStmt(const DeallocateStmt &) = delete; DeallocateStmt &operator=(const DeallocateStmt &) = delete; DeallocateStmt() = delete;
  std::tuple<std::list<AllocateObject>, std::list<StatOrErrmsg>> t;
};


struct AssignmentStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignmentStmt(AssignmentStmt &&) = default; AssignmentStmt &operator=(AssignmentStmt &&) = default; AssignmentStmt(const AssignmentStmt &) = delete; AssignmentStmt &operator=(const AssignmentStmt &) = delete; AssignmentStmt() = delete;
  using TypedAssignment =
      common::ForwardOwningPointer<evaluate::GenericAssignmentWrapper>;
  mutable TypedAssignment typedAssignment;
  std::tuple<Variable, Expr> t;
};


struct BoundsSpec { BoundsSpec(BoundsSpec &&) = default; BoundsSpec &operator=(BoundsSpec &&) = default; BoundsSpec(const BoundsSpec &) = delete; BoundsSpec &operator=(const BoundsSpec &) = delete; BoundsSpec() = delete; BoundsSpec(BoundExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; BoundExpr v; };


struct BoundsRemapping {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BoundsRemapping(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BoundsRemapping(BoundsRemapping &&) = default; BoundsRemapping &operator=(BoundsRemapping &&) = default; BoundsRemapping(const BoundsRemapping &) = delete; BoundsRemapping &operator=(const BoundsRemapping &) = delete; BoundsRemapping() = delete;
  std::tuple<BoundExpr, BoundExpr> t;
};
# 2006 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct PointerAssignmentStmt {
  struct Bounds {
    template <typename A, typename = common::NoLvalue<A>> Bounds(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Bounds(Bounds &&) = default; Bounds &operator=(Bounds &&) = default; Bounds(const Bounds &) = delete; Bounds &operator=(const Bounds &) = delete; Bounds() = delete;
    std::variant<std::list<BoundsRemapping>, std::list<BoundsSpec>> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PointerAssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PointerAssignmentStmt(PointerAssignmentStmt &&) = default; PointerAssignmentStmt &operator=(PointerAssignmentStmt &&) = default; PointerAssignmentStmt(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt &operator=(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt() = delete;
  mutable AssignmentStmt::TypedAssignment typedAssignment;
  std::tuple<DataRef, Bounds, Expr> t;
};




struct WhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereStmt(WhereStmt &&) = default; WhereStmt &operator=(WhereStmt &&) = default; WhereStmt(const WhereStmt &) = delete; WhereStmt &operator=(const WhereStmt &) = delete; WhereStmt() = delete;
  std::tuple<LogicalExpr, AssignmentStmt> t;
};


struct WhereConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstructStmt(WhereConstructStmt &&) = default; WhereConstructStmt &operator=(WhereConstructStmt &&) = default; WhereConstructStmt(const WhereConstructStmt &) = delete; WhereConstructStmt &operator=(const WhereConstructStmt &) = delete; WhereConstructStmt() = delete;
  std::tuple<std::optional<Name>, LogicalExpr> t;
};



struct WhereBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> WhereBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WhereBodyConstruct(WhereBodyConstruct &&) = default; WhereBodyConstruct &operator=(WhereBodyConstruct &&) = default; WhereBodyConstruct(const WhereBodyConstruct &) = delete; WhereBodyConstruct &operator=(const WhereBodyConstruct &) = delete; WhereBodyConstruct() = delete;
  std::variant<Statement<AssignmentStmt>, Statement<WhereStmt>,
      common::Indirection<WhereConstruct>>
      u;
};



struct MaskedElsewhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhereStmt(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt &operator=(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt &operator=(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt() = delete;
  std::tuple<LogicalExpr, std::optional<Name>> t;
};


struct ElsewhereStmt { ElsewhereStmt(ElsewhereStmt &&) = default; ElsewhereStmt &operator=(ElsewhereStmt &&) = default; ElsewhereStmt(const ElsewhereStmt &) = delete; ElsewhereStmt &operator=(const ElsewhereStmt &) = delete; ElsewhereStmt() = delete; ElsewhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndWhereStmt { EndWhereStmt(EndWhereStmt &&) = default; EndWhereStmt &operator=(EndWhereStmt &&) = default; EndWhereStmt(const EndWhereStmt &) = delete; EndWhereStmt &operator=(const EndWhereStmt &) = delete; EndWhereStmt() = delete; EndWhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };





struct WhereConstruct {
  struct MaskedElsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhere(MaskedElsewhere &&) = default; MaskedElsewhere &operator=(MaskedElsewhere &&) = default; MaskedElsewhere(const MaskedElsewhere &) = delete; MaskedElsewhere &operator=(const MaskedElsewhere &) = delete; MaskedElsewhere() = delete;
    std::tuple<Statement<MaskedElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  struct Elsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Elsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Elsewhere(Elsewhere &&) = default; Elsewhere &operator=(Elsewhere &&) = default; Elsewhere(const Elsewhere &) = delete; Elsewhere &operator=(const Elsewhere &) = delete; Elsewhere() = delete;
    std::tuple<Statement<ElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstruct(WhereConstruct &&) = default; WhereConstruct &operator=(WhereConstruct &&) = default; WhereConstruct(const WhereConstruct &) = delete; WhereConstruct &operator=(const WhereConstruct &) = delete; WhereConstruct() = delete;
  std::tuple<Statement<WhereConstructStmt>, std::list<WhereBodyConstruct>,
      std::list<MaskedElsewhere>, std::optional<Elsewhere>,
      Statement<EndWhereStmt>>
      t;
};



struct ForallConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstructStmt(ForallConstructStmt &&) = default; ForallConstructStmt &operator=(ForallConstructStmt &&) = default; ForallConstructStmt(const ForallConstructStmt &) = delete; ForallConstructStmt &operator=(const ForallConstructStmt &) = delete; ForallConstructStmt() = delete;
  std::tuple<std::optional<Name>, common::Indirection<ConcurrentHeader>> t;
};


struct ForallAssignmentStmt {
  template <typename A, typename = common::NoLvalue<A>> ForallAssignmentStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallAssignmentStmt(ForallAssignmentStmt &&) = default; ForallAssignmentStmt &operator=(ForallAssignmentStmt &&) = default; ForallAssignmentStmt(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt &operator=(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt() = delete;
  std::variant<AssignmentStmt, PointerAssignmentStmt> u;
};


struct ForallStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallStmt(ForallStmt &&) = default; ForallStmt &operator=(ForallStmt &&) = default; ForallStmt(const ForallStmt &) = delete; ForallStmt &operator=(const ForallStmt &) = delete; ForallStmt() = delete;
  std::tuple<common::Indirection<ConcurrentHeader>,
      UnlabeledStatement<ForallAssignmentStmt>>
      t;
};




struct ForallBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> ForallBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallBodyConstruct(ForallBodyConstruct &&) = default; ForallBodyConstruct &operator=(ForallBodyConstruct &&) = default; ForallBodyConstruct(const ForallBodyConstruct &) = delete; ForallBodyConstruct &operator=(const ForallBodyConstruct &) = delete; ForallBodyConstruct() = delete;
  std::variant<Statement<ForallAssignmentStmt>, Statement<WhereStmt>,
      WhereConstruct, common::Indirection<ForallConstruct>,
      Statement<ForallStmt>>
      u;
};


struct EndForallStmt { EndForallStmt(EndForallStmt &&) = default; EndForallStmt &operator=(EndForallStmt &&) = default; EndForallStmt(const EndForallStmt &) = delete; EndForallStmt &operator=(const EndForallStmt &) = delete; EndForallStmt() = delete; EndForallStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct ForallConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstruct(ForallConstruct &&) = default; ForallConstruct &operator=(ForallConstruct &&) = default; ForallConstruct(const ForallConstruct &) = delete; ForallConstruct &operator=(const ForallConstruct &) = delete; ForallConstruct() = delete;
  std::tuple<Statement<ForallConstructStmt>, std::list<ForallBodyConstruct>,
      Statement<EndForallStmt>>
      t;
};


using Block = std::list<ExecutionPartConstruct>;


struct Selector {
  template <typename A, typename = common::NoLvalue<A>> Selector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Selector(Selector &&) = default; Selector &operator=(Selector &&) = default; Selector(const Selector &) = delete; Selector &operator=(const Selector &) = delete; Selector() = delete;
  std::variant<Expr, Variable> u;
};


struct Association {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Association(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Association(Association &&) = default; Association &operator=(Association &&) = default; Association(const Association &) = delete; Association &operator=(const Association &) = delete; Association() = delete;
  std::tuple<Name, Selector> t;
};



struct AssociateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateStmt(AssociateStmt &&) = default; AssociateStmt &operator=(AssociateStmt &&) = default; AssociateStmt(const AssociateStmt &) = delete; AssociateStmt &operator=(const AssociateStmt &) = delete; AssociateStmt() = delete;
  std::tuple<std::optional<Name>, std::list<Association>> t;
};


struct EndAssociateStmt { EndAssociateStmt(EndAssociateStmt &&) = default; EndAssociateStmt &operator=(EndAssociateStmt &&) = default; EndAssociateStmt(const EndAssociateStmt &) = delete; EndAssociateStmt &operator=(const EndAssociateStmt &) = delete; EndAssociateStmt() = delete; EndAssociateStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct AssociateConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateConstruct(AssociateConstruct &&) = default; AssociateConstruct &operator=(AssociateConstruct &&) = default; AssociateConstruct(const AssociateConstruct &) = delete; AssociateConstruct &operator=(const AssociateConstruct &) = delete; AssociateConstruct() = delete;
  std::tuple<Statement<AssociateStmt>, Block, Statement<EndAssociateStmt>> t;
};


struct BlockStmt { BlockStmt(BlockStmt &&) = default; BlockStmt &operator=(BlockStmt &&) = default; BlockStmt(const BlockStmt &) = delete; BlockStmt &operator=(const BlockStmt &) = delete; BlockStmt() = delete; BlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockStmt { EndBlockStmt(EndBlockStmt &&) = default; EndBlockStmt &operator=(EndBlockStmt &&) = default; EndBlockStmt(const EndBlockStmt &) = delete; EndBlockStmt &operator=(const EndBlockStmt &) = delete; EndBlockStmt() = delete; EndBlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2160 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct BlockSpecificationPart { BlockSpecificationPart(BlockSpecificationPart &&) = default; BlockSpecificationPart &operator=(BlockSpecificationPart &&) = default; BlockSpecificationPart(const BlockSpecificationPart &) = delete; BlockSpecificationPart &operator=(const BlockSpecificationPart &) = delete; BlockSpecificationPart() = delete; BlockSpecificationPart(SpecificationPart &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; SpecificationPart v; };



struct BlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockConstruct(BlockConstruct &&) = default; BlockConstruct &operator=(BlockConstruct &&) = default; BlockConstruct(const BlockConstruct &) = delete; BlockConstruct &operator=(const BlockConstruct &) = delete; BlockConstruct() = delete;
  std::tuple<Statement<BlockStmt>, BlockSpecificationPart, Block,
      Statement<EndBlockStmt>>
      t;
};


struct CoarrayAssociation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CoarrayAssociation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CoarrayAssociation(CoarrayAssociation &&) = default; CoarrayAssociation &operator=(CoarrayAssociation &&) = default; CoarrayAssociation(const CoarrayAssociation &) = delete; CoarrayAssociation &operator=(const CoarrayAssociation &) = delete; CoarrayAssociation() = delete;
  std::tuple<CodimensionDecl, Selector> t;
};




struct ChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamStmt(ChangeTeamStmt &&) = default; ChangeTeamStmt &operator=(ChangeTeamStmt &&) = default; ChangeTeamStmt(const ChangeTeamStmt &) = delete; ChangeTeamStmt &operator=(const ChangeTeamStmt &) = delete; ChangeTeamStmt() = delete;
  std::tuple<std::optional<Name>, TeamValue, std::list<CoarrayAssociation>,
      std::list<StatOrErrmsg>>
      t;
};



struct EndChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EndChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EndChangeTeamStmt(EndChangeTeamStmt &&) = default; EndChangeTeamStmt &operator=(EndChangeTeamStmt &&) = default; EndChangeTeamStmt(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt &operator=(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt() = delete;
  std::tuple<std::list<StatOrErrmsg>, std::optional<Name>> t;
};


struct ChangeTeamConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamConstruct(ChangeTeamConstruct &&) = default; ChangeTeamConstruct &operator=(ChangeTeamConstruct &&) = default; ChangeTeamConstruct(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct &operator=(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct() = delete;
  std::tuple<Statement<ChangeTeamStmt>, Block, Statement<EndChangeTeamStmt>> t;
};



struct CriticalStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalStmt(CriticalStmt &&) = default; CriticalStmt &operator=(CriticalStmt &&) = default; CriticalStmt(const CriticalStmt &) = delete; CriticalStmt &operator=(const CriticalStmt &) = delete; CriticalStmt() = delete;
  std::tuple<std::optional<Name>, std::list<StatOrErrmsg>> t;
};


struct EndCriticalStmt { EndCriticalStmt(EndCriticalStmt &&) = default; EndCriticalStmt &operator=(EndCriticalStmt &&) = default; EndCriticalStmt(const EndCriticalStmt &) = delete; EndCriticalStmt &operator=(const EndCriticalStmt &) = delete; EndCriticalStmt() = delete; EndCriticalStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct CriticalConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalConstruct(CriticalConstruct &&) = default; CriticalConstruct &operator=(CriticalConstruct &&) = default; CriticalConstruct(const CriticalConstruct &) = delete; CriticalConstruct &operator=(const CriticalConstruct &) = delete; CriticalConstruct() = delete;
  std::tuple<Statement<CriticalStmt>, Block, Statement<EndCriticalStmt>> t;
};





struct ConcurrentControl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentControl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentControl(ConcurrentControl &&) = default; ConcurrentControl &operator=(ConcurrentControl &&) = default; ConcurrentControl(const ConcurrentControl &) = delete; ConcurrentControl &operator=(const ConcurrentControl &) = delete; ConcurrentControl() = delete;
  std::tuple<Name, ScalarIntExpr, ScalarIntExpr, std::optional<ScalarIntExpr>>
      t;
};




struct ConcurrentHeader {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentHeader(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentHeader(ConcurrentHeader &&) = default; ConcurrentHeader &operator=(ConcurrentHeader &&) = default; ConcurrentHeader(const ConcurrentHeader &) = delete; ConcurrentHeader &operator=(const ConcurrentHeader &) = delete; ConcurrentHeader() = delete;
  std::tuple<std::optional<IntegerTypeSpec>, std::list<ConcurrentControl>,
      std::optional<ScalarLogicalExpr>>
      t;
};




struct LocalitySpec {
  template <typename A, typename = common::NoLvalue<A>> LocalitySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LocalitySpec(LocalitySpec &&) = default; LocalitySpec &operator=(LocalitySpec &&) = default; LocalitySpec(const LocalitySpec &) = delete; LocalitySpec &operator=(const LocalitySpec &) = delete; LocalitySpec() = delete;
  struct Local { Local(Local &&) = default; Local &operator=(Local &&) = default; Local(const Local &) = delete; Local &operator=(const Local &) = delete; Local() = delete; Local(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct LocalInit { LocalInit(LocalInit &&) = default; LocalInit &operator=(LocalInit &&) = default; LocalInit(const LocalInit &) = delete; LocalInit &operator=(const LocalInit &) = delete; LocalInit() = delete; LocalInit(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct DefaultNone { DefaultNone() {} DefaultNone(const DefaultNone &) {} DefaultNone(DefaultNone &&) {} DefaultNone &operator=(const DefaultNone &) { return *this; }; DefaultNone &operator=(DefaultNone &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<Local, LocalInit, Shared, DefaultNone> u;
};







struct LoopControl {
  template <typename A, typename = common::NoLvalue<A>> LoopControl(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LoopControl(LoopControl &&) = default; LoopControl &operator=(LoopControl &&) = default; LoopControl(const LoopControl &) = delete; LoopControl &operator=(const LoopControl &) = delete; LoopControl() = delete;
  struct Concurrent {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Concurrent(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Concurrent(Concurrent &&) = default; Concurrent &operator=(Concurrent &&) = default; Concurrent(const Concurrent &) = delete; Concurrent &operator=(const Concurrent &) = delete; Concurrent() = delete;
    std::tuple<ConcurrentHeader, std::list<LocalitySpec>> t;
  };
  using Bounds = LoopBounds<ScalarName, ScalarExpr>;
  std::variant<Bounds, ScalarLogicalExpr, Concurrent> u;
};



struct LabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LabelDoStmt(LabelDoStmt &&) = default; LabelDoStmt &operator=(LabelDoStmt &&) = default; LabelDoStmt(const LabelDoStmt &) = delete; LabelDoStmt &operator=(const LabelDoStmt &) = delete; LabelDoStmt() = delete;
  std::tuple<Label, std::optional<LoopControl>> t;
};


struct NonLabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NonLabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NonLabelDoStmt(NonLabelDoStmt &&) = default; NonLabelDoStmt &operator=(NonLabelDoStmt &&) = default; NonLabelDoStmt(const NonLabelDoStmt &) = delete; NonLabelDoStmt &operator=(const NonLabelDoStmt &) = delete; NonLabelDoStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Label>,
      std::optional<LoopControl>>
      t;
};


struct EndDoStmt { EndDoStmt(EndDoStmt &&) = default; EndDoStmt &operator=(EndDoStmt &&) = default; EndDoStmt(const EndDoStmt &) = delete; EndDoStmt &operator=(const EndDoStmt &) = delete; EndDoStmt() = delete; EndDoStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2289 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct DoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DoConstruct(DoConstruct &&) = default; DoConstruct &operator=(DoConstruct &&) = default; DoConstruct(const DoConstruct &) = delete; DoConstruct &operator=(const DoConstruct &) = delete; DoConstruct() = delete;
  const std::optional<LoopControl> &GetLoopControl() const;
  bool IsDoNormal() const;
  bool IsDoWhile() const;
  bool IsDoConcurrent() const;
  std::tuple<Statement<NonLabelDoStmt>, Block, Statement<EndDoStmt>> t;
};


struct CycleStmt { CycleStmt(CycleStmt &&) = default; CycleStmt &operator=(CycleStmt &&) = default; CycleStmt(const CycleStmt &) = delete; CycleStmt &operator=(const CycleStmt &) = delete; CycleStmt() = delete; CycleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct IfThenStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfThenStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfThenStmt(IfThenStmt &&) = default; IfThenStmt &operator=(IfThenStmt &&) = default; IfThenStmt(const IfThenStmt &) = delete; IfThenStmt &operator=(const IfThenStmt &) = delete; IfThenStmt() = delete;
  std::tuple<std::optional<Name>, ScalarLogicalExpr> t;
};



struct ElseIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfStmt(ElseIfStmt &&) = default; ElseIfStmt &operator=(ElseIfStmt &&) = default; ElseIfStmt(const ElseIfStmt &) = delete; ElseIfStmt &operator=(const ElseIfStmt &) = delete; ElseIfStmt() = delete;
  std::tuple<ScalarLogicalExpr, std::optional<Name>> t;
};


struct ElseStmt { ElseStmt(ElseStmt &&) = default; ElseStmt &operator=(ElseStmt &&) = default; ElseStmt(const ElseStmt &) = delete; ElseStmt &operator=(const ElseStmt &) = delete; ElseStmt() = delete; ElseStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndIfStmt { EndIfStmt(EndIfStmt &&) = default; EndIfStmt &operator=(EndIfStmt &&) = default; EndIfStmt(const EndIfStmt &) = delete; EndIfStmt &operator=(const EndIfStmt &) = delete; EndIfStmt() = delete; EndIfStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct IfConstruct {
  struct ElseIfBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfBlock(ElseIfBlock &&) = default; ElseIfBlock &operator=(ElseIfBlock &&) = default; ElseIfBlock(const ElseIfBlock &) = delete; ElseIfBlock &operator=(const ElseIfBlock &) = delete; ElseIfBlock() = delete;
    std::tuple<Statement<ElseIfStmt>, Block> t;
  };
  struct ElseBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseBlock(ElseBlock &&) = default; ElseBlock &operator=(ElseBlock &&) = default; ElseBlock(const ElseBlock &) = delete; ElseBlock &operator=(const ElseBlock &) = delete; ElseBlock() = delete;
    std::tuple<Statement<ElseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfConstruct(IfConstruct &&) = default; IfConstruct &operator=(IfConstruct &&) = default; IfConstruct(const IfConstruct &) = delete; IfConstruct &operator=(const IfConstruct &) = delete; IfConstruct() = delete;
  std::tuple<Statement<IfThenStmt>, Block, std::list<ElseIfBlock>,
      std::optional<ElseBlock>, Statement<EndIfStmt>>
      t;
};


struct IfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfStmt(IfStmt &&) = default; IfStmt &operator=(IfStmt &&) = default; IfStmt(const IfStmt &) = delete; IfStmt &operator=(const IfStmt &) = delete; IfStmt() = delete;
  std::tuple<ScalarLogicalExpr, UnlabeledStatement<ActionStmt>> t;
};



struct SelectCaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectCaseStmt(SelectCaseStmt &&) = default; SelectCaseStmt &operator=(SelectCaseStmt &&) = default; SelectCaseStmt(const SelectCaseStmt &) = delete; SelectCaseStmt &operator=(const SelectCaseStmt &) = delete; SelectCaseStmt() = delete;
  std::tuple<std::optional<Name>, Scalar<Expr>> t;
};


using CaseValue = Scalar<ConstantExpr>;



struct CaseValueRange {
  template <typename A, typename = common::NoLvalue<A>> CaseValueRange(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseValueRange(CaseValueRange &&) = default; CaseValueRange &operator=(CaseValueRange &&) = default; CaseValueRange(const CaseValueRange &) = delete; CaseValueRange &operator=(const CaseValueRange &) = delete; CaseValueRange() = delete;
  struct Range {
    Range(Range &&) = default; Range &operator=(Range &&) = default; Range(const Range &) = delete; Range &operator=(const Range &) = delete; Range() = delete;
    Range(std::optional<CaseValue> &&l, std::optional<CaseValue> &&u)
        : lower{std::move(l)}, upper{std::move(u)} {}
    std::optional<CaseValue> lower, upper;
  };
  std::variant<CaseValue, Range> u;
};


struct Default { Default() {} Default(const Default &) {} Default(Default &&) {} Default &operator=(const Default &) { return *this; }; Default &operator=(Default &&) { return *this; }; using EmptyTrait = std::true_type; };

struct CaseSelector {
  template <typename A, typename = common::NoLvalue<A>> CaseSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseSelector(CaseSelector &&) = default; CaseSelector &operator=(CaseSelector &&) = default; CaseSelector(const CaseSelector &) = delete; CaseSelector &operator=(const CaseSelector &) = delete; CaseSelector() = delete;
  std::variant<std::list<CaseValueRange>, Default> u;
};


struct CaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseStmt(CaseStmt &&) = default; CaseStmt &operator=(CaseStmt &&) = default; CaseStmt(const CaseStmt &) = delete; CaseStmt &operator=(const CaseStmt &) = delete; CaseStmt() = delete;
  std::tuple<CaseSelector, std::optional<Name>> t;
};




struct EndSelectStmt { EndSelectStmt(EndSelectStmt &&) = default; EndSelectStmt &operator=(EndSelectStmt &&) = default; EndSelectStmt(const EndSelectStmt &) = delete; EndSelectStmt &operator=(const EndSelectStmt &) = delete; EndSelectStmt() = delete; EndSelectStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct CaseConstruct {
  struct Case {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Case(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Case(Case &&) = default; Case &operator=(Case &&) = default; Case(const Case &) = delete; Case &operator=(const Case &) = delete; Case() = delete;
    std::tuple<Statement<CaseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseConstruct(CaseConstruct &&) = default; CaseConstruct &operator=(CaseConstruct &&) = default; CaseConstruct(const CaseConstruct &) = delete; CaseConstruct &operator=(const CaseConstruct &) = delete; CaseConstruct() = delete;
  std::tuple<Statement<SelectCaseStmt>, std::list<Case>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectRankStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankStmt(SelectRankStmt &&) = default; SelectRankStmt &operator=(SelectRankStmt &&) = default; SelectRankStmt(const SelectRankStmt &) = delete; SelectRankStmt &operator=(const SelectRankStmt &) = delete; SelectRankStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct SelectRankCaseStmt {
  struct Rank {
    template <typename A, typename = common::NoLvalue<A>> Rank(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rank(Rank &&) = default; Rank &operator=(Rank &&) = default; Rank(const Rank &) = delete; Rank &operator=(const Rank &) = delete; Rank() = delete;
    std::variant<ScalarIntConstantExpr, Star, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankCaseStmt(SelectRankCaseStmt &&) = default; SelectRankCaseStmt &operator=(SelectRankCaseStmt &&) = default; SelectRankCaseStmt(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt &operator=(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt() = delete;
  std::tuple<Rank, std::optional<Name>> t;
};




struct SelectRankConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankConstruct(SelectRankConstruct &&) = default; SelectRankConstruct &operator=(SelectRankConstruct &&) = default; SelectRankConstruct(const SelectRankConstruct &) = delete; SelectRankConstruct &operator=(const SelectRankConstruct &) = delete; SelectRankConstruct() = delete;
  struct RankCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> RankCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; RankCase(RankCase &&) = default; RankCase &operator=(RankCase &&) = default; RankCase(const RankCase &) = delete; RankCase &operator=(const RankCase &) = delete; RankCase() = delete;
    std::tuple<Statement<SelectRankCaseStmt>, Block> t;
  };
  std::tuple<Statement<SelectRankStmt>, std::list<RankCase>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectTypeStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeStmt(SelectTypeStmt &&) = default; SelectTypeStmt &operator=(SelectTypeStmt &&) = default; SelectTypeStmt(const SelectTypeStmt &) = delete; SelectTypeStmt &operator=(const SelectTypeStmt &) = delete; SelectTypeStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct TypeGuardStmt {
  struct Guard {
    template <typename A, typename = common::NoLvalue<A>> Guard(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Guard(Guard &&) = default; Guard &operator=(Guard &&) = default; Guard(const Guard &) = delete; Guard &operator=(const Guard &) = delete; Guard() = delete;
    std::variant<TypeSpec, DerivedTypeSpec, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeGuardStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeGuardStmt(TypeGuardStmt &&) = default; TypeGuardStmt &operator=(TypeGuardStmt &&) = default; TypeGuardStmt(const TypeGuardStmt &) = delete; TypeGuardStmt &operator=(const TypeGuardStmt &) = delete; TypeGuardStmt() = delete;
  std::tuple<Guard, std::optional<Name>> t;
};



struct SelectTypeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeConstruct(SelectTypeConstruct &&) = default; SelectTypeConstruct &operator=(SelectTypeConstruct &&) = default; SelectTypeConstruct(const SelectTypeConstruct &) = delete; SelectTypeConstruct &operator=(const SelectTypeConstruct &) = delete; SelectTypeConstruct() = delete;
  struct TypeCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeCase(TypeCase &&) = default; TypeCase &operator=(TypeCase &&) = default; TypeCase(const TypeCase &) = delete; TypeCase &operator=(const TypeCase &) = delete; TypeCase() = delete;
    std::tuple<Statement<TypeGuardStmt>, Block> t;
  };
  std::tuple<Statement<SelectTypeStmt>, std::list<TypeCase>,
      Statement<EndSelectStmt>>
      t;
};


struct ExitStmt { ExitStmt(ExitStmt &&) = default; ExitStmt &operator=(ExitStmt &&) = default; ExitStmt(const ExitStmt &) = delete; ExitStmt &operator=(const ExitStmt &) = delete; ExitStmt() = delete; ExitStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct GotoStmt { GotoStmt(GotoStmt &&) = default; GotoStmt &operator=(GotoStmt &&) = default; GotoStmt(const GotoStmt &) = delete; GotoStmt &operator=(const GotoStmt &) = delete; GotoStmt() = delete; GotoStmt(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };


struct ComputedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComputedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComputedGotoStmt(ComputedGotoStmt &&) = default; ComputedGotoStmt &operator=(ComputedGotoStmt &&) = default; ComputedGotoStmt(const ComputedGotoStmt &) = delete; ComputedGotoStmt &operator=(const ComputedGotoStmt &) = delete; ComputedGotoStmt() = delete;
  std::tuple<std::list<Label>, ScalarIntExpr> t;
};





struct StopCode { StopCode(StopCode &&) = default; StopCode &operator=(StopCode &&) = default; StopCode(const StopCode &) = delete; StopCode &operator=(const StopCode &) = delete; StopCode() = delete; StopCode(Scalar<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<Expr> v; };




struct StopStmt {
  enum class Kind { Stop, ErrorStop }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Stop, ErrorStop")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Stop, ErrorStop")}; return names[static_cast<std::size_t>(e)]; }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StopStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StopStmt(StopStmt &&) = default; StopStmt &operator=(StopStmt &&) = default; StopStmt(const StopStmt &) = delete; StopStmt &operator=(const StopStmt &) = delete; StopStmt() = delete;
  std::tuple<Kind, std::optional<StopCode>, std::optional<ScalarLogicalExpr>> t;
};


struct SyncAllStmt { SyncAllStmt(SyncAllStmt &&) = default; SyncAllStmt &operator=(SyncAllStmt &&) = default; SyncAllStmt(const SyncAllStmt &) = delete; SyncAllStmt &operator=(const SyncAllStmt &) = delete; SyncAllStmt() = delete; SyncAllStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };



struct SyncImagesStmt {
  struct ImageSet {
    template <typename A, typename = common::NoLvalue<A>> ImageSet(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImageSet(ImageSet &&) = default; ImageSet &operator=(ImageSet &&) = default; ImageSet(const ImageSet &) = delete; ImageSet &operator=(const ImageSet &) = delete; ImageSet() = delete;
    std::variant<IntExpr, Star> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncImagesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncImagesStmt(SyncImagesStmt &&) = default; SyncImagesStmt &operator=(SyncImagesStmt &&) = default; SyncImagesStmt(const SyncImagesStmt &) = delete; SyncImagesStmt &operator=(const SyncImagesStmt &) = delete; SyncImagesStmt() = delete;
  std::tuple<ImageSet, std::list<StatOrErrmsg>> t;
};


struct SyncMemoryStmt { SyncMemoryStmt(SyncMemoryStmt &&) = default; SyncMemoryStmt &operator=(SyncMemoryStmt &&) = default; SyncMemoryStmt(const SyncMemoryStmt &) = delete; SyncMemoryStmt &operator=(const SyncMemoryStmt &) = delete; SyncMemoryStmt() = delete; SyncMemoryStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };


struct SyncTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncTeamStmt(SyncTeamStmt &&) = default; SyncTeamStmt &operator=(SyncTeamStmt &&) = default; SyncTeamStmt(const SyncTeamStmt &) = delete; SyncTeamStmt &operator=(const SyncTeamStmt &) = delete; SyncTeamStmt() = delete;
  std::tuple<TeamValue, std::list<StatOrErrmsg>> t;
};


using EventVariable = Scalar<Variable>;


struct EventPostStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventPostStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventPostStmt(EventPostStmt &&) = default; EventPostStmt &operator=(EventPostStmt &&) = default; EventPostStmt(const EventPostStmt &) = delete; EventPostStmt &operator=(const EventPostStmt &) = delete; EventPostStmt() = delete;
  std::tuple<EventVariable, std::list<StatOrErrmsg>> t;
};





struct EventWaitStmt {
  struct EventWaitSpec {
    template <typename A, typename = common::NoLvalue<A>> EventWaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; EventWaitSpec(EventWaitSpec &&) = default; EventWaitSpec &operator=(EventWaitSpec &&) = default; EventWaitSpec(const EventWaitSpec &) = delete; EventWaitSpec &operator=(const EventWaitSpec &) = delete; EventWaitSpec() = delete;
    std::variant<ScalarIntExpr, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventWaitStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventWaitStmt(EventWaitStmt &&) = default; EventWaitStmt &operator=(EventWaitStmt &&) = default; EventWaitStmt(const EventWaitStmt &) = delete; EventWaitStmt &operator=(const EventWaitStmt &) = delete; EventWaitStmt() = delete;
  std::tuple<EventVariable, std::list<EventWaitSpec>> t;
};


using TeamVariable = Scalar<Variable>;





struct FormTeamStmt {
  struct FormTeamSpec {
    template <typename A, typename = common::NoLvalue<A>> FormTeamSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; FormTeamSpec(FormTeamSpec &&) = default; FormTeamSpec &operator=(FormTeamSpec &&) = default; FormTeamSpec(const FormTeamSpec &) = delete; FormTeamSpec &operator=(const FormTeamSpec &) = delete; FormTeamSpec() = delete;
    std::variant<ScalarIntExpr, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FormTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FormTeamStmt(FormTeamStmt &&) = default; FormTeamStmt &operator=(FormTeamStmt &&) = default; FormTeamStmt(const FormTeamStmt &) = delete; FormTeamStmt &operator=(const FormTeamStmt &) = delete; FormTeamStmt() = delete;
  std::tuple<ScalarIntExpr, TeamVariable, std::list<FormTeamSpec>> t;
};


using LockVariable = Scalar<Variable>;



struct LockStmt {
  struct LockStat {
    template <typename A, typename = common::NoLvalue<A>> LockStat(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LockStat(LockStat &&) = default; LockStat &operator=(LockStat &&) = default; LockStat(const LockStat &) = delete; LockStat &operator=(const LockStat &) = delete; LockStat() = delete;
    std::variant<Scalar<Logical<Variable>>, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LockStmt(LockStmt &&) = default; LockStmt &operator=(LockStmt &&) = default; LockStmt(const LockStmt &) = delete; LockStmt &operator=(const LockStmt &) = delete; LockStmt() = delete;
  std::tuple<LockVariable, std::list<LockStat>> t;
};


struct UnlockStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> UnlockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; UnlockStmt(UnlockStmt &&) = default; UnlockStmt &operator=(UnlockStmt &&) = default; UnlockStmt(const UnlockStmt &) = delete; UnlockStmt &operator=(const UnlockStmt &) = delete; UnlockStmt() = delete;
  std::tuple<LockVariable, std::list<StatOrErrmsg>> t;
};


struct FileUnitNumber { FileUnitNumber(FileUnitNumber &&) = default; FileUnitNumber &operator=(FileUnitNumber &&) = default; FileUnitNumber(const FileUnitNumber &) = delete; FileUnitNumber &operator=(const FileUnitNumber &) = delete; FileUnitNumber() = delete; FileUnitNumber(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
# 2586 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct IoUnit {
  template <typename A, typename = common::NoLvalue<A>> IoUnit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoUnit(IoUnit &&) = default; IoUnit &operator=(IoUnit &&) = default; IoUnit(const IoUnit &) = delete; IoUnit &operator=(const IoUnit &) = delete; IoUnit() = delete;
  std::variant<Variable, FileUnitNumber, Star> u;
};


using FileNameExpr = ScalarDefaultCharExpr;
# 2611 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct StatusExpr { StatusExpr(StatusExpr &&) = default; StatusExpr &operator=(StatusExpr &&) = default; StatusExpr(const StatusExpr &) = delete; StatusExpr &operator=(const StatusExpr &) = delete; StatusExpr() = delete; StatusExpr(ScalarDefaultCharExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharExpr v; };
struct ErrLabel { ErrLabel(ErrLabel &&) = default; ErrLabel &operator=(ErrLabel &&) = default; ErrLabel(const ErrLabel &) = delete; ErrLabel &operator=(const ErrLabel &) = delete; ErrLabel() = delete; ErrLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };

struct ConnectSpec {
  template <typename A, typename = common::NoLvalue<A>> ConnectSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ConnectSpec(ConnectSpec &&) = default; ConnectSpec &operator=(ConnectSpec &&) = default; ConnectSpec(const ConnectSpec &) = delete; ConnectSpec &operator=(const ConnectSpec &) = delete; ConnectSpec() = delete;
  struct CharExpr {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; }


    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Recl { Recl(Recl &&) = default; Recl &operator=(Recl &&) = default; Recl(const Recl &) = delete; Recl &operator=(const Recl &) = delete; Recl() = delete; Recl(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Newunit { Newunit(Newunit &&) = default; Newunit &operator=(Newunit &&) = default; Newunit(const Newunit &) = delete; Newunit &operator=(const Newunit &) = delete; Newunit() = delete; Newunit(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<FileUnitNumber, FileNameExpr, CharExpr, MsgVariable,
      StatVariable, Recl, Newunit, ErrLabel, StatusExpr>
      u;
};


struct OpenStmt { OpenStmt(OpenStmt &&) = default; OpenStmt &operator=(OpenStmt &&) = default; OpenStmt(const OpenStmt &) = delete; OpenStmt &operator=(const OpenStmt &) = delete; OpenStmt() = delete; OpenStmt(std::list<ConnectSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ConnectSpec> v; };






struct CloseStmt {
  struct CloseSpec {
    template <typename A, typename = common::NoLvalue<A>> CloseSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CloseSpec(CloseSpec &&) = default; CloseSpec &operator=(CloseSpec &&) = default; CloseSpec(const CloseSpec &) = delete; CloseSpec &operator=(const CloseSpec &) = delete; CloseSpec() = delete;
    std::variant<FileUnitNumber, StatVariable, MsgVariable, ErrLabel,
        StatusExpr>
        u;
  };
  CloseStmt(CloseStmt &&) = default; CloseStmt &operator=(CloseStmt &&) = default; CloseStmt(const CloseStmt &) = delete; CloseStmt &operator=(const CloseStmt &) = delete; CloseStmt() = delete; CloseStmt(std::list<CloseSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<CloseSpec> v;
};



struct Format {
  template <typename A, typename = common::NoLvalue<A>> Format(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Format(Format &&) = default; Format &operator=(Format &&) = default; Format(const Format &) = delete; Format &operator=(const Format &) = delete; Format() = delete;
  std::variant<Expr, Label, Star> u;
};


struct IdVariable { IdVariable(IdVariable &&) = default; IdVariable &operator=(IdVariable &&) = default; IdVariable(const IdVariable &) = delete; IdVariable &operator=(const IdVariable &) = delete; IdVariable() = delete; IdVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
# 2670 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct EndLabel { EndLabel(EndLabel &&) = default; EndLabel &operator=(EndLabel &&) = default; EndLabel(const EndLabel &) = delete; EndLabel &operator=(const EndLabel &) = delete; EndLabel() = delete; EndLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct EorLabel { EorLabel(EorLabel &&) = default; EorLabel &operator=(EorLabel &&) = default; EorLabel(const EorLabel &) = delete; EorLabel &operator=(const EorLabel &) = delete; EorLabel() = delete; EorLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct IoControlSpec {
  template <typename A, typename = common::NoLvalue<A>> IoControlSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoControlSpec(IoControlSpec &&) = default; IoControlSpec &operator=(IoControlSpec &&) = default; IoControlSpec(const IoControlSpec &) = delete; IoControlSpec &operator=(const IoControlSpec &) = delete; IoControlSpec() = delete;
  struct CharExpr {
    enum class Kind { Advance, Blank, Decimal, Delim, Pad, Round, Sign }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Asynchronous { Asynchronous(Asynchronous &&) = default; Asynchronous &operator=(Asynchronous &&) = default; Asynchronous(const Asynchronous &) = delete; Asynchronous &operator=(const Asynchronous &) = delete; Asynchronous() = delete; Asynchronous(ScalarDefaultCharConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharConstantExpr v; };
  struct Pos { Pos(Pos &&) = default; Pos &operator=(Pos &&) = default; Pos(const Pos &) = delete; Pos &operator=(const Pos &) = delete; Pos() = delete; Pos(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Rec { Rec(Rec &&) = default; Rec &operator=(Rec &&) = default; Rec(const Rec &) = delete; Rec &operator=(const Rec &) = delete; Rec() = delete; Rec(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Size { Size(Size &&) = default; Size &operator=(Size &&) = default; Size(const Size &) = delete; Size &operator=(const Size &) = delete; Size() = delete; Size(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<IoUnit, Format, Name, CharExpr, Asynchronous, EndLabel, EorLabel,
      ErrLabel, IdVariable, MsgVariable, StatVariable, Pos, Rec, Size>
      u;
};


struct InputItem {
  template <typename A, typename = common::NoLvalue<A>> InputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InputItem(InputItem &&) = default; InputItem &operator=(InputItem &&) = default; InputItem(const InputItem &) = delete; InputItem &operator=(const InputItem &) = delete; InputItem() = delete;
  std::variant<Variable, common::Indirection<InputImpliedDo>> u;
};




struct ReadStmt {
  ReadStmt(ReadStmt &&) = default; ReadStmt &operator=(ReadStmt &&) = default; ReadStmt(const ReadStmt &) = delete; ReadStmt &operator=(const ReadStmt &) = delete; ReadStmt() = delete;
  ReadStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<InputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;


  std::list<IoControlSpec> controls;
  std::list<InputItem> items;
};


struct OutputItem {
  template <typename A, typename = common::NoLvalue<A>> OutputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OutputItem(OutputItem &&) = default; OutputItem &operator=(OutputItem &&) = default; OutputItem(const OutputItem &) = delete; OutputItem &operator=(const OutputItem &) = delete; OutputItem() = delete;
  std::variant<Expr, common::Indirection<OutputImpliedDo>> u;
};


struct WriteStmt {
  WriteStmt(WriteStmt &&) = default; WriteStmt &operator=(WriteStmt &&) = default; WriteStmt(const WriteStmt &) = delete; WriteStmt &operator=(const WriteStmt &) = delete; WriteStmt() = delete;
  WriteStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<OutputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;

  std::list<IoControlSpec> controls;
  std::list<OutputItem> items;
};


struct PrintStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PrintStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PrintStmt(PrintStmt &&) = default; PrintStmt &operator=(PrintStmt &&) = default; PrintStmt(const PrintStmt &) = delete; PrintStmt &operator=(const PrintStmt &) = delete; PrintStmt() = delete;
  std::tuple<Format, std::list<OutputItem>> t;
};



using IoImpliedDoControl = LoopBounds<DoVariable, ScalarIntExpr>;



struct InputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InputImpliedDo(InputImpliedDo &&) = default; InputImpliedDo &operator=(InputImpliedDo &&) = default; InputImpliedDo(const InputImpliedDo &) = delete; InputImpliedDo &operator=(const InputImpliedDo &) = delete; InputImpliedDo() = delete;
  std::tuple<std::list<InputItem>, IoImpliedDoControl> t;
};

struct OutputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OutputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OutputImpliedDo(OutputImpliedDo &&) = default; OutputImpliedDo &operator=(OutputImpliedDo &&) = default; OutputImpliedDo(const OutputImpliedDo &) = delete; OutputImpliedDo &operator=(const OutputImpliedDo &) = delete; OutputImpliedDo() = delete;
  std::tuple<std::list<OutputItem>, IoImpliedDoControl> t;
};





struct IdExpr { IdExpr(IdExpr &&) = default; IdExpr &operator=(IdExpr &&) = default; IdExpr(const IdExpr &) = delete; IdExpr &operator=(const IdExpr &) = delete; IdExpr() = delete; IdExpr(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct WaitSpec {
  template <typename A, typename = common::NoLvalue<A>> WaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WaitSpec(WaitSpec &&) = default; WaitSpec &operator=(WaitSpec &&) = default; WaitSpec(const WaitSpec &) = delete; WaitSpec &operator=(const WaitSpec &) = delete; WaitSpec() = delete;
  std::variant<FileUnitNumber, EndLabel, EorLabel, ErrLabel, IdExpr,
      MsgVariable, StatVariable>
      u;
};


struct WaitStmt { WaitStmt(WaitStmt &&) = default; WaitStmt &operator=(WaitStmt &&) = default; WaitStmt(const WaitStmt &) = delete; WaitStmt &operator=(const WaitStmt &) = delete; WaitStmt() = delete; WaitStmt(std::list<WaitSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<WaitSpec> v; };







struct PositionOrFlushSpec {
  template <typename A, typename = common::NoLvalue<A>> PositionOrFlushSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PositionOrFlushSpec(PositionOrFlushSpec &&) = default; PositionOrFlushSpec &operator=(PositionOrFlushSpec &&) = default; PositionOrFlushSpec(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec &operator=(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec() = delete;
  std::variant<FileUnitNumber, MsgVariable, StatVariable, ErrLabel> u;
};



struct BackspaceStmt { BackspaceStmt(BackspaceStmt &&) = default; BackspaceStmt &operator=(BackspaceStmt &&) = default; BackspaceStmt(const BackspaceStmt &) = delete; BackspaceStmt &operator=(const BackspaceStmt &) = delete; BackspaceStmt() = delete; BackspaceStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };



struct EndfileStmt { EndfileStmt(EndfileStmt &&) = default; EndfileStmt &operator=(EndfileStmt &&) = default; EndfileStmt(const EndfileStmt &) = delete; EndfileStmt &operator=(const EndfileStmt &) = delete; EndfileStmt() = delete; EndfileStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct RewindStmt { RewindStmt(RewindStmt &&) = default; RewindStmt &operator=(RewindStmt &&) = default; RewindStmt(const RewindStmt &) = delete; RewindStmt &operator=(const RewindStmt &) = delete; RewindStmt() = delete; RewindStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct FlushStmt { FlushStmt(FlushStmt &&) = default; FlushStmt &operator=(FlushStmt &&) = default; FlushStmt(const FlushStmt &) = delete; FlushStmt &operator=(const FlushStmt &) = delete; FlushStmt() = delete; FlushStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };
# 2830 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct InquireSpec {
  template <typename A, typename = common::NoLvalue<A>> InquireSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireSpec(InquireSpec &&) = default; InquireSpec &operator=(InquireSpec &&) = default; InquireSpec(const InquireSpec &) = delete; InquireSpec &operator=(const InquireSpec &) = delete; InquireSpec() = delete;
  struct CharVar {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; }



    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharVar(CharVar &&) = default; CharVar &operator=(CharVar &&) = default; CharVar(const CharVar &) = delete; CharVar &operator=(const CharVar &) = delete; CharVar() = delete;
    std::tuple<Kind, ScalarDefaultCharVariable> t;
  };
  struct IntVar {
    enum class Kind { Iostat, Nextrec, Number, Pos, Recl, Size }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Iostat, Nextrec, Number, Pos, Recl, Size")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Iostat, Nextrec, Number, Pos, Recl, Size")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntVar(IntVar &&) = default; IntVar &operator=(IntVar &&) = default; IntVar(const IntVar &) = delete; IntVar &operator=(const IntVar &) = delete; IntVar() = delete;
    std::tuple<Kind, ScalarIntVariable> t;
  };
  struct LogVar {
    enum class Kind { Exist, Named, Opened, Pending }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Exist, Named, Opened, Pending")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Exist, Named, Opened, Pending")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> LogVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LogVar(LogVar &&) = default; LogVar &operator=(LogVar &&) = default; LogVar(const LogVar &) = delete; LogVar &operator=(const LogVar &) = delete; LogVar() = delete;
    std::tuple<Kind, Scalar<Logical<Variable>>> t;
  };
  std::variant<FileUnitNumber, FileNameExpr, CharVar, IntVar, LogVar, IdExpr,
      ErrLabel>
      u;
};




struct InquireStmt {
  template <typename A, typename = common::NoLvalue<A>> InquireStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireStmt(InquireStmt &&) = default; InquireStmt &operator=(InquireStmt &&) = default; InquireStmt(const InquireStmt &) = delete; InquireStmt &operator=(const InquireStmt &) = delete; InquireStmt() = delete;
  struct Iolength {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Iolength(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Iolength(Iolength &&) = default; Iolength &operator=(Iolength &&) = default; Iolength(const Iolength &) = delete; Iolength &operator=(const Iolength &) = delete; Iolength() = delete;
    std::tuple<ScalarIntVariable, std::list<OutputItem>> t;
  };
  std::variant<std::list<InquireSpec>, Iolength> u;
};


struct FormatStmt { FormatStmt(FormatStmt &&) = default; FormatStmt &operator=(FormatStmt &&) = default; FormatStmt(const FormatStmt &) = delete; FormatStmt &operator=(const FormatStmt &) = delete; FormatStmt() = delete; FormatStmt(format::FormatSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; format::FormatSpecification v; };


struct ProgramStmt { ProgramStmt(ProgramStmt &&) = default; ProgramStmt &operator=(ProgramStmt &&) = default; ProgramStmt(const ProgramStmt &) = delete; ProgramStmt &operator=(const ProgramStmt &) = delete; ProgramStmt() = delete; ProgramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndProgramStmt { EndProgramStmt(EndProgramStmt &&) = default; EndProgramStmt &operator=(EndProgramStmt &&) = default; EndProgramStmt(const EndProgramStmt &) = delete; EndProgramStmt &operator=(const EndProgramStmt &) = delete; EndProgramStmt() = delete; EndProgramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct MainProgram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MainProgram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MainProgram(MainProgram &&) = default; MainProgram &operator=(MainProgram &&) = default; MainProgram(const MainProgram &) = delete; MainProgram &operator=(const MainProgram &) = delete; MainProgram() = delete;
  std::tuple<std::optional<Statement<ProgramStmt>>, SpecificationPart,
      ExecutionPart, std::optional<InternalSubprogramPart>,
      Statement<EndProgramStmt>>
      t;
};


struct ModuleStmt { ModuleStmt(ModuleStmt &&) = default; ModuleStmt &operator=(ModuleStmt &&) = default; ModuleStmt(const ModuleStmt &) = delete; ModuleStmt &operator=(const ModuleStmt &) = delete; ModuleStmt() = delete; ModuleStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };




struct ModuleSubprogram {
  template <typename A, typename = common::NoLvalue<A>> ModuleSubprogram(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ModuleSubprogram(ModuleSubprogram &&) = default; ModuleSubprogram &operator=(ModuleSubprogram &&) = default; ModuleSubprogram(const ModuleSubprogram &) = delete; ModuleSubprogram &operator=(const ModuleSubprogram &) = delete; ModuleSubprogram() = delete;
  std::variant<common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>,
      common::Indirection<SeparateModuleSubprogram>>
      u;
};


struct ModuleSubprogramPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ModuleSubprogramPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ModuleSubprogramPart(ModuleSubprogramPart &&) = default; ModuleSubprogramPart &operator=(ModuleSubprogramPart &&) = default; ModuleSubprogramPart(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart &operator=(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart() = delete;
  std::tuple<Statement<ContainsStmt>, std::list<ModuleSubprogram>> t;
};


struct EndModuleStmt { EndModuleStmt(EndModuleStmt &&) = default; EndModuleStmt &operator=(EndModuleStmt &&) = default; EndModuleStmt(const EndModuleStmt &) = delete; EndModuleStmt &operator=(const EndModuleStmt &) = delete; EndModuleStmt() = delete; EndModuleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Module {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Module(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Module(Module &&) = default; Module &operator=(Module &&) = default; Module(const Module &) = delete; Module &operator=(const Module &) = delete; Module() = delete;
  std::tuple<Statement<ModuleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndModuleStmt>>
      t;
};





struct Rename {
  template <typename A, typename = common::NoLvalue<A>> Rename(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rename(Rename &&) = default; Rename &operator=(Rename &&) = default; Rename(const Rename &) = delete; Rename &operator=(const Rename &) = delete; Rename() = delete;
  struct Names {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Names(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Names(Names &&) = default; Names &operator=(Names &&) = default; Names(const Names &) = delete; Names &operator=(const Names &) = delete; Names() = delete;
    std::tuple<Name, Name> t;
  };
  struct Operators {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Operators(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Operators(Operators &&) = default; Operators &operator=(Operators &&) = default; Operators(const Operators &) = delete; Operators &operator=(const Operators &) = delete; Operators() = delete;
    std::tuple<DefinedOpName, DefinedOpName> t;
  };
  std::variant<Names, Operators> u;
};


struct ParentIdentifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ParentIdentifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ParentIdentifier(ParentIdentifier &&) = default; ParentIdentifier &operator=(ParentIdentifier &&) = default; ParentIdentifier(const ParentIdentifier &) = delete; ParentIdentifier &operator=(const ParentIdentifier &) = delete; ParentIdentifier() = delete;
  std::tuple<Name, std::optional<Name>> t;
};


struct SubmoduleStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubmoduleStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubmoduleStmt(SubmoduleStmt &&) = default; SubmoduleStmt &operator=(SubmoduleStmt &&) = default; SubmoduleStmt(const SubmoduleStmt &) = delete; SubmoduleStmt &operator=(const SubmoduleStmt &) = delete; SubmoduleStmt() = delete;
  std::tuple<ParentIdentifier, Name> t;
};


struct EndSubmoduleStmt { EndSubmoduleStmt(EndSubmoduleStmt &&) = default; EndSubmoduleStmt &operator=(EndSubmoduleStmt &&) = default; EndSubmoduleStmt(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt &operator=(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt() = delete; EndSubmoduleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Submodule {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Submodule(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Submodule(Submodule &&) = default; Submodule &operator=(Submodule &&) = default; Submodule(const Submodule &) = delete; Submodule &operator=(const Submodule &) = delete; Submodule() = delete;
  std::tuple<Statement<SubmoduleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndSubmoduleStmt>>
      t;
};


struct BlockDataStmt { BlockDataStmt(BlockDataStmt &&) = default; BlockDataStmt &operator=(BlockDataStmt &&) = default; BlockDataStmt(const BlockDataStmt &) = delete; BlockDataStmt &operator=(const BlockDataStmt &) = delete; BlockDataStmt() = delete; BlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockDataStmt { EndBlockDataStmt(EndBlockDataStmt &&) = default; EndBlockDataStmt &operator=(EndBlockDataStmt &&) = default; EndBlockDataStmt(const EndBlockDataStmt &) = delete; EndBlockDataStmt &operator=(const EndBlockDataStmt &) = delete; EndBlockDataStmt() = delete; EndBlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct BlockData {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockData(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockData(BlockData &&) = default; BlockData &operator=(BlockData &&) = default; BlockData(const BlockData &) = delete; BlockData &operator=(const BlockData &) = delete; BlockData() = delete;
  std::tuple<Statement<BlockDataStmt>, SpecificationPart,
      Statement<EndBlockDataStmt>>
      t;
};







struct GenericSpec {
  template <typename A, typename = common::NoLvalue<A>> GenericSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; GenericSpec(GenericSpec &&) = default; GenericSpec &operator=(GenericSpec &&) = default; GenericSpec(const GenericSpec &) = delete; GenericSpec &operator=(const GenericSpec &) = delete; GenericSpec() = delete;
  struct Assignment { Assignment() {} Assignment(const Assignment &) {} Assignment(Assignment &&) {} Assignment &operator=(const Assignment &) { return *this; }; Assignment &operator=(Assignment &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadFormatted { ReadFormatted() {} ReadFormatted(const ReadFormatted &) {} ReadFormatted(ReadFormatted &&) {} ReadFormatted &operator=(const ReadFormatted &) { return *this; }; ReadFormatted &operator=(ReadFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadUnformatted { ReadUnformatted() {} ReadUnformatted(const ReadUnformatted &) {} ReadUnformatted(ReadUnformatted &&) {} ReadUnformatted &operator=(const ReadUnformatted &) { return *this; }; ReadUnformatted &operator=(ReadUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteFormatted { WriteFormatted() {} WriteFormatted(const WriteFormatted &) {} WriteFormatted(WriteFormatted &&) {} WriteFormatted &operator=(const WriteFormatted &) { return *this; }; WriteFormatted &operator=(WriteFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteUnformatted { WriteUnformatted() {} WriteUnformatted(const WriteUnformatted &) {} WriteUnformatted(WriteUnformatted &&) {} WriteUnformatted &operator=(const WriteUnformatted &) { return *this; }; WriteUnformatted &operator=(WriteUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  CharBlock source;
  std::variant<Name, DefinedOperator, Assignment, ReadFormatted,
      ReadUnformatted, WriteFormatted, WriteUnformatted>
      u;
};



struct GenericStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> GenericStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; GenericStmt(GenericStmt &&) = default; GenericStmt &operator=(GenericStmt &&) = default; GenericStmt(const GenericStmt &) = delete; GenericStmt &operator=(const GenericStmt &) = delete; GenericStmt() = delete;
  std::tuple<std::optional<AccessSpec>, GenericSpec, std::list<Name>> t;
};


struct InterfaceStmt {
  template <typename A, typename = common::NoLvalue<A>> InterfaceStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceStmt(InterfaceStmt &&) = default; InterfaceStmt &operator=(InterfaceStmt &&) = default; InterfaceStmt(const InterfaceStmt &) = delete; InterfaceStmt &operator=(const InterfaceStmt &) = delete; InterfaceStmt() = delete;

  InterfaceStmt(Abstract x) : u{x} {}

  std::variant<std::optional<GenericSpec>, Abstract> u;
};



struct Only {
  template <typename A, typename = common::NoLvalue<A>> Only(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Only(Only &&) = default; Only &operator=(Only &&) = default; Only(const Only &) = delete; Only &operator=(const Only &) = delete; Only() = delete;
  std::variant<common::Indirection<GenericSpec>, Name, Rename> u;
};





struct UseStmt {
  UseStmt(UseStmt &&) = default; UseStmt &operator=(UseStmt &&) = default; UseStmt(const UseStmt &) = delete; UseStmt &operator=(const UseStmt &) = delete; UseStmt() = delete;
  enum class ModuleNature { Intrinsic, Non_Intrinsic }; [[maybe_unused]] static constexpr std::size_t ModuleNature_enumSize{ ::Fortran::common::CountEnumNames("Intrinsic, Non_Intrinsic")}; [[maybe_unused]] static inline std::string_view EnumToString(ModuleNature e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ModuleNature_enumSize>("Intrinsic, Non_Intrinsic")}; return names[static_cast<std::size_t>(e)]; }
  template <typename A>
  UseStmt(std::optional<ModuleNature> &&nat, Name &&n, std::list<A> &&x)
      : nature(std::move(nat)), moduleName(std::move(n)), u(std::move(x)) {}
  std::optional<ModuleNature> nature;
  Name moduleName;
  std::variant<std::list<Rename>, std::list<Only>> u;
};




struct ProcAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ProcAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcAttrSpec(ProcAttrSpec &&) = default; ProcAttrSpec &operator=(ProcAttrSpec &&) = default; ProcAttrSpec(const ProcAttrSpec &) = delete; ProcAttrSpec &operator=(const ProcAttrSpec &) = delete; ProcAttrSpec() = delete;
  std::variant<AccessSpec, LanguageBindingSpec, IntentSpec, Optional, Pointer,
      Protected, Save>
      u;
};




struct ProcedureDeclarationStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureDeclarationStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureDeclarationStmt(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt &operator=(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt &operator=(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt() = delete;
  std::tuple<std::optional<ProcInterface>, std::list<ProcAttrSpec>,
      std::list<ProcDecl>>
      t;
};






struct PrefixSpec {
  template <typename A, typename = common::NoLvalue<A>> PrefixSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PrefixSpec(PrefixSpec &&) = default; PrefixSpec &operator=(PrefixSpec &&) = default; PrefixSpec(const PrefixSpec &) = delete; PrefixSpec &operator=(const PrefixSpec &) = delete; PrefixSpec() = delete;
  struct Elemental { Elemental() {} Elemental(const Elemental &) {} Elemental(Elemental &&) {} Elemental &operator=(const Elemental &) { return *this; }; Elemental &operator=(Elemental &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Impure { Impure() {} Impure(const Impure &) {} Impure(Impure &&) {} Impure &operator=(const Impure &) { return *this; }; Impure &operator=(Impure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Module { Module() {} Module(const Module &) {} Module(Module &&) {} Module &operator=(const Module &) { return *this; }; Module &operator=(Module &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Non_Recursive { Non_Recursive() {} Non_Recursive(const Non_Recursive &) {} Non_Recursive(Non_Recursive &&) {} Non_Recursive &operator=(const Non_Recursive &) { return *this; }; Non_Recursive &operator=(Non_Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Pure { Pure() {} Pure(const Pure &) {} Pure(Pure &&) {} Pure &operator=(const Pure &) { return *this; }; Pure &operator=(Pure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Recursive { Recursive() {} Recursive(const Recursive &) {} Recursive(Recursive &&) {} Recursive &operator=(const Recursive &) { return *this; }; Recursive &operator=(Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Attributes { Attributes(Attributes &&) = default; Attributes &operator=(Attributes &&) = default; Attributes(const Attributes &) = delete; Attributes &operator=(const Attributes &) = delete; Attributes() = delete; Attributes(std::list<common::CUDASubprogramAttrs> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<common::CUDASubprogramAttrs> v; };
  struct Launch_Bounds { Launch_Bounds(Launch_Bounds &&) = default; Launch_Bounds &operator=(Launch_Bounds &&) = default; Launch_Bounds(const Launch_Bounds &) = delete; Launch_Bounds &operator=(const Launch_Bounds &) = delete; Launch_Bounds() = delete; Launch_Bounds(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  struct Cluster_Dims { Cluster_Dims(Cluster_Dims &&) = default; Cluster_Dims &operator=(Cluster_Dims &&) = default; Cluster_Dims(const Cluster_Dims &) = delete; Cluster_Dims &operator=(const Cluster_Dims &) = delete; Cluster_Dims() = delete; Cluster_Dims(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  std::variant<DeclarationTypeSpec, Elemental, Impure, Module, Non_Recursive,
      Pure, Recursive, Attributes, Launch_Bounds, Cluster_Dims>
      u;
};




struct Suffix {
  Suffix(Suffix &&) = default; Suffix &operator=(Suffix &&) = default; Suffix(const Suffix &) = delete; Suffix &operator=(const Suffix &) = delete; Suffix() = delete;
  Suffix(LanguageBindingSpec &&lbs, std::optional<Name> &&rn)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  Suffix(Name &&rn, std::optional<LanguageBindingSpec> &&lbs)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  std::optional<LanguageBindingSpec> binding;
  std::optional<Name> resultName;
};





struct FunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionStmt(FunctionStmt &&) = default; FunctionStmt &operator=(FunctionStmt &&) = default; FunctionStmt(const FunctionStmt &) = delete; FunctionStmt &operator=(const FunctionStmt &) = delete; FunctionStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<Name>,
      std::optional<Suffix>>
      t;
};


struct EndFunctionStmt { EndFunctionStmt(EndFunctionStmt &&) = default; EndFunctionStmt &operator=(EndFunctionStmt &&) = default; EndFunctionStmt(const EndFunctionStmt &) = delete; EndFunctionStmt &operator=(const EndFunctionStmt &) = delete; EndFunctionStmt() = delete; EndFunctionStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct DummyArg {
  template <typename A, typename = common::NoLvalue<A>> DummyArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DummyArg(DummyArg &&) = default; DummyArg &operator=(DummyArg &&) = default; DummyArg(const DummyArg &) = delete; DummyArg &operator=(const DummyArg &) = delete; DummyArg() = delete;
  std::variant<Name, Star> u;
};




struct SubroutineStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineStmt(SubroutineStmt &&) = default; SubroutineStmt &operator=(SubroutineStmt &&) = default; SubroutineStmt(const SubroutineStmt &) = delete; SubroutineStmt &operator=(const SubroutineStmt &) = delete; SubroutineStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<DummyArg>,
      std::optional<LanguageBindingSpec>>
      t;
};


struct EndSubroutineStmt { EndSubroutineStmt(EndSubroutineStmt &&) = default; EndSubroutineStmt &operator=(EndSubroutineStmt &&) = default; EndSubroutineStmt(const EndSubroutineStmt &) = delete; EndSubroutineStmt &operator=(const EndSubroutineStmt &) = delete; EndSubroutineStmt() = delete; EndSubroutineStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct InterfaceBody {
  template <typename A, typename = common::NoLvalue<A>> InterfaceBody(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceBody(InterfaceBody &&) = default; InterfaceBody &operator=(InterfaceBody &&) = default; InterfaceBody(const InterfaceBody &) = delete; InterfaceBody &operator=(const InterfaceBody &) = delete; InterfaceBody() = delete;
  struct Function {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Function(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Function(Function &&) = default; Function &operator=(Function &&) = default; Function(const Function &) = delete; Function &operator=(const Function &) = delete; Function() = delete;
    std::tuple<Statement<FunctionStmt>, common::Indirection<SpecificationPart>,
        Statement<EndFunctionStmt>>
        t;
  };
  struct Subroutine {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Subroutine(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Subroutine(Subroutine &&) = default; Subroutine &operator=(Subroutine &&) = default; Subroutine(const Subroutine &) = delete; Subroutine &operator=(const Subroutine &) = delete; Subroutine() = delete;
    std::tuple<Statement<SubroutineStmt>,
        common::Indirection<SpecificationPart>, Statement<EndSubroutineStmt>>
        t;
  };
  std::variant<Function, Subroutine> u;
};


struct ProcedureStmt {
  enum class Kind { ModuleProcedure, Procedure }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("ModuleProcedure, Procedure")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("ModuleProcedure, Procedure")}; return names[static_cast<std::size_t>(e)]; }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureStmt(ProcedureStmt &&) = default; ProcedureStmt &operator=(ProcedureStmt &&) = default; ProcedureStmt(const ProcedureStmt &) = delete; ProcedureStmt &operator=(const ProcedureStmt &) = delete; ProcedureStmt() = delete;
  std::tuple<Kind, std::list<Name>> t;
};


struct InterfaceSpecification {
  template <typename A, typename = common::NoLvalue<A>> InterfaceSpecification(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceSpecification(InterfaceSpecification &&) = default; InterfaceSpecification &operator=(InterfaceSpecification &&) = default; InterfaceSpecification(const InterfaceSpecification &) = delete; InterfaceSpecification &operator=(const InterfaceSpecification &) = delete; InterfaceSpecification() = delete;
  std::variant<InterfaceBody, Statement<ProcedureStmt>> u;
};


struct EndInterfaceStmt { EndInterfaceStmt(EndInterfaceStmt &&) = default; EndInterfaceStmt &operator=(EndInterfaceStmt &&) = default; EndInterfaceStmt(const EndInterfaceStmt &) = delete; EndInterfaceStmt &operator=(const EndInterfaceStmt &) = delete; EndInterfaceStmt() = delete; EndInterfaceStmt(std::optional<GenericSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<GenericSpec> v; };



struct InterfaceBlock {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InterfaceBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InterfaceBlock(InterfaceBlock &&) = default; InterfaceBlock &operator=(InterfaceBlock &&) = default; InterfaceBlock(const InterfaceBlock &) = delete; InterfaceBlock &operator=(const InterfaceBlock &) = delete; InterfaceBlock() = delete;
  std::tuple<Statement<InterfaceStmt>, std::list<InterfaceSpecification>,
      Statement<EndInterfaceStmt>>
      t;
};


struct ExternalStmt { ExternalStmt(ExternalStmt &&) = default; ExternalStmt &operator=(ExternalStmt &&) = default; ExternalStmt(const ExternalStmt &) = delete; ExternalStmt &operator=(const ExternalStmt &) = delete; ExternalStmt() = delete; ExternalStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };


struct IntrinsicStmt { IntrinsicStmt(IntrinsicStmt &&) = default; IntrinsicStmt &operator=(IntrinsicStmt &&) = default; IntrinsicStmt(const IntrinsicStmt &) = delete; IntrinsicStmt &operator=(const IntrinsicStmt &) = delete; IntrinsicStmt() = delete; IntrinsicStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct ProcedureDesignator {
  template <typename A, typename = common::NoLvalue<A>> ProcedureDesignator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcedureDesignator(ProcedureDesignator &&) = default; ProcedureDesignator &operator=(ProcedureDesignator &&) = default; ProcedureDesignator(const ProcedureDesignator &) = delete; ProcedureDesignator &operator=(const ProcedureDesignator &) = delete; ProcedureDesignator() = delete;
  std::variant<Name, ProcComponentRef> u;
};


struct AltReturnSpec { AltReturnSpec(AltReturnSpec &&) = default; AltReturnSpec &operator=(AltReturnSpec &&) = default; AltReturnSpec(const AltReturnSpec &) = delete; AltReturnSpec &operator=(const AltReturnSpec &) = delete; AltReturnSpec() = delete; AltReturnSpec(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };




struct ActualArg {
  struct PercentRef { PercentRef(PercentRef &&) = default; PercentRef &operator=(PercentRef &&) = default; PercentRef(const PercentRef &) = delete; PercentRef &operator=(const PercentRef &) = delete; PercentRef() = delete; PercentRef(Variable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Variable v; };
  struct PercentVal { PercentVal(PercentVal &&) = default; PercentVal &operator=(PercentVal &&) = default; PercentVal(const PercentVal &) = delete; PercentVal &operator=(const PercentVal &) = delete; PercentVal() = delete; PercentVal(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };
  template <typename A, typename = common::NoLvalue<A>> ActualArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ActualArg(ActualArg &&) = default; ActualArg &operator=(ActualArg &&) = default; ActualArg(const ActualArg &) = delete; ActualArg &operator=(const ActualArg &) = delete; ActualArg() = delete;
  ActualArg(Expr &&x) : u{common::Indirection<Expr>(std::move(x))} {}
  std::variant<common::Indirection<Expr>, AltReturnSpec, PercentRef, PercentVal>
      u;
};


struct ActualArgSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ActualArgSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ActualArgSpec(ActualArgSpec &&) = default; ActualArgSpec &operator=(ActualArgSpec &&) = default; ActualArgSpec(const ActualArgSpec &) = delete; ActualArgSpec &operator=(const ActualArgSpec &) = delete; ActualArgSpec() = delete;
  std::tuple<std::optional<Keyword>, ActualArg> t;
};



struct Call {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Call(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Call(Call &&) = default; Call &operator=(Call &&) = default; Call(const Call &) = delete; Call &operator=(const Call &) = delete; Call() = delete;
  std::tuple<ProcedureDesignator, std::list<ActualArgSpec>> t;
};

struct FunctionReference {
  FunctionReference(FunctionReference &&) = default; FunctionReference &operator=(FunctionReference &&) = default; FunctionReference(const FunctionReference &) = delete; FunctionReference &operator=(const FunctionReference &) = delete; FunctionReference() = delete; FunctionReference(Call &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Call v;
  CharBlock source;
  Designator ConvertToArrayElementRef();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
};





struct CallStmt {
  CallStmt(CallStmt &&) = default; CallStmt &operator=(CallStmt &&) = default; CallStmt(const CallStmt &) = delete; CallStmt &operator=(const CallStmt &) = delete; CallStmt() = delete;
  struct Chevrons {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Chevrons(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Chevrons(Chevrons &&) = default; Chevrons &operator=(Chevrons &&) = default; Chevrons(const Chevrons &) = delete; Chevrons &operator=(const Chevrons &) = delete; Chevrons() = delete;
    std::tuple<ScalarExpr, ScalarExpr, std::optional<ScalarIntExpr>,
        std::optional<ScalarIntExpr>>
        t;
  };
  explicit CallStmt(ProcedureDesignator &&pd, std::optional<Chevrons> &&ch,
      std::list<ActualArgSpec> &&args)
      : call{std::move(pd), std::move(args)}, chevrons{std::move(ch)} {}
  Call call;
  std::optional<Chevrons> chevrons;
  CharBlock source;
  mutable common::ForwardOwningPointer<evaluate::ProcedureRef>
      typedCall;
};




struct FunctionSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionSubprogram(FunctionSubprogram &&) = default; FunctionSubprogram &operator=(FunctionSubprogram &&) = default; FunctionSubprogram(const FunctionSubprogram &) = delete; FunctionSubprogram &operator=(const FunctionSubprogram &) = delete; FunctionSubprogram() = delete;
  std::tuple<Statement<FunctionStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndFunctionStmt>>
      t;
};




struct SubroutineSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineSubprogram(SubroutineSubprogram &&) = default; SubroutineSubprogram &operator=(SubroutineSubprogram &&) = default; SubroutineSubprogram(const SubroutineSubprogram &) = delete; SubroutineSubprogram &operator=(const SubroutineSubprogram &) = delete; SubroutineSubprogram() = delete;
  std::tuple<Statement<SubroutineStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndSubroutineStmt>>
      t;
};


struct MpSubprogramStmt { MpSubprogramStmt(MpSubprogramStmt &&) = default; MpSubprogramStmt &operator=(MpSubprogramStmt &&) = default; MpSubprogramStmt(const MpSubprogramStmt &) = delete; MpSubprogramStmt &operator=(const MpSubprogramStmt &) = delete; MpSubprogramStmt() = delete; MpSubprogramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndMpSubprogramStmt { EndMpSubprogramStmt(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt &operator=(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt &operator=(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt() = delete; EndMpSubprogramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct SeparateModuleSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SeparateModuleSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SeparateModuleSubprogram(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram &operator=(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram &operator=(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram() = delete;
  std::tuple<Statement<MpSubprogramStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndMpSubprogramStmt>>
      t;
};


struct EntryStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EntryStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EntryStmt(EntryStmt &&) = default; EntryStmt &operator=(EntryStmt &&) = default; EntryStmt(const EntryStmt &) = delete; EntryStmt &operator=(const EntryStmt &) = delete; EntryStmt() = delete;
  std::tuple<Name, std::list<DummyArg>, std::optional<Suffix>> t;
};


struct ReturnStmt { ReturnStmt(ReturnStmt &&) = default; ReturnStmt &operator=(ReturnStmt &&) = default; ReturnStmt(const ReturnStmt &) = delete; ReturnStmt &operator=(const ReturnStmt &) = delete; ReturnStmt() = delete; ReturnStmt(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };



struct StmtFunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StmtFunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StmtFunctionStmt(StmtFunctionStmt &&) = default; StmtFunctionStmt &operator=(StmtFunctionStmt &&) = default; StmtFunctionStmt(const StmtFunctionStmt &) = delete; StmtFunctionStmt &operator=(const StmtFunctionStmt &) = delete; StmtFunctionStmt() = delete;
  std::tuple<Name, std::list<Name>, Scalar<Expr>> t;
  Statement<ActionStmt> ConvertToAssignment();
};





struct CompilerDirective {
  template <typename A, typename = common::NoLvalue<A>> CompilerDirective(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CompilerDirective(CompilerDirective &&) = default; CompilerDirective &operator=(CompilerDirective &&) = default; CompilerDirective(const CompilerDirective &) = delete; CompilerDirective &operator=(const CompilerDirective &) = delete; CompilerDirective() = delete;
  struct IgnoreTKR {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IgnoreTKR(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IgnoreTKR(IgnoreTKR &&) = default; IgnoreTKR &operator=(IgnoreTKR &&) = default; IgnoreTKR(const IgnoreTKR &) = delete; IgnoreTKR &operator=(const IgnoreTKR &) = delete; IgnoreTKR() = delete;
    std::tuple<std::optional<std::list<const char *>>, Name> t;
  };
  struct LoopCount {
    LoopCount(LoopCount &&) = default; LoopCount &operator=(LoopCount &&) = default; LoopCount(const LoopCount &) = delete; LoopCount &operator=(const LoopCount &) = delete; LoopCount() = delete; LoopCount(std::list<std::uint64_t> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<std::uint64_t> v;
  };
  struct NameValue {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> NameValue(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NameValue(NameValue &&) = default; NameValue &operator=(NameValue &&) = default; NameValue(const NameValue &) = delete; NameValue &operator=(const NameValue &) = delete; NameValue() = delete;
    std::tuple<Name, std::optional<std::uint64_t>> t;
  };
  CharBlock source;
  std::variant<std::list<IgnoreTKR>, LoopCount, std::list<NameValue>> u;
};


struct CUDAAttributesStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUDAAttributesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUDAAttributesStmt(CUDAAttributesStmt &&) = default; CUDAAttributesStmt &operator=(CUDAAttributesStmt &&) = default; CUDAAttributesStmt(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt &operator=(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt() = delete;
  std::tuple<common::CUDADataAttr, std::list<Name>> t;
};


struct BasedPointer {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BasedPointer(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BasedPointer(BasedPointer &&) = default; BasedPointer &operator=(BasedPointer &&) = default; BasedPointer(const BasedPointer &) = delete; BasedPointer &operator=(const BasedPointer &) = delete; BasedPointer() = delete;
  std::tuple<ObjectName, ObjectName, std::optional<ArraySpec>> t;
};
struct BasedPointerStmt { BasedPointerStmt(BasedPointerStmt &&) = default; BasedPointerStmt &operator=(BasedPointerStmt &&) = default; BasedPointerStmt(const BasedPointerStmt &) = delete; BasedPointerStmt &operator=(const BasedPointerStmt &) = delete; BasedPointerStmt() = delete; BasedPointerStmt(std::list<BasedPointer> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<BasedPointer> v; };

struct Union;
struct StructureDef;

struct StructureField {
  template <typename A, typename = common::NoLvalue<A>> StructureField(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StructureField(StructureField &&) = default; StructureField &operator=(StructureField &&) = default; StructureField(const StructureField &) = delete; StructureField &operator=(const StructureField &) = delete; StructureField() = delete;
  std::variant<Statement<DataComponentDefStmt>,
      common::Indirection<StructureDef>, common::Indirection<Union>>
      u;
};

struct Map {
  struct MapStmt { MapStmt() {} MapStmt(const MapStmt &) {} MapStmt(MapStmt &&) {} MapStmt &operator=(const MapStmt &) { return *this; }; MapStmt &operator=(MapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndMapStmt { EndMapStmt() {} EndMapStmt(const EndMapStmt &) {} EndMapStmt(EndMapStmt &&) {} EndMapStmt &operator=(const EndMapStmt &) { return *this; }; EndMapStmt &operator=(EndMapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Map(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete;
  std::tuple<Statement<MapStmt>, std::list<StructureField>,
      Statement<EndMapStmt>>
      t;
};

struct Union {
  struct UnionStmt { UnionStmt() {} UnionStmt(const UnionStmt &) {} UnionStmt(UnionStmt &&) {} UnionStmt &operator=(const UnionStmt &) { return *this; }; UnionStmt &operator=(UnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndUnionStmt { EndUnionStmt() {} EndUnionStmt(const EndUnionStmt &) {} EndUnionStmt(EndUnionStmt &&) {} EndUnionStmt &operator=(const EndUnionStmt &) { return *this; }; EndUnionStmt &operator=(EndUnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Union(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Union(Union &&) = default; Union &operator=(Union &&) = default; Union(const Union &) = delete; Union &operator=(const Union &) = delete; Union() = delete;
  std::tuple<Statement<UnionStmt>, std::list<Map>, Statement<EndUnionStmt>> t;
};

struct StructureStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureStmt(StructureStmt &&) = default; StructureStmt &operator=(StructureStmt &&) = default; StructureStmt(const StructureStmt &) = delete; StructureStmt &operator=(const StructureStmt &) = delete; StructureStmt() = delete;
  std::tuple<std::optional<Name>, std::list<EntityDecl>> t;
};

struct StructureDef {
  struct EndStructureStmt { EndStructureStmt() {} EndStructureStmt(const EndStructureStmt &) {} EndStructureStmt(EndStructureStmt &&) {} EndStructureStmt &operator=(const EndStructureStmt &) { return *this; }; EndStructureStmt &operator=(EndStructureStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureDef(StructureDef &&) = default; StructureDef &operator=(StructureDef &&) = default; StructureDef(const StructureDef &) = delete; StructureDef &operator=(const StructureDef &) = delete; StructureDef() = delete;
  std::tuple<Statement<StructureStmt>, std::list<StructureField>,
      Statement<EndStructureStmt>>
      t;
};



struct OldParameterStmt { OldParameterStmt(OldParameterStmt &&) = default; OldParameterStmt &operator=(OldParameterStmt &&) = default; OldParameterStmt(const OldParameterStmt &) = delete; OldParameterStmt &operator=(const OldParameterStmt &) = delete; OldParameterStmt() = delete; OldParameterStmt(std::list<NamedConstantDef> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<NamedConstantDef> v; };


struct ArithmeticIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ArithmeticIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ArithmeticIfStmt(ArithmeticIfStmt &&) = default; ArithmeticIfStmt &operator=(ArithmeticIfStmt &&) = default; ArithmeticIfStmt(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt &operator=(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt() = delete;
  std::tuple<Expr, Label, Label, Label> t;
};

struct AssignStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignStmt(AssignStmt &&) = default; AssignStmt &operator=(AssignStmt &&) = default; AssignStmt(const AssignStmt &) = delete; AssignStmt &operator=(const AssignStmt &) = delete; AssignStmt() = delete;
  std::tuple<Label, Name> t;
};

struct AssignedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignedGotoStmt(AssignedGotoStmt &&) = default; AssignedGotoStmt &operator=(AssignedGotoStmt &&) = default; AssignedGotoStmt(const AssignedGotoStmt &) = delete; AssignedGotoStmt &operator=(const AssignedGotoStmt &) = delete; AssignedGotoStmt() = delete;
  std::tuple<Name, std::list<Label>> t;
};

struct PauseStmt { PauseStmt(PauseStmt &&) = default; PauseStmt &operator=(PauseStmt &&) = default; PauseStmt(const PauseStmt &) = delete; PauseStmt &operator=(const PauseStmt &) = delete; PauseStmt() = delete; PauseStmt(std::optional<StopCode> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<StopCode> v; };




struct OmpProcBindClause {
  enum class Type { Close, Master, Spread, Primary }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Close, Master, Spread, Primary")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Close, Master, Spread, Primary")}; return names[static_cast<std::size_t>(e)]; }
  OmpProcBindClause(OmpProcBindClause &&) = default; OmpProcBindClause &operator=(OmpProcBindClause &&) = default; OmpProcBindClause(const OmpProcBindClause &) = delete; OmpProcBindClause &operator=(const OmpProcBindClause &) = delete; OmpProcBindClause() = delete; OmpProcBindClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};


struct OmpDefaultClause {
  enum class Type { Private, Firstprivate, Shared, None }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Private, Firstprivate, Shared, None")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Private, Firstprivate, Shared, None")}; return names[static_cast<std::size_t>(e)]; }
  OmpDefaultClause(OmpDefaultClause &&) = default; OmpDefaultClause &operator=(OmpDefaultClause &&) = default; OmpDefaultClause(const OmpDefaultClause &) = delete; OmpDefaultClause &operator=(const OmpDefaultClause &) = delete; OmpDefaultClause() = delete; OmpDefaultClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};





struct OmpObject {
  template <typename A, typename = common::NoLvalue<A>> OmpObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpObject(OmpObject &&) = default; OmpObject &operator=(OmpObject &&) = default; OmpObject(const OmpObject &) = delete; OmpObject &operator=(const OmpObject &) = delete; OmpObject() = delete;
  std::variant<Designator, Name> u;
};

struct OmpObjectList { OmpObjectList(OmpObjectList &&) = default; OmpObjectList &operator=(OmpObjectList &&) = default; OmpObjectList(const OmpObjectList &) = delete; OmpObjectList &operator=(const OmpObjectList &) = delete; OmpObjectList() = delete; OmpObjectList(std::list<OmpObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpObject> v; };


struct OmpMapType {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapType(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapType(OmpMapType &&) = default; OmpMapType &operator=(OmpMapType &&) = default; OmpMapType(const OmpMapType &) = delete; OmpMapType &operator=(const OmpMapType &) = delete; OmpMapType() = delete;
  struct Always { Always() {} Always(const Always &) {} Always(Always &&) {} Always &operator=(const Always &) { return *this; }; Always &operator=(Always &&) { return *this; }; using EmptyTrait = std::true_type; };
  enum class Type { To, From, Tofrom, Alloc, Release, Delete }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("To, From, Tofrom, Alloc, Release, Delete")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("To, From, Tofrom, Alloc, Release, Delete")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<Always>, Type> t;
};


struct OmpMapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapClause(OmpMapClause &&) = default; OmpMapClause &operator=(OmpMapClause &&) = default; OmpMapClause(const OmpMapClause &) = delete; OmpMapClause &operator=(const OmpMapClause &) = delete; OmpMapClause() = delete;
  std::tuple<std::optional<OmpMapType>, OmpObjectList> t;
};


struct OmpDefaultmapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDefaultmapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDefaultmapClause(OmpDefaultmapClause &&) = default; OmpDefaultmapClause &operator=(OmpDefaultmapClause &&) = default; OmpDefaultmapClause(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause &operator=(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause() = delete;
  enum class ImplicitBehavior { Alloc, To, From, Tofrom, Firstprivate, None, Default }; [[maybe_unused]] static constexpr std::size_t ImplicitBehavior_enumSize{ ::Fortran::common::CountEnumNames("Alloc, To, From, Tofrom, Firstprivate, None, Default")}; [[maybe_unused]] static inline std::string_view EnumToString(ImplicitBehavior e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImplicitBehavior_enumSize>("Alloc, To, From, Tofrom, Firstprivate, None, Default")}; return names[static_cast<std::size_t>(e)]; }

  enum class VariableCategory { Scalar, Aggregate, Allocatable, Pointer }; [[maybe_unused]] static constexpr std::size_t VariableCategory_enumSize{ ::Fortran::common::CountEnumNames("Scalar, Aggregate, Allocatable, Pointer")}; [[maybe_unused]] static inline std::string_view EnumToString(VariableCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<VariableCategory_enumSize>("Scalar, Aggregate, Allocatable, Pointer")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<ImplicitBehavior, std::optional<VariableCategory>> t;
};


struct OmpScheduleModifierType {
  enum class ModType { Monotonic, Nonmonotonic, Simd }; [[maybe_unused]] static constexpr std::size_t ModType_enumSize{ ::Fortran::common::CountEnumNames("Monotonic, Nonmonotonic, Simd")}; [[maybe_unused]] static inline std::string_view EnumToString(ModType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ModType_enumSize>("Monotonic, Nonmonotonic, Simd")}; return names[static_cast<std::size_t>(e)]; }
  OmpScheduleModifierType(OmpScheduleModifierType &&) = default; OmpScheduleModifierType &operator=(OmpScheduleModifierType &&) = default; OmpScheduleModifierType(const OmpScheduleModifierType &) = delete; OmpScheduleModifierType &operator=(const OmpScheduleModifierType &) = delete; OmpScheduleModifierType() = delete; OmpScheduleModifierType(ModType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ModType v;
};

struct OmpScheduleModifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpScheduleModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpScheduleModifier(OmpScheduleModifier &&) = default; OmpScheduleModifier &operator=(OmpScheduleModifier &&) = default; OmpScheduleModifier(const OmpScheduleModifier &) = delete; OmpScheduleModifier &operator=(const OmpScheduleModifier &) = delete; OmpScheduleModifier() = delete;
  struct Modifier1 { Modifier1(Modifier1 &&) = default; Modifier1 &operator=(Modifier1 &&) = default; Modifier1(const Modifier1 &) = delete; Modifier1 &operator=(const Modifier1 &) = delete; Modifier1() = delete; Modifier1(OmpScheduleModifierType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleModifierType v; };
  struct Modifier2 { Modifier2(Modifier2 &&) = default; Modifier2 &operator=(Modifier2 &&) = default; Modifier2(const Modifier2 &) = delete; Modifier2 &operator=(const Modifier2 &) = delete; Modifier2() = delete; Modifier2(OmpScheduleModifierType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleModifierType v; };
  std::tuple<Modifier1, std::optional<Modifier2>> t;
};



struct OmpScheduleClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpScheduleClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpScheduleClause(OmpScheduleClause &&) = default; OmpScheduleClause &operator=(OmpScheduleClause &&) = default; OmpScheduleClause(const OmpScheduleClause &) = delete; OmpScheduleClause &operator=(const OmpScheduleClause &) = delete; OmpScheduleClause() = delete;
  enum class ScheduleType { Static, Dynamic, Guided, Auto, Runtime }; [[maybe_unused]] static constexpr std::size_t ScheduleType_enumSize{ ::Fortran::common::CountEnumNames("Static, Dynamic, Guided, Auto, Runtime")}; [[maybe_unused]] static inline std::string_view EnumToString(ScheduleType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ScheduleType_enumSize>("Static, Dynamic, Guided, Auto, Runtime")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<OmpScheduleModifier>, ScheduleType,
      std::optional<ScalarIntExpr>>
      t;
};


struct OmpDeviceClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDeviceClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDeviceClause(OmpDeviceClause &&) = default; OmpDeviceClause &operator=(OmpDeviceClause &&) = default; OmpDeviceClause(const OmpDeviceClause &) = delete; OmpDeviceClause &operator=(const OmpDeviceClause &) = delete; OmpDeviceClause() = delete;
  enum class DeviceModifier { Ancestor, Device_Num }; [[maybe_unused]] static constexpr std::size_t DeviceModifier_enumSize{ ::Fortran::common::CountEnumNames("Ancestor, Device_Num")}; [[maybe_unused]] static inline std::string_view EnumToString(DeviceModifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DeviceModifier_enumSize>("Ancestor, Device_Num")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<DeviceModifier>, ScalarIntExpr> t;
};


struct OmpDeviceTypeClause {
  enum class Type { Any, Host, Nohost }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Any, Host, Nohost")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Any, Host, Nohost")}; return names[static_cast<std::size_t>(e)]; }
  OmpDeviceTypeClause(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause &operator=(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause &operator=(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause() = delete; OmpDeviceTypeClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};


struct OmpIfClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIfClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIfClause(OmpIfClause &&) = default; OmpIfClause &operator=(OmpIfClause &&) = default; OmpIfClause(const OmpIfClause &) = delete; OmpIfClause &operator=(const OmpIfClause &) = delete; OmpIfClause() = delete;
  enum class DirectiveNameModifier { Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams }; [[maybe_unused]] static constexpr std::size_t DirectiveNameModifier_enumSize{ ::Fortran::common::CountEnumNames("Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams")}; [[maybe_unused]] static inline std::string_view EnumToString(DirectiveNameModifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DirectiveNameModifier_enumSize>("Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams")}; return names[static_cast<std::size_t>(e)]; }

  std::tuple<std::optional<DirectiveNameModifier>, ScalarLogicalExpr> t;
};


struct OmpAlignedClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAlignedClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAlignedClause(OmpAlignedClause &&) = default; OmpAlignedClause &operator=(OmpAlignedClause &&) = default; OmpAlignedClause(const OmpAlignedClause &) = delete; OmpAlignedClause &operator=(const OmpAlignedClause &) = delete; OmpAlignedClause() = delete;
  CharBlock source;
  std::tuple<OmpObjectList, std::optional<ScalarIntConstantExpr>> t;
};


struct OmpOrderModifier {
  template <typename A, typename = common::NoLvalue<A>> OmpOrderModifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpOrderModifier(OmpOrderModifier &&) = default; OmpOrderModifier &operator=(OmpOrderModifier &&) = default; OmpOrderModifier(const OmpOrderModifier &) = delete; OmpOrderModifier &operator=(const OmpOrderModifier &) = delete; OmpOrderModifier() = delete;
  enum class Kind { Reproducible, Unconstrained }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Reproducible, Unconstrained")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Reproducible, Unconstrained")}; return names[static_cast<std::size_t>(e)]; }
  std::variant<Kind> u;
};

struct OmpOrderClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpOrderClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpOrderClause(OmpOrderClause &&) = default; OmpOrderClause &operator=(OmpOrderClause &&) = default; OmpOrderClause(const OmpOrderClause &) = delete; OmpOrderClause &operator=(const OmpOrderClause &) = delete; OmpOrderClause() = delete;
  enum class Type { Concurrent }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Concurrent")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Concurrent")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<OmpOrderModifier>, Type> t;
};


struct OmpLinearModifier {
  enum class Type { Ref, Val, Uval }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Ref, Val, Uval")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Ref, Val, Uval")}; return names[static_cast<std::size_t>(e)]; }
  OmpLinearModifier(OmpLinearModifier &&) = default; OmpLinearModifier &operator=(OmpLinearModifier &&) = default; OmpLinearModifier(const OmpLinearModifier &) = delete; OmpLinearModifier &operator=(const OmpLinearModifier &) = delete; OmpLinearModifier() = delete; OmpLinearModifier(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};



struct OmpLinearClause {
  template <typename A, typename = common::NoLvalue<A>> OmpLinearClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpLinearClause(OmpLinearClause &&) = default; OmpLinearClause &operator=(OmpLinearClause &&) = default; OmpLinearClause(const OmpLinearClause &) = delete; OmpLinearClause &operator=(const OmpLinearClause &) = delete; OmpLinearClause() = delete;
  struct WithModifier {
    WithModifier(WithModifier &&) = default; WithModifier &operator=(WithModifier &&) = default; WithModifier(const WithModifier &) = delete; WithModifier &operator=(const WithModifier &) = delete; WithModifier() = delete;
    WithModifier(OmpLinearModifier &&m, std::list<Name> &&n,
        std::optional<ScalarIntConstantExpr> &&s)
        : modifier(std::move(m)), names(std::move(n)), step(std::move(s)) {}
    OmpLinearModifier modifier;
    std::list<Name> names;
    std::optional<ScalarIntConstantExpr> step;
  };
  struct WithoutModifier {
    WithoutModifier(WithoutModifier &&) = default; WithoutModifier &operator=(WithoutModifier &&) = default; WithoutModifier(const WithoutModifier &) = delete; WithoutModifier &operator=(const WithoutModifier &) = delete; WithoutModifier() = delete;
    WithoutModifier(
        std::list<Name> &&n, std::optional<ScalarIntConstantExpr> &&s)
        : names(std::move(n)), step(std::move(s)) {}
    std::list<Name> names;
    std::optional<ScalarIntConstantExpr> step;
  };
  std::variant<WithModifier, WithoutModifier> u;
};



struct OmpReductionOperator {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionOperator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionOperator(OmpReductionOperator &&) = default; OmpReductionOperator &operator=(OmpReductionOperator &&) = default; OmpReductionOperator(const OmpReductionOperator &) = delete; OmpReductionOperator &operator=(const OmpReductionOperator &) = delete; OmpReductionOperator() = delete;
  std::variant<DefinedOperator, ProcedureDesignator> u;
};



struct OmpReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpReductionClause(OmpReductionClause &&) = default; OmpReductionClause &operator=(OmpReductionClause &&) = default; OmpReductionClause(const OmpReductionClause &) = delete; OmpReductionClause &operator=(const OmpReductionClause &) = delete; OmpReductionClause() = delete;
  std::tuple<OmpReductionOperator, OmpObjectList> t;
};



struct OmpInReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpInReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpInReductionClause(OmpInReductionClause &&) = default; OmpInReductionClause &operator=(OmpInReductionClause &&) = default; OmpInReductionClause(const OmpInReductionClause &) = delete; OmpInReductionClause &operator=(const OmpInReductionClause &) = delete; OmpInReductionClause() = delete;
  std::tuple<OmpReductionOperator, OmpObjectList> t;
};






struct OmpAllocateClause {
  struct AllocateModifier {
    struct Allocator { Allocator(Allocator &&) = default; Allocator &operator=(Allocator &&) = default; Allocator(const Allocator &) = delete; Allocator &operator=(const Allocator &) = delete; Allocator() = delete; Allocator(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
    struct Align { Align(Align &&) = default; Align &operator=(Align &&) = default; Align(const Align &) = delete; Align &operator=(const Align &) = delete; Align() = delete; Align(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
    struct ComplexModifier {
      template <typename... Ts, typename = common::NoLvalue<Ts...>> ComplexModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComplexModifier(ComplexModifier &&) = default; ComplexModifier &operator=(ComplexModifier &&) = default; ComplexModifier(const ComplexModifier &) = delete; ComplexModifier &operator=(const ComplexModifier &) = delete; ComplexModifier() = delete;
      std::tuple<Allocator, Align> t;
    };
    template <typename A, typename = common::NoLvalue<A>> AllocateModifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocateModifier(AllocateModifier &&) = default; AllocateModifier &operator=(AllocateModifier &&) = default; AllocateModifier(const AllocateModifier &) = delete; AllocateModifier &operator=(const AllocateModifier &) = delete; AllocateModifier() = delete;
    std::variant<Allocator, ComplexModifier, Align> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAllocateClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAllocateClause(OmpAllocateClause &&) = default; OmpAllocateClause &operator=(OmpAllocateClause &&) = default; OmpAllocateClause(const OmpAllocateClause &) = delete; OmpAllocateClause &operator=(const OmpAllocateClause &) = delete; OmpAllocateClause() = delete;
  std::tuple<std::optional<AllocateModifier>, OmpObjectList> t;
};


struct OmpDependSinkVecLength {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDependSinkVecLength(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDependSinkVecLength(OmpDependSinkVecLength &&) = default; OmpDependSinkVecLength &operator=(OmpDependSinkVecLength &&) = default; OmpDependSinkVecLength(const OmpDependSinkVecLength &) = delete; OmpDependSinkVecLength &operator=(const OmpDependSinkVecLength &) = delete; OmpDependSinkVecLength() = delete;
  std::tuple<DefinedOperator, ScalarIntConstantExpr> t;
};


struct OmpDependSinkVec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDependSinkVec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDependSinkVec(OmpDependSinkVec &&) = default; OmpDependSinkVec &operator=(OmpDependSinkVec &&) = default; OmpDependSinkVec(const OmpDependSinkVec &) = delete; OmpDependSinkVec &operator=(const OmpDependSinkVec &) = delete; OmpDependSinkVec() = delete;
  std::tuple<Name, std::optional<OmpDependSinkVecLength>> t;
};


struct OmpDependenceType {
  enum class Type { In, Out, Inout, Source, Sink }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("In, Out, Inout, Source, Sink")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("In, Out, Inout, Source, Sink")}; return names[static_cast<std::size_t>(e)]; }
  OmpDependenceType(OmpDependenceType &&) = default; OmpDependenceType &operator=(OmpDependenceType &&) = default; OmpDependenceType(const OmpDependenceType &) = delete; OmpDependenceType &operator=(const OmpDependenceType &) = delete; OmpDependenceType() = delete; OmpDependenceType(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};



struct OmpDependClause {
  template <typename A, typename = common::NoLvalue<A>> OmpDependClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDependClause(OmpDependClause &&) = default; OmpDependClause &operator=(OmpDependClause &&) = default; OmpDependClause(const OmpDependClause &) = delete; OmpDependClause &operator=(const OmpDependClause &) = delete; OmpDependClause() = delete;
  struct Source { Source() {} Source(const Source &) {} Source(Source &&) {} Source &operator=(const Source &) { return *this; }; Source &operator=(Source &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Sink { Sink(Sink &&) = default; Sink &operator=(Sink &&) = default; Sink(const Sink &) = delete; Sink &operator=(const Sink &) = delete; Sink() = delete; Sink(std::list<OmpDependSinkVec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpDependSinkVec> v; };
  struct InOut {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> InOut(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InOut(InOut &&) = default; InOut &operator=(InOut &&) = default; InOut(const InOut &) = delete; InOut &operator=(const InOut &) = delete; InOut() = delete;
    std::tuple<OmpDependenceType, std::list<Designator>> t;
  };
  std::variant<Source, Sink, InOut> u;
};




struct OmpAtomicDefaultMemOrderClause {
  OmpAtomicDefaultMemOrderClause(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause &operator=(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause &operator=(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause() = delete; OmpAtomicDefaultMemOrderClause(common::OmpAtomicDefaultMemOrderType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::OmpAtomicDefaultMemOrderType v;

};


struct OmpClause {
  template <typename A, typename = common::NoLvalue<A>> OmpClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpClause(OmpClause &&) = default; OmpClause &operator=(OmpClause &&) = default; OmpClause(const OmpClause &) = delete; OmpClause &operator=(const OmpClause &) = delete; OmpClause() = delete;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3624 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
struct AcqRel { AcqRel() {} AcqRel(const AcqRel &) {} AcqRel(AcqRel &&) {} AcqRel &operator=(const AcqRel &) { return *this; }; AcqRel &operator=(AcqRel &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Acquire { Acquire() {} Acquire(const Acquire &) {} Acquire(Acquire &&) {} Acquire &operator=(const Acquire &) { return *this; }; Acquire &operator=(Acquire &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AdjustArgs { AdjustArgs() {} AdjustArgs(const AdjustArgs &) {} AdjustArgs(AdjustArgs &&) {} AdjustArgs &operator=(const AdjustArgs &) { return *this; }; AdjustArgs &operator=(AdjustArgs &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Affinity { Affinity() {} Affinity(const Affinity &) {} Affinity(Affinity &&) {} Affinity &operator=(const Affinity &) { return *this; }; Affinity &operator=(Affinity &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Align { Align() {} Align(const Align &) {} Align(Align &&) {} Align &operator=(const Align &) { return *this; }; Align &operator=(Align &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Aligned { Aligned(Aligned &&) = default; Aligned &operator=(Aligned &&) = default; Aligned(const Aligned &) = delete; Aligned &operator=(const Aligned &) = delete; Aligned() = delete; Aligned(OmpAlignedClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAlignedClause v; };
struct Allocate { Allocate(Allocate &&) = default; Allocate &operator=(Allocate &&) = default; Allocate(const Allocate &) = delete; Allocate &operator=(const Allocate &) = delete; Allocate() = delete; Allocate(OmpAllocateClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAllocateClause v; };
struct Allocator { Allocator(Allocator &&) = default; Allocator &operator=(Allocator &&) = default; Allocator(const Allocator &) = delete; Allocator &operator=(const Allocator &) = delete; Allocator() = delete; Allocator(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct AppendArgs { AppendArgs() {} AppendArgs(const AppendArgs &) {} AppendArgs(AppendArgs &&) {} AppendArgs &operator=(const AppendArgs &) { return *this; }; AppendArgs &operator=(AppendArgs &&) { return *this; }; using EmptyTrait = std::true_type; };
struct At { At() {} At(const At &) {} At(At &&) {} At &operator=(const At &) { return *this; }; At &operator=(At &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AtomicDefaultMemOrder { AtomicDefaultMemOrder(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder &operator=(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder &operator=(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder() = delete; AtomicDefaultMemOrder(OmpAtomicDefaultMemOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAtomicDefaultMemOrderClause v; };
struct Bind { Bind() {} Bind(const Bind &) {} Bind(Bind &&) {} Bind &operator=(const Bind &) { return *this; }; Bind &operator=(Bind &&) { return *this; }; using EmptyTrait = std::true_type; };
struct CancellationConstructType { CancellationConstructType() {} CancellationConstructType(const CancellationConstructType &) {} CancellationConstructType(CancellationConstructType &&) {} CancellationConstructType &operator=(const CancellationConstructType &) { return *this; }; CancellationConstructType &operator=(CancellationConstructType &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Compare { Compare() {} Compare(const Compare &) {} Compare(Compare &&) {} Compare &operator=(const Compare &) { return *this; }; Compare &operator=(Compare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Copyprivate { Copyprivate(Copyprivate &&) = default; Copyprivate &operator=(Copyprivate &&) = default; Copyprivate(const Copyprivate &) = delete; Copyprivate &operator=(const Copyprivate &) = delete; Copyprivate() = delete; Copyprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(OmpDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultClause v; };
struct Defaultmap { Defaultmap(Defaultmap &&) = default; Defaultmap &operator=(Defaultmap &&) = default; Defaultmap(const Defaultmap &) = delete; Defaultmap &operator=(const Defaultmap &) = delete; Defaultmap() = delete; Defaultmap(OmpDefaultmapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultmapClause v; };
struct Depend { Depend(Depend &&) = default; Depend &operator=(Depend &&) = default; Depend(const Depend &) = delete; Depend &operator=(const Depend &) = delete; Depend() = delete; Depend(OmpDependClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDependClause v; };
struct Depobj { Depobj() {} Depobj(const Depobj &) {} Depobj(Depobj &&) {} Depobj &operator=(const Depobj &) { return *this; }; Depobj &operator=(Depobj &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Destroy { Destroy() {} Destroy(const Destroy &) {} Destroy(Destroy &&) {} Destroy &operator=(const Destroy &) { return *this; }; Destroy &operator=(Destroy &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Detach { Detach() {} Detach(const Detach &) {} Detach(Detach &&) {} Detach &operator=(const Detach &) { return *this; }; Detach &operator=(Detach &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(OmpDeviceClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceClause v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(OmpDeviceTypeClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceTypeClause v; };
struct DistSchedule { DistSchedule(DistSchedule &&) = default; DistSchedule &operator=(DistSchedule &&) = default; DistSchedule(const DistSchedule &) = delete; DistSchedule &operator=(const DistSchedule &) = delete; DistSchedule() = delete; DistSchedule(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Doacross { Doacross() {} Doacross(const Doacross &) {} Doacross(Doacross &&) {} Doacross &operator=(const Doacross &) { return *this; }; Doacross &operator=(Doacross &&) { return *this; }; using EmptyTrait = std::true_type; };
struct DynamicAllocators { DynamicAllocators() {} DynamicAllocators(const DynamicAllocators &) {} DynamicAllocators(DynamicAllocators &&) {} DynamicAllocators &operator=(const DynamicAllocators &) { return *this; }; DynamicAllocators &operator=(DynamicAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Enter { Enter(Enter &&) = default; Enter &operator=(Enter &&) = default; Enter(const Enter &) = delete; Enter &operator=(const Enter &) = delete; Enter() = delete; Enter(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Exclusive { Exclusive() {} Exclusive(const Exclusive &) {} Exclusive(Exclusive &&) {} Exclusive &operator=(const Exclusive &) { return *this; }; Exclusive &operator=(Exclusive &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Fail { Fail() {} Fail(const Fail &) {} Fail(Fail &&) {} Fail &operator=(const Fail &) { return *this; }; Fail &operator=(Fail &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Filter { Filter(Filter &&) = default; Filter &operator=(Filter &&) = default; Filter(const Filter &) = delete; Filter &operator=(const Filter &) = delete; Filter() = delete; Filter(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Final { Final(Final &&) = default; Final &operator=(Final &&) = default; Final(const Final &) = delete; Final &operator=(const Final &) = delete; Final() = delete; Final(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Flush { Flush() {} Flush(const Flush &) {} Flush(Flush &&) {} Flush &operator=(const Flush &) { return *this; }; Flush &operator=(Flush &&) { return *this; }; using EmptyTrait = std::true_type; };
struct From { From(From &&) = default; From &operator=(From &&) = default; From(const From &) = delete; From &operator=(const From &) = delete; From() = delete; From(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Full { Full() {} Full(const Full &) {} Full(Full &&) {} Full &operator=(const Full &) { return *this; }; Full &operator=(Full &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Grainsize { Grainsize(Grainsize &&) = default; Grainsize &operator=(Grainsize &&) = default; Grainsize(const Grainsize &) = delete; Grainsize &operator=(const Grainsize &) = delete; Grainsize() = delete; Grainsize(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct HasDeviceAddr { HasDeviceAddr(HasDeviceAddr &&) = default; HasDeviceAddr &operator=(HasDeviceAddr &&) = default; HasDeviceAddr(const HasDeviceAddr &) = delete; HasDeviceAddr &operator=(const HasDeviceAddr &) = delete; HasDeviceAddr() = delete; HasDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Hint { Hint(Hint &&) = default; Hint &operator=(Hint &&) = default; Hint(const Hint &) = delete; Hint &operator=(const Hint &) = delete; Hint() = delete; Hint(ConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ConstantExpr v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(OmpIfClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpIfClause v; };
struct InReduction { InReduction(InReduction &&) = default; InReduction &operator=(InReduction &&) = default; InReduction(const InReduction &) = delete; InReduction &operator=(const InReduction &) = delete; InReduction() = delete; InReduction(OmpInReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpInReductionClause v; };
struct Inbranch { Inbranch() {} Inbranch(const Inbranch &) {} Inbranch(Inbranch &&) {} Inbranch &operator=(const Inbranch &) { return *this; }; Inbranch &operator=(Inbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Inclusive { Inclusive() {} Inclusive(const Inclusive &) {} Inclusive(Inclusive &&) {} Inclusive &operator=(const Inclusive &) { return *this; }; Inclusive &operator=(Inclusive &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Indirect { Indirect() {} Indirect(const Indirect &) {} Indirect(Indirect &&) {} Indirect &operator=(const Indirect &) { return *this; }; Indirect &operator=(Indirect &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Init { Init() {} Init(const Init &) {} Init(Init &&) {} Init &operator=(const Init &) { return *this; }; Init &operator=(Init &&) { return *this; }; using EmptyTrait = std::true_type; };
struct IsDevicePtr { IsDevicePtr(IsDevicePtr &&) = default; IsDevicePtr &operator=(IsDevicePtr &&) = default; IsDevicePtr(const IsDevicePtr &) = delete; IsDevicePtr &operator=(const IsDevicePtr &) = delete; IsDevicePtr() = delete; IsDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Lastprivate { Lastprivate(Lastprivate &&) = default; Lastprivate &operator=(Lastprivate &&) = default; Lastprivate(const Lastprivate &) = delete; Lastprivate &operator=(const Lastprivate &) = delete; Lastprivate() = delete; Lastprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Linear { Linear(Linear &&) = default; Linear &operator=(Linear &&) = default; Linear(const Linear &) = delete; Linear &operator=(const Linear &) = delete; Linear() = delete; Linear(OmpLinearClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpLinearClause v; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Map { Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete; Map(OmpMapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpMapClause v; };
struct Match { Match() {} Match(const Match &) {} Match(Match &&) {} Match &operator=(const Match &) { return *this; }; Match &operator=(Match &&) { return *this; }; using EmptyTrait = std::true_type; };
struct MemoryOrder { MemoryOrder() {} MemoryOrder(const MemoryOrder &) {} MemoryOrder(MemoryOrder &&) {} MemoryOrder &operator=(const MemoryOrder &) { return *this; }; MemoryOrder &operator=(MemoryOrder &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Mergeable { Mergeable() {} Mergeable(const Mergeable &) {} Mergeable(Mergeable &&) {} Mergeable &operator=(const Mergeable &) { return *this; }; Mergeable &operator=(Mergeable &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Message { Message() {} Message(const Message &) {} Message(Message &&) {} Message &operator=(const Message &) { return *this; }; Message &operator=(Message &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nogroup { Nogroup() {} Nogroup(const Nogroup &) {} Nogroup(Nogroup &&) {} Nogroup &operator=(const Nogroup &) { return *this; }; Nogroup &operator=(Nogroup &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nowait { Nowait() {} Nowait(const Nowait &) {} Nowait(Nowait &&) {} Nowait &operator=(const Nowait &) { return *this; }; Nowait &operator=(Nowait &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nocontext { Nocontext(Nocontext &&) = default; Nocontext &operator=(Nocontext &&) = default; Nocontext(const Nocontext &) = delete; Nocontext &operator=(const Nocontext &) = delete; Nocontext() = delete; Nocontext(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Nontemporal { Nontemporal(Nontemporal &&) = default; Nontemporal &operator=(Nontemporal &&) = default; Nontemporal(const Nontemporal &) = delete; Nontemporal &operator=(const Nontemporal &) = delete; Nontemporal() = delete; Nontemporal(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Notinbranch { Notinbranch() {} Notinbranch(const Notinbranch &) {} Notinbranch(Notinbranch &&) {} Notinbranch &operator=(const Notinbranch &) { return *this; }; Notinbranch &operator=(Notinbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Novariants { Novariants(Novariants &&) = default; Novariants &operator=(Novariants &&) = default; Novariants(const Novariants &) = delete; Novariants &operator=(const Novariants &) = delete; Novariants() = delete; Novariants(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct NumTasks { NumTasks(NumTasks &&) = default; NumTasks &operator=(NumTasks &&) = default; NumTasks(const NumTasks &) = delete; NumTasks &operator=(const NumTasks &) = delete; NumTasks() = delete; NumTasks(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct NumTeams { NumTeams(NumTeams &&) = default; NumTeams &operator=(NumTeams &&) = default; NumTeams(const NumTeams &) = delete; NumTeams &operator=(const NumTeams &) = delete; NumTeams() = delete; NumTeams(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct NumThreads { NumThreads(NumThreads &&) = default; NumThreads &operator=(NumThreads &&) = default; NumThreads(const NumThreads &) = delete; NumThreads &operator=(const NumThreads &) = delete; NumThreads() = delete; NumThreads(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct OmpxAttribute { OmpxAttribute() {} OmpxAttribute(const OmpxAttribute &) {} OmpxAttribute(OmpxAttribute &&) {} OmpxAttribute &operator=(const OmpxAttribute &) { return *this; }; OmpxAttribute &operator=(OmpxAttribute &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OmpxDynCgroupMem { OmpxDynCgroupMem(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem &operator=(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem &operator=(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem() = delete; OmpxDynCgroupMem(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct OmpxBare { OmpxBare() {} OmpxBare(const OmpxBare &) {} OmpxBare(OmpxBare &&) {} OmpxBare &operator=(const OmpxBare &) { return *this; }; OmpxBare &operator=(OmpxBare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Order { Order(Order &&) = default; Order &operator=(Order &&) = default; Order(const Order &) = delete; Order &operator=(const Order &) = delete; Order() = delete; Order(OmpOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpOrderClause v; };
struct Ordered { Ordered(Ordered &&) = default; Ordered &operator=(Ordered &&) = default; Ordered(const Ordered &) = delete; Ordered &operator=(const Ordered &) = delete; Ordered() = delete; Ordered(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Partial { Partial(Partial &&) = default; Partial &operator=(Partial &&) = default; Partial(const Partial &) = delete; Partial &operator=(const Partial &) = delete; Partial() = delete; Partial(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Priority { Priority(Priority &&) = default; Priority &operator=(Priority &&) = default; Priority(const Priority &) = delete; Priority &operator=(const Priority &) = delete; Priority() = delete; Priority(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct ProcBind { ProcBind(ProcBind &&) = default; ProcBind &operator=(ProcBind &&) = default; ProcBind(const ProcBind &) = delete; ProcBind &operator=(const ProcBind &) = delete; ProcBind() = delete; ProcBind(OmpProcBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpProcBindClause v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(OmpReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpReductionClause v; };
struct Relaxed { Relaxed() {} Relaxed(const Relaxed &) {} Relaxed(Relaxed &&) {} Relaxed &operator=(const Relaxed &) { return *this; }; Relaxed &operator=(Relaxed &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Release { Release() {} Release(const Release &) {} Release(Release &&) {} Release &operator=(const Release &) { return *this; }; Release &operator=(Release &&) { return *this; }; using EmptyTrait = std::true_type; };
struct ReverseOffload { ReverseOffload() {} ReverseOffload(const ReverseOffload &) {} ReverseOffload(ReverseOffload &&) {} ReverseOffload &operator=(const ReverseOffload &) { return *this; }; ReverseOffload &operator=(ReverseOffload &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Safelen { Safelen(Safelen &&) = default; Safelen &operator=(Safelen &&) = default; Safelen(const Safelen &) = delete; Safelen &operator=(const Safelen &) = delete; Safelen() = delete; Safelen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Schedule { Schedule(Schedule &&) = default; Schedule &operator=(Schedule &&) = default; Schedule(const Schedule &) = delete; Schedule &operator=(const Schedule &) = delete; Schedule() = delete; Schedule(OmpScheduleClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleClause v; };
struct SeqCst { SeqCst() {} SeqCst(const SeqCst &) {} SeqCst(SeqCst &&) {} SeqCst &operator=(const SeqCst &) { return *this; }; SeqCst &operator=(SeqCst &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Severity { Severity() {} Severity(const Severity &) {} Severity(Severity &&) {} Severity &operator=(const Severity &) { return *this; }; Severity &operator=(Severity &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Simd { Simd() {} Simd(const Simd &) {} Simd(Simd &&) {} Simd &operator=(const Simd &) { return *this; }; Simd &operator=(Simd &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Simdlen { Simdlen(Simdlen &&) = default; Simdlen &operator=(Simdlen &&) = default; Simdlen(const Simdlen &) = delete; Simdlen &operator=(const Simdlen &) = delete; Simdlen() = delete; Simdlen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Sizes { Sizes(Sizes &&) = default; Sizes &operator=(Sizes &&) = default; Sizes(const Sizes &) = delete; Sizes &operator=(const Sizes &) = delete; Sizes() = delete; Sizes(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct TaskReduction { TaskReduction(TaskReduction &&) = default; TaskReduction &operator=(TaskReduction &&) = default; TaskReduction(const TaskReduction &) = delete; TaskReduction &operator=(const TaskReduction &) = delete; TaskReduction() = delete; TaskReduction(OmpReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpReductionClause v; };
struct ThreadLimit { ThreadLimit(ThreadLimit &&) = default; ThreadLimit &operator=(ThreadLimit &&) = default; ThreadLimit(const ThreadLimit &) = delete; ThreadLimit &operator=(const ThreadLimit &) = delete; ThreadLimit() = delete; ThreadLimit(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Threadprivate { Threadprivate() {} Threadprivate(const Threadprivate &) {} Threadprivate(Threadprivate &&) {} Threadprivate &operator=(const Threadprivate &) { return *this; }; Threadprivate &operator=(Threadprivate &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Threads { Threads() {} Threads(const Threads &) {} Threads(Threads &&) {} Threads &operator=(const Threads &) { return *this; }; Threads &operator=(Threads &&) { return *this; }; using EmptyTrait = std::true_type; };
struct To { To(To &&) = default; To &operator=(To &&) = default; To(const To &) = delete; To &operator=(const To &) = delete; To() = delete; To(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UnifiedAddress { UnifiedAddress() {} UnifiedAddress(const UnifiedAddress &) {} UnifiedAddress(UnifiedAddress &&) {} UnifiedAddress &operator=(const UnifiedAddress &) { return *this; }; UnifiedAddress &operator=(UnifiedAddress &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UnifiedSharedMemory { UnifiedSharedMemory() {} UnifiedSharedMemory(const UnifiedSharedMemory &) {} UnifiedSharedMemory(UnifiedSharedMemory &&) {} UnifiedSharedMemory &operator=(const UnifiedSharedMemory &) { return *this; }; UnifiedSharedMemory &operator=(UnifiedSharedMemory &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Uniform { Uniform(Uniform &&) = default; Uniform &operator=(Uniform &&) = default; Uniform(const Uniform &) = delete; Uniform &operator=(const Uniform &) = delete; Uniform() = delete; Uniform(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Untied { Untied() {} Untied(const Untied &) {} Untied(Untied &&) {} Untied &operator=(const Untied &) { return *this; }; Untied &operator=(Untied &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Update { Update() {} Update(const Update &) {} Update(Update &&) {} Update &operator=(const Update &) { return *this; }; Update &operator=(Update &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Use { Use() {} Use(const Use &) {} Use(Use &&) {} Use &operator=(const Use &) { return *this; }; Use &operator=(Use &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UseDeviceAddr { UseDeviceAddr(UseDeviceAddr &&) = default; UseDeviceAddr &operator=(UseDeviceAddr &&) = default; UseDeviceAddr(const UseDeviceAddr &) = delete; UseDeviceAddr &operator=(const UseDeviceAddr &) = delete; UseDeviceAddr() = delete; UseDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UseDevicePtr { UseDevicePtr(UseDevicePtr &&) = default; UseDevicePtr &operator=(UseDevicePtr &&) = default; UseDevicePtr(const UseDevicePtr &) = delete; UseDevicePtr &operator=(const UseDevicePtr &) = delete; UseDevicePtr() = delete; UseDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UsesAllocators { UsesAllocators() {} UsesAllocators(const UsesAllocators &) {} UsesAllocators(UsesAllocators &&) {} UsesAllocators &operator=(const UsesAllocators &) { return *this; }; UsesAllocators &operator=(UsesAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct When { When() {} When(const When &) {} When(When &&) {} When &operator=(const When &) { return *this; }; When &operator=(When &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 3612 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3734 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
AcqRel
, Acquire
, AdjustArgs
, Affinity
, Align
, Aligned
, Allocate
, Allocator
, AppendArgs
, At
, AtomicDefaultMemOrder
, Bind
, CancellationConstructType
, Capture
, Collapse
, Compare
, Copyprivate
, Copyin
, Default
, Defaultmap
, Depend
, Depobj
, Destroy
, Detach
, Device
, DeviceType
, DistSchedule
, Doacross
, DynamicAllocators
, Enter
, Exclusive
, Fail
, Filter
, Final
, Firstprivate
, Flush
, From
, Full
, Grainsize
, HasDeviceAddr
, Hint
, If
, InReduction
, Inbranch
, Inclusive
, Indirect
, Init
, IsDevicePtr
, Lastprivate
, Linear
, Link
, Map
, Match
, MemoryOrder
, Mergeable
, Message
, Nogroup
, Nowait
, Nocontext
, Nontemporal
, Notinbranch
, Novariants
, NumTasks
, NumTeams
, NumThreads
, OmpxAttribute
, OmpxDynCgroupMem
, OmpxBare
, Order
, Ordered
, Partial
, Priority
, Private
, ProcBind
, Read
, Reduction
, Relaxed
, Release
, ReverseOffload
, Safelen
, Schedule
, SeqCst
, Severity
, Shared
, Simd
, Simdlen
, Sizes
, TaskReduction
, ThreadLimit
, Threadprivate
, Threads
, To
, UnifiedAddress
, UnifiedSharedMemory
, Uniform
, Unknown
, Untied
, Update
, Use
, UseDeviceAddr
, UseDevicePtr
, UsesAllocators
, When
, Write
# 3618 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct OmpClauseList {
  OmpClauseList(OmpClauseList &&) = default; OmpClauseList &operator=(OmpClauseList &&) = default; OmpClauseList(const OmpClauseList &) = delete; OmpClauseList &operator=(const OmpClauseList &) = delete; OmpClauseList() = delete; OmpClauseList(std::list<OmpClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpClause> v;
  CharBlock source;
};



struct OmpSectionsDirective {
  OmpSectionsDirective(OmpSectionsDirective &&) = default; OmpSectionsDirective &operator=(OmpSectionsDirective &&) = default; OmpSectionsDirective(const OmpSectionsDirective &) = delete; OmpSectionsDirective &operator=(const OmpSectionsDirective &) = delete; OmpSectionsDirective() = delete; OmpSectionsDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};

struct OmpBeginSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginSectionsDirective(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective &operator=(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective &operator=(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};
struct OmpEndSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndSectionsDirective(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective &operator=(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective &operator=(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};






struct OpenMPSectionConstruct {
  OpenMPSectionConstruct(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct &operator=(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct &operator=(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct() = delete; OpenMPSectionConstruct(Block &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Block v;
  CharBlock source;
};




struct OmpSectionBlocks { OmpSectionBlocks(OmpSectionBlocks &&) = default; OmpSectionBlocks &operator=(OmpSectionBlocks &&) = default; OmpSectionBlocks(const OmpSectionBlocks &) = delete; OmpSectionBlocks &operator=(const OmpSectionBlocks &) = delete; OmpSectionBlocks() = delete; OmpSectionBlocks(std::list<OpenMPConstruct> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OpenMPConstruct> v; };

struct OpenMPSectionsConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSectionsConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSectionsConstruct(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct &operator=(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct &operator=(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct() = delete;
  std::tuple<OmpBeginSectionsDirective, OmpSectionBlocks,
      OmpEndSectionsDirective>
      t;
};


struct OmpBlockDirective {
  OmpBlockDirective(OmpBlockDirective &&) = default; OmpBlockDirective &operator=(OmpBlockDirective &&) = default; OmpBlockDirective(const OmpBlockDirective &) = delete; OmpBlockDirective &operator=(const OmpBlockDirective &) = delete; OmpBlockDirective() = delete; OmpBlockDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};




struct OmpDeclareTargetWithList {
  OmpDeclareTargetWithList(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList &operator=(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList &operator=(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList() = delete; OmpDeclareTargetWithList(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v;
  CharBlock source;
};

struct OmpDeclareTargetWithClause {
  OmpDeclareTargetWithClause(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause &operator=(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause &operator=(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause() = delete; OmpDeclareTargetWithClause(OmpClauseList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpClauseList v;
  CharBlock source;
};

struct OmpDeclareTargetSpecifier {
  template <typename A, typename = common::NoLvalue<A>> OmpDeclareTargetSpecifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDeclareTargetSpecifier(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier &operator=(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier &operator=(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier() = delete;
  std::variant<OmpDeclareTargetWithList, OmpDeclareTargetWithClause> u;
};

struct OpenMPDeclareTargetConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareTargetConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareTargetConstruct(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct &operator=(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct &operator=(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpDeclareTargetSpecifier> t;
};



struct OmpReductionCombiner {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionCombiner(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionCombiner(OmpReductionCombiner &&) = default; OmpReductionCombiner &operator=(OmpReductionCombiner &&) = default; OmpReductionCombiner(const OmpReductionCombiner &) = delete; OmpReductionCombiner &operator=(const OmpReductionCombiner &) = delete; OmpReductionCombiner() = delete;
  struct FunctionCombiner { FunctionCombiner(FunctionCombiner &&) = default; FunctionCombiner &operator=(FunctionCombiner &&) = default; FunctionCombiner(const FunctionCombiner &) = delete; FunctionCombiner &operator=(const FunctionCombiner &) = delete; FunctionCombiner() = delete; FunctionCombiner(Call &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Call v; };
  std::variant<AssignmentStmt, FunctionCombiner> u;
};

struct OmpReductionInitializerClause { OmpReductionInitializerClause(OmpReductionInitializerClause &&) = default; OmpReductionInitializerClause &operator=(OmpReductionInitializerClause &&) = default; OmpReductionInitializerClause(const OmpReductionInitializerClause &) = delete; OmpReductionInitializerClause &operator=(const OmpReductionInitializerClause &) = delete; OmpReductionInitializerClause() = delete; OmpReductionInitializerClause(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };

struct OpenMPDeclareReductionConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareReductionConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareReductionConstruct(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct &operator=(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct &operator=(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpReductionOperator, std::list<DeclarationTypeSpec>,
      OmpReductionCombiner, std::optional<OmpReductionInitializerClause>>
      t;
};



struct OpenMPDeclareSimdConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareSimdConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareSimdConstruct(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct &operator=(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct &operator=(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};


struct OpenMPRequiresConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPRequiresConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPRequiresConstruct(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct &operator=(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct &operator=(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList> t;
};


struct OpenMPThreadprivate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPThreadprivate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPThreadprivate(OpenMPThreadprivate &&) = default; OpenMPThreadprivate &operator=(OpenMPThreadprivate &&) = default; OpenMPThreadprivate(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate &operator=(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList> t;
};


struct OpenMPDeclarativeAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclarativeAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclarativeAllocate(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate &operator=(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate &operator=(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList, OmpClauseList> t;
};

struct OpenMPDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPDeclarativeConstruct(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct &operator=(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct &operator=(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPDeclarativeAllocate, OpenMPDeclareReductionConstruct,
      OpenMPDeclareSimdConstruct, OpenMPDeclareTargetConstruct,
      OpenMPThreadprivate, OpenMPRequiresConstruct>
      u;
};


struct OmpCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpCriticalDirective(OmpCriticalDirective &&) = default; OmpCriticalDirective &operator=(OmpCriticalDirective &&) = default; OmpCriticalDirective(const OmpCriticalDirective &) = delete; OmpCriticalDirective &operator=(const OmpCriticalDirective &) = delete; OmpCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};
struct OmpEndCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndCriticalDirective(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective &operator=(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective &operator=(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>> t;
};
struct OpenMPCriticalConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCriticalConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCriticalConstruct(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct &operator=(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct &operator=(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct() = delete;
  std::tuple<OmpCriticalDirective, Block, OmpEndCriticalDirective> t;
};





struct OpenMPExecutableAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPExecutableAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPExecutableAllocate(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate &operator=(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate &operator=(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<OmpObjectList>, OmpClauseList,
      std::optional<std::list<OpenMPDeclarativeAllocate>>,
      Statement<AllocateStmt>>
      t;
};

struct OmpEndAllocators { OmpEndAllocators() {} OmpEndAllocators(const OmpEndAllocators &) {} OmpEndAllocators(OmpEndAllocators &&) {} OmpEndAllocators &operator=(const OmpEndAllocators &) { return *this; }; OmpEndAllocators &operator=(OmpEndAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };





struct OpenMPAllocatorsConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPAllocatorsConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPAllocatorsConstruct(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct &operator=(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct &operator=(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList, Statement<AllocateStmt>,
      std::optional<OmpEndAllocators>>
      t;
};

struct OmpMemoryOrderClause {
  OmpMemoryOrderClause(OmpMemoryOrderClause &&) = default; OmpMemoryOrderClause &operator=(OmpMemoryOrderClause &&) = default; OmpMemoryOrderClause(const OmpMemoryOrderClause &) = delete; OmpMemoryOrderClause &operator=(const OmpMemoryOrderClause &) = delete; OmpMemoryOrderClause() = delete; OmpMemoryOrderClause(OmpClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpClause v;
  CharBlock source;
};

struct OmpAtomicClause {
  template <typename A, typename = common::NoLvalue<A>> OmpAtomicClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpAtomicClause(OmpAtomicClause &&) = default; OmpAtomicClause &operator=(OmpAtomicClause &&) = default; OmpAtomicClause(const OmpAtomicClause &) = delete; OmpAtomicClause &operator=(const OmpAtomicClause &) = delete; OmpAtomicClause() = delete;
  CharBlock source;
  std::variant<OmpMemoryOrderClause, OmpClause> u;
};

struct OmpAtomicClauseList {
  OmpAtomicClauseList(OmpAtomicClauseList &&) = default; OmpAtomicClauseList &operator=(OmpAtomicClauseList &&) = default; OmpAtomicClauseList(const OmpAtomicClauseList &) = delete; OmpAtomicClauseList &operator=(const OmpAtomicClauseList &) = delete; OmpAtomicClauseList() = delete; OmpAtomicClauseList(std::list<OmpAtomicClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpAtomicClause> v;
  CharBlock source;
};

struct OmpEndAtomic { OmpEndAtomic() {} OmpEndAtomic(const OmpEndAtomic &) {} OmpEndAtomic(OmpEndAtomic &&) {} OmpEndAtomic &operator=(const OmpEndAtomic &) { return *this; }; OmpEndAtomic &operator=(OmpEndAtomic &&) { return *this; }; using EmptyTrait = std::true_type; };


struct OmpAtomicRead {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicRead(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicRead(OmpAtomicRead &&) = default; OmpAtomicRead &operator=(OmpAtomicRead &&) = default; OmpAtomicRead(const OmpAtomicRead &) = delete; OmpAtomicRead &operator=(const OmpAtomicRead &) = delete; OmpAtomicRead() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};

struct OmpAtomicWrite {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicWrite(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicWrite(OmpAtomicWrite &&) = default; OmpAtomicWrite &operator=(OmpAtomicWrite &&) = default; OmpAtomicWrite(const OmpAtomicWrite &) = delete; OmpAtomicWrite &operator=(const OmpAtomicWrite &) = delete; OmpAtomicWrite() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};

struct OmpAtomicUpdate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicUpdate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicUpdate(OmpAtomicUpdate &&) = default; OmpAtomicUpdate &operator=(OmpAtomicUpdate &&) = default; OmpAtomicUpdate(const OmpAtomicUpdate &) = delete; OmpAtomicUpdate &operator=(const OmpAtomicUpdate &) = delete; OmpAtomicUpdate() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};

struct OmpAtomicCapture {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicCapture(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicCapture(OmpAtomicCapture &&) = default; OmpAtomicCapture &operator=(OmpAtomicCapture &&) = default; OmpAtomicCapture(const OmpAtomicCapture &) = delete; OmpAtomicCapture &operator=(const OmpAtomicCapture &) = delete; OmpAtomicCapture() = delete;
  CharBlock source;
  struct Stmt1 { Stmt1(Stmt1 &&) = default; Stmt1 &operator=(Stmt1 &&) = default; Stmt1(const Stmt1 &) = delete; Stmt1 &operator=(const Stmt1 &) = delete; Stmt1() = delete; Stmt1(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  struct Stmt2 { Stmt2(Stmt2 &&) = default; Stmt2 &operator=(Stmt2 &&) = default; Stmt2(const Stmt2 &) = delete; Stmt2 &operator=(const Stmt2 &) = delete; Stmt2() = delete; Stmt2(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList, Stmt1, Stmt2,
      OmpEndAtomic>
      t;
};


struct OmpAtomic {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomic(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomic(OmpAtomic &&) = default; OmpAtomic &operator=(OmpAtomic &&) = default; OmpAtomic(const OmpAtomic &) = delete; OmpAtomic &operator=(const OmpAtomic &) = delete; OmpAtomic() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpAtomicClauseList, Statement<AssignmentStmt>,
      std::optional<OmpEndAtomic>>
      t;
};





struct OpenMPAtomicConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPAtomicConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPAtomicConstruct(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct &operator=(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct &operator=(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct() = delete;
  std::variant<OmpAtomicRead, OmpAtomicWrite, OmpAtomicCapture, OmpAtomicUpdate,
      OmpAtomic>
      u;
};


struct OmpLoopDirective {
  OmpLoopDirective(OmpLoopDirective &&) = default; OmpLoopDirective &operator=(OmpLoopDirective &&) = default; OmpLoopDirective(const OmpLoopDirective &) = delete; OmpLoopDirective &operator=(const OmpLoopDirective &) = delete; OmpLoopDirective() = delete; OmpLoopDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};


struct OmpCancelType {
  enum class Type { Parallel, Sections, Do, Taskgroup }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Parallel, Sections, Do, Taskgroup")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Parallel, Sections, Do, Taskgroup")}; return names[static_cast<std::size_t>(e)]; }
  OmpCancelType(OmpCancelType &&) = default; OmpCancelType &operator=(OmpCancelType &&) = default; OmpCancelType(const OmpCancelType &) = delete; OmpCancelType &operator=(const OmpCancelType &) = delete; OmpCancelType() = delete; OmpCancelType(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
  CharBlock source;
};


struct OpenMPCancellationPointConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCancellationPointConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCancellationPointConstruct(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct &operator=(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct &operator=(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpCancelType> t;
};


struct OpenMPCancelConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCancelConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCancelConstruct(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct &operator=(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct &operator=(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct() = delete;
  struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
  CharBlock source;
  std::tuple<Verbatim, OmpCancelType, std::optional<If>> t;
};


struct OpenMPFlushConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPFlushConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPFlushConstruct(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct &operator=(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct &operator=(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<std::list<OmpMemoryOrderClause>>,
      std::optional<OmpObjectList>>
      t;
};

struct OmpSimpleStandaloneDirective {
  OmpSimpleStandaloneDirective(OmpSimpleStandaloneDirective &&) = default; OmpSimpleStandaloneDirective &operator=(OmpSimpleStandaloneDirective &&) = default; OmpSimpleStandaloneDirective(const OmpSimpleStandaloneDirective &) = delete; OmpSimpleStandaloneDirective &operator=(const OmpSimpleStandaloneDirective &) = delete; OmpSimpleStandaloneDirective() = delete; OmpSimpleStandaloneDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};

struct OpenMPSimpleStandaloneConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSimpleStandaloneConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSimpleStandaloneConstruct(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct &operator=(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct &operator=(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct() = delete;
  CharBlock source;
  std::tuple<OmpSimpleStandaloneDirective, OmpClauseList> t;
};

struct OpenMPStandaloneConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPStandaloneConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPStandaloneConstruct(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct &operator=(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct &operator=(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPSimpleStandaloneConstruct, OpenMPFlushConstruct,
      OpenMPCancelConstruct, OpenMPCancellationPointConstruct>
      u;
};

struct OmpBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginLoopDirective(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective &operator=(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective &operator=(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndLoopDirective(OmpEndLoopDirective &&) = default; OmpEndLoopDirective &operator=(OmpEndLoopDirective &&) = default; OmpEndLoopDirective(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective &operator=(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpBeginBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginBlockDirective(OmpBeginBlockDirective &&) = default; OmpBeginBlockDirective &operator=(OmpBeginBlockDirective &&) = default; OmpBeginBlockDirective(const OmpBeginBlockDirective &) = delete; OmpBeginBlockDirective &operator=(const OmpBeginBlockDirective &) = delete; OmpBeginBlockDirective() = delete;
  std::tuple<OmpBlockDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndBlockDirective(OmpEndBlockDirective &&) = default; OmpEndBlockDirective &operator=(OmpEndBlockDirective &&) = default; OmpEndBlockDirective(const OmpEndBlockDirective &) = delete; OmpEndBlockDirective &operator=(const OmpEndBlockDirective &) = delete; OmpEndBlockDirective() = delete;
  std::tuple<OmpBlockDirective, OmpClauseList> t;
  CharBlock source;
};

struct OpenMPBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPBlockConstruct(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct &operator=(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct &operator=(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct() = delete;
  std::tuple<OmpBeginBlockDirective, Block, OmpEndBlockDirective> t;
};


struct OpenMPLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPLoopConstruct(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct &operator=(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct &operator=(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct() = delete;
  OpenMPLoopConstruct(OmpBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<OmpBeginLoopDirective, std::optional<DoConstruct>,
      std::optional<OmpEndLoopDirective>>
      t;
};

struct OpenMPConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPConstruct(OpenMPConstruct &&) = default; OpenMPConstruct &operator=(OpenMPConstruct &&) = default; OpenMPConstruct(const OpenMPConstruct &) = delete; OpenMPConstruct &operator=(const OpenMPConstruct &) = delete; OpenMPConstruct() = delete;
  std::variant<OpenMPStandaloneConstruct, OpenMPSectionsConstruct,
      OpenMPSectionConstruct, OpenMPLoopConstruct, OpenMPBlockConstruct,
      OpenMPAtomicConstruct, OpenMPDeclarativeAllocate,
      OpenMPExecutableAllocate, OpenMPAllocatorsConstruct,
      OpenMPCriticalConstruct>
      u;
};



struct AccObject {
  template <typename A, typename = common::NoLvalue<A>> AccObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccObject(AccObject &&) = default; AccObject &operator=(AccObject &&) = default; AccObject(const AccObject &) = delete; AccObject &operator=(const AccObject &) = delete; AccObject() = delete;
  std::variant<Designator, Name> u;
};

struct AccObjectList { AccObjectList(AccObjectList &&) = default; AccObjectList &operator=(AccObjectList &&) = default; AccObjectList(const AccObjectList &) = delete; AccObjectList &operator=(const AccObjectList &) = delete; AccObjectList() = delete; AccObjectList(std::list<AccObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccObject> v; };


struct AccBlockDirective {
  AccBlockDirective(AccBlockDirective &&) = default; AccBlockDirective &operator=(AccBlockDirective &&) = default; AccBlockDirective(const AccBlockDirective &) = delete; AccBlockDirective &operator=(const AccBlockDirective &) = delete; AccBlockDirective() = delete; AccBlockDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccLoopDirective {
  AccLoopDirective(AccLoopDirective &&) = default; AccLoopDirective &operator=(AccLoopDirective &&) = default; AccLoopDirective(const AccLoopDirective &) = delete; AccLoopDirective &operator=(const AccLoopDirective &) = delete; AccLoopDirective() = delete; AccLoopDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccStandaloneDirective {
  AccStandaloneDirective(AccStandaloneDirective &&) = default; AccStandaloneDirective &operator=(AccStandaloneDirective &&) = default; AccStandaloneDirective(const AccStandaloneDirective &) = delete; AccStandaloneDirective &operator=(const AccStandaloneDirective &) = delete; AccStandaloneDirective() = delete; AccStandaloneDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccCombinedDirective {
  AccCombinedDirective(AccCombinedDirective &&) = default; AccCombinedDirective &operator=(AccCombinedDirective &&) = default; AccCombinedDirective(const AccCombinedDirective &) = delete; AccCombinedDirective &operator=(const AccCombinedDirective &) = delete; AccCombinedDirective() = delete; AccCombinedDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccDeclarativeDirective {
  AccDeclarativeDirective(AccDeclarativeDirective &&) = default; AccDeclarativeDirective &operator=(AccDeclarativeDirective &&) = default; AccDeclarativeDirective(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective &operator=(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective() = delete; AccDeclarativeDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccBindClause {
  template <typename A, typename = common::NoLvalue<A>> AccBindClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccBindClause(AccBindClause &&) = default; AccBindClause &operator=(AccBindClause &&) = default; AccBindClause(const AccBindClause &) = delete; AccBindClause &operator=(const AccBindClause &) = delete; AccBindClause() = delete;
  std::variant<Name, ScalarDefaultCharExpr> u;
  CharBlock source;
};

struct AccDefaultClause {
  AccDefaultClause(AccDefaultClause &&) = default; AccDefaultClause &operator=(AccDefaultClause &&) = default; AccDefaultClause(const AccDefaultClause &) = delete; AccDefaultClause &operator=(const AccDefaultClause &) = delete; AccDefaultClause() = delete; AccDefaultClause(llvm::acc::DefaultValue &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::DefaultValue v;
  CharBlock source;
};

struct AccDataModifier {
  enum class Modifier { ReadOnly, Zero }; [[maybe_unused]] static constexpr std::size_t Modifier_enumSize{ ::Fortran::common::CountEnumNames("ReadOnly, Zero")}; [[maybe_unused]] static inline std::string_view EnumToString(Modifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Modifier_enumSize>("ReadOnly, Zero")}; return names[static_cast<std::size_t>(e)]; }
  AccDataModifier(AccDataModifier &&) = default; AccDataModifier &operator=(AccDataModifier &&) = default; AccDataModifier(const AccDataModifier &) = delete; AccDataModifier &operator=(const AccDataModifier &) = delete; AccDataModifier() = delete; AccDataModifier(Modifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Modifier v;
  CharBlock source;
};

struct AccObjectListWithModifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithModifier(AccObjectListWithModifier &&) = default; AccObjectListWithModifier &operator=(AccObjectListWithModifier &&) = default; AccObjectListWithModifier(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier &operator=(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier() = delete;
  std::tuple<std::optional<AccDataModifier>, AccObjectList> t;
};


struct AccReductionOperator {
  enum class Operator { Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv }; [[maybe_unused]] static constexpr std::size_t Operator_enumSize{ ::Fortran::common::CountEnumNames("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; [[maybe_unused]] static inline std::string_view EnumToString(Operator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Operator_enumSize>("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; return names[static_cast<std::size_t>(e)]; }

  AccReductionOperator(AccReductionOperator &&) = default; AccReductionOperator &operator=(AccReductionOperator &&) = default; AccReductionOperator(const AccReductionOperator &) = delete; AccReductionOperator &operator=(const AccReductionOperator &) = delete; AccReductionOperator() = delete; AccReductionOperator(Operator &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Operator v;
  CharBlock source;
};

struct AccObjectListWithReduction {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithReduction(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithReduction(AccObjectListWithReduction &&) = default; AccObjectListWithReduction &operator=(AccObjectListWithReduction &&) = default; AccObjectListWithReduction(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction &operator=(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction() = delete;
  std::tuple<AccReductionOperator, AccObjectList> t;
};

struct AccWaitArgument {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccWaitArgument(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccWaitArgument(AccWaitArgument &&) = default; AccWaitArgument &operator=(AccWaitArgument &&) = default; AccWaitArgument(const AccWaitArgument &) = delete; AccWaitArgument &operator=(const AccWaitArgument &) = delete; AccWaitArgument() = delete;
  std::tuple<std::optional<ScalarIntExpr>, std::list<ScalarIntExpr>> t;
};

struct AccDeviceTypeExpr {
  enum class Device { Star, Default, Nvidia, Radeon, Host, Multicore }; [[maybe_unused]] static constexpr std::size_t Device_enumSize{ ::Fortran::common::CountEnumNames("Star, Default, Nvidia, Radeon, Host, Multicore")}; [[maybe_unused]] static inline std::string_view EnumToString(Device e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Device_enumSize>("Star, Default, Nvidia, Radeon, Host, Multicore")}; return names[static_cast<std::size_t>(e)]; }
  AccDeviceTypeExpr(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr &operator=(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr &operator=(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr() = delete; AccDeviceTypeExpr(Device &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Device v;
  CharBlock source;
};

struct AccDeviceTypeExprList {
  AccDeviceTypeExprList(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList &operator=(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList &operator=(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList() = delete; AccDeviceTypeExprList(std::list<AccDeviceTypeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccDeviceTypeExpr> v;

};

struct AccTileExpr {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccTileExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccTileExpr(AccTileExpr &&) = default; AccTileExpr &operator=(AccTileExpr &&) = default; AccTileExpr(const AccTileExpr &) = delete; AccTileExpr &operator=(const AccTileExpr &) = delete; AccTileExpr() = delete;
  CharBlock source;
  std::tuple<std::optional<ScalarIntConstantExpr>> t;
};

struct AccTileExprList {
  AccTileExprList(AccTileExprList &&) = default; AccTileExprList &operator=(AccTileExprList &&) = default; AccTileExprList(const AccTileExprList &) = delete; AccTileExprList &operator=(const AccTileExprList &) = delete; AccTileExprList() = delete; AccTileExprList(std::list<AccTileExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccTileExpr> v;
};

struct AccSizeExpr {
  AccSizeExpr(AccSizeExpr &&) = default; AccSizeExpr &operator=(AccSizeExpr &&) = default; AccSizeExpr(const AccSizeExpr &) = delete; AccSizeExpr &operator=(const AccSizeExpr &) = delete; AccSizeExpr() = delete; AccSizeExpr(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v;
};

struct AccSizeExprList {
  AccSizeExprList(AccSizeExprList &&) = default; AccSizeExprList &operator=(AccSizeExprList &&) = default; AccSizeExprList(const AccSizeExprList &) = delete; AccSizeExprList &operator=(const AccSizeExprList &) = delete; AccSizeExprList() = delete; AccSizeExprList(std::list<AccSizeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccSizeExpr> v;
};

struct AccSelfClause {
  template <typename A, typename = common::NoLvalue<A>> AccSelfClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccSelfClause(AccSelfClause &&) = default; AccSelfClause &operator=(AccSelfClause &&) = default; AccSelfClause(const AccSelfClause &) = delete; AccSelfClause &operator=(const AccSelfClause &) = delete; AccSelfClause() = delete;
  std::variant<std::optional<ScalarLogicalExpr>, AccObjectList> u;
  CharBlock source;
};


struct AccGangArg {
  template <typename A, typename = common::NoLvalue<A>> AccGangArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccGangArg(AccGangArg &&) = default; AccGangArg &operator=(AccGangArg &&) = default; AccGangArg(const AccGangArg &) = delete; AccGangArg &operator=(const AccGangArg &) = delete; AccGangArg() = delete;
  struct Num { Num(Num &&) = default; Num &operator=(Num &&) = default; Num(const Num &) = delete; Num &operator=(const Num &) = delete; Num() = delete; Num(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Dim { Dim(Dim &&) = default; Dim &operator=(Dim &&) = default; Dim(const Dim &) = delete; Dim &operator=(const Dim &) = delete; Dim() = delete; Dim(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Static { Static(Static &&) = default; Static &operator=(Static &&) = default; Static(const Static &) = delete; Static &operator=(const Static &) = delete; Static() = delete; Static(AccSizeExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccSizeExpr v; };
  std::variant<Num, Dim, Static> u;
  CharBlock source;
};

struct AccGangArgList {
  AccGangArgList(AccGangArgList &&) = default; AccGangArgList &operator=(AccGangArgList &&) = default; AccGangArgList(const AccGangArgList &) = delete; AccGangArgList &operator=(const AccGangArgList &) = delete; AccGangArgList() = delete; AccGangArgList(std::list<AccGangArg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccGangArg> v;
};

struct AccCollapseArg {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccCollapseArg(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccCollapseArg(AccCollapseArg &&) = default; AccCollapseArg &operator=(AccCollapseArg &&) = default; AccCollapseArg(const AccCollapseArg &) = delete; AccCollapseArg &operator=(const AccCollapseArg &) = delete; AccCollapseArg() = delete;
  std::tuple<bool, ScalarIntConstantExpr> t;
};

struct AccClause {
  template <typename A, typename = common::NoLvalue<A>> AccClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccClause(AccClause &&) = default; AccClause &operator=(AccClause &&) = default; AccClause(const AccClause &) = delete; AccClause &operator=(const AccClause &) = delete; AccClause() = delete;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 697 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
struct Async { Async(Async &&) = default; Async &operator=(Async &&) = default; Async(const Async &) = delete; Async &operator=(const Async &) = delete; Async() = delete; Async(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Attach { Attach(Attach &&) = default; Attach &operator=(Attach &&) = default; Attach(const Attach &) = delete; Attach &operator=(const Attach &) = delete; Attach() = delete; Attach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Auto { Auto() {} Auto(const Auto &) {} Auto(Auto &&) {} Auto &operator=(const Auto &) { return *this; }; Auto &operator=(Auto &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Bind { Bind(Bind &&) = default; Bind &operator=(Bind &&) = default; Bind(const Bind &) = delete; Bind &operator=(const Bind &) = delete; Bind() = delete; Bind(AccBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBindClause v; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(AccCollapseArg &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCollapseArg v; };
struct Copy { Copy(Copy &&) = default; Copy &operator=(Copy &&) = default; Copy(const Copy &) = delete; Copy &operator=(const Copy &) = delete; Copy() = delete; Copy(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Copyout { Copyout(Copyout &&) = default; Copyout &operator=(Copyout &&) = default; Copyout(const Copyout &) = delete; Copyout &operator=(const Copyout &) = delete; Copyout() = delete; Copyout(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Create { Create(Create &&) = default; Create &operator=(Create &&) = default; Create(const Create &) = delete; Create &operator=(const Create &) = delete; Create() = delete; Create(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(AccDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDefaultClause v; };
struct DefaultAsync { DefaultAsync(DefaultAsync &&) = default; DefaultAsync &operator=(DefaultAsync &&) = default; DefaultAsync(const DefaultAsync &) = delete; DefaultAsync &operator=(const DefaultAsync &) = delete; DefaultAsync() = delete; DefaultAsync(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Delete { Delete(Delete &&) = default; Delete &operator=(Delete &&) = default; Delete(const Delete &) = delete; Delete &operator=(const Delete &) = delete; Delete() = delete; Delete(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Detach { Detach(Detach &&) = default; Detach &operator=(Detach &&) = default; Detach(const Detach &) = delete; Detach &operator=(const Detach &) = delete; Detach() = delete; Detach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceNum { DeviceNum(DeviceNum &&) = default; DeviceNum &operator=(DeviceNum &&) = default; DeviceNum(const DeviceNum &) = delete; DeviceNum &operator=(const DeviceNum &) = delete; DeviceNum() = delete; DeviceNum(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Deviceptr { Deviceptr(Deviceptr &&) = default; Deviceptr &operator=(Deviceptr &&) = default; Deviceptr(const Deviceptr &) = delete; Deviceptr &operator=(const Deviceptr &) = delete; Deviceptr() = delete; Deviceptr(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceResident { DeviceResident(DeviceResident &&) = default; DeviceResident &operator=(DeviceResident &&) = default; DeviceResident(const DeviceResident &) = delete; DeviceResident &operator=(const DeviceResident &) = delete; DeviceResident() = delete; DeviceResident(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(AccDeviceTypeExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDeviceTypeExprList v; };
struct Finalize { Finalize() {} Finalize(const Finalize &) {} Finalize(Finalize &&) {} Finalize &operator=(const Finalize &) { return *this; }; Finalize &operator=(Finalize &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Gang { Gang(Gang &&) = default; Gang &operator=(Gang &&) = default; Gang(const Gang &) = delete; Gang &operator=(const Gang &) = delete; Gang() = delete; Gang(std::optional<AccGangArgList> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccGangArgList> v; };
struct Host { Host(Host &&) = default; Host &operator=(Host &&) = default; Host(const Host &) = delete; Host &operator=(const Host &) = delete; Host() = delete; Host(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(ScalarExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarExpr v; };
struct IfPresent { IfPresent() {} IfPresent(const IfPresent &) {} IfPresent(IfPresent &&) {} IfPresent &operator=(const IfPresent &) { return *this; }; IfPresent &operator=(IfPresent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Independent { Independent() {} Independent(const Independent &) {} Independent(Independent &&) {} Independent &operator=(const Independent &) { return *this; }; Independent &operator=(Independent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct NoCreate { NoCreate(NoCreate &&) = default; NoCreate &operator=(NoCreate &&) = default; NoCreate(const NoCreate &) = delete; NoCreate &operator=(const NoCreate &) = delete; NoCreate() = delete; NoCreate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Nohost { Nohost() {} Nohost(const Nohost &) {} Nohost(Nohost &&) {} Nohost &operator=(const Nohost &) { return *this; }; Nohost &operator=(Nohost &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NumGangs { NumGangs(NumGangs &&) = default; NumGangs &operator=(NumGangs &&) = default; NumGangs(const NumGangs &) = delete; NumGangs &operator=(const NumGangs &) = delete; NumGangs() = delete; NumGangs(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct NumWorkers { NumWorkers(NumWorkers &&) = default; NumWorkers &operator=(NumWorkers &&) = default; NumWorkers(const NumWorkers &) = delete; NumWorkers &operator=(const NumWorkers &) = delete; NumWorkers() = delete; NumWorkers(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Present { Present(Present &&) = default; Present &operator=(Present &&) = default; Present(const Present &) = delete; Present &operator=(const Present &) = delete; Present() = delete; Present(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(AccObjectListWithReduction &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithReduction v; };
struct Self { Self(Self &&) = default; Self &operator=(Self &&) = default; Self(const Self &) = delete; Self &operator=(const Self &) = delete; Self() = delete; Self(std::optional<AccSelfClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccSelfClause> v; };
struct Seq { Seq() {} Seq(const Seq &) {} Seq(Seq &&) {} Seq &operator=(const Seq &) { return *this; }; Seq &operator=(Seq &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Tile { Tile(Tile &&) = default; Tile &operator=(Tile &&) = default; Tile(const Tile &) = delete; Tile &operator=(const Tile &) = delete; Tile() = delete; Tile(AccTileExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccTileExprList v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UseDevice { UseDevice(UseDevice &&) = default; UseDevice &operator=(UseDevice &&) = default; UseDevice(const UseDevice &) = delete; UseDevice &operator=(const UseDevice &) = delete; UseDevice() = delete; UseDevice(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Vector { Vector(Vector &&) = default; Vector &operator=(Vector &&) = default; Vector(const Vector &) = delete; Vector &operator=(const Vector &) = delete; Vector() = delete; Vector(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct VectorLength { VectorLength(VectorLength &&) = default; VectorLength &operator=(VectorLength &&) = default; VectorLength(const VectorLength &) = delete; VectorLength &operator=(const VectorLength &) = delete; VectorLength() = delete; VectorLength(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Wait { Wait(Wait &&) = default; Wait &operator=(Wait &&) = default; Wait(const Wait &) = delete; Wait &operator=(const Wait &) = delete; Wait() = delete; Wait(std::optional<AccWaitArgument> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccWaitArgument> v; };
struct Worker { Worker(Worker &&) = default; Worker &operator=(Worker &&) = default; Worker(const Worker &) = delete; Worker &operator=(const Worker &) = delete; Worker() = delete; Worker(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 4123 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 748 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
Async
, Attach
, Auto
, Bind
, Capture
, Collapse
, Copy
, Copyin
, Copyout
, Create
, Default
, DefaultAsync
, Delete
, Detach
, Device
, DeviceNum
, Deviceptr
, DeviceResident
, DeviceType
, Finalize
, Firstprivate
, Gang
, Host
, If
, IfPresent
, Independent
, Link
, NoCreate
, Nohost
, NumGangs
, NumWorkers
, Present
, Private
, Read
, Reduction
, Self
, Seq
, Tile
, Unknown
, UseDevice
, Vector
, VectorLength
, Wait
, Worker
, Write
# 4129 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct AccClauseList {
  AccClauseList(AccClauseList &&) = default; AccClauseList &operator=(AccClauseList &&) = default; AccClauseList(const AccClauseList &) = delete; AccClauseList &operator=(const AccClauseList &) = delete; AccClauseList() = delete; AccClauseList(std::list<AccClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccClause> v;
  CharBlock source;
};

struct OpenACCRoutineConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCRoutineConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCRoutineConstruct(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct &operator=(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct &operator=(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, AccClauseList> t;
};

struct OpenACCCacheConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCacheConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCacheConstruct(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct &operator=(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct &operator=(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, AccObjectListWithModifier> t;
};

struct OpenACCWaitConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCWaitConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCWaitConstruct(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct &operator=(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct &operator=(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<AccWaitArgument>, AccClauseList> t;
};

struct AccBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginLoopDirective(AccBeginLoopDirective &&) = default; AccBeginLoopDirective &operator=(AccBeginLoopDirective &&) = default; AccBeginLoopDirective(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective &operator=(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective() = delete;
  std::tuple<AccLoopDirective, AccClauseList> t;
  CharBlock source;
};

struct AccBeginBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginBlockDirective(AccBeginBlockDirective &&) = default; AccBeginBlockDirective &operator=(AccBeginBlockDirective &&) = default; AccBeginBlockDirective(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective &operator=(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective() = delete;
  CharBlock source;
  std::tuple<AccBlockDirective, AccClauseList> t;
};

struct AccEndBlockDirective {
  CharBlock source;
  AccEndBlockDirective(AccEndBlockDirective &&) = default; AccEndBlockDirective &operator=(AccEndBlockDirective &&) = default; AccEndBlockDirective(const AccEndBlockDirective &) = delete; AccEndBlockDirective &operator=(const AccEndBlockDirective &) = delete; AccEndBlockDirective() = delete; AccEndBlockDirective(AccBlockDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBlockDirective v;
};


struct AccEndAtomic { AccEndAtomic() {} AccEndAtomic(const AccEndAtomic &) {} AccEndAtomic(AccEndAtomic &&) {} AccEndAtomic &operator=(const AccEndAtomic &) { return *this; }; AccEndAtomic &operator=(AccEndAtomic &&) { return *this; }; using EmptyTrait = std::true_type; };


struct AccAtomicRead {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicRead(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicRead(AccAtomicRead &&) = default; AccAtomicRead &operator=(AccAtomicRead &&) = default; AccAtomicRead(const AccAtomicRead &) = delete; AccAtomicRead &operator=(const AccAtomicRead &) = delete; AccAtomicRead() = delete;
  std::tuple<Verbatim, Statement<AssignmentStmt>, std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicWrite {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicWrite(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicWrite(AccAtomicWrite &&) = default; AccAtomicWrite &operator=(AccAtomicWrite &&) = default; AccAtomicWrite(const AccAtomicWrite &) = delete; AccAtomicWrite &operator=(const AccAtomicWrite &) = delete; AccAtomicWrite() = delete;
  std::tuple<Verbatim, Statement<AssignmentStmt>, std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicUpdate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicUpdate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicUpdate(AccAtomicUpdate &&) = default; AccAtomicUpdate &operator=(AccAtomicUpdate &&) = default; AccAtomicUpdate(const AccAtomicUpdate &) = delete; AccAtomicUpdate &operator=(const AccAtomicUpdate &) = delete; AccAtomicUpdate() = delete;
  std::tuple<std::optional<Verbatim>, Statement<AssignmentStmt>,
      std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicCapture {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicCapture(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicCapture(AccAtomicCapture &&) = default; AccAtomicCapture &operator=(AccAtomicCapture &&) = default; AccAtomicCapture(const AccAtomicCapture &) = delete; AccAtomicCapture &operator=(const AccAtomicCapture &) = delete; AccAtomicCapture() = delete;
  struct Stmt1 { Stmt1(Stmt1 &&) = default; Stmt1 &operator=(Stmt1 &&) = default; Stmt1(const Stmt1 &) = delete; Stmt1 &operator=(const Stmt1 &) = delete; Stmt1() = delete; Stmt1(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  struct Stmt2 { Stmt2(Stmt2 &&) = default; Stmt2 &operator=(Stmt2 &&) = default; Stmt2(const Stmt2 &) = delete; Stmt2 &operator=(const Stmt2 &) = delete; Stmt2() = delete; Stmt2(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  std::tuple<Verbatim, Stmt1, Stmt2, AccEndAtomic> t;
};

struct OpenACCAtomicConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCAtomicConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCAtomicConstruct(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct &operator=(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct &operator=(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct() = delete;
  std::variant<AccAtomicRead, AccAtomicWrite, AccAtomicCapture, AccAtomicUpdate>
      u;
  CharBlock source;
};

struct OpenACCBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCBlockConstruct(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct &operator=(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct &operator=(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct() = delete;
  std::tuple<AccBeginBlockDirective, Block, AccEndBlockDirective> t;
};

struct OpenACCStandaloneDeclarativeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneDeclarativeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneDeclarativeConstruct(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct &operator=(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct &operator=(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct() = delete;
  CharBlock source;
  std::tuple<AccDeclarativeDirective, AccClauseList> t;
};

struct AccBeginCombinedDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginCombinedDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginCombinedDirective(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective &operator=(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective &operator=(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective() = delete;
  CharBlock source;
  std::tuple<AccCombinedDirective, AccClauseList> t;
};

struct AccEndCombinedDirective {
  AccEndCombinedDirective(AccEndCombinedDirective &&) = default; AccEndCombinedDirective &operator=(AccEndCombinedDirective &&) = default; AccEndCombinedDirective(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective &operator=(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective() = delete; AccEndCombinedDirective(AccCombinedDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCombinedDirective v;
  CharBlock source;
};

struct OpenACCCombinedConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCombinedConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCombinedConstruct(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct &operator=(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct &operator=(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct() = delete;
  CharBlock source;
  OpenACCCombinedConstruct(AccBeginCombinedDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginCombinedDirective, std::optional<DoConstruct>,
      std::optional<AccEndCombinedDirective>>
      t;
};

struct OpenACCDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCDeclarativeConstruct(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct &operator=(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct &operator=(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenACCStandaloneDeclarativeConstruct, OpenACCRoutineConstruct>
      u;
};

struct AccEndLoop { AccEndLoop() {} AccEndLoop(const AccEndLoop &) {} AccEndLoop(AccEndLoop &&) {} AccEndLoop &operator=(const AccEndLoop &) { return *this; }; AccEndLoop &operator=(AccEndLoop &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OpenACCLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCLoopConstruct(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct &operator=(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct &operator=(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct() = delete;
  OpenACCLoopConstruct(AccBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginLoopDirective, std::optional<DoConstruct>,
      std::optional<AccEndLoop>>
      t;
};

struct OpenACCEndConstruct {
  OpenACCEndConstruct(OpenACCEndConstruct &&) = default; OpenACCEndConstruct &operator=(OpenACCEndConstruct &&) = default; OpenACCEndConstruct(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct &operator=(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct() = delete; OpenACCEndConstruct(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct OpenACCStandaloneConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneConstruct(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct &operator=(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct &operator=(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct() = delete;
  CharBlock source;
  std::tuple<AccStandaloneDirective, AccClauseList> t;
};

struct OpenACCConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCConstruct(OpenACCConstruct &&) = default; OpenACCConstruct &operator=(OpenACCConstruct &&) = default; OpenACCConstruct(const OpenACCConstruct &) = delete; OpenACCConstruct &operator=(const OpenACCConstruct &) = delete; OpenACCConstruct() = delete;
  std::variant<OpenACCBlockConstruct, OpenACCCombinedConstruct,
      OpenACCLoopConstruct, OpenACCStandaloneConstruct, OpenACCCacheConstruct,
      OpenACCWaitConstruct, OpenACCAtomicConstruct, OpenACCEndConstruct>
      u;
};

struct CUFKernelDoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUFKernelDoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUFKernelDoConstruct(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct &operator=(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct &operator=(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct() = delete;
  struct Directive {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Directive(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Directive(Directive &&) = default; Directive &operator=(Directive &&) = default; Directive(const Directive &) = delete; Directive &operator=(const Directive &) = delete; Directive() = delete;
    CharBlock source;
    std::tuple<std::optional<ScalarIntConstantExpr>, std::list<ScalarIntExpr>,
        std::list<ScalarIntExpr>, std::optional<ScalarIntExpr>>
        t;
  };
  std::tuple<Directive, std::optional<DoConstruct>> t;
};

}
