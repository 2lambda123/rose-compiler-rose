namespace Fortran::common {

constexpr std::size_t CountEnumNames(const char *p) {
  std::size_t n{0};
  std::size_t any{0};
  for (; *p; ++p) {
    if (*p == ',') {
      n += any;
      any = 0;
    } else if (*p != ' ') {
      any = 1;
    }
  }
  return n + any;
}

template <std::size_t ITEMS>
constexpr std::array<std::string_view, ITEMS> EnumNames(const char *p) {
  std::array<std::string_view, ITEMS> result{""};
  std::size_t at{0};
  const char *start{nullptr};
  for (; *p; ++p) {
    if (*p == ',' || *p == ' ') {
      if (start) {
        result[at++] =
            std::string_view{start, static_cast<std::size_t>(p - start)};
        start = nullptr;
      }
    } else if (!start) {
      start = p;
    }
  }
  if (start) {
    result[at] = std::string_view{start, static_cast<std::size_t>(p - start)};
  }
  return result;
}
# 71 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-class.h"
}
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h" 1
# 45 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 46 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h" 2


namespace Fortran::common {
namespace log2visit {

template <std::size_t LOW, std::size_t HIGH, typename RESULT, typename VISITOR,
    typename... VARIANT>
inline RESULT Log2VisitHelper(
    VISITOR &&visitor, std::size_t which, VARIANT &&...u) {
  if constexpr (LOW == HIGH) {
    return visitor(std::get<LOW>(std::forward<VARIANT>(u))...);
  } else {
    static constexpr std::size_t mid{(HIGH + LOW) / 2};
    if (which <= mid) {
      return Log2VisitHelper<LOW, mid, RESULT>(
          std::forward<VISITOR>(visitor), which, std::forward<VARIANT>(u)...);
    } else {
      return Log2VisitHelper<(mid + 1), HIGH, RESULT>(
          std::forward<VISITOR>(visitor), which, std::forward<VARIANT>(u)...);
    }
  }
}

template <typename VISITOR, typename... VARIANT>
inline auto visit(VISITOR &&visitor, VARIANT &&...u)
    -> decltype(visitor(std::get<0>(std::forward<VARIANT>(u))...)) {
  using Result = decltype(visitor(std::get<0>(std::forward<VARIANT>(u))...));
  if constexpr (sizeof...(u) == 1) {
    static constexpr std::size_t high{
        (std::variant_size_v<std::decay_t<decltype(u)>> * ...) - 1};
    return Log2VisitHelper<0, high, Result>(std::forward<VISITOR>(visitor),
        u.index()..., std::forward<VARIANT>(u)...);
  } else {

    return ::std::visit(
        std::forward<VISITOR>(visitor), std::forward<VARIANT>(u)...);
  }
}

}
# 95 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/visit.h"
using ::std::visit;




}
# 28 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 1 3
# 190 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 191 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 192 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3
# 196 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 200 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 2 3


namespace std { inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __list_node;
template <class _Tp, class _VoidPtr> struct __list_node_base;

template <class _Tp, class _VoidPtr>
struct __list_node_pointer_traits {
  typedef typename __rebind_pointer<_VoidPtr, __list_node<_Tp, _VoidPtr> >::type
        __node_pointer;
  typedef typename __rebind_pointer<_VoidPtr, __list_node_base<_Tp, _VoidPtr> >::type
        __base_pointer;




  typedef typename conditional<
          is_pointer<_VoidPtr>::value,
          __base_pointer,
          __node_pointer
  >::type __link_pointer;


  typedef typename conditional<
          is_same<__link_pointer, __node_pointer>::value,
          __base_pointer,
          __node_pointer
  >::type __non_link_pointer;

  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __link_pointer __unsafe_link_pointer_cast(__link_pointer __p) {
      return __p;
  }

  static __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  __link_pointer __unsafe_link_pointer_cast(__non_link_pointer __p) {
      return static_cast<__link_pointer>(static_cast<_VoidPtr>(__p));
  }

};

template <class _Tp, class _VoidPtr>
struct __list_node_base
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__node_pointer __node_pointer;
    typedef typename _NodeTraits::__base_pointer __base_pointer;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __prev_;
    __link_pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_node_base() : __prev_(_NodeTraits::__unsafe_link_pointer_cast(__self())),
                         __next_(_NodeTraits::__unsafe_link_pointer_cast(__self())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __base_pointer __self() {
        return pointer_traits<__base_pointer>::pointer_to(*this);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __as_node() {
        return static_cast<__node_pointer>(__self());
    }
};

template <class _Tp, class _VoidPtr>
struct __attribute__((__standalone_debug__)) __list_node
    : public __list_node_base<_Tp, _VoidPtr>
{
    _Tp __value_;

    typedef __list_node_base<_Tp, _VoidPtr> __base;
    typedef typename __base::__link_pointer __link_pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __link_pointer __as_link() {
        return static_cast<__link_pointer>(__base::__self());
    }
};

template <class _Tp, class _Alloc = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) list;
template <class _Tp, class _Alloc> class __list_imp;
template <class _Tp, class _VoidPtr> class __attribute__ ((__type_visibility__("default"))) __list_const_iterator;

template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 303 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __list_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}




    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
    template<class, class> friend class __list_const_iterator;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator() noexcept : __ptr_(nullptr)
    {



    }
# 355 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator operator++(int) {__list_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_iterator operator--(int) {__list_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __list_iterator& __x, const __list_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
     bool operator!=(const __list_iterator& __x, const __list_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _VoidPtr>
class __attribute__ ((__type_visibility__("default"))) __list_const_iterator
{
    typedef __list_node_pointer_traits<_Tp, _VoidPtr> _NodeTraits;
    typedef typename _NodeTraits::__link_pointer __link_pointer;

    __link_pointer __ptr_;
# 426 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __list_const_iterator(__link_pointer __p) noexcept : __ptr_(__p) {}


    template<class, class> friend class list;
    template<class, class> friend class __list_imp;
public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef const value_type& reference;
    typedef typename __rebind_pointer<_VoidPtr, const value_type>::type pointer;
    typedef typename pointer_traits<pointer>::difference_type difference_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator() noexcept : __ptr_(nullptr)
    {



    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator(const __list_iterator<_Tp, _VoidPtr>& __p) noexcept
        : __ptr_(__p.__ptr_)
    {



    }
# 482 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const
    {




        return __ptr_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const
    {




        return pointer_traits<pointer>::pointer_to(__ptr_->__as_node()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator& operator++()
    {




        __ptr_ = __ptr_->__next_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator operator++(int) {__list_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator& operator--()
    {




        __ptr_ = __ptr_->__prev_;
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_const_iterator operator--(int) {__list_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __list_const_iterator& __x, const __list_const_iterator& __y)
    {
        return __x.__ptr_ == __y.__ptr_;
    }
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __list_const_iterator& __x, const __list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __list_imp
{
    __list_imp(const __list_imp&);
    __list_imp& operator=(const __list_imp&);
public:
    typedef _Alloc allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef typename __alloc_traits::void_pointer __void_pointer;
    typedef __list_iterator<value_type, __void_pointer> iterator;
    typedef __list_const_iterator<value_type, __void_pointer> const_iterator;
    typedef __list_node_base<value_type, __void_pointer> __node_base;
    typedef __list_node<value_type, __void_pointer> __node;
    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_alloc_traits;
    typedef typename __node_alloc_traits::pointer __node_pointer;
    typedef typename __node_alloc_traits::pointer __node_const_pointer;
    typedef __list_node_pointer_traits<value_type, __void_pointer> __node_pointer_traits;
    typedef typename __node_pointer_traits::__link_pointer __link_pointer;
    typedef __link_pointer __link_const_pointer;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::difference_type difference_type;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node_base>::type __node_base_allocator;
    typedef typename allocator_traits<__node_base_allocator>::pointer __node_base_pointer;
    static_assert((!is_same<allocator_type, __node_allocator>::value),
                  "internal allocator type must differ from user-specified "
                  "type; otherwise overload resolution breaks");

    __node_base __end_;
    __compressed_pair<size_type, __node_allocator> __size_alloc_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __link_pointer __end_as_link() const noexcept {
        return __node_pointer_traits::__unsafe_link_pointer_cast(
                const_cast<__node_base&>(__end_).__self());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          size_type& __sz() noexcept {return __size_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& __sz() const noexcept
        {return __size_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __node_alloc() noexcept
          {return __size_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __node_alloc() const noexcept
        {return __size_alloc_.second();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type __node_alloc_max_size() const noexcept {
        return __node_alloc_traits::max_size(__node_alloc());
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __unlink_nodes(__link_pointer __f, __link_pointer __l) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp(const allocator_type& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __list_imp(const __node_allocator& __a);

    __list_imp(__node_allocator&& __a) noexcept;

    ~__list_imp();
    void clear() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __sz() == 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
    {



        return iterator(__end_.__next_);

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
    {



        return const_iterator(__end_.__next_);

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
    {



        return iterator(__end_as_link());

    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
    {



        return const_iterator(__end_as_link());

    }

    void swap(__list_imp& __c)

        noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp& __c)
        noexcept(!__node_alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __node_alloc_traits::propagate_on_container_move_assignment::value>());}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp& __c, true_type)
        {
            if (__node_alloc() != __c.__node_alloc())
                clear();
            __node_alloc() = __c.__node_alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __list_imp&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {
            __node_alloc() = std::__1::move(__c.__node_alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__list_imp&, false_type)
        noexcept
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __invalidate_all_iterators() {



    }
};


template <class _Tp, class _Alloc>
inline
void
__list_imp<_Tp, _Alloc>::__unlink_nodes(__link_pointer __f, __link_pointer __l)
    noexcept
{
    __f->__prev_->__next_ = __l->__next_;
    __l->__next_->__prev_ = __f->__prev_;
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    : __size_alloc_(0, __default_init_tag())
{
}

template <class _Tp, class _Alloc>
inline
__list_imp<_Tp, _Alloc>::__list_imp(const allocator_type& __a)
    : __size_alloc_(0, __node_allocator(__a))
{
}

template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(const __node_allocator& __a)
    : __size_alloc_(0, __a) {}


template <class _Tp, class _Alloc>
inline __list_imp<_Tp, _Alloc>::__list_imp(__node_allocator&& __a) noexcept
    : __size_alloc_(0, std::__1::move(__a)) {}


template <class _Tp, class _Alloc>
__list_imp<_Tp, _Alloc>::~__list_imp() {
  clear();



}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::clear() noexcept
{
    if (!empty())
    {
        __node_allocator& __na = __node_alloc();
        __link_pointer __f = __end_.__next_;
        __link_pointer __l = __end_as_link();
        __unlink_nodes(__f, __l->__prev_);
        __sz() = 0;
        while (__f != __l)
        {
            __node_pointer __np = __f->__as_node();
            __f = __f->__next_;
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
        __invalidate_all_iterators();
    }
}

template <class _Tp, class _Alloc>
void
__list_imp<_Tp, _Alloc>::swap(__list_imp& __c)

        noexcept




{
    ((void)0);



    using std::__1::swap;
    std::__1::__swap_allocator(__node_alloc(), __c.__node_alloc());
    swap(__sz(), __c.__sz());
    swap(__end_, __c.__end_);
    if (__sz() == 0)
        __end_.__next_ = __end_.__prev_ = __end_as_link();
    else
        __end_.__prev_->__next_ = __end_.__next_->__prev_ = __end_as_link();
    if (__c.__sz() == 0)
        __c.__end_.__next_ = __c.__end_.__prev_ = __c.__end_as_link();
    else
        __c.__end_.__prev_->__next_ = __c.__end_.__next_->__prev_ = __c.__end_as_link();
# 832 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
}

template <class _Tp, class _Alloc >
class __attribute__ ((__type_visibility__("default"))) list
    : private __list_imp<_Tp, _Alloc>
{
    typedef __list_imp<_Tp, _Alloc> base;
    typedef typename base::__node __node;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__node_alloc_traits __node_alloc_traits;
    typedef typename base::__node_base __node_base;
    typedef typename base::__node_base_pointer __node_base_pointer;
    typedef typename base::__link_pointer __link_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;
    static_assert((is_same<value_type, typename allocator_type::value_type>::value),
                  "Invalid allocator::value_type");
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename base::pointer pointer;
    typedef typename base::const_pointer const_pointer;
    typedef typename base::size_type size_type;
    typedef typename base::difference_type difference_type;
    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;



    typedef void __remove_return_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
    {



    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit list(const allocator_type& __a) : base(__a)
    {



    }
    explicit list(size_type __n);

    explicit list(size_type __n, const allocator_type& __a);

    list(size_type __n, const value_type& __x);
    list(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);
    template <class _InpIter>
        list(_InpIter __f, _InpIter __l, const allocator_type& __a,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);

    list(const list& __c);
    list(const list& __c, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(const list& __c);

    list(initializer_list<value_type> __il);
    list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list(list&& __c)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list(list&& __c, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    list& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    template <class _InpIter>
        void assign(_InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);
    void assign(size_type __n, const value_type& __x);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return base::__sz();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return base::empty();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
        {
            return std::__1::min<size_type>(
                base::__node_alloc_max_size(),
                numeric_limits<difference_type >::max());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return base::end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return base::begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return base::end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front()
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const
    {
        ((void)0);
        return base::__end_.__next_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference back()
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference back() const
    {
        ((void)0);
        return base::__end_.__prev_->__as_node()->__value_;
    }


    void push_front(value_type&& __x);
    void push_back(value_type&& __x);

    template <class... _Args>

       reference emplace_front(_Args&&... __args);



    template <class... _Args>

        reference emplace_back(_Args&&... __args);



    template <class... _Args>
        iterator emplace(const_iterator __p, _Args&&... __args);

    iterator insert(const_iterator __p, value_type&& __x);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, initializer_list<value_type> __il)
        {return insert(__p, __il.begin(), __il.end());}


    void push_front(const value_type& __x);
    void push_back(const value_type& __x);


    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __emplace_back(_Arg&& __arg) { emplace_back(std::__1::forward<_Arg>(__arg)); }





    iterator insert(const_iterator __p, const value_type& __x);
    iterator insert(const_iterator __p, size_type __n, const value_type& __x);
    template <class _InpIter>
        iterator insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(list& __c)

        noexcept




        {base::swap(__c);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {base::clear();}

    void pop_front();
    void pop_back();

    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __x);

    void splice(const_iterator __p, list& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c) {splice(__p, __c);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c, const_iterator __i)
        {splice(__p, __c, __i);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice(const_iterator __p, list&& __c, const_iterator __f, const_iterator __l)
        {splice(__p, __c, __f, __l);}

    void splice(const_iterator __p, list& __c, const_iterator __i);
    void splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l);

    __remove_return_type remove(const value_type& __x);
    template <class _Pred> __remove_return_type remove_if(_Pred __pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __remove_return_type unique() { return unique(__equal_to<value_type>()); }
    template <class _BinaryPred>
        __remove_return_type unique(_BinaryPred __binary_pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(list& __c);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(list&& __c) {merge(__c);}

    template <class _Comp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void merge(list&& __c, _Comp __comp) {merge(__c, __comp);}

    template <class _Comp>
        void merge(list& __c, _Comp __comp);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void sort();
    template <class _Comp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void sort(_Comp __comp);

    void reverse() noexcept;

    bool __invariants() const;

    typedef __allocator_destructor<__node_allocator> __node_destructor;
    typedef unique_ptr<__node, __node_destructor> __hold_pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __hold_pointer __allocate_node(__node_allocator& __na) {
      __node_pointer __p = __node_alloc_traits::allocate(__na, 1);
      __p->__prev_ = nullptr;
      return __hold_pointer(__p, __node_destructor(__na, 1));
    }
# 1128 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static void __link_nodes (__link_pointer __p, __link_pointer __f, __link_pointer __l);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __link_nodes_at_front(__link_pointer __f, __link_pointer __l);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __link_nodes_at_back (__link_pointer __f, __link_pointer __l);
    iterator __iterator(size_type __n);
    template <class _Comp>
        static iterator __sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp);

    void __move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value);
    void __move_assign(list& __c, false_type);
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
list(_InputIterator, _InputIterator)
  -> list<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
list(_InputIterator, _InputIterator, _Alloc)
  -> list<__iter_value_type<_InputIterator>, _Alloc>;



template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes(__link_pointer __p, __link_pointer __f, __link_pointer __l)
{
    __p->__prev_->__next_ = __f;
    __f->__prev_ = __p->__prev_;
    __p->__prev_ = __l;
    __l->__next_ = __p;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_front(__link_pointer __f, __link_pointer __l)
{
    __f->__prev_ = base::__end_as_link();
    __l->__next_ = base::__end_.__next_;
    __l->__next_->__prev_ = __l;
    base::__end_.__next_ = __f;
}


template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::__link_nodes_at_back(__link_pointer __f, __link_pointer __l)
{
    __l->__next_ = base::__end_as_link();
    __f->__prev_ = base::__end_.__prev_;
    __f->__prev_->__next_ = __f;
    base::__end_.__prev_ = __l;
}


template <class _Tp, class _Alloc>
inline
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__iterator(size_type __n)
{
    return __n <= base::__sz() / 2 ? std::__1::next(begin(), __n)
                                   : std::__1::prev(end(), base::__sz() - __n);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n)
{



    for (; __n > 0; --__n)

        emplace_back();



}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const allocator_type& __a) : base(__a)
{



    for (; __n > 0; --__n)
        emplace_back();
}


template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(size_type __n, const value_type& __x, const allocator_type& __a)
    : base(__a)
{



    for (; __n > 0; --__n)
        push_back(__x);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l,
                        typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
template <class _InpIter>
list<_Tp, _Alloc>::list(_InpIter __f, _InpIter __l, const allocator_type& __a,
                        typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
    : base(__a)
{



    for (; __f != __l; ++__f)
        __emplace_back(*__f);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c)
    : base(__node_alloc_traits::select_on_container_copy_construction(
          __c.__node_alloc())) {



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(const list& __c, const __identity_t<allocator_type>& __a)
    : base(__a)
{



    for (const_iterator __i = __c.begin(), __e = __c.end(); __i != __e; ++__i)
        push_back(*__i);
}



template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il, const allocator_type& __a)
    : base(__a)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
list<_Tp, _Alloc>::list(initializer_list<value_type> __il)
{



    for (typename initializer_list<value_type>::const_iterator __i = __il.begin(),
            __e = __il.end(); __i != __e; ++__i)
        push_back(*__i);
}

template <class _Tp, class _Alloc>
inline list<_Tp, _Alloc>::list(list&& __c)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : base(std::__1::move(__c.__node_alloc())) {



    splice(end(), __c);
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>::list(list&& __c, const __identity_t<allocator_type>& __a)
    : base(__a)
{



    if (__a == __c.get_allocator())
        splice(end(), __c);
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(list&& __c)
        noexcept(__node_alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<__node_allocator>::value)


{
    __move_assign(__c, integral_constant<bool,
          __node_alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, false_type)
{
    if (base::__node_alloc() != __c.__node_alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::__move_assign(list& __c, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
{
    clear();
    base::__move_assign_alloc(__c);
    splice(end(), __c);
}



template <class _Tp, class _Alloc>
inline
list<_Tp, _Alloc>&
list<_Tp, _Alloc>::operator=(const list& __c)
{
    if (this != &__c)
    {
        base::__copy_assign_alloc(__c);
        assign(__c.begin(), __c.end());
    }
    return *this;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
void
list<_Tp, _Alloc>::assign(_InpIter __f, _InpIter __l,
                          typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __f != __l && __i != __e; ++__f, ++__i)
        *__i = *__f;
    if (__i == __e)
        insert(__e, __f, __l);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::assign(size_type __n, const value_type& __x)
{
    iterator __i = begin();
    iterator __e = end();
    for (; __n > 0 && __i != __e; --__n, ++__i)
        *__i = __x;
    if (__i == __e)
        insert(__e, __n, __x);
    else
        erase(__i, __e);



}

template <class _Tp, class _Alloc>
inline
_Alloc
list<_Tp, _Alloc>::get_allocator() const noexcept
{
    return allocator_type(base::__node_alloc());
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, const value_type& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes(__p.__ptr_, __hold->__as_link(), __hold->__as_link());
    ++base::__sz();



    return iterator(__hold.release()->__as_link());

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, size_type __n, const value_type& __x)
{






    iterator __r(__p.__ptr_);

    if (__n > 0)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;



        __r = iterator(__hold->__as_link());

        __hold.release();
        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
template <class _InpIter>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, _InpIter __f, _InpIter __l,
             typename enable_if<__is_cpp17_input_iterator<_InpIter>::value>::type*)
{






    iterator __r(__p.__ptr_);

    if (__f != __l)
    {
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
        ++__ds;



        __r = iterator(__hold.get()->__as_link());

        __hold.release();
        iterator __e = __r;

        try
        {

            for (++__f; __f != __l; ++__f, (void) ++__e, (void) ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), *__f);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(__p.__ptr_, __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_front(__nl, __nl);
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(const value_type& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_front(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::push_back(value_type&& __x)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_nodes_at_back(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();
    __hold.release();
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_nodes_at_front(__hold.get()->__as_link(), __hold.get()->__as_link());
    ++base::__sz();

    return __hold.release()->__value_;



}

template <class _Tp, class _Alloc>
template <class... _Args>

typename list<_Tp, _Alloc>::reference



list<_Tp, _Alloc>::emplace_back(_Args&&... __args)
{
    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold->__as_link();
    __link_nodes_at_back(__nl, __nl);
    ++base::__sz();

    return __hold.release()->__value_;



}

template <class _Tp, class _Alloc>
template <class... _Args>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::emplace(const_iterator __p, _Args&&... __args)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::forward<_Args>(__args)...);
    __link_pointer __nl = __hold.get()->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::insert(const_iterator __p, value_type&& __x)
{





    __node_allocator& __na = base::__node_alloc();
    __hold_pointer __hold = __allocate_node(__na);
    __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), std::__1::move(__x));
    __link_pointer __nl = __hold->__as_link();
    __link_nodes(__p.__ptr_, __nl, __nl);
    ++base::__sz();
    __hold.release();



    return iterator(__nl);

}



template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_front()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1765 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::pop_back()
{
    ((void)0);
    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = base::__end_.__prev_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1794 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __p)
{





    ((void)0);

    __node_allocator& __na = base::__node_alloc();
    __link_pointer __n = __p.__ptr_;
    __link_pointer __r = __n->__next_;
    base::__unlink_nodes(__n, __n);
    --base::__sz();
# 1830 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    __node_pointer __np = __n->__as_node();
    __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
    __node_alloc_traits::deallocate(__na, __np, 1);



    return iterator(__r);

}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::erase(const_iterator __f, const_iterator __l)
{
# 1852 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__f != __l)
    {
        __node_allocator& __na = base::__node_alloc();
        base::__unlink_nodes(__f.__ptr_, __l.__ptr_->__prev_);
        while (__f != __l)
        {
            __link_pointer __n = __f.__ptr_;
            ++__f;
            --base::__sz();
# 1876 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
            __node_pointer __np = __n->__as_node();
            __node_alloc_traits::destroy(__na, std::__1::addressof(__np->__value_));
            __node_alloc_traits::deallocate(__na, __np, 1);
        }
    }



    return iterator(__l.__ptr_);

}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
        ++__ds;



        iterator __r = iterator(__hold.release()->__as_link());

        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_));
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes_at_back(__r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::resize(size_type __n, const value_type& __x)
{
    if (__n < base::__sz())
        erase(__iterator(__n), end());
    else if (__n > base::__sz())
    {
        __n -= base::__sz();
        size_type __ds = 0;
        __node_allocator& __na = base::__node_alloc();
        __hold_pointer __hold = __allocate_node(__na);
        __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
        ++__ds;
        __link_pointer __nl = __hold.release()->__as_link();



        iterator __r = iterator(__nl);

        iterator __e = __r;

        try
        {

            for (--__n; __n != 0; --__n, ++__e, ++__ds)
            {
                __hold.reset(__node_alloc_traits::allocate(__na, 1));
                __node_alloc_traits::construct(__na, std::__1::addressof(__hold->__value_), __x);
                __e.__ptr_->__next_ = __hold.get()->__as_link();
                __hold->__prev_ = __e.__ptr_;
                __hold.release();
            }

        }
        catch (...)
        {
            while (true)
            {
                __node_alloc_traits::destroy(__na, std::__1::addressof(*__e));
                __link_pointer __prev = __e.__ptr_->__prev_;
                __node_alloc_traits::deallocate(__na, __e.__ptr_->__as_node(), 1);
                if (__prev == 0)
                    break;



                __e = iterator(__prev);

            }
            throw;
        }

        __link_nodes(base::__end_as_link(), __r.__ptr_, __e.__ptr_);
        base::__sz() += __ds;
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c)
{
    ((void)0);






    if (!__c.empty())
    {
        __link_pointer __f = __c.__end_.__next_;
        __link_pointer __l = __c.__end_.__prev_;
        base::__unlink_nodes(__f, __l);
        __link_nodes(__p.__ptr_, __f, __l);
        base::__sz() += __c.__sz();
        __c.__sz() = 0;
# 2042 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __i)
{
# 2060 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__p.__ptr_ != __i.__ptr_ && __p.__ptr_ != __i.__ptr_->__next_)
    {
        __link_pointer __f = __i.__ptr_;
        base::__unlink_nodes(__f, __f);
        __link_nodes(__p.__ptr_, __f, __f);
        --__c.__sz();
        ++base::__sz();
# 2087 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::splice(const_iterator __p, list& __c, const_iterator __f, const_iterator __l)
{
# 2113 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    if (__f != __l)
    {
        __link_pointer __first = __f.__ptr_;
        --__l;
        __link_pointer __last = __l.__ptr_;
        if (this != &__c)
        {
            size_type __s = std::__1::distance(__f, __l) + 1;
            __c.__sz() -= __s;
            base::__sz() += __s;
        }
        base::__unlink_nodes(__first, __last);
        __link_nodes(__p.__ptr_, __first, __last);
# 2150 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove(const value_type& __x)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (const_iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (*__i == __x)
        {
            const_iterator __j = std::__1::next(__i);
            for (; __j != __e && *__j == __x; ++__j)
                ;
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _Pred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::remove_if(_Pred __pred)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        if (__pred(*__i))
        {
            iterator __j = std::__1::next(__i);
            for (; __j != __e && __pred(*__j); ++__j)
                ;
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            if (__i != __e)
                ++__i;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
template <class _BinaryPred>
typename list<_Tp, _Alloc>::__remove_return_type
list<_Tp, _Alloc>::unique(_BinaryPred __binary_pred)
{
    list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ;
        if (++__i != __j) {
            __deleted_nodes.splice(__deleted_nodes.end(), *this, __i, __j);
            __i = __j;
            }
    }

    return (__remove_return_type) __deleted_nodes.size();
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::merge(list& __c)
{
    merge(__c, __less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
void
list<_Tp, _Alloc>::merge(list& __c, _Comp __comp)
{
    if (this != std::__1::addressof(__c))
    {
        iterator __f1 = begin();
        iterator __e1 = end();
        iterator __f2 = __c.begin();
        iterator __e2 = __c.end();
        while (__f1 != __e1 && __f2 != __e2)
        {
            if (__comp(*__f2, *__f1))
            {
                size_type __ds = 1;
                iterator __m2 = std::__1::next(__f2);
                for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2, ++__ds)
                    ;
                base::__sz() += __ds;
                __c.__sz() -= __ds;
                __link_pointer __f = __f2.__ptr_;
                __link_pointer __l = __m2.__ptr_->__prev_;
                __f2 = __m2;
                base::__unlink_nodes(__f, __l);
                __m2 = std::__1::next(__f1);
                __link_nodes(__f1.__ptr_, __f, __l);
                __f1 = __m2;
            }
            else
                ++__f1;
        }
        splice(__e1, __c);
# 2281 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
    }
}

template <class _Tp, class _Alloc>
inline
void
list<_Tp, _Alloc>::sort()
{
    sort(__less<value_type>());
}

template <class _Tp, class _Alloc>
template <class _Comp>
inline
void
list<_Tp, _Alloc>::sort(_Comp __comp)
{
    __sort(begin(), end(), base::__sz(), __comp);
}

template <class _Tp, class _Alloc>
template <class _Comp>
typename list<_Tp, _Alloc>::iterator
list<_Tp, _Alloc>::__sort(iterator __f1, iterator __e2, size_type __n, _Comp& __comp)
{
    switch (__n)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(*--__e2, *__f1))
        {
            __link_pointer __f = __e2.__ptr_;
            base::__unlink_nodes(__f, __f);
            __link_nodes(__f1.__ptr_, __f, __f);
            return __e2;
        }
        return __f1;
    }
    size_type __n2 = __n / 2;
    iterator __e1 = std::__1::next(__f1, __n2);
    iterator __r = __f1 = __sort(__f1, __e1, __n2, __comp);
    iterator __f2 = __e1 = __sort(__e1, __e2, __n - __n2, __comp);
    if (__comp(*__f2, *__f1))
    {
        iterator __m2 = std::__1::next(__f2);
        for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
            ;
        __link_pointer __f = __f2.__ptr_;
        __link_pointer __l = __m2.__ptr_->__prev_;
        __r = __f2;
        __e1 = __f2 = __m2;
        base::__unlink_nodes(__f, __l);
        __m2 = std::__1::next(__f1);
        __link_nodes(__f1.__ptr_, __f, __l);
        __f1 = __m2;
    }
    else
        ++__f1;
    while (__f1 != __e1 && __f2 != __e2)
    {
        if (__comp(*__f2, *__f1))
        {
            iterator __m2 = std::__1::next(__f2);
            for (; __m2 != __e2 && __comp(*__m2, *__f1); ++__m2)
                ;
            __link_pointer __f = __f2.__ptr_;
            __link_pointer __l = __m2.__ptr_->__prev_;
            if (__e1 == __f2)
                __e1 = __m2;
            __f2 = __m2;
            base::__unlink_nodes(__f, __l);
            __m2 = std::__1::next(__f1);
            __link_nodes(__f1.__ptr_, __f, __l);
            __f1 = __m2;
        }
        else
            ++__f1;
    }
    return __r;
}

template <class _Tp, class _Alloc>
void
list<_Tp, _Alloc>::reverse() noexcept
{
    if (base::__sz() > 1)
    {
        iterator __e = end();
        for (iterator __i = begin(); __i.__ptr_ != __e.__ptr_;)
        {
            std::__1::swap(__i.__ptr_->__prev_, __i.__ptr_->__next_);
            __i.__ptr_ = __i.__ptr_->__prev_;
        }
        std::__1::swap(__e.__ptr_->__prev_, __e.__ptr_->__next_);
    }
}

template <class _Tp, class _Alloc>
bool
list<_Tp, _Alloc>::__invariants() const
{
    return size() == std::__1::distance(begin(), end());
}
# 2419 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2490 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/list" 3
} }
# 31 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 32 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 1 3
# 158 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 159 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3
# 164 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 168 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/optional" 2 3


namespace std
{

class __attribute__ ((__visibility__("default"))) __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0))) bad_optional_access
    : public exception
{
public:

    virtual ~bad_optional_access() noexcept;
    virtual const char* what() const noexcept;
};

}



namespace std { inline namespace __1 {

[[noreturn]]
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
void __throw_bad_optional_access() {

        throw bad_optional_access();



}

struct nullopt_t
{
    struct __secret_tag { __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __secret_tag() = default; };
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr explicit nullopt_t(__secret_tag, __secret_tag) noexcept {}
};

inline constexpr nullopt_t nullopt{nullopt_t::__secret_tag{}, nullopt_t::__secret_tag{}};

template <class _Tp, bool = is_trivially_destructible<_Tp>::value>
struct __optional_destruct_base;

template <class _Tp>
struct __optional_destruct_base<_Tp, false>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  ~__optional_destruct_base()
    {
        if (__engaged_)
            __val_.~value_type();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept
    {
        if (__engaged_)
        {
            __val_.~value_type();
            __engaged_ = false;
        }
    }
};

template <class _Tp>
struct __optional_destruct_base<_Tp, true>
{
    typedef _Tp value_type;
    static_assert(is_object_v<value_type>,
        "instantiation of optional with a non-object type is undefined behavior");
    union
    {
        char __null_state_;
        value_type __val_;
    };
    bool __engaged_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_destruct_base() noexcept
        : __null_state_(),
           __engaged_(false) {}

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_destruct_base(in_place_t, _Args&&... __args)
        : __val_(std::__1::forward<_Args>(__args)...),
           __engaged_(true) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept
    {
        if (__engaged_)
        {
            __engaged_ = false;
        }
    }
};

template <class _Tp, bool = is_reference<_Tp>::value>
struct __optional_storage_base : __optional_destruct_base<_Tp>
{
    using __base = __optional_destruct_base<_Tp>;
    using value_type = _Tp;
    using __base::__base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool has_value() const noexcept
    {
        return this->__engaged_;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type& __get() & noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr const value_type& __get() const& noexcept
    {
        return this->__val_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type&& __get() && noexcept
    {
        return std::__1::move(this->__val_);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr const value_type&& __get() const&& noexcept
    {
        return std::__1::move(this->__val_);
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct(_Args&&... __args)
    {
        ((void)0);



        ::new ((void*)std::__1::addressof(this->__val_)) value_type(std::__1::forward<_Args>(__args)...);

        this->__engaged_ = true;
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __assign_from(_That&& __opt)
    {
        if (this->__engaged_ == __opt.has_value())
        {
            if (this->__engaged_)
                this->__val_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (this->__engaged_)
                this->reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};




template <class _Tp>
struct __optional_storage_base<_Tp, true>
{
    using value_type = _Tp;
    using __raw_type = remove_reference_t<_Tp>;
    __raw_type* __value_;

    template <class _Up>
    static constexpr bool __can_bind_reference() {
        using _RawUp = typename remove_reference<_Up>::type;
        using _UpPtr = _RawUp*;
        using _RawTp = typename remove_reference<_Tp>::type;
        using _TpPtr = _RawTp*;
        using _CheckLValueArg = integral_constant<bool,
            (is_lvalue_reference<_Up>::value && is_convertible<_UpPtr, _TpPtr>::value)
        || is_same<_RawUp, reference_wrapper<_RawTp>>::value
        || is_same<_RawUp, reference_wrapper<typename remove_const<_RawTp>::type>>::value
        >;
        return (is_lvalue_reference<_Tp>::value && _CheckLValueArg::value)
            || (is_rvalue_reference<_Tp>::value && !is_lvalue_reference<_Up>::value &&
                is_convertible<_UpPtr, _TpPtr>::value);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __optional_storage_base() noexcept
        : __value_(nullptr) {}

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit __optional_storage_base(in_place_t, _UArg&& __uarg)
        : __value_(std::__1::addressof(__uarg))
    {
      static_assert(__can_bind_reference<_UArg>(),
        "Attempted to construct a reference element in tuple from a "
        "possible temporary");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void reset() noexcept { __value_ = nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr bool has_value() const noexcept
      { return __value_ != nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type& __get() const& noexcept
      { return *__value_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type&& __get() const&& noexcept
      { return std::__1::forward<value_type>(*__value_); }

    template <class _UArg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct(_UArg&& __val)
    {
        ((void)0);
        static_assert(__can_bind_reference<_UArg>(),
            "Attempted to construct a reference element in tuple from a "
            "possible temporary");
        __value_ = std::__1::addressof(__val);
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __construct_from(_That&& __opt)
    {
        if (__opt.has_value())
            __construct(std::__1::forward<_That>(__opt).__get());
    }

    template <class _That>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void __assign_from(_That&& __opt)
    {
        if (has_value() == __opt.has_value())
        {
            if (has_value())
                *__value_ = std::__1::forward<_That>(__opt).__get();
        }
        else
        {
            if (has_value())
                reset();
            else
                __construct(std::__1::forward<_That>(__opt).__get());
        }
    }
};

template <class _Tp, bool = is_trivially_copy_constructible<_Tp>::value>
struct __optional_copy_base : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;
};

template <class _Tp>
struct __optional_copy_base<_Tp, false> : __optional_storage_base<_Tp>
{
    using __optional_storage_base<_Tp>::__optional_storage_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_copy_base(const __optional_copy_base& __opt)
    {
        this->__construct_from(__opt);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base(__optional_copy_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base& operator=(const __optional_copy_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_base& operator=(__optional_copy_base&&) = default;
};

template <class _Tp, bool = is_trivially_move_constructible<_Tp>::value>
struct __optional_move_base : __optional_copy_base<_Tp>
{
    using __optional_copy_base<_Tp>::__optional_copy_base;
};

template <class _Tp>
struct __optional_move_base<_Tp, false> : __optional_copy_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_base<_Tp>::__optional_copy_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base(const __optional_move_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_move_base(__optional_move_base&& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type>)
    {
        this->__construct_from(std::__1::move(__opt));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base& operator=(const __optional_move_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_base& operator=(__optional_move_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_copy_constructible<_Tp>::value &&
    is_trivially_copy_assignable<_Tp>::value>
struct __optional_copy_assign_base : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;
};

template <class _Tp>
struct __optional_copy_assign_base<_Tp, false> : __optional_move_base<_Tp>
{
    using __optional_move_base<_Tp>::__optional_move_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base(const __optional_copy_assign_base&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base(__optional_copy_assign_base&&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_copy_assign_base& operator=(const __optional_copy_assign_base& __opt)
    {
        this->__assign_from(__opt);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_copy_assign_base& operator=(__optional_copy_assign_base&&) = default;
};

template <class _Tp, bool =
    is_trivially_destructible<_Tp>::value &&
    is_trivially_move_constructible<_Tp>::value &&
    is_trivially_move_assignable<_Tp>::value>
struct __optional_move_assign_base : __optional_copy_assign_base<_Tp>
{
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;
};

template <class _Tp>
struct __optional_move_assign_base<_Tp, false> : __optional_copy_assign_base<_Tp>
{
    using value_type = _Tp;
    using __optional_copy_assign_base<_Tp>::__optional_copy_assign_base;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base() = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base(const __optional_move_assign_base& __opt) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base(__optional_move_assign_base&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __optional_move_assign_base& operator=(const __optional_move_assign_base&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  __optional_move_assign_base& operator=(__optional_move_assign_base&& __opt)
        noexcept(is_nothrow_move_assignable_v<value_type> &&
                 is_nothrow_move_constructible_v<value_type>)
    {
        this->__assign_from(std::__1::move(__opt));
        return *this;
    }
};

template <class _Tp>
using __optional_sfinae_ctor_base_t = __sfinae_ctor_base<
    is_copy_constructible<_Tp>::value,
    is_move_constructible<_Tp>::value
>;

template <class _Tp>
using __optional_sfinae_assign_base_t = __sfinae_assign_base<
    (is_copy_constructible<_Tp>::value && is_copy_assignable<_Tp>::value),
    (is_move_constructible<_Tp>::value && is_move_assignable<_Tp>::value)
>;

template <class _Tp>
class optional
    : private __optional_move_assign_base<_Tp>
    , private __optional_sfinae_ctor_base_t<_Tp>
    , private __optional_sfinae_assign_base_t<_Tp>
{
    using __base = __optional_move_assign_base<_Tp>;
public:
    using value_type = _Tp;

private:

    static_assert(!is_same_v<__uncvref_t<value_type>, in_place_t>,
        "instantiation of optional with in_place_t is ill-formed");
    static_assert(!is_same_v<__uncvref_t<value_type>, nullopt_t>,
        "instantiation of optional with nullopt_t is ill-formed");
    static_assert(!is_reference_v<value_type>,
        "instantiation of optional with a reference type is ill-formed");
    static_assert(is_destructible_v<value_type>,
        "instantiation of optional with a non-destructible type is ill-formed");
    static_assert(!is_array_v<value_type>,
        "instantiation of optional with an array type is ill-formed");


    struct _CheckOptionalArgsConstructor {
      template <class _Up>
      static constexpr bool __enable_implicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 is_convertible_v<_Up&&, _Tp>;
      }

      template <class _Up>
      static constexpr bool __enable_explicit() {
          return is_constructible_v<_Tp, _Up&&> &&
                 !is_convertible_v<_Up&&, _Tp>;
      }
    };
    template <class _Up>
    using _CheckOptionalArgsCtor = _If<
        _IsNotSame<__uncvref_t<_Up>, in_place_t>::value &&
        _IsNotSame<__uncvref_t<_Up>, optional>::value,
        _CheckOptionalArgsConstructor,
        __check_tuple_constructor_fail
    >;
    template <class _QualUp>
    struct _CheckOptionalLikeConstructor {
      template <class _Up, class _Opt = optional<_Up>>
      using __check_constructible_from_opt = _Or<
          is_constructible<_Tp, _Opt&>,
          is_constructible<_Tp, _Opt const&>,
          is_constructible<_Tp, _Opt&&>,
          is_constructible<_Tp, _Opt const&&>,
          is_convertible<_Opt&, _Tp>,
          is_convertible<_Opt const&, _Tp>,
          is_convertible<_Opt&&, _Tp>,
          is_convertible<_Opt const&&, _Tp>
      >;
      template <class _Up, class _Opt = optional<_Up>>
      using __check_assignable_from_opt = _Or<
          is_assignable<_Tp&, _Opt&>,
          is_assignable<_Tp&, _Opt const&>,
          is_assignable<_Tp&, _Opt&&>,
          is_assignable<_Tp&, _Opt const&&>
      >;
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_implicit() {
          return is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_explicit() {
          return !is_convertible<_QUp, _Tp>::value &&
              !__check_constructible_from_opt<_Up>::value;
      }
      template <class _Up, class _QUp = _QualUp>
      static constexpr bool __enable_assign() {


          return !__check_constructible_from_opt<_Up>::value &&
              !__check_assignable_from_opt<_Up>::value;
      }
    };

    template <class _Up, class _QualUp>
    using _CheckOptionalLikeCtor = _If<
      _And<
         _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
    template <class _Up, class _QualUp>
    using _CheckOptionalLikeAssign = _If<
      _And<
          _IsNotSame<_Up, _Tp>,
          is_constructible<_Tp, _QualUp>,
          is_assignable<_Tp&, _QualUp>
      >::value,
      _CheckOptionalLikeConstructor<_QualUp>,
      __check_tuple_constructor_fail
    >;
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(optional&&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr optional(nullopt_t) noexcept {}

    template <class _InPlaceT, class... _Args, class = _EnableIf<
          _And<
              _IsSame<_InPlaceT, in_place_t>,
              is_constructible<value_type, _Args...>
            >::value
        >
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(_InPlaceT, _Args&&... __args)
        : __base(in_place, std::__1::forward<_Args>(__args)...) {}

    template <class _Up, class... _Args, class = _EnableIf<
        is_constructible_v<value_type, initializer_list<_Up>&, _Args...>>
    >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(in_place_t, initializer_list<_Up> __il, _Args&&... __args)
        : __base(in_place, __il, std::__1::forward<_Args>(__args)...) {}

    template <class _Up = value_type, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}

    template <class _Up, _EnableIf<
        _CheckOptionalArgsCtor<_Up>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit optional(_Up&& __v)
        : __base(in_place, std::__1::forward<_Up>(__v)) {}


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up const&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  explicit optional(const optional<_Up>& __v)
    {
        this->__construct_from(__v);
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_implicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }
    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_explicit<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  explicit optional(optional<_Up>&& __v)
    {
        this->__construct_from(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional& operator=(nullopt_t) noexcept
    {
        reset();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) optional& operator=(const optional&) = default;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) optional& operator=(optional&&) = default;


    template <class _Up = value_type,
              class = _EnableIf<
                      _And<
                          _IsNotSame<__uncvref_t<_Up>, optional>,
                          _Or<
                              _IsNotSame<__uncvref_t<_Up>, value_type>,
                              _Not<is_scalar<value_type>>
                          >,
                          is_constructible<value_type, _Up>,
                          is_assignable<value_type&, _Up>
                      >::value>
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(_Up&& __v)
    {
        if (this->has_value())
            this->__get() = std::__1::forward<_Up>(__v);
        else
            this->__construct(std::__1::forward<_Up>(__v));
        return *this;
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeAssign<_Up, _Up const&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(const optional<_Up>& __v)
    {
        this->__assign_from(__v);
        return *this;
    }


    template <class _Up, _EnableIf<
        _CheckOptionalLikeCtor<_Up, _Up &&>::template __enable_assign<_Up>()
    , int> = 0>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  optional&
    operator=(optional<_Up>&& __v)
    {
        this->__assign_from(std::__1::move(__v));
        return *this;
    }

    template <class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  _Tp &
    emplace(_Args&&... __args)
    {
        reset();
        this->__construct(std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    template <class _Up, class... _Args,
              class = _EnableIf
                      <
                          is_constructible_v<value_type, initializer_list<_Up>&, _Args...>
                      >
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  _Tp &
    emplace(initializer_list<_Up> __il, _Args&&... __args)
    {
        reset();
        this->__construct(__il, std::__1::forward<_Args>(__args)...);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
                                  void swap(optional& __opt)
        noexcept(is_nothrow_move_constructible_v<value_type> &&
                 is_nothrow_swappable_v<value_type>)
    {
        if (this->has_value() == __opt.has_value())
        {
            using std::__1::swap;
            if (this->has_value())
                swap(this->__get(), __opt.__get());
        }
        else
        {
            if (this->has_value())
            {
                __opt.__construct(std::__1::move(this->__get()));
                reset();
            }
            else
            {
                this->__construct(std::__1::move(__opt.__get()));
                __opt.reset();
            }
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    add_pointer_t<value_type const>
    operator->() const
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    add_pointer_t<value_type>
    operator->()
    {
        ((void)0);

        return std::__1::addressof(this->__get());



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const value_type&
    operator*() const& noexcept
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    value_type&
    operator*() & noexcept
    {
        ((void)0);
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    value_type&&
    operator*() && noexcept
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    const value_type&&
    operator*() const&& noexcept
    {
        ((void)0);
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr explicit operator bool() const noexcept { return has_value(); }

    using __base::has_value;
    using __base::__get;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type const& value() const&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type& value() &
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return this->__get();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type&& value() &&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __attribute__((availability(macosx,strict,introduced=10.13))) __attribute__((availability(ios,strict,introduced=11.0))) __attribute__((availability(tvos,strict,introduced=11.0))) __attribute__((availability(watchos,strict,introduced=4.0)))
    constexpr value_type const&& value() const&&
    {
        if (!this->has_value())
            __throw_bad_optional_access();
        return std::__1::move(this->__get());
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type value_or(_Up&& __v) const&
    {
        static_assert(is_copy_constructible_v<value_type>,
                      "optional<T>::value_or: T must be copy constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? this->__get() :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr value_type value_or(_Up&& __v) &&
    {
        static_assert(is_move_constructible_v<value_type>,
                      "optional<T>::value_or: T must be move constructible");
        static_assert(is_convertible_v<_Up, value_type>,
                      "optional<T>::value_or: U must be convertible to T");
        return this->has_value() ? std::__1::move(this->__get()) :
                                  static_cast<value_type>(std::__1::forward<_Up>(__v));
    }

    using __base::reset;

private:
    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static _Up*
    __operator_arrow(true_type, _Up& __x)
    {
        return std::__1::addressof(__x);
    }

    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static constexpr _Up*
    __operator_arrow(false_type, _Up& __x)
    {
        return &__x;
    }
};


template<class _Tp>
    optional(_Tp) -> optional<_Tp>;



template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x == *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (static_cast<bool>(__x) != static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x != *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return false;
    if (!static_cast<bool>(__x))
        return true;
    return *__x < *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return false;
    if (!static_cast<bool>(__y))
        return true;
    return *__x > *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__x))
        return true;
    if (!static_cast<bool>(__y))
        return false;
    return *__x <= *__y;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const optional<_Up>& __y)
{
    if (!static_cast<bool>(__y))
        return true;
    if (!static_cast<bool>(__x))
        return false;
    return *__x >= *__y;
}


template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator==(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator!=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(const optional<_Tp>&, nullopt_t) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return !static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator<=(nullopt_t, const optional<_Tp>&) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(const optional<_Tp>& __x, nullopt_t) noexcept
{
    return static_cast<bool>(__x);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>(nullopt_t, const optional<_Tp>&) noexcept
{
    return false;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(const optional<_Tp>&, nullopt_t) noexcept
{
    return true;
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
bool
operator>=(nullopt_t, const optional<_Tp>& __x) noexcept
{
    return !static_cast<bool>(__x);
}


template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x == __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() ==
        declval<const _Up&>()), bool>,
    bool
>
operator==(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v == *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x != __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() !=
        declval<const _Up&>()), bool>,
    bool
>
operator!=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v != *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x < __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <
        declval<const _Up&>()), bool>,
    bool
>
operator<(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v < *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x <= __v : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() <=
        declval<const _Up&>()), bool>,
    bool
>
operator<=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v <= *__x : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x > __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >
        declval<const _Up&>()), bool>,
    bool
>
operator>(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v > *__x : true;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const optional<_Tp>& __x, const _Up& __v)
{
    return static_cast<bool>(__x) ? *__x >= __v : false;
}

template <class _Tp, class _Up>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
_EnableIf<
    is_convertible_v<decltype(declval<const _Tp&>() >=
        declval<const _Up&>()), bool>,
    bool
>
operator>=(const _Tp& __v, const optional<_Up>& __x)
{
    return static_cast<bool>(__x) ? __v >= *__x : true;
}


template <class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EnableIf<
    is_move_constructible_v<_Tp> && is_swappable_v<_Tp>,
    void
>
swap(optional<_Tp>& __x, optional<_Tp>& __y) noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Tp>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<decay_t<_Tp>> make_optional(_Tp&& __v)
{
    return optional<decay_t<_Tp>>(std::__1::forward<_Tp>(__v));
}

template <class _Tp, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<_Tp> make_optional(_Args&&... __args)
{
    return optional<_Tp>(in_place, std::__1::forward<_Args>(__args)...);
}

template <class _Tp, class _Up, class... _Args>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
optional<_Tp> make_optional(initializer_list<_Up> __il, _Args&&... __args)
{
    return optional<_Tp>(in_place, __il, std::__1::forward<_Args>(__args)...);
}

template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) hash<
    __enable_hash_helper<optional<_Tp>, remove_const_t<_Tp>>
>
{

    __attribute__ ((deprecated)) typedef optional<_Tp> argument_type;
    __attribute__ ((deprecated)) typedef size_t result_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const optional<_Tp>& __opt) const
    {
        return static_cast<bool>(__opt) ? hash<remove_const_t<_Tp>>()(*__opt) : 0;
    }
};

} }
# 33 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 36 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h" 2
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
using namespace std::literals::string_literals;

namespace Fortran::common {
# 61 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename... LAMBDAS> struct visitors : LAMBDAS... {
  using LAMBDAS::operator()...;
};

template <typename... LAMBDAS> visitors(LAMBDAS... x) -> visitors<LAMBDAS...>;


[[noreturn]] void die(const char *, ...);
# 118 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename T> constexpr T &Deref(T *p, const char *file, int line) {
  if (!p) {
    Fortran::common::die("nullptr dereference at %s(%d)", file, line);
  }
  return *p;
}

template <typename T>
constexpr T &Deref(const std::unique_ptr<T> &p, const char *file, int line) {
  if (!p) {
    Fortran::common::die("nullptr dereference at %s(%d)", file, line);
  }
  return *p;
}


template <typename A> A Clone(const A &x) { return x; }
# 147 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/idioms.h"
template <typename A, typename... B>
using IfNoLvalue = std::enable_if_t<(... && !std::is_lvalue_reference_v<B>), A>;
template <typename... RVREF> using NoLvalue = IfNoLvalue<void, RVREF...>;
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" 2




namespace Fortran::common {

template <typename A> class Interval {
public:
  using type = A;
  constexpr Interval() {}
  constexpr Interval(const A &s, std::size_t n = 1) : start_{s}, size_{n} {}
  constexpr Interval(A &&s, std::size_t n = 1)
      : start_{std::move(s)}, size_{n} {}
  constexpr Interval(const Interval &) = default;
  constexpr Interval(Interval &&) = default;
  constexpr Interval &operator=(const Interval &) = default;
  constexpr Interval &operator=(Interval &&) = default;

  constexpr bool operator<(const Interval &that) const {
    return start_ < that.start_ ||
        (start_ == that.start_ && size_ < that.size_);
  }
  constexpr bool operator<=(const Interval &that) const {
    return start_ < that.start_ ||
        (start_ == that.start_ && size_ <= that.size_);
  }
  constexpr bool operator==(const Interval &that) const {
    return start_ == that.start_ && size_ == that.size_;
  }
  constexpr bool operator!=(const Interval &that) const {
    return !(*this == that);
  }
  constexpr bool operator>=(const Interval &that) const {
    return !(*this < that);
  }
  constexpr bool operator>(const Interval &that) const {
    return !(*this <= that);
  }

  constexpr const A &start() const { return start_; }
  constexpr std::size_t size() const { return size_; }
  constexpr bool empty() const { return size_ == 0; }

  constexpr bool Contains(const A &x) const {
    return start_ <= x && x < start_ + size_;
  }
  constexpr bool Contains(const Interval &that) const {
    return Contains(that.start_) && Contains(that.start_ + (that.size_ - 1));
  }
  constexpr bool IsDisjointWith(const Interval &that) const {
    return that.NextAfter() <= start_ || NextAfter() <= that.start_;
  }
  constexpr bool ImmediatelyPrecedes(const Interval &that) const {
    return NextAfter() == that.start_;
  }
  void Annex(const Interval &that) {
    size_ = (that.start_ + that.size_) - start_;
  }
  bool AnnexIfPredecessor(const Interval &that) {
    if (ImmediatelyPrecedes(that)) {
      size_ += that.size_;
      return true;
    }
    return false;
  }
  void ExtendToCover(const Interval &that) {
    if (size_ == 0) {
      *this = that;
    } else if (that.size_ != 0) {
      const auto end{std::max(NextAfter(), that.NextAfter())};
      start_ = std::min(start_, that.start_);
      size_ = end - start_;
    }
  }

  std::size_t MemberOffset(const A &x) const {
    ((Contains(x)) || (Fortran::common::die("CHECK(" "Contains(x)" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" "(%d)", 92), false));
    return x - start_;
  }
  A OffsetMember(std::size_t n) const {
    ((n <= size_) || (Fortran::common::die("CHECK(" "n <= size_" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/interval.h" "(%d)", 96), false));
    return start_ + n;
  }

  constexpr A Last() const { return start_ + (size_ - 1); }
  constexpr A NextAfter() const { return start_ + size_; }
  constexpr Interval Prefix(std::size_t n) const {
    return {start_, std::min(size_, n)};
  }
  Interval Suffix(std::size_t n) const {
    n = std::min(n, size_);
    return {start_ + n, size_ - n};
  }

  constexpr Interval Intersection(const Interval &that) const {
    if (that.NextAfter() <= start_) {
      return {};
    } else if (that.start_ <= start_) {
      auto skip{start_ - that.start_};
      return {start_, std::min(size_, that.size_ - skip)};
    } else if (NextAfter() <= that.start_) {
      return {};
    } else {
      auto skip{that.start_ - start_};
      return {that.start_, std::min(that.size_, size_ - skip)};
    }
  }

private:
  A start_;
  std::size_t size_{0};
};
}
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-block.h" 2







namespace llvm {
class raw_ostream;
}

namespace Fortran::parser {

class CharBlock {
public:
  constexpr CharBlock() {}
  constexpr CharBlock(const char *x, std::size_t n = 1) : interval_{x, n} {}
  constexpr CharBlock(const char *b, const char *ep1)
      : interval_{b, static_cast<std::size_t>(ep1 - b)} {}
  CharBlock(const std::string &s) : interval_{s.data(), s.size()} {}
  constexpr CharBlock(const CharBlock &) = default;
  constexpr CharBlock(CharBlock &&) = default;
  constexpr CharBlock &operator=(const CharBlock &) = default;
  constexpr CharBlock &operator=(CharBlock &&) = default;

  constexpr bool empty() const { return interval_.empty(); }
  constexpr std::size_t size() const { return interval_.size(); }
  constexpr const char *begin() const { return interval_.start(); }
  constexpr const char *end() const {
    return interval_.start() + interval_.size();
  }
  constexpr const char &operator[](std::size_t j) const {
    return interval_.start()[j];
  }

  bool Contains(const CharBlock &that) const {
    return interval_.Contains(that.interval_);
  }

  void ExtendToCover(const CharBlock &that) {
    interval_.ExtendToCover(that.interval_);
  }



  char FirstNonBlank() const {
    for (char ch : *this) {
      if (ch != ' ' && ch != '\t') {
        return ch;
      }
    }
    return ' ';
  }



  char OnlyNonBlank() const {
    char result{' '};
    for (char ch : *this) {
      if (ch != ' ' && ch != '\t') {
        if (result == ' ') {
          result = ch;
        } else {
          return ' ';
        }
      }
    }
    return result;
  }

  std::size_t CountLeadingBlanks() const {
    std::size_t n{size()};
    std::size_t j{0};
    for (; j < n; ++j) {
      char ch{(*this)[j]};
      if (ch != ' ' && ch != '\t') {
        break;
      }
    }
    return j;
  }

  bool IsBlank() const { return FirstNonBlank() == ' '; }

  std::string ToString() const {
    return std::string{interval_.start(), interval_.size()};
  }


  std::string NULTerminatedToString() const {
    return std::string{interval_.start(),
                         strnlen(interval_.start(), interval_.size())};
  }

  bool operator<(const CharBlock &that) const { return Compare(that) < 0; }
  bool operator<=(const CharBlock &that) const { return Compare(that) <= 0; }
  bool operator==(const CharBlock &that) const { return Compare(that) == 0; }
  bool operator!=(const CharBlock &that) const { return Compare(that) != 0; }
  bool operator>=(const CharBlock &that) const { return Compare(that) >= 0; }
  bool operator>(const CharBlock &that) const { return Compare(that) > 0; }

  bool operator<(const char *that) const { return Compare(that) < 0; }
  bool operator<=(const char *that) const { return Compare(that) <= 0; }
  bool operator==(const char *that) const { return Compare(that) == 0; }
  bool operator!=(const char *that) const { return Compare(that) != 0; }
  bool operator>=(const char *that) const { return Compare(that) >= 0; }
  bool operator>(const char *that) const { return Compare(that) > 0; }

  friend bool operator<(const char *, const CharBlock &);
  friend bool operator<=(const char *, const CharBlock &);
  friend bool operator==(const char *, const CharBlock &);
  friend bool operator!=(const char *, const CharBlock &);
  friend bool operator>=(const char *, const CharBlock &);
  friend bool operator>(const char *, const CharBlock &);

private:
  int Compare(const CharBlock &that) const {
    std::size_t bytes{std::min(size(), that.size())};
    int cmp{std::memcmp(static_cast<const void *>(begin()),
        static_cast<const void *>(that.begin()), bytes)};
    if (cmp != 0) {
      return cmp;
    }
    return size() < that.size() ? -1 : size() > that.size();
  }

  int Compare(const char *that) const {
    std::size_t bytes{size()};
    if (int cmp{std::strncmp(begin(), that, bytes)}) {
      return cmp;
    }
    return that[bytes] == '\0' ? 0 : -1;
  }

  common::Interval<const char *> interval_{nullptr, 0};
};

inline bool operator<(const char *left, const CharBlock &right) {
  return right > left;
}
inline bool operator<=(const char *left, const CharBlock &right) {
  return right >= left;
}
inline bool operator==(const char *left, const CharBlock &right) {
  return right == left;
}
inline bool operator!=(const char *left, const CharBlock &right) {
  return right != left;
}
inline bool operator>=(const char *left, const CharBlock &right) {
  return right <= left;
}
inline bool operator>(const char *left, const CharBlock &right) {
  return right < left;
}


struct CharBlockPointerComparator {
  bool operator()(CharBlock x, CharBlock y) const {
    return x.end() < y.begin();
  }
};

llvm::raw_ostream &operator<<(llvm::raw_ostream &os, const CharBlock &x);

}


template <> struct std::hash<Fortran::parser::CharBlock> {
  std::size_t operator()(const Fortran::parser::CharBlock &x) const {
    std::size_t hash{0}, bytes{x.size()};
    for (std::size_t j{0}; j < bytes; ++j) {
      hash = (hash * 31) ^ x[j];
    }
    return hash;
  }
};
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/characters.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/characters.h"
namespace Fortran::parser {

extern bool useHexadecimalEscapeSequences;






enum class Encoding { LATIN_1, UTF_8 };

inline constexpr bool IsUpperCaseLetter(char ch) {
  return ch >= 'A' && ch <= 'Z';
}

inline constexpr bool IsLowerCaseLetter(char ch) {
  return ch >= 'a' && ch <= 'z';
}

inline constexpr bool IsLetter(char ch) {
  return IsUpperCaseLetter(ch) || IsLowerCaseLetter(ch);
}

inline constexpr bool IsDecimalDigit(char ch) { return ch >= '0' && ch <= '9'; }

inline constexpr bool IsHexadecimalDigit(char ch) {
  return (ch >= '0' && ch <= '9') || (ch >= 'A' && ch <= 'F') ||
      (ch >= 'a' && ch <= 'f');
}

inline constexpr bool IsOctalDigit(char ch) { return ch >= '0' && ch <= '7'; }

inline constexpr bool IsLegalIdentifierStart(char ch) {
  return IsLetter(ch) || ch == '_' || ch == '@' || ch == '$';
}

inline constexpr bool IsLegalInIdentifier(char ch) {
  return IsLegalIdentifierStart(ch) || IsDecimalDigit(ch);
}

inline constexpr bool IsPrintable(char ch) { return ch >= ' ' && ch <= '~'; }

inline constexpr bool IsWhiteSpace(char ch) {
  return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\v' || ch == '\f' ||
      ch == '\r';
}

inline constexpr char ToLowerCaseLetter(char ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 'a' : ch;
}

inline constexpr char ToLowerCaseLetter(char &&ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 'a' : ch;
}

inline std::string ToLowerCaseLetters(std::string_view str) {
  std::string lowered{str};
  for (char &ch : lowered) {
    ch = ToLowerCaseLetter(ch);
  }
  return lowered;
}

inline constexpr char ToUpperCaseLetter(char ch) {
  return IsLowerCaseLetter(ch) ? ch - 'a' + 'A' : ch;
}

inline constexpr char ToUpperCaseLetter(char &&ch) {
  return IsLowerCaseLetter(ch) ? ch - 'a' + 'A' : ch;
}

inline std::string ToUpperCaseLetters(std::string_view str) {
  std::string raised{str};
  for (char &ch : raised) {
    ch = ToUpperCaseLetter(ch);
  }
  return raised;
}

inline constexpr bool IsSameApartFromCase(char x, char y) {
  return ToLowerCaseLetter(x) == ToLowerCaseLetter(y);
}

inline constexpr char DecimalDigitValue(char ch) { return ch - '0'; }

inline constexpr char HexadecimalDigitValue(char ch) {
  return IsUpperCaseLetter(ch) ? ch - 'A' + 10
      : IsLowerCaseLetter(ch) ? ch - 'a' + 10
                               : DecimalDigitValue(ch);
}

inline constexpr std::optional<char> BackslashEscapeValue(char ch) {
  switch (ch) {
  case 'a':
    return std::nullopt;
  case 'b':
    return '\b';
  case 'f':
    return '\f';
  case 'n':
    return '\n';
  case 'r':
    return '\r';
  case 't':
    return '\t';
  case 'v':
    return '\v';
  case '"':
  case '\'':
  case '\\':
    return ch;
  default:
    return std::nullopt;
  }
}

inline constexpr std::optional<char> BackslashEscapeChar(char ch) {
  switch (ch) {
  case '\a':
    return std::nullopt;
  case '\b':
    return 'b';
  case '\f':
    return 'f';
  case '\n':
    return 'n';
  case '\r':
    return 'r';
  case '\t':
    return 't';
  case '\v':
    return 'v';
  case '"':
  case '\'':
  case '\\':
    return ch;
  default:
    return std::nullopt;
  }
}


inline constexpr bool IsValidFortranTokenCharacter(char ch) {
  switch (ch) {
  case '"':
  case '%':
  case '\'':
  case '(':
  case ')':
  case '*':
  case '+':
  case ',':
  case '-':
  case '.':
  case '/':
  case ':':
  case ';':
  case '<':
  case '=':
  case '>':
  case '[':
  case ']':
    return true;
  default:
    return IsLegalIdentifierStart(ch) || IsDecimalDigit(ch);
  }
}

struct EncodedCharacter {
  static constexpr int maxEncodingBytes{6};
  char buffer[maxEncodingBytes];
  int bytes{0};
};

template <Encoding ENCODING> EncodedCharacter EncodeCharacter(char32_t ucs);
template <> EncodedCharacter EncodeCharacter<Encoding::LATIN_1>(char32_t);
template <> EncodedCharacter EncodeCharacter<Encoding::UTF_8>(char32_t);

EncodedCharacter EncodeCharacter(Encoding, char32_t ucs);

template <Encoding ENCODING, typename STRING>
std::string EncodeString(const STRING &);
extern template std::string EncodeString<Encoding::LATIN_1, std::string>(
    const std::string &);
extern template std::string EncodeString<Encoding::UTF_8, std::u32string>(
    const std::u32string &);



template <typename NORMAL, typename INSERTED>
void EmitQuotedChar(char32_t ch, const NORMAL &emit, const INSERTED &insert,
    bool backslashEscapes = true, Encoding encoding = Encoding::UTF_8) {
  auto emitOneByte{[&](std::uint8_t ch) {
    if (backslashEscapes && (ch < ' ' || ch >= 0x7f || ch == '\\')) {
      if (std::optional<char> escape{BackslashEscapeChar(ch)}) {
        insert('\\');
        emit(*escape);
      } else if (useHexadecimalEscapeSequences) {
        insert('\\');
        insert('x');
        int top{ch >> 4}, bottom{ch & 0xf};
        insert(top > 9 ? 'a' + top - 10 : '0' + top);
        insert(bottom > 9 ? 'a' + bottom - 10 : '0' + bottom);
      } else {

        insert('\\');
        insert('0' + (ch >> 6));
        insert('0' + ((ch >> 3) & 7));
        insert('0' + (ch & 7));
      }
    } else if (ch == '\n') {
      insert('\\');
      insert('n');
    } else {
      emit(ch);
    }
  }};
  if (ch <= 0x7f) {
    emitOneByte(ch);
  } else {
    EncodedCharacter encoded{EncodeCharacter(encoding, ch)};
    for (int j{0}; j < encoded.bytes; ++j) {
      emitOneByte(encoded.buffer[j]);
    }
  }
}

std::string QuoteCharacterLiteral(const std::string &,
    bool backslashEscapes = true, Encoding = Encoding::LATIN_1);
std::string QuoteCharacterLiteral(const std::u16string &,
    bool backslashEscapes = true, Encoding = Encoding::UTF_8);
std::string QuoteCharacterLiteral(const std::u32string &,
    bool backslashEscapes = true, Encoding = Encoding::UTF_8);

int UTF_8CharacterBytes(const char *);

struct DecodedCharacter {
  char32_t codepoint{0};
  int bytes{0};
};

template <Encoding ENCODING>
DecodedCharacter DecodeRawCharacter(const char *, std::size_t);
template <>
DecodedCharacter DecodeRawCharacter<Encoding::LATIN_1>(
    const char *, std::size_t);

template <>
DecodedCharacter DecodeRawCharacter<Encoding::UTF_8>(const char *, std::size_t);


template <Encoding ENCODING>
DecodedCharacter DecodeCharacter(
    const char *, std::size_t, bool backslashEscapes);
extern template DecodedCharacter DecodeCharacter<Encoding::LATIN_1>(
    const char *, std::size_t, bool);
extern template DecodedCharacter DecodeCharacter<Encoding::UTF_8>(
    const char *, std::size_t, bool);

DecodedCharacter DecodeCharacter(
    Encoding, const char *, std::size_t, bool backslashEscapes);

template <typename RESULT, Encoding ENCODING>
RESULT DecodeString(const std::string &, bool backslashEscapes);
extern template std::string DecodeString<std::string, Encoding::LATIN_1>(
    const std::string &, bool);
extern template std::u16string DecodeString<std::u16string, Encoding::UTF_8>(
    const std::string &, bool);
extern template std::u32string DecodeString<std::u32string, Encoding::UTF_8>(
    const std::string &, bool);
}
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 1 3
# 239 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 1 3
# 242 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 251 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/14.0.0/include/inttypes.h" 1 3
# 21 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/14.0.0/include/inttypes.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/inttypes.h" 1 3 4
# 227 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/inttypes.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 228 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/inttypes.h" 2 3 4



extern "C" {


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
imaxabs(intmax_t j);


typedef struct {
 intmax_t quot;
 intmax_t rem;
} imaxdiv_t;

__attribute__((availability(macosx,introduced=10.4)))
extern imaxdiv_t
imaxdiv(intmax_t __numer, intmax_t __denom);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
strtoimax(const char * __nptr,
   char ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
strtoumax(const char * __nptr,
   char ** __endptr,
   int __base);


__attribute__((availability(macosx,introduced=10.4)))
extern intmax_t
wcstoimax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);

__attribute__((availability(macosx,introduced=10.4)))
extern uintmax_t
wcstoumax(const wchar_t * __nptr,
   wchar_t ** __endptr,
   int __base);






}
# 22 "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/clang/14.0.0/include/inttypes.h" 2 3
# 252 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/inttypes.h" 2 3
# 240 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 2 3
# 243 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cinttypes" 3


namespace std { inline namespace __1 {

using ::imaxdiv_t __attribute__((using_if_exists));
using ::imaxabs __attribute__((using_if_exists));
using ::imaxdiv __attribute__((using_if_exists));
using ::strtoimax __attribute__((using_if_exists));
using ::strtoumax __attribute__((using_if_exists));
using ::wcstoimax __attribute__((using_if_exists));
using ::wcstoumax __attribute__((using_if_exists));

} }
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h" 2





namespace Fortran::format {
# 37 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
struct IntrinsicTypeDataEditDesc {
  enum class Kind { I, B, O, Z, F, E, EN, ES, EX, G, L, A, D };
  IntrinsicTypeDataEditDesc() = delete;
  IntrinsicTypeDataEditDesc(IntrinsicTypeDataEditDesc &&) = default;
  IntrinsicTypeDataEditDesc &operator=(IntrinsicTypeDataEditDesc &&) = default;
  IntrinsicTypeDataEditDesc(Kind &&k, std::optional<int> &&w,
      std::optional<int> &&d, std::optional<int> &&e)
      : kind{k}, width{std::move(w)}, digits{std::move(d)}, exponentWidth{
                                                                std::move(e)} {}
  Kind kind;
  std::optional<int> width;
  std::optional<int> digits;
  std::optional<int> exponentWidth;
};




struct DerivedTypeDataEditDesc {
  DerivedTypeDataEditDesc() = delete;
  DerivedTypeDataEditDesc(DerivedTypeDataEditDesc &&) = default;
  DerivedTypeDataEditDesc &operator=(DerivedTypeDataEditDesc &&) = default;
  DerivedTypeDataEditDesc(std::string &&t, std::list<std::int64_t> &&p)
      : type{std::move(t)}, parameters{std::move(p)} {}
  std::string type;
  std::list<std::int64_t> parameters;
};
# 75 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/format-specification.h"
struct ControlEditDesc {
  enum class Kind {
    T,
    TL,
    TR,
    X,
    Slash,
    Colon,
    SS,
    SP,
    S,
    P,
    BN,
    BZ,
    RU,
    RD,
    RZ,
    RN,
    RC,
    RP,
    DC,
    DP,
    Dollar,
    Backslash,
  };
  ControlEditDesc() = delete;
  ControlEditDesc(ControlEditDesc &&) = default;
  ControlEditDesc &operator=(ControlEditDesc &&) = default;
  explicit ControlEditDesc(Kind k) : kind{k} {}
  ControlEditDesc(Kind k, std::int64_t ct) : kind{k}, count{ct} {}
  ControlEditDesc(std::int64_t ct, Kind k) : kind{k}, count{ct} {}
  Kind kind;
  std::int64_t count{1};
};






struct FormatItem {
  FormatItem() = delete;
  FormatItem(FormatItem &&) = default;
  FormatItem &operator=(FormatItem &&) = default;
  template <typename A, typename = common::NoLvalue<A>>
  FormatItem(std::optional<std::uint64_t> &&r, A &&x)
      : repeatCount{std::move(r)}, u{std::move(x)} {}
  template <typename A, typename = common::NoLvalue<A>>
  explicit FormatItem(A &&x) : u{std::move(x)} {}
  std::optional<std::uint64_t> repeatCount;
  std::variant<IntrinsicTypeDataEditDesc, DerivedTypeDataEditDesc,
      ControlEditDesc, std::string, std::list<FormatItem>>
      u;
};





struct FormatSpecification {
  FormatSpecification() = delete;
  FormatSpecification(FormatSpecification &&) = default;
  FormatSpecification &operator=(FormatSpecification &&) = default;
  explicit FormatSpecification(std::list<FormatItem> &&is)
      : items(std::move(is)) {}
  FormatSpecification(std::list<FormatItem> &&is, std::list<FormatItem> &&us)
      : items(std::move(is)), unlimitedItems(std::move(us)) {}
  std::list<FormatItem> items, unlimitedItems;
};
}
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-set.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-set.h"
namespace Fortran::parser {

struct SetOfChars {
  constexpr SetOfChars() {}

  constexpr SetOfChars(char c) {






    if (c == '\n') {

      c = '^';
    } else if (c < 32 || c >= 127) {

      c = '?';
    } else if (c >= 96) {

      c -= 32;
    }

    bits_ = static_cast<std::uint64_t>(1) << (c - 32);
  }

  constexpr SetOfChars(const char str[], std::size_t n) {
    for (std::size_t j{0}; j < n; ++j) {
      bits_ |= SetOfChars{str[j]}.bits_;
    }
  }

  constexpr SetOfChars(const SetOfChars &) = default;
  constexpr SetOfChars(SetOfChars &&) = default;
  constexpr SetOfChars &operator=(const SetOfChars &) = default;
  constexpr SetOfChars &operator=(SetOfChars &&) = default;
  constexpr bool empty() const { return bits_ == 0; }

  constexpr bool Has(SetOfChars that) const {
    return (that.bits_ & ~bits_) == 0;
  }
  constexpr SetOfChars Union(SetOfChars that) const {
    return SetOfChars{bits_ | that.bits_};
  }
  constexpr SetOfChars Intersection(SetOfChars that) const {
    return SetOfChars{bits_ & that.bits_};
  }
  constexpr SetOfChars Difference(SetOfChars that) const {
    return SetOfChars{bits_ & ~that.bits_};
  }

  std::string ToString() const;

private:
  constexpr SetOfChars(std::uint64_t b) : bits_{b} {}
  std::uint64_t bits_{0};
};
}
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 1
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-buffer.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-buffer.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 1 3
# 275 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 1 3
# 19 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 23 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__bit_reference" 2 3


namespace std { inline namespace __1 {

template <class _Cp, bool _IsConst, typename _Cp::__storage_type = 0> class __bit_iterator;
template <class _Cp> class __bit_const_reference;

template <class _Tp>
struct __has_storage_type
{
    static const bool value = false;
};

template <class _Cp, bool = __has_storage_type<_Cp>::value>
class __bit_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;

    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, false>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference(const __bit_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool operator ~() const noexcept
        {return !static_cast<bool>(*this);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference& operator=(bool __x) noexcept
    {
        if (__x)
            *__seg_ |= __mask_;
        else
            *__seg_ &= ~__mask_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference& operator=(const __bit_reference& __x) noexcept
        {return operator=(static_cast<bool>(__x));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void flip() noexcept {*__seg_ ^= __mask_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator<_Cp, false> operator&() const noexcept
        {return __bit_iterator<_Cp, false>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}
};

template <class _Cp>
class __bit_reference<_Cp, false>
{
};

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp, class _Dp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, __bit_reference<_Dp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__bit_reference<_Cp> __x, bool& __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(bool& __x, __bit_reference<_Cp> __y) noexcept
{
    bool __t = __x;
    __x = __y;
    __y = __t;
}

template <class _Cp>
class __bit_const_reference
{
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__const_storage_pointer __storage_pointer;

    __storage_pointer __seg_;
    __storage_type __mask_;

    friend typename _Cp::__self;
    friend class __bit_iterator<_Cp, true>;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_const_reference(const __bit_const_reference&) = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_const_reference(const __bit_reference<_Cp>& __x) noexcept
        : __seg_(__x.__seg_), __mask_(__x.__mask_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr operator bool() const noexcept
        {return static_cast<bool>(*__seg_ & __mask_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator<_Cp, true> operator&() const noexcept
        {return __bit_iterator<_Cp, true>(__seg_, static_cast<unsigned>(__libcpp_ctz(__mask_)));}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr
    __bit_const_reference(__storage_pointer __s, __storage_type __m) noexcept
        : __seg_(__s), __mask_(__m) {}

    __bit_const_reference& operator=(const __bit_const_reference&) = delete;
};



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        if (*__first.__seg_)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(*__first.__seg_)));

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, _IsConst>
__find_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
        if (__n == __dn)
            return __first + __n;
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
    {
        __storage_type __b = ~*__first.__seg_;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = ~*__first.__seg_ & __m;
        if (__b)
            return _It(__first.__seg_, static_cast<unsigned>(std::__1::__libcpp_ctz(__b)));
    }
    return _It(__first.__seg_, static_cast<unsigned>(__n));
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, _IsConst>
find(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__find_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__find_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_true(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst>
typename __bit_iterator<_Cp, _IsConst>::difference_type
__count_bool_false(__bit_iterator<_Cp, _IsConst> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, _IsConst> _It;
    typedef typename _It::__storage_type __storage_type;
    typedef typename _It::difference_type difference_type;
    const int __bits_per_word = _It::__bits_per_word;
    difference_type __r = 0;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        __r = std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
        __n -= __dn;
        ++__first.__seg_;
    }

    for (; __n >= __bits_per_word; ++__first.__seg_, __n -= __bits_per_word)
        __r += std::__1::__libcpp_popcount(~*__first.__seg_);

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __r += std::__1::__libcpp_popcount(~*__first.__seg_ & __m);
    }
    return __r;
}

template <class _Cp, bool _IsConst, class _Tp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __bit_iterator<_Cp, _IsConst>::difference_type
count(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, const _Tp& __value_)
{
    if (static_cast<bool>(__value_))
        return std::__1::__count_bool_true(__first, static_cast<typename _Cp::size_type>(__last - __first));
    return std::__1::__count_bool_false(__first, static_cast<typename _Cp::size_type>(__last - __first));
}



template <class _Cp>
void
__fill_n_false(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ &= ~__m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), 0, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ &= ~__m;
    }
}

template <class _Cp>
void
__fill_n_true(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n)
{
    typedef __bit_iterator<_Cp, false> _It;
    typedef typename _It::__storage_type __storage_type;
    const int __bits_per_word = _It::__bits_per_word;

    if (__first.__ctz_ != 0)
    {
        __storage_type __clz_f = static_cast<__storage_type>(__bits_per_word - __first.__ctz_);
        __storage_type __dn = std::__1::min(__clz_f, __n);
        __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
        *__first.__seg_ |= __m;
        __n -= __dn;
        ++__first.__seg_;
    }

    __storage_type __nw = __n / __bits_per_word;
    std::__1::memset(std::__1::__to_address(__first.__seg_), -1, __nw * sizeof(__storage_type));
    __n -= __nw * __bits_per_word;

    if (__n > 0)
    {
        __first.__seg_ += __nw;
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        *__first.__seg_ |= __m;
    }
}

template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
fill_n(__bit_iterator<_Cp, false> __first, typename _Cp::size_type __n, bool __value_)
{
    if (__n > 0)
    {
        if (__value_)
            std::__1::__fill_n_true(__first, __n);
        else
            std::__1::__fill_n_false(__first, __n);
    }
}



template <class _Cp>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
fill(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __last, bool __value_)
{
    std::__1::fill_n(__first, static_cast<typename _Cp::size_type>(__last - __first), __value_);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        __storage_type __nw = __n / __bits_per_word;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__first.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;
        __result.__seg_ += __nw;

        if (__n > 0)
        {
            __first.__seg_ += __nw;
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    static const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
                *__result.__seg_ |= __b << (__result.__ctz_ - __first.__ctz_);
            else
                *__result.__seg_ |= __b >> (__first.__ctz_ - __result.__ctz_);
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> (__first.__ctz_ + __ddn);
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b = *__first.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            ++__result.__seg_;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b >> __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b << __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b >> __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
copy(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__first.__ctz_ == __result.__ctz_)
        return std::__1::__copy_aligned(__first, __last, __result);
    return std::__1::__copy_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_aligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                     __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz);
            __storage_type __b = *__last.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                       __result.__ctz_) % __bits_per_word);

         }



        __storage_type __nw = __n / __bits_per_word;
        __result.__seg_ -= __nw;
        __last.__seg_ -= __nw;
        std::__1::memmove(std::__1::__to_address(__result.__seg_),
                       std::__1::__to_address(__last.__seg_),
                       __nw * sizeof(__storage_type));
        __n -= __nw * __bits_per_word;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            *--__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b;
            __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
__bit_iterator<_Cp, false>
__copy_backward_unaligned(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last,
                                                       __bit_iterator<_Cp, false> __result)
{
    typedef __bit_iterator<_Cp, _IsConst> _In;
    typedef typename _In::difference_type difference_type;
    typedef typename _In::__storage_type __storage_type;
    const int __bits_per_word = _In::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__last.__ctz_ != 0)
        {
            difference_type __dn = std::__1::min(static_cast<difference_type>(__last.__ctz_), __n);
            __n -= __dn;
            unsigned __clz_l = __bits_per_word - __last.__ctz_;
            __storage_type __m = (~__storage_type(0) << (__last.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_l);
            __storage_type __b = *__last.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min(__dn, static_cast<difference_type>(__result.__ctz_));
            if (__ddn > 0)
            {
                __m = (~__storage_type(0) << (__result.__ctz_ - __ddn)) & (~__storage_type(0) >> __clz_r);
                *__result.__seg_ &= ~__m;
                if (__result.__ctz_ > __last.__ctz_)
                    *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
                else
                    *__result.__seg_ |= __b >> (__last.__ctz_ - __result.__ctz_);
                __result.__ctz_ = static_cast<unsigned>(((-__ddn & (__bits_per_word - 1)) +
                                                         __result.__ctz_) % __bits_per_word);
                __dn -= __ddn;
            }
            if (__dn > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__dn & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                __last.__ctz_ -= __dn + __ddn;
                *__result.__seg_ |= __b << (__result.__ctz_ - __last.__ctz_);
            }

         }



        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        __storage_type __m = ~__storage_type(0) >> __clz_r;
        for (; __n >= __bits_per_word; __n -= __bits_per_word)
        {
            __storage_type __b = *--__last.__seg_;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> __clz_r;
            *--__result.__seg_ &= __m;
            *__result.__seg_ |= __b << __result.__ctz_;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) << (__bits_per_word - __n);
            __storage_type __b = *--__last.__seg_ & __m;
            __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__result.__ctz_));
            __m = (~__storage_type(0) << (__result.__ctz_ - __dn)) & (~__storage_type(0) >> __clz_r);
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b >> (__bits_per_word - __result.__ctz_);
            __result.__ctz_ = static_cast<unsigned>(((-__dn & (__bits_per_word - 1)) +
                                                     __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {

                --__result.__seg_;
                __result.__ctz_ = static_cast<unsigned>(-__n & (__bits_per_word - 1));
                __m = ~__storage_type(0) << __result.__ctz_;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b << (__result.__ctz_ - (__bits_per_word - __n - __dn));
            }
        }
    }
    return __result;
}

template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
copy_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    if (__last.__ctz_ == __result.__ctz_)
        return std::__1::__copy_backward_aligned(__first, __last, __result);
    return std::__1::__copy_backward_unaligned(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
move(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy(__first, __last, __result);
}



template <class _Cp, bool _IsConst>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<_Cp, false>
move_backward(__bit_iterator<_Cp, _IsConst> __first, __bit_iterator<_Cp, _IsConst> __last, __bit_iterator<_Cp, false> __result)
{
    return std::__1::copy_backward(__first, __last, __result);
}



template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_aligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                      __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            ++__first.__seg_;

        }


        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_, ++__result.__seg_)
            swap(*__first.__seg_, *__result.__seg_);

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1;
            *__first.__seg_ |= __b2;
            __result.__ctz_ = static_cast<unsigned>(__n);
        }
    }
    return __result;
}

template <class __C1, class __C2>
__bit_iterator<__C2, false>
__swap_ranges_unaligned(__bit_iterator<__C1, false> __first, __bit_iterator<__C1, false> __last,
                        __bit_iterator<__C2, false> __result)
{
    typedef __bit_iterator<__C1, false> _I1;
    typedef typename _I1::difference_type difference_type;
    typedef typename _I1::__storage_type __storage_type;
    const int __bits_per_word = _I1::__bits_per_word;
    difference_type __n = __last - __first;
    if (__n > 0)
    {

        if (__first.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            unsigned __clz_r = __bits_per_word - __result.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            if (__result.__ctz_ > __first.__ctz_)
            {
                unsigned __s = __result.__ctz_ - __first.__ctz_;
                *__result.__seg_ |= __b1 << __s;
                *__first.__seg_ |= __b2 >> __s;
            }
            else
            {
                unsigned __s = __first.__ctz_ - __result.__ctz_;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
            }
            __result.__seg_ += (__ddn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__ddn + __result.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                unsigned __s = __first.__ctz_ + __ddn;
                *__result.__seg_ |= __b1 >> __s;
                *__first.__seg_ |= __b2 << __s;
                __result.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first.__seg_;

        }


        __storage_type __m = ~__storage_type(0) << __result.__ctz_;
        unsigned __clz_r = __bits_per_word - __result.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first.__seg_)
        {
            __storage_type __b1 = *__first.__seg_;
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ = __b2 >> __result.__ctz_;
            ++__result.__seg_;
            __b2 = *__result.__seg_ & ~__m;
            *__result.__seg_ &= __m;
            *__result.__seg_ |= __b1 >> __clz_r;
            *__first.__seg_ |= __b2 << __clz_r;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b1 = *__first.__seg_ & __m;
            *__first.__seg_ &= ~__m;
            __storage_type __dn = std::__1::min<__storage_type>(__n, __clz_r);
            __m = (~__storage_type(0) << __result.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            __storage_type __b2 = *__result.__seg_ & __m;
            *__result.__seg_ &= ~__m;
            *__result.__seg_ |= __b1 << __result.__ctz_;
            *__first.__seg_ |= __b2 >> __result.__ctz_;
            __result.__seg_ += (__dn + __result.__ctz_) / __bits_per_word;
            __result.__ctz_ = static_cast<unsigned>((__dn + __result.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                __b2 = *__result.__seg_ & __m;
                *__result.__seg_ &= ~__m;
                *__result.__seg_ |= __b1 >> __dn;
                *__first.__seg_ |= __b2 << __dn;
                __result.__ctz_ = static_cast<unsigned>(__n);
            }
        }
    }
    return __result;
}

template <class __C1, class __C2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__bit_iterator<__C2, false>
swap_ranges(__bit_iterator<__C1, false> __first1, __bit_iterator<__C1, false> __last1,
            __bit_iterator<__C2, false> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__swap_ranges_aligned(__first1, __last1, __first2);
    return std::__1::__swap_ranges_unaligned(__first1, __last1, __first2);
}



template <class _Cp>
struct __bit_array
{
    typedef typename _Cp::difference_type difference_type;
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename _Cp::__storage_pointer __storage_pointer;
    typedef typename _Cp::iterator iterator;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;
    static const unsigned _Np = 4;

    difference_type __size_;
    __storage_type __word_[_Np];

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) static difference_type capacity()
        {return static_cast<difference_type>(_Np * __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit __bit_array(difference_type __s) : __size_(__s) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]), 0);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end()
    {
        return iterator(pointer_traits<__storage_pointer>::pointer_to(__word_[0]) + __size_ / __bits_per_word,
                                                  static_cast<unsigned>(__size_ % __bits_per_word));
    }
};

template <class _Cp>
__bit_iterator<_Cp, false>
rotate(__bit_iterator<_Cp, false> __first, __bit_iterator<_Cp, false> __middle, __bit_iterator<_Cp, false> __last)
{
    typedef __bit_iterator<_Cp, false> _I1;
    typedef typename _I1::difference_type difference_type;
    difference_type __d1 = __middle - __first;
    difference_type __d2 = __last - __middle;
    _I1 __r = __first + __d2;
    while (__d1 != 0 && __d2 != 0)
    {
        if (__d1 <= __d2)
        {
            if (__d1 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d1);
                std::__1::copy(__first, __middle, __b.begin());
                std::__1::copy(__b.begin(), __b.end(), std::__1::copy(__middle, __last, __first));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = std::__1::swap_ranges(__first, __middle, __middle);
                __first = __middle;
                __middle = __mp;
                __d2 -= __d1;
            }
        }
        else
        {
            if (__d2 <= __bit_array<_Cp>::capacity())
            {
                __bit_array<_Cp> __b(__d2);
                std::__1::copy(__middle, __last, __b.begin());
                std::__1::copy_backward(__b.begin(), __b.end(), std::__1::copy_backward(__first, __middle, __last));
                break;
            }
            else
            {
                __bit_iterator<_Cp, false> __mp = __first + __d2;
                std::__1::swap_ranges(__first, __mp, __middle);
                __first = __mp;
                __d1 -= __d2;
            }
        }
    }
    return __r;
}



template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_unaligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                  __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz_f = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz_f), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz_f - __dn));
            __storage_type __b = *__first1.__seg_ & __m;
            unsigned __clz_r = __bits_per_word - __first2.__ctz_;
            __storage_type __ddn = std::__1::min<__storage_type>(__dn, __clz_r);
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __ddn));
            if (__first2.__ctz_ > __first1.__ctz_)
            {
                if ((*__first2.__seg_ & __m) != (__b << (__first2.__ctz_ - __first1.__ctz_)))
                    return false;
            }
            else
            {
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ - __first2.__ctz_)))
                    return false;
            }
            __first2.__seg_ += (__ddn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__ddn + __first2.__ctz_) % __bits_per_word);
            __dn -= __ddn;
            if (__dn > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __dn);
                if ((*__first2.__seg_ & __m) != (__b >> (__first1.__ctz_ + __ddn)))
                    return false;
                __first2.__ctz_ = static_cast<unsigned>(__dn);
            }
            ++__first1.__seg_;

        }


        unsigned __clz_r = __bits_per_word - __first2.__ctz_;
        __storage_type __m = ~__storage_type(0) << __first2.__ctz_;
        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_)
        {
            __storage_type __b = *__first1.__seg_;
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            ++__first2.__seg_;
            if ((*__first2.__seg_ & ~__m) != (__b >> __clz_r))
                return false;
        }

        if (__n > 0)
        {
            __m = ~__storage_type(0) >> (__bits_per_word - __n);
            __storage_type __b = *__first1.__seg_ & __m;
            __storage_type __dn = std::__1::min(__n, static_cast<difference_type>(__clz_r));
            __m = (~__storage_type(0) << __first2.__ctz_) & (~__storage_type(0) >> (__clz_r - __dn));
            if ((*__first2.__seg_ & __m) != (__b << __first2.__ctz_))
                return false;
            __first2.__seg_ += (__dn + __first2.__ctz_) / __bits_per_word;
            __first2.__ctz_ = static_cast<unsigned>((__dn + __first2.__ctz_) % __bits_per_word);
            __n -= __dn;
            if (__n > 0)
            {
                __m = ~__storage_type(0) >> (__bits_per_word - __n);
                if ((*__first2.__seg_ & __m) != (__b >> __dn))
                    return false;
            }
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
bool
__equal_aligned(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1,
                __bit_iterator<_Cp, _IC2> __first2)
{
    typedef __bit_iterator<_Cp, _IC1> _It;
    typedef typename _It::difference_type difference_type;
    typedef typename _It::__storage_type __storage_type;
    static const int __bits_per_word = _It::__bits_per_word;
    difference_type __n = __last1 - __first1;
    if (__n > 0)
    {

        if (__first1.__ctz_ != 0)
        {
            unsigned __clz = __bits_per_word - __first1.__ctz_;
            difference_type __dn = std::__1::min(static_cast<difference_type>(__clz), __n);
            __n -= __dn;
            __storage_type __m = (~__storage_type(0) << __first1.__ctz_) & (~__storage_type(0) >> (__clz - __dn));
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
            ++__first2.__seg_;
            ++__first1.__seg_;


        }



        for (; __n >= __bits_per_word; __n -= __bits_per_word, ++__first1.__seg_, ++__first2.__seg_)
            if (*__first2.__seg_ != *__first1.__seg_)
                return false;

        if (__n > 0)
        {
            __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
            if ((*__first2.__seg_ & __m) != (*__first1.__seg_ & __m))
                return false;
        }
    }
    return true;
}

template <class _Cp, bool _IC1, bool _IC2>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
equal(__bit_iterator<_Cp, _IC1> __first1, __bit_iterator<_Cp, _IC1> __last1, __bit_iterator<_Cp, _IC2> __first2)
{
    if (__first1.__ctz_ == __first2.__ctz_)
        return std::__1::__equal_aligned(__first1, __last1, __first2);
    return std::__1::__equal_unaligned(__first1, __last1, __first2);
}

template <class _Cp, bool _IsConst,
          typename _Cp::__storage_type>
class __bit_iterator
{
public:
    typedef typename _Cp::difference_type difference_type;
    typedef bool value_type;
    typedef __bit_iterator pointer;
    typedef typename conditional<_IsConst, __bit_const_reference<_Cp>, __bit_reference<_Cp> >::type reference;
    typedef random_access_iterator_tag iterator_category;

private:
    typedef typename _Cp::__storage_type __storage_type;
    typedef typename conditional<_IsConst, typename _Cp::__const_storage_pointer,
                                           typename _Cp::__storage_pointer>::type __storage_pointer;
    static const unsigned __bits_per_word = _Cp::__bits_per_word;

    __storage_pointer __seg_;
    unsigned __ctz_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator() noexcept

    : __seg_(nullptr), __ctz_(0)

    {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator(const __bit_iterator<_Cp, false>& __it) noexcept
        : __seg_(__it.__seg_), __ctz_(__it.__ctz_) {}






    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator& operator=(const _If<_IsConst, struct __private_nat, __bit_iterator>& __it) {
        __seg_ = __it.__seg_;
        __ctz_ = __it.__ctz_;
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const noexcept
        {return reference(__seg_, __storage_type(1) << __ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator++()
    {
        if (__ctz_ != __bits_per_word-1)
            ++__ctz_;
        else
        {
            __ctz_ = 0;
            ++__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator++(int)
    {
        __bit_iterator __tmp = *this;
        ++(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator--()
    {
        if (__ctz_ != 0)
            --__ctz_;
        else
        {
            __ctz_ = __bits_per_word - 1;
            --__seg_;
        }
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator--(int)
    {
        __bit_iterator __tmp = *this;
        --(*this);
        return __tmp;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator+=(difference_type __n)
    {
        if (__n >= 0)
            __seg_ += (__n + __ctz_) / __bits_per_word;
        else
            __seg_ += static_cast<difference_type>(__n - __bits_per_word + __ctz_ + 1)
                    / static_cast<difference_type>(__bits_per_word);
        __n &= (__bits_per_word - 1);
        __ctz_ = static_cast<unsigned>((__n + __ctz_) % __bits_per_word);
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator& operator-=(difference_type __n)
    {
        return *this += -__n;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator+(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t += __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __bit_iterator operator-(difference_type __n) const
    {
        __bit_iterator __t(*this);
        __t -= __n;
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend __bit_iterator operator+(difference_type __n, const __bit_iterator& __it) {return __it + __n;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend difference_type operator-(const __bit_iterator& __x, const __bit_iterator& __y)
        {return (__x.__seg_ - __y.__seg_) * __bits_per_word + __x.__ctz_ - __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](difference_type __n) const {return *(*this + __n);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator==(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ == __y.__seg_ && __x.__ctz_ == __y.__ctz_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator!=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x == __y);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator<(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __x.__seg_ < __y.__seg_ || (__x.__seg_ == __y.__seg_ && __x.__ctz_ < __y.__ctz_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator>(const __bit_iterator& __x, const __bit_iterator& __y)
        {return __y < __x;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator<=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__y < __x);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) friend bool operator>=(const __bit_iterator& __x, const __bit_iterator& __y)
        {return !(__x < __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __bit_iterator(__storage_pointer __s, unsigned __ctz) noexcept
        : __seg_(__s), __ctz_(__ctz) {}

    friend typename _Cp::__self;

    friend class __bit_reference<_Cp>;
    friend class __bit_const_reference<_Cp>;
    friend class __bit_iterator<_Cp, true>;
    template <class _Dp> friend struct __bit_array;
    template <class _Dp> friend void __fill_n_false(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp> friend void __fill_n_true(__bit_iterator<_Dp, false> __first, typename _Dp::size_type __n);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                  __bit_iterator<_Dp, _IC> __last,
                                                                                  __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                    __bit_iterator<_Dp, _IC> __last,
                                                                                    __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy(__bit_iterator<_Dp, _IC> __first,
                                                                        __bit_iterator<_Dp, _IC> __last,
                                                                        __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_aligned(__bit_iterator<_Dp, _IC> __first,
                                                                                           __bit_iterator<_Dp, _IC> __last,
                                                                                           __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> __copy_backward_unaligned(__bit_iterator<_Dp, _IC> __first,
                                                                                             __bit_iterator<_Dp, _IC> __last,
                                                                                             __bit_iterator<_Dp, false> __result);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, false> copy_backward(__bit_iterator<_Dp, _IC> __first,
                                                                                 __bit_iterator<_Dp, _IC> __last,
                                                                                 __bit_iterator<_Dp, false> __result);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_aligned(__bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C1, false>,
                                                                                           __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> __swap_ranges_unaligned(__bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C1, false>,
                                                                                             __bit_iterator<__C2, false>);
    template <class __C1, class __C2>friend __bit_iterator<__C2, false> swap_ranges(__bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C1, false>,
                                                                                 __bit_iterator<__C2, false>);
    template <class _Dp> friend __bit_iterator<_Dp, false> rotate(__bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>,
                                                                __bit_iterator<_Dp, false>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_aligned(__bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC1>,
                                                    __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool __equal_unaligned(__bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC1>,
                                                      __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC1, bool _IC2> friend bool equal(__bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC1>,
                                                                __bit_iterator<_Dp, _IC2>);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_true(__bit_iterator<_Dp, _IC>,
                                                                          typename _Dp::size_type);
    template <class _Dp, bool _IC> friend __bit_iterator<_Dp, _IC> __find_bool_false(__bit_iterator<_Dp, _IC>,
                                                                           typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_true(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
    template <class _Dp, bool _IC> friend typename __bit_iterator<_Dp, _IC>::difference_type
                   __count_bool_false(__bit_iterator<_Dp, _IC>, typename _Dp::size_type);
};

} }
# 276 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 1 3







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 9 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 2 3
# 12 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 16 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__split_buffer" 2 3


namespace std { inline namespace __1 {

template <bool>
class __split_buffer_common
{
protected:
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <class _Tp, class _Allocator = allocator<_Tp> >
struct __split_buffer
    : private __split_buffer_common<true>
{
private:
    __split_buffer(const __split_buffer&);
    __split_buffer& operator=(const __split_buffer&);
public:
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename remove_reference<allocator_type>::type __alloc_rr;
    typedef allocator_traits<__alloc_rr> __alloc_traits;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __first_;
    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;
    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __alloc_rr& __alloc() noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const __alloc_rr& __alloc() const noexcept {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer& __end_cap() noexcept {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const pointer& __end_cap() const noexcept {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __split_buffer()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __split_buffer(__alloc_rr& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __split_buffer(const __alloc_rr& __a);
    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);
    ~__split_buffer();

    __split_buffer(__split_buffer&& __c)
        noexcept(is_nothrow_move_constructible<allocator_type>::value);
    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);
    __split_buffer& operator=(__split_buffer&& __c)
        noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin() noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator begin() const noexcept {return __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end() noexcept {return __end_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator end() const noexcept {return __end_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
        {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type size() const {return static_cast<size_type>(__end_ - __begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool empty() const {return __end_ == __begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const {return *__begin_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() {return *(__end_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const {return *(__end_ - 1);}

    void reserve(size_type __n);
    void shrink_to_fit() noexcept;
    void push_front(const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(const_reference __x);
    void push_front(value_type&& __x);
    void push_back(value_type&& __x);
    template <class... _Args>
        void emplace_back(_Args&&... __args);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_front() {__destruct_at_begin(__begin_+1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_back() {__destruct_at_end(__end_-1);}

    void __construct_at_end(size_type __n);
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _InputIter>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIter>::value &&
           !__is_cpp17_forward_iterator<_InputIter>::value,
            void
        >::type
        __construct_at_end(_InputIter __first, _InputIter __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __destruct_at_begin(pointer __new_begin)
        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, false_type);
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_begin(pointer __new_begin, true_type);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept
        {__destruct_at_end(__new_last, false_type());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, false_type) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void __destruct_at_end(pointer __new_last, true_type) noexcept;

    void swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value);


    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__split_buffer&, false_type) noexcept
        {}

    struct _ConstructTransaction {
      explicit _ConstructTransaction(pointer* __p, size_type __n) noexcept
      : __pos_(*__p), __end_(*__p + __n), __dest_(__p) {
      }
      ~_ConstructTransaction() {
        *__dest_ = __pos_;
      }
      pointer __pos_;
     const pointer __end_;
    private:
     pointer *__dest_;
    };
};

template <class _Tp, class _Allocator>
bool
__split_buffer<_Tp, _Allocator>::__invariants() const
{
    if (__first_ == nullptr)
    {
        if (__begin_ != nullptr)
            return false;
        if (__end_ != nullptr)
            return false;
        if (__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (__begin_ < __first_)
            return false;
        if (__end_ < __begin_)
            return false;
        if (__end_cap() < __end_)
            return false;
    }
    return true;
}






template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_));
    }
}







template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(&this->__end_, __n);
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIter>
typename enable_if
<
     __is_cpp17_input_iterator<_InputIter>::value &&
    !__is_cpp17_forward_iterator<_InputIter>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)
{
    __alloc_rr& __a = this->__alloc();
    for (; __first != __last; ++__first)
    {
        if (__end_ == __end_cap())
        {
            size_type __old_cap = __end_cap() - __first_;
            size_type __new_cap = std::__1::max<size_type>(2 * __old_cap, 8);
            __split_buffer __buf(__new_cap, 0, __a);
            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)
                __alloc_traits::construct(__buf.__alloc(),
                        std::__1::__to_address(__buf.__end_), std::__1::move(*__p));
            swap(__buf);
        }
        __alloc_traits::construct(__a, std::__1::__to_address(this->__end_), *__first);
        ++this->__end_;
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    _ConstructTransaction __tx(&this->__end_, std::__1::distance(__first, __last));
    for (; __tx.__pos_ != __tx.__end_; ++__tx.__pos_, ++__first) {
        __alloc_traits::construct(this->__alloc(),
            std::__1::__to_address(__tx.__pos_), *__first);
    }
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)
{
    while (__begin_ != __new_begin)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(__begin_++));
}

template <class _Tp, class _Allocator>
inline
void
__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)
{
    __begin_ = __new_begin;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) noexcept
{
    while (__new_last != __end_)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__end_));
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) noexcept
{
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;
    __begin_ = __end_ = __first_ + __start;
    __end_cap() = __first_ + __cap;
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
inline
__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)
    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)
{
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::~__split_buffer()
{
    clear();
    if (__first_)
        __alloc_traits::deallocate(__alloc(), __first_, capacity());
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)
    noexcept(is_nothrow_move_constructible<allocator_type>::value)
    : __first_(std::__1::move(__c.__first_)),
      __begin_(std::__1::move(__c.__begin_)),
      __end_(std::__1::move(__c.__end_)),
      __end_cap_(std::__1::move(__c.__end_cap_))
{
    __c.__first_ = nullptr;
    __c.__begin_ = nullptr;
    __c.__end_ = nullptr;
    __c.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)
    : __end_cap_(nullptr, __a)
{
    if (__a == __c.__alloc())
    {
        __first_ = __c.__first_;
        __begin_ = __c.__begin_;
        __end_ = __c.__end_;
        __end_cap() = __c.__end_cap();
        __c.__first_ = nullptr;
        __c.__begin_ = nullptr;
        __c.__end_ = nullptr;
        __c.__end_cap() = nullptr;
    }
    else
    {
        size_type __cap = __c.size();
        __first_ = __alloc_traits::allocate(__alloc(), __cap);
        __begin_ = __end_ = __first_;
        __end_cap() = __first_ + __cap;
        typedef move_iterator<iterator> _Ip;
        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));
    }
}

template <class _Tp, class _Allocator>
__split_buffer<_Tp, _Allocator>&
__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)
    noexcept((__alloc_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value) || !__alloc_traits::propagate_on_container_move_assignment::value)


{
    clear();
    shrink_to_fit();
    __first_ = __c.__first_;
    __begin_ = __c.__begin_;
    __end_ = __c.__end_;
    __end_cap() = __c.__end_cap();
    __move_assign_alloc(__c,
        integral_constant<bool,
                          __alloc_traits::propagate_on_container_move_assignment::value>());
    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;
    return *this;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)
        noexcept(!__alloc_traits::propagate_on_container_swap::value|| __is_nothrow_swappable<__alloc_rr>::value)

{
    std::__1::swap(__first_, __x.__first_);
    std::__1::swap(__begin_, __x.__begin_);
    std::__1::swap(__end_, __x.__end_);
    std::__1::swap(__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(__alloc(), __x.__alloc());
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n < capacity())
    {
        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());
        __t.__construct_at_end(move_iterator<pointer>(__begin_),
                               move_iterator<pointer>(__end_));
        std::__1::swap(__first_, __t.__first_);
        std::__1::swap(__begin_, __t.__begin_);
        std::__1::swap(__end_, __t.__end_);
        std::__1::swap(__end_cap(), __t.__end_cap());
    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            __t.__end_ = __t.__begin_ + (__end_ - __begin_);
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1), __x);
    --__begin_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)
{
    if (__begin_ == __first_)
    {
        if (__end_ < __end_cap())
        {
            difference_type __d = __end_cap() - __end_;
            __d = (__d + 1) / 2;
            __begin_ = std::__1::move_backward(__begin_, __end_, __end_ + __d);
            __end_ += __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__begin_-1),
            std::__1::move(__x));
    --__begin_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_), __x);
    ++__end_;
}

template <class _Tp, class _Allocator>
void
__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
            std::__1::move(__x));
    ++__end_;
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (__end_ == __end_cap())
    {
        if (__begin_ > __first_)
        {
            difference_type __d = __begin_ - __first_;
            __d = (__d + 1) / 2;
            __end_ = std::__1::move(__begin_, __end_, __begin_ - __d);
            __begin_ -= __d;
        }
        else
        {
            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);
            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());
            __t.__construct_at_end(move_iterator<pointer>(__begin_),
                                   move_iterator<pointer>(__end_));
            std::__1::swap(__first_, __t.__first_);
            std::__1::swap(__begin_, __t.__begin_);
            std::__1::swap(__end_, __t.__end_);
            std::__1::swap(__end_cap(), __t.__end_cap());
        }
    }
    __alloc_traits::construct(__alloc(), std::__1::__to_address(__end_),
                              std::__1::forward<_Args>(__args)...);
    ++__end_;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)
        noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 280 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 289 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 290 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 292 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3
# 296 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 300 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 2 3


namespace std { inline namespace __1 {

template <bool>
class __attribute__ ((__type_visibility__("default"))) __vector_base_common
{
protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base_common() {}
    [[noreturn]] void __throw_length_error() const;
    [[noreturn]] void __throw_out_of_range() const;
};

template <bool __b>
void
__vector_base_common<__b>::__throw_length_error() const
{
    std::__1::__throw_length_error("vector");
}

template <bool __b>
void
__vector_base_common<__b>::__throw_out_of_range() const
{
    std::__1::__throw_out_of_range("vector");
}

extern template class __attribute__ ((__visibility__("default"))) __vector_base_common<true>;

template <class _Tp, class _Allocator>
class __vector_base
    : protected __vector_base_common<true>
{
public:
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
protected:
    typedef _Tp value_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;

    pointer __begin_;
    pointer __end_;
    __compressed_pair<pointer, allocator_type> __end_cap_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type& __alloc() noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const allocator_type& __alloc() const noexcept
        {return __end_cap_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer& __end_cap() noexcept
        {return __end_cap_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const pointer& __end_cap() const noexcept
        {return __end_cap_.first();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __vector_base(allocator_type&& __a) noexcept;

    ~__vector_base();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__destruct_at_end(__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return static_cast<size_type>(__end_cap() - __begin_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c)
        {__copy_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c)
        noexcept(!__alloc_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __alloc_traits::propagate_on_container_move_assignment::value>());}

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_length_error() const {

        __vector_base_common<true>::__throw_length_error();



    }

    [[noreturn]] __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __throw_out_of_range() const {

        __vector_base_common<true>::__throw_out_of_range();



    }

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
            {
                clear();
                __alloc_traits::deallocate(__alloc(), __begin_, capacity());
                __begin_ = __end_ = __end_cap() = nullptr;
            }
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __vector_base&, false_type)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__vector_base&, false_type)
        noexcept
        {}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) noexcept
{
    pointer __soon_to_be_end = __end_;
    while (__new_last != __soon_to_be_end)
        __alloc_traits::destroy(__alloc(), std::__1::__to_address(--__soon_to_be_end));
    __end_ = __new_last;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base()
        noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __default_init_tag())
{
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, __a)
{
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
__vector_base<_Tp, _Allocator>::__vector_base(allocator_type&& __a) noexcept
    : __begin_(nullptr),
      __end_(nullptr),
      __end_cap_(nullptr, std::__1::move(__a)) {}


template <class _Tp, class _Allocator>
__vector_base<_Tp, _Allocator>::~__vector_base()
{
    if (__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(__alloc(), __begin_, capacity());
    }
}

template <class _Tp, class _Allocator >
class __attribute__ ((__type_visibility__("default"))) vector
    : private __vector_base<_Tp, _Allocator>
{
private:
    typedef __vector_base<_Tp, _Allocator> __base;
    typedef allocator<_Tp> __default_allocator_type;
public:
    typedef vector __self;
    typedef _Tp value_type;
    typedef _Allocator allocator_type;
    typedef typename __base::__alloc_traits __alloc_traits;
    typedef typename __base::reference reference;
    typedef typename __base::const_reference const_reference;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef __wrap_iter<pointer> iterator;
    typedef __wrap_iter<const_pointer> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value)
        {



        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit vector(const allocator_type& __a)



        noexcept

        : __base(__a)
    {



    }
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __x);
    vector(size_type __n, const value_type& __x, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value,
                                 _InputIterator>::type __last);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value,
                                 _ForwardIterator>::type __last);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                 is_constructible<
                                    value_type,
                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~vector()
    {
        __annotate_delete();



    }

    vector(const vector& __x);
    vector(const vector& __x, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(const vector& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x)

        noexcept;




    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __x, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(vector&& __x)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const_reference __u);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return this->__alloc();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator begin() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator begin() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator end() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator end() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept
        {return static_cast<size_type>(this->__end_ - this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return __base::capacity();}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return this->__begin_ == this->__end_;}
    size_type max_size() const noexcept;
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __n) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __n) const noexcept;
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const noexcept
    {
        ((void)0);
        return *this->__begin_;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const noexcept
    {
        ((void)0);
        return *(this->__end_ - 1);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type* data() noexcept
        {return std::__1::__to_address(this->__begin_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type* data() const noexcept
        {return std::__1::__to_address(this->__begin_);}





    template <class _Arg>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __emplace_back(_Arg&& __arg) {
      emplace_back(std::__1::forward<_Arg>(__arg));
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(const_reference __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void push_back(value_type&& __x);

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))

        reference emplace_back(_Args&&... __args);





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void pop_back();

    iterator insert(const_iterator __position, const_reference __x);


    iterator insert(const_iterator __position, value_type&& __x);
    template <class... _Args>
        iterator emplace(const_iterator __position, _Args&&... __args);


    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_InputIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value &&
            is_constructible<
                 value_type,
                 typename iterator_traits<_ForwardIterator>::reference>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        size_type __old_size = size();
        __base::clear();
        __annotate_shrink(__old_size);
        __invalidate_all_iterators();
    }

    void resize(size_type __sz);
    void resize(size_type __sz, const_reference __x);

    void swap(vector&)

        noexcept;





    bool __invariants() const;
# 823 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_all_iterators();
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_iterators_past(pointer __new_last);
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __recommend(size_type __new_size) const;
    void __construct_at_end(size_type __n);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __construct_at_end(size_type __n, const_reference __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n);
    void __append(size_type __n);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __make_iter(pointer __p) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator __make_iter(const_pointer __p) const noexcept;
    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);
    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);
    void __move_range(pointer __from_s, pointer __from_e, pointer __to);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(vector& __c, false_type)
        noexcept(__alloc_traits::is_always_equal::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destruct_at_end(pointer __new_last) noexcept
    {
        __invalidate_iterators_past(__new_last);
        size_type __old_size = size();
        __base::__destruct_at_end(__new_last);
        __annotate_shrink(__old_size);
    }


    template <class _Up>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inline void __push_back_slow_path(_Up&& __x);

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    inline void __emplace_back_slow_path(_Args&&... __args);
# 889 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_contiguous_container(const void*, const void*, const void*,
                                         const void*) const noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_new(size_type __current_size) const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + capacity(), data() + __current_size);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_delete() const noexcept {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + capacity());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_increase(size_type __n) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + size(), data() + size() + __n);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __annotate_shrink(size_type __old_size) const noexcept
    {
      __annotate_contiguous_container(data(), data() + capacity(),
                                      data() + __old_size, data() + size());
    }

  struct _ConstructTransaction {
    explicit _ConstructTransaction(vector &__v, size_type __n)
      : __v_(__v), __pos_(__v.__end_), __new_end_(__v.__end_ + __n) {



    }
    ~_ConstructTransaction() {
      __v_.__end_ = __pos_;





    }

    vector &__v_;
    pointer __pos_;
    const_pointer const __new_end_;

  private:
    _ConstructTransaction(_ConstructTransaction const&) = delete;
    _ConstructTransaction& operator=(_ConstructTransaction const&) = delete;
  };

  template <class ..._Args>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  void __construct_one_at_end(_Args&& ...__args) {
    _ConstructTransaction __tx(*this, 1);
    __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__tx.__pos_),
        std::__1::forward<_Args>(__args)...);
    ++__tx.__pos_;
  }
};


template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
vector(_InputIterator, _InputIterator, _Alloc)
  -> vector<__iter_value_type<_InputIterator>, _Alloc>;


template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)
{

    __annotate_delete();
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::pointer
vector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)
{
    __annotate_delete();
    pointer __r = __v.__begin_;
    std::__1::__construct_backward_with_exception_guarantees(this->__alloc(), this->__begin_, __p, __v.__begin_);
    std::__1::__construct_forward_with_exception_guarantees(this->__alloc(), __p, this->__end_, __v.__end_);
    std::__1::swap(this->__begin_, __v.__begin_);
    std::__1::swap(this->__end_, __v.__end_);
    std::__1::swap(this->__end_cap(), __v.__end_cap());
    __v.__first_ = __v.__begin_;
    __annotate_new(size());
    __invalidate_all_iterators();
    return __r;
}
# 1009 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);
    this->__end_cap() = this->__begin_ + __n;
    __annotate_new(0);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        clear();
        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());
        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;
    }
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::max_size() const noexcept
{
    return std::__1::min<size_type>(__alloc_traits::max_size(this->__alloc()),
                                 numeric_limits<difference_type>::max());
}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::size_type
vector<_Tp, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max<size_type>(2 * __cap, __new_size);
}






template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos));
    }
}







template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)
{
    _ConstructTransaction __tx(*this, __n);
    const_pointer __new_end = __tx.__new_end_;
    for (pointer __pos = __tx.__pos_; __pos != __new_end; ++__pos, __tx.__pos_ = __pos) {
        __alloc_traits::construct(this->__alloc(), std::__1::__to_address(__pos), __x);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last, size_type __n)
{
    _ConstructTransaction __tx(*this, __n);
    std::__1::__construct_range_forward(this->__alloc(), __first, __last, __tx.__pos_);
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n);
        __swap_out_circular_buffer(__v);
    }
}





template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)
{
    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)
        this->__construct_at_end(__n, __x);
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);
        __v.__construct_at_end(__n, __x);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n);
    }
}


template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __base(__a)
{



    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value,
                          _InputIterator>::type __last)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
vector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value &&
                         is_constructible<
                            value_type,
                            typename iterator_traits<_InputIterator>::reference>::value>::type*)
    : __base(__a)
{



    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value,
                                                   _ForwardIterator>::type __last)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
vector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value &&
                                is_constructible<
                                   value_type,
                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)
    : __base(__a)
{



    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x)
    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}

template <class _Tp, class _Allocator>
vector<_Tp, _Allocator>::vector(const vector& __x, const __identity_t<allocator_type>& __a)
    : __base(__a)
{



    size_type __n = __x.size();
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__x.__begin_, __x.__end_, __n);
    }
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(vector&& __x)

        noexcept



    : __base(std::__1::move(__x.__alloc()))
{




    this->__begin_ = __x.__begin_;
    this->__end_ = __x.__end_;
    this->__end_cap() = __x.__end_cap();
    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(vector&& __x, const __identity_t<allocator_type>& __a)
    : __base(__a)
{



    if (__a == __x.__alloc())
    {
        this->__begin_ = __x.__begin_;
        this->__end_ = __x.__end_;
        this->__end_cap() = __x.__end_cap();
        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;



    }
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __base(__a)
{



    if (__il.size() > 0)
    {
        __vallocate(__il.size());
        __construct_at_end(__il.begin(), __il.end(), __il.size());
    }
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(vector&& __x)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__x, integral_constant<bool,
          __alloc_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)
    noexcept(__alloc_traits::is_always_equal::value)
{
    if (__base::__alloc() != __c.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__c.begin()), _Ip(__c.end()));
    }
    else
        __move_assign(__c, true_type());
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __base::__move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__end_ = __c.__end_;
    this->__end_cap() = __c.__end_cap();
    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;



}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<_Tp, _Allocator>&
vector<_Tp, _Allocator>::operator=(const vector& __x)
{
    if (this != &__x)
    {
        __base::__copy_assign_alloc(__x);
        assign(__x.__begin_, __x.__end_);
    }
    return *this;
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        __emplace_back(*__first);
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    void
>::type
vector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __new_size = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__new_size <= capacity())
    {
        _ForwardIterator __mid = __last;
        bool __growing = false;
        if (__new_size > size())
        {
            __growing = true;
            __mid = __first;
            std::__1::advance(__mid, size());
        }
        pointer __m = std::__1::copy(__first, __mid, this->__begin_);
        if (__growing)
            __construct_at_end(__mid, __last, __new_size - size());
        else
            this->__destruct_at_end(__m);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(__new_size));
        __construct_at_end(__first, __last, __new_size);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)
{
    if (__n <= capacity())
    {
        size_type __s = size();
        std::__1::fill_n(this->__begin_, std::__1::min(__n, __s), __u);
        if (__n > __s)
            __construct_at_end(__n - __s, __u);
        else
            this->__destruct_at_end(this->__begin_ + __n);
    }
    else
    {
        __vdeallocate();
        __vallocate(__recommend(static_cast<size_type>(__n)));
        __construct_at_end(__n, __u);
    }
    __invalidate_all_iterators();
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::__make_iter(pointer __p) noexcept
{



    return iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::__make_iter(const_pointer __p) const noexcept
{



    return const_iterator(__p);

}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::begin() noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::begin() const noexcept
{
    return __make_iter(this->__begin_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::end() noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_iterator
vector<_Tp, _Allocator>::end() const noexcept
{
    return __make_iter(this->__end_);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::operator[](size_type __n) noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::operator[](size_type __n) const noexcept
{
    ((void)0);
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::reference
vector<_Tp, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::const_reference
vector<_Tp, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return this->__begin_[__n];
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);
        __swap_out_circular_buffer(__v);
    }
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::shrink_to_fit() noexcept
{
    if (capacity() > size())
    {

        try
        {

            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);
            __swap_out_circular_buffer(__v);

        }
        catch (...)
        {
        }

    }
}

template <class _Tp, class _Allocator>
template <class _Up>
void

vector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)



{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Up>(__x));
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::push_back(const_reference __x)
{
    if (this->__end_ != this->__end_cap())
    {
        __construct_one_at_end(__x);
    }
    else
        __push_back_slow_path(__x);
}



template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::push_back(value_type&& __x)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::move(__x));
    }
    else
        __push_back_slow_path(std::__1::move(__x));
}

template <class _Tp, class _Allocator>
template <class... _Args>
void
vector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)
{
    allocator_type& __a = this->__alloc();
    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);

    __alloc_traits::construct(__a, std::__1::__to_address(__v.__end_), std::__1::forward<_Args>(__args)...);
    __v.__end_++;
    __swap_out_circular_buffer(__v);
}

template <class _Tp, class _Allocator>
template <class... _Args>
inline

typename vector<_Tp, _Allocator>::reference



vector<_Tp, _Allocator>::emplace_back(_Args&&... __args)
{
    if (this->__end_ < this->__end_cap())
    {
        __construct_one_at_end(std::__1::forward<_Args>(__args)...);
    }
    else
        __emplace_back_slow_path(std::__1::forward<_Args>(__args)...);

    return this->back();

}



template <class _Tp, class _Allocator>
inline
void
vector<_Tp, _Allocator>::pop_back()
{
    ((void)0);
    this->__destruct_at_end(this->__end_ - 1);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __position)
{





    ((void)0);

    difference_type __ps = __position - cbegin();
    pointer __p = this->__begin_ + __ps;
    this->__destruct_at_end(std::__1::move(__p + 1, this->__end_, __p));
    this->__invalidate_iterators_past(__p-1);
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
# 1758 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
    ((void)0);
    pointer __p = this->__begin_ + (__first - begin());
    if (__first != __last) {
        this->__destruct_at_end(std::__1::move(__p + (__last - __first), this->__end_, __p));
        this->__invalidate_iterators_past(__p - 1);
    }
    iterator __r = __make_iter(__p);
    return __r;
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)
{
    pointer __old_last = this->__end_;
    difference_type __n = __old_last - __to;
    {
      pointer __i = __from_s + __n;
      _ConstructTransaction __tx(*this, __from_e - __i);
      for (pointer __pos = __tx.__pos_; __i < __from_e;
           ++__i, ++__pos, __tx.__pos_ = __pos) {
          __alloc_traits::construct(this->__alloc(),
                                    std::__1::__to_address(__pos),
                                    std::__1::move(*__i));
      }
    }
    std::__1::move_backward(__from_s, __from_s + __n, __old_last);
}

template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(__x);
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
            if (__p <= __xr && __xr < this->__end_)
                ++__xr;
            *__p = *__xr;
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(__x);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::move(__x));
        }
        else
        {
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__x);
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.push_back(std::__1::move(__x));
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class... _Args>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (this->__end_ < this->__end_cap())
    {
        if (__p == this->__end_)
        {
            __construct_one_at_end(std::__1::forward<_Args>(__args)...);
        }
        else
        {
            __temp_value<value_type, _Allocator> __tmp(this->__alloc(), std::__1::forward<_Args>(__args)...);
            __move_range(__p, this->__end_, __p + 1);
            *__p = std::__1::move(__tmp.get());
        }
    }
    else
    {
        allocator_type& __a = this->__alloc();
        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);
        __v.emplace_back(std::__1::forward<_Args>(__args)...);
        __p = __swap_out_circular_buffer(__v, __p);
    }
    return __make_iter(__p);
}



template <class _Tp, class _Allocator>
typename vector<_Tp, _Allocator>::iterator
vector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)
{





    pointer __p = this->__begin_ + (__position - begin());
    if (__n > 0)
    {
        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            if (__n > static_cast<size_type>(this->__end_ - __p))
            {
                size_type __cx = __n - (this->__end_ - __p);
                __construct_at_end(__cx, __x);
                __n -= __cx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);
                if (__p <= __xr && __xr < this->__end_)
                    __xr += __old_n;
                std::__1::fill_n(__p, __n, *__xr);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__n, __x);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_InputIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{





    difference_type __off = __position - begin();
    pointer __p = this->__begin_ + __off;
    allocator_type& __a = this->__alloc();
    pointer __old_last = this->__end_;
    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)
    {
        __construct_one_at_end(*__first);
    }
    __split_buffer<value_type, allocator_type&> __v(__a);
    if (__first != __last)
    {

        try
        {

            __v.__construct_at_end(__first, __last);
            difference_type __old_size = __old_last - this->__begin_;
            difference_type __old_p = __p - this->__begin_;
            reserve(__recommend(size() + __v.size()));
            __p = this->__begin_ + __old_p;
            __old_last = this->__begin_ + __old_size;

        }
        catch (...)
        {
            erase(__make_iter(__old_last), end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_last, this->__end_);
    insert(__make_iter(__p), std::__1::make_move_iterator(__v.begin()),
                             std::__1::make_move_iterator(__v.end()));
    return begin() + __off;
}

template <class _Tp, class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value &&
    is_constructible<
       _Tp,
       typename iterator_traits<_ForwardIterator>::reference>::value,
    typename vector<_Tp, _Allocator>::iterator
>::type
vector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{





    pointer __p = this->__begin_ + (__position - begin());
    difference_type __n = std::__1::distance(__first, __last);
    if (__n > 0)
    {
        if (__n <= this->__end_cap() - this->__end_)
        {
            size_type __old_n = __n;
            pointer __old_last = this->__end_;
            _ForwardIterator __m = __last;
            difference_type __dx = this->__end_ - __p;
            if (__n > __dx)
            {
                __m = __first;
                difference_type __diff = this->__end_ - __p;
                std::__1::advance(__m, __diff);
                __construct_at_end(__m, __last, __n - __diff);
                __n = __dx;
            }
            if (__n > 0)
            {
                __move_range(__p, __old_last, __p + __old_n);
                std::__1::copy(__first, __m, __p);
            }
        }
        else
        {
            allocator_type& __a = this->__alloc();
            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);
            __v.__construct_at_end(__first, __last);
            __p = __swap_out_circular_buffer(__v, __p);
        }
    }
    return __make_iter(__p);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)
{
    size_type __cs = size();
    if (__cs < __sz)
        this->__append(__sz - __cs, __x);
    else if (__cs > __sz)
        this->__destruct_at_end(this->__begin_ + __sz);
}

template <class _Tp, class _Allocator>
void
vector<_Tp, _Allocator>::swap(vector& __x)

    noexcept




{
    ((void)0);



    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__end_, __x.__end_);
    std::__1::swap(this->__end_cap(), __x.__end_cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool,__alloc_traits::propagate_on_container_swap::value>());



}

template <class _Tp, class _Allocator>
bool
vector<_Tp, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__end_ != nullptr || this->__end_cap() != nullptr)
            return false;
    }
    else
    {
        if (this->__begin_ > this->__end_)
            return false;
        if (this->__begin_ == this->__end_cap())
            return false;
        if (this->__end_ > this->__end_cap())
            return false;
    }
    return true;
}
# 2141 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::__invalidate_all_iterators()
{



}


template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<_Tp, _Allocator>::__invalidate_iterators_past(pointer __new_last) {
# 2169 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
  ((void)__new_last);

}



template <class _Allocator> class vector<bool, _Allocator>;

template <class _Allocator> struct hash<vector<bool, _Allocator> >;

template <class _Allocator>
struct __has_storage_type<vector<bool, _Allocator> >
{
    static const bool value = true;
};

template <class _Allocator>
class __attribute__ ((__type_visibility__("default"))) vector<bool, _Allocator>
    : private __vector_base_common<true>
{
public:
    typedef vector __self;
    typedef bool value_type;
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef size_type __storage_type;
    typedef __bit_iterator<vector, false> pointer;
    typedef __bit_iterator<vector, true> const_pointer;
    typedef pointer iterator;
    typedef const_pointer const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;

private:
    typedef typename __rebind_alloc_helper<__alloc_traits, __storage_type>::type __storage_allocator;
    typedef allocator_traits<__storage_allocator> __storage_traits;
    typedef typename __storage_traits::pointer __storage_pointer;
    typedef typename __storage_traits::const_pointer __const_storage_pointer;

    __storage_pointer __begin_;
    size_type __size_;
    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;
public:
    typedef __bit_reference<vector> reference;
    typedef __bit_const_reference<vector> const_reference;
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type& __cap() noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& __cap() const noexcept
        {return __cap_alloc_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __storage_allocator& __alloc() noexcept
        {return __cap_alloc_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __storage_allocator& __alloc() const noexcept
        {return __cap_alloc_.second();}

    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __internal_cap_to_external(size_type __n) noexcept
        {return __n * __bits_per_word;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __external_cap_to_internal(size_type __n) noexcept
        {return (__n - 1) / __bits_per_word + 1;}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector() noexcept(is_nothrow_default_constructible<allocator_type>::value);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) explicit vector(const allocator_type& __a)



        noexcept;

    ~vector();
    explicit vector(size_type __n);

    explicit vector(size_type __n, const allocator_type& __a);

    vector(size_type __n, const value_type& __v);
    vector(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _InputIterator>
        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                                 !__is_cpp17_forward_iterator<_InputIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);
    template <class _ForwardIterator>
        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
               typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type* = 0);

    vector(const vector& __v);
    vector(const vector& __v, const allocator_type& __a);
    vector& operator=(const vector& __v);


    vector(initializer_list<value_type> __il);
    vector(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector(vector&& __v)

        noexcept;



    vector(vector&& __v, const __identity_t<allocator_type>& __a);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(vector&& __v)
        noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value));

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    vector& operator=(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end()); return *this;}



    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value &&
           !__is_cpp17_forward_iterator<_InputIterator>::value,
           void
        >::type
        assign(_InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
           void
        >::type
        assign(_ForwardIterator __first, _ForwardIterator __last);

    void assign(size_type __n, const value_type& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il)
        {assign(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) allocator_type get_allocator() const noexcept
        {return allocator_type(this->__alloc());}

    size_type max_size() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type capacity() const noexcept
        {return __internal_cap_to_external(__cap());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept
        {return __size_;}
                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return __size_ == 0;}
    void reserve(size_type __n);
    void shrink_to_fit() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        {return __make_iter(__size_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rbegin() noexcept
        {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reverse_iterator rend() noexcept
        {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return __make_iter(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return __make_iter(__size_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept
        {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept
        {return rend();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_type __n) {return __make_ref(__n);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference operator[](size_type __n) const {return __make_ref(__n);}
    reference at(size_type __n);
    const_reference at(size_type __n) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference front() {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference front() const {return __make_ref(0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference back() {return __make_ref(__size_ - 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_reference back() const {return __make_ref(__size_ - 1);}

    void push_back(const value_type& __x);

    template <class... _Args>

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference emplace_back(_Args&&... __args)



    {
        push_back ( value_type ( std::__1::forward<_Args>(__args)... ));

        return this->back();

    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void pop_back() {--__size_;}


    template <class... _Args>
   __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator emplace(const_iterator position, _Args&&... __args)
        { return insert ( position, value_type ( std::__1::forward<_Args>(__args)... )); }


    iterator insert(const_iterator __position, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const value_type& __x);
    iterator insert(const_iterator __position, size_type __n, const_reference __x);
    template <class _InputIterator>
        typename enable_if
        <
             __is_cpp17_input_iterator <_InputIterator>::value &&
            !__is_cpp17_forward_iterator<_InputIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            iterator
        >::type
        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __position, initializer_list<value_type> __il)
        {return insert(__position, __il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator erase(const_iterator __position);
    iterator erase(const_iterator __first, const_iterator __last);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__size_ = 0;}

    void swap(vector&)

        noexcept;




    static void swap(reference __x, reference __y) noexcept { std::__1::swap(__x, __y); }

    void resize(size_type __sz, value_type __x = false);
    void flip() noexcept;

    bool __invariants() const;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __invalidate_all_iterators();
    void __vallocate(size_type __n);
    void __vdeallocate() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    static size_type __align_it(size_type __new_size) noexcept
        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_type __recommend(size_type __new_size) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void __construct_at_end(size_type __n, bool __x);
    template <class _ForwardIterator>
        typename enable_if
        <
            __is_cpp17_forward_iterator<_ForwardIterator>::value,
            void
        >::type
        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);
    void __append(size_type __n, const_reference __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference __make_ref(size_type __pos) noexcept
        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference __make_ref(size_type __pos) const noexcept
        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __make_iter(size_type __pos) noexcept
        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator __make_iter(size_type __pos) const noexcept
        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __const_iterator_cast(const_iterator __p) noexcept
        {return begin() + (__p - cbegin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector& __v)
        {__copy_assign_alloc(__v, integral_constant<bool,
                      __storage_traits::propagate_on_container_copy_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector& __c, true_type)
        {
            if (__alloc() != __c.__alloc())
                __vdeallocate();
            __alloc() = __c.__alloc();
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const vector&, false_type)
        {}

    void __move_assign(vector& __c, false_type);
    void __move_assign(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector& __c)
        noexcept(!__storage_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<allocator_type>::value)


        {__move_assign_alloc(__c, integral_constant<bool,
                      __storage_traits::propagate_on_container_move_assignment::value>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector& __c, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value)
        {
            __alloc() = std::__1::move(__c.__alloc());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(vector&, false_type)
        noexcept
        {}

    size_t __hash_code() const noexcept;

    friend class __bit_reference<vector>;
    friend class __bit_const_reference<vector>;
    friend class __bit_iterator<vector, false>;
    friend class __bit_iterator<vector, true>;
    friend struct __bit_array<vector>;
    friend struct __attribute__ ((__type_visibility__("default"))) hash<vector>;
};

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<bool, _Allocator>::__invalidate_all_iterators()
{
}
# 2550 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
template <class _Allocator>
void
vector<bool, _Allocator>::__vallocate(size_type __n)
{
    if (__n > max_size())
        this->__throw_length_error();
    __n = __external_cap_to_internal(__n);
    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);
    this->__size_ = 0;
    this->__cap() = __n;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__vdeallocate() noexcept
{
    if (this->__begin_ != nullptr)
    {
        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());
        __invalidate_all_iterators();
        this->__begin_ = nullptr;
        this->__size_ = this->__cap() = 0;
    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::max_size() const noexcept
{
    size_type __amax = __storage_traits::max_size(__alloc());
    size_type __nmax = numeric_limits<size_type>::max() / 2;
    if (__nmax / __bits_per_word <= __amax)
        return __nmax;
    return __internal_cap_to_external(__amax);
}


template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<bool, _Allocator>::size_type
vector<bool, _Allocator>::__recommend(size_type __new_size) const
{
    const size_type __ms = max_size();
    if (__new_size > __ms)
        this->__throw_length_error();
    const size_type __cap = capacity();
    if (__cap >= __ms / 2)
        return __ms;
    return std::__1::max(2 * __cap, __align_it(__new_size));
}





template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
vector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)
{
    size_type __old_size = this->__size_;
    this->__size_ += __n;
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::fill_n(__make_iter(__old_size), __n, __x);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    void
>::type
vector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)
{
    size_type __old_size = this->__size_;
    this->__size_ += std::__1::distance(__first, __last);
    if (__old_size == 0 || ((__old_size - 1) / __bits_per_word) != ((this->__size_ - 1) / __bits_per_word))
    {
        if (this->__size_ <= __bits_per_word)
            this->__begin_[0] = __storage_type(0);
        else
            this->__begin_[(this->__size_ - 1) / __bits_per_word] = __storage_type(0);
    }
    std::__1::copy(__first, __last, __make_iter(__old_size));
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>::vector()
    noexcept(is_nothrow_default_constructible<allocator_type>::value)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>::vector(const allocator_type& __a)



        noexcept

    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, false);
    }
}


template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__n, __x);
    }
}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _InputIterator>
vector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,
       typename enable_if<__is_cpp17_input_iterator <_InputIterator>::value &&
                         !__is_cpp17_forward_iterator<_InputIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{

    try
    {

        for (; __first != __last; ++__first)
            push_back(*__first);

    }
    catch (...)
    {
        if (__begin_ != nullptr)
            __storage_traits::deallocate(__alloc(), __begin_, __cap());
        __invalidate_all_iterators();
        throw;
    }

}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
template <class _ForwardIterator>
vector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,
                                typename enable_if<__is_cpp17_forward_iterator<_ForwardIterator>::value>::type*)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(std::__1::distance(__first, __last));
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__first, __last);
    }
}



template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __default_init_tag())
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, static_cast<__storage_allocator>(__a))
{
    size_type __n = static_cast<size_type>(__il.size());
    if (__n > 0)
    {
        __vallocate(__n);
        __construct_at_end(__il.begin(), __il.end());
    }
}



template <class _Allocator>
vector<bool, _Allocator>::~vector()
{
    if (__begin_ != nullptr)
        __storage_traits::deallocate(__alloc(), __begin_, __cap());
    __invalidate_all_iterators();
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(const vector& __v)
{
    if (this != &__v)
    {
        __copy_assign_alloc(__v);
        if (__v.__size_)
        {
            if (__v.__size_ > capacity())
            {
                __vdeallocate();
                __vallocate(__v.__size_);
            }
            std::__1::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);
        }
        __size_ = __v.__size_;
    }
    return *this;
}



template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) vector<bool, _Allocator>::vector(vector&& __v)

    noexcept



    : __begin_(__v.__begin_),
      __size_(__v.__size_),
      __cap_alloc_(std::__1::move(__v.__cap_alloc_)) {
    __v.__begin_ = nullptr;
    __v.__size_ = 0;
    __v.__cap() = 0;
}

template <class _Allocator>
vector<bool, _Allocator>::vector(vector&& __v, const __identity_t<allocator_type>& __a)
    : __begin_(nullptr),
      __size_(0),
      __cap_alloc_(0, __a)
{
    if (__a == allocator_type(__v.__alloc()))
    {
        this->__begin_ = __v.__begin_;
        this->__size_ = __v.__size_;
        this->__cap() = __v.__cap();
        __v.__begin_ = nullptr;
        __v.__cap() = __v.__size_ = 0;
    }
    else if (__v.size() > 0)
    {
        __vallocate(__v.size());
        __construct_at_end(__v.begin(), __v.end());
    }
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
vector<bool, _Allocator>&
vector<bool, _Allocator>::operator=(vector&& __v)
    noexcept((__noexcept_move_assign_container<_Allocator, __alloc_traits>::value))
{
    __move_assign(__v, integral_constant<bool,
          __storage_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, false_type)
{
    if (__alloc() != __c.__alloc())
        assign(__c.begin(), __c.end());
    else
        __move_assign(__c, true_type());
}

template <class _Allocator>
void
vector<bool, _Allocator>::__move_assign(vector& __c, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    __vdeallocate();
    __move_assign_alloc(__c);
    this->__begin_ = __c.__begin_;
    this->__size_ = __c.__size_;
    this->__cap() = __c.__cap();
    __c.__begin_ = nullptr;
    __c.__cap() = __c.__size_ = 0;
}



template <class _Allocator>
void
vector<bool, _Allocator>::assign(size_type __n, const value_type& __x)
{
    __size_ = 0;
    if (__n > 0)
    {
        size_type __c = capacity();
        if (__n <= __c)
            __size_ = __n;
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__n));
            __v.__size_ = __n;
            swap(__v);
        }
        std::__1::fill_n(begin(), __n, __x);
    }
  __invalidate_all_iterators();
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value &&
   !__is_cpp17_forward_iterator<_InputIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)
{
    clear();
    for (; __first != __last; ++__first)
        push_back(*__first);
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
   void
>::type
vector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)
{
    clear();
    difference_type __ns = std::__1::distance(__first, __last);
    ((void)0);
    const size_t __n = static_cast<size_type>(__ns);
    if (__n)
    {
        if (__n > capacity())
        {
            __vdeallocate();
            __vallocate(__n);
        }
        __construct_at_end(__first, __last);
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::reserve(size_type __n)
{
    if (__n > capacity())
    {
        vector __v(this->__alloc());
        __v.__vallocate(__n);
        __v.__construct_at_end(this->begin(), this->end());
        swap(__v);
        __invalidate_all_iterators();
    }
}

template <class _Allocator>
void
vector<bool, _Allocator>::shrink_to_fit() noexcept
{
    if (__external_cap_to_internal(size()) > __cap())
    {

        try
        {

            vector(*this, allocator_type(__alloc())).swap(*this);

        }
        catch (...)
        {
        }

    }
}

template <class _Allocator>
typename vector<bool, _Allocator>::reference
vector<bool, _Allocator>::at(size_type __n)
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
typename vector<bool, _Allocator>::const_reference
vector<bool, _Allocator>::at(size_type __n) const
{
    if (__n >= size())
        this->__throw_out_of_range();
    return (*this)[__n];
}

template <class _Allocator>
void
vector<bool, _Allocator>::push_back(const value_type& __x)
{
    if (this->__size_ == this->capacity())
        reserve(__recommend(this->__size_ + 1));
    ++this->__size_;
    back() = __x;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)
{
    iterator __r;
    if (size() < capacity())
    {
        const_iterator __old_end = end();
        ++__size_;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + 1));
        __v.__size_ = __size_ + 1;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    *__r = __x;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)
{
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::fill_n(__r, __n, __x);
    return __r;
}

template <class _Allocator>
template <class _InputIterator>
typename enable_if
<
     __is_cpp17_input_iterator <_InputIterator>::value &&
    !__is_cpp17_forward_iterator<_InputIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)
{
    difference_type __off = __position - begin();
    iterator __p = __const_iterator_cast(__position);
    iterator __old_end = end();
    for (; size() != capacity() && __first != __last; ++__first)
    {
        ++this->__size_;
        back() = *__first;
    }
    vector __v(__alloc());
    if (__first != __last)
    {

        try
        {

            __v.assign(__first, __last);
            difference_type __old_size = static_cast<difference_type>(__old_end - begin());
            difference_type __old_p = __p - begin();
            reserve(__recommend(size() + __v.size()));
            __p = begin() + __old_p;
            __old_end = begin() + __old_size;

        }
        catch (...)
        {
            erase(__old_end, end());
            throw;
        }

    }
    __p = std::__1::rotate(__p, __old_end, end());
    insert(__p, __v.begin(), __v.end());
    return begin() + __off;
}

template <class _Allocator>
template <class _ForwardIterator>
typename enable_if
<
    __is_cpp17_forward_iterator<_ForwardIterator>::value,
    typename vector<bool, _Allocator>::iterator
>::type
vector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)
{
    const difference_type __n_signed = std::__1::distance(__first, __last);
    ((void)0);
    const size_type __n = static_cast<size_type>(__n_signed);
    iterator __r;
    size_type __c = capacity();
    if (__n <= __c && size() <= __c - __n)
    {
        const_iterator __old_end = end();
        __size_ += __n;
        std::__1::copy_backward(__position, __old_end, end());
        __r = __const_iterator_cast(__position);
    }
    else
    {
        vector __v(__alloc());
        __v.reserve(__recommend(__size_ + __n));
        __v.__size_ = __size_ + __n;
        __r = std::__1::copy(cbegin(), __position, __v.begin());
        std::__1::copy_backward(__position, cend(), __v.end());
        swap(__v);
    }
    std::__1::copy(__first, __last, __r);
    return __r;
}

template <class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __position)
{
    iterator __r = __const_iterator_cast(__position);
    std::__1::copy(__position + 1, this->cend(), __r);
    --__size_;
    return __r;
}

template <class _Allocator>
typename vector<bool, _Allocator>::iterator
vector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)
{
    iterator __r = __const_iterator_cast(__first);
    difference_type __d = __last - __first;
    std::__1::copy(__last, this->cend(), __r);
    __size_ -= __d;
    return __r;
}

template <class _Allocator>
void
vector<bool, _Allocator>::swap(vector& __x)

    noexcept




{
    std::__1::swap(this->__begin_, __x.__begin_);
    std::__1::swap(this->__size_, __x.__size_);
    std::__1::swap(this->__cap(), __x.__cap());
    std::__1::__swap_allocator(this->__alloc(), __x.__alloc(),
        integral_constant<bool, __alloc_traits::propagate_on_container_swap::value>());
}

template <class _Allocator>
void
vector<bool, _Allocator>::resize(size_type __sz, value_type __x)
{
    size_type __cs = size();
    if (__cs < __sz)
    {
        iterator __r;
        size_type __c = capacity();
        size_type __n = __sz - __cs;
        if (__n <= __c && __cs <= __c - __n)
        {
            __r = end();
            __size_ += __n;
        }
        else
        {
            vector __v(__alloc());
            __v.reserve(__recommend(__size_ + __n));
            __v.__size_ = __size_ + __n;
            __r = std::__1::copy(cbegin(), cend(), __v.begin());
            swap(__v);
        }
        std::__1::fill_n(__r, __n, __x);
    }
    else
        __size_ = __sz;
}

template <class _Allocator>
void
vector<bool, _Allocator>::flip() noexcept
{

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <class _Allocator>
bool
vector<bool, _Allocator>::__invariants() const
{
    if (this->__begin_ == nullptr)
    {
        if (this->__size_ != 0 || this->__cap() != 0)
            return false;
    }
    else
    {
        if (this->__cap() == 0)
            return false;
        if (this->__size_ > this->capacity())
            return false;
    }
    return true;
}

template <class _Allocator>
size_t
vector<bool, _Allocator>::__hash_code() const noexcept
{
    size_t __h = 0;

    size_type __n = __size_;
    __storage_pointer __p = __begin_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        __h ^= *__p;

    if (__n > 0)
    {
        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __h ^= *__p & __m;
    }
    return __h;
}

template <class _Allocator>
struct __attribute__ ((__type_visibility__("default"))) hash<vector<bool, _Allocator> >
    : public unary_function<vector<bool, _Allocator>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const vector<bool, _Allocator>& __vec) const noexcept
        {return __vec.__hash_code();}
};

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();
    return __sz == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 3432 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/vector" 3
} }
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/char-buffer.h" 2

namespace Fortran::parser {

class CharBuffer {
public:
  CharBuffer() {}
  CharBuffer(CharBuffer &&that)
      : blocks_(std::move(that.blocks_)), bytes_{that.bytes_},
        lastBlockEmpty_{that.lastBlockEmpty_} {
    that.clear();
  }
  CharBuffer &operator=(CharBuffer &&that) {
    blocks_ = std::move(that.blocks_);
    bytes_ = that.bytes_;
    lastBlockEmpty_ = that.lastBlockEmpty_;
    that.clear();
    return *this;
  }

  bool empty() const { return bytes_ == 0; }
  std::size_t bytes() const { return bytes_; }

  void clear() {
    blocks_.clear();
    bytes_ = 0;
    lastBlockEmpty_ = false;
  }

  char *FreeSpace(std::size_t &);
  void Claim(std::size_t);



  std::size_t Put(const char *data, std::size_t n);
  std::size_t Put(const std::string &);
  std::size_t Put(char x) { return Put(&x, 1); }

  std::string Marshal() const;

private:
  struct Block {
    static constexpr std::size_t capacity{1 << 20};
    char data[capacity];
  };

  int LastBlockOffset() const { return bytes_ % Block::capacity; }
  std::list<Block> blocks_;
  std::size_t bytes_{0};
  bool lastBlockEmpty_{false};
};
}
# 14 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference.h" 2
namespace Fortran::common {
template <typename A> class Reference {
public:
  using type = A;
  Reference(type &x) : p_{&x} {}
  Reference(const Reference &that) : p_{that.p_} {}
  Reference(Reference &&that) : p_{that.p_} {}
  Reference &operator=(const Reference &that) {
    p_ = that.p_;
    return *this;
  }
  Reference &operator=(Reference &&that) {
    p_ = that.p_;
    return *this;
  }






  operator std::conditional_t<std::is_const_v<type>, type &, void>()
      const noexcept {
    if constexpr (std::is_const_v<type>) {
      return *p_;
    }
  }

  type &get() const noexcept { return *p_; }
  type *operator->() const { return p_; }
  type &operator*() const { return *p_; }

  bool operator==(std::add_const_t<A> &that) const {
    return p_ == &that || *p_ == that;
  }
  bool operator!=(std::add_const_t<A> &that) const { return !(*this == that); }
  bool operator==(const Reference &that) const {
    return p_ == that.p_ || *this == *that.p_;
  }
  bool operator!=(const Reference &that) const { return !(*this == that); }

private:
  type *p_;
};
template <typename A> Reference(A &) -> Reference<A>;
}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/DataTypes.h" 1
# 43 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/DataTypes.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 1 3 4
# 84 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_char.h" 3 4
typedef unsigned char u_char;
# 85 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_short.h" 3 4
typedef unsigned short u_short;
# 86 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_u_int.h" 3 4
typedef unsigned int u_int;
# 87 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;


typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
typedef char * caddr_t;
# 100 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
typedef __darwin_blksize_t blksize_t;
# 109 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_gid_t.h" 3 4
typedef __darwin_gid_t gid_t;
# 110 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
typedef __uint32_t in_addr_t;
# 111 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
typedef __uint16_t in_port_t;
# 112 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino_t.h" 3 4
typedef __darwin_ino_t ino_t;
# 113 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
typedef __darwin_ino64_t ino64_t;
# 116 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_key_t.h" 3 4
typedef __int32_t key_t;
# 119 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
typedef __uint16_t nlink_t;
# 121 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 138 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
static inline __int32_t
major(__uint32_t _x)
{
 return (__int32_t)(((__uint32_t)_x >> 24) & 0xff);
}

static inline __int32_t
minor(__uint32_t _x)
{
 return (__int32_t)((_x) & 0xffffff);
}

static inline dev_t
makedev(__uint32_t _major, __uint32_t _minor)
{
 return (dev_t)(((_major) << 24) | (_minor));
}
# 166 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 167 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
typedef __darwin_useconds_t useconds_t;
# 171 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
typedef __darwin_suseconds_t suseconds_t;
# 172 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
typedef __darwin_size_t rsize_t;
# 175 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 176 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4








# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 49 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_def.h" 3 4
extern "C" {
typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) __attribute__((availability(macosx,introduced=11.0))) __attribute__((availability(ios,introduced=14.0))) __attribute__((availability(tvos,introduced=14.0))) __attribute__((availability(watchos,introduced=7.0)));
}

inline __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunguarded-availability-new"

 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }

#pragma clang diagnostic pop

}


inline __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

inline __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}
# 185 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4




typedef __int32_t fd_mask;







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 198 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 199 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 200 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 201 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 202 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 205 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 232 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 233 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 31 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 234 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/sys/types.h" 2 3 4
# 44 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/DataTypes.h" 2
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/ExternC.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h" 2

extern "C" {
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
#pragma clang diagnostic push
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
#pragma clang diagnostic error "-Wstrict-prototypes"







typedef int LLVMBool;
# 48 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
typedef struct LLVMOpaqueMemoryBuffer *LLVMMemoryBufferRef;




typedef struct LLVMOpaqueContext *LLVMContextRef;







typedef struct LLVMOpaqueModule *LLVMModuleRef;






typedef struct LLVMOpaqueType *LLVMTypeRef;






typedef struct LLVMOpaqueValue *LLVMValueRef;






typedef struct LLVMOpaqueBasicBlock *LLVMBasicBlockRef;






typedef struct LLVMOpaqueMetadata *LLVMMetadataRef;






typedef struct LLVMOpaqueNamedMDNode *LLVMNamedMDNodeRef;






typedef struct LLVMOpaqueValueMetadataEntry LLVMValueMetadataEntry;






typedef struct LLVMOpaqueBuilder *LLVMBuilderRef;






typedef struct LLVMOpaqueDIBuilder *LLVMDIBuilderRef;






typedef struct LLVMOpaqueModuleProvider *LLVMModuleProviderRef;


typedef struct LLVMOpaquePassManager *LLVMPassManagerRef;





typedef struct LLVMOpaqueUse *LLVMUseRef;






typedef struct LLVMOpaqueAttributeRef *LLVMAttributeRef;




typedef struct LLVMOpaqueDiagnosticInfo *LLVMDiagnosticInfoRef;




typedef struct LLVMComdat *LLVMComdatRef;




typedef struct LLVMOpaqueModuleFlagEntry LLVMModuleFlagEntry;




typedef struct LLVMOpaqueJITEventListener *LLVMJITEventListenerRef;




typedef struct LLVMOpaqueBinary *LLVMBinaryRef;





#pragma clang diagnostic pop
# 171 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm-c/Types.h"
 }
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 1
# 47 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/DataTypes.h" 1
# 48 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/llvm-config.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stddef.h" 1 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Compiler.h" 2
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h" 2

namespace llvm {
  class StringRef;
  class Twine;


  typedef void (*fatal_error_handler_t)(void *user_data,
                                        const char *reason,
                                        bool gen_crash_diag);
# 44 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
  void install_fatal_error_handler(fatal_error_handler_t handler,
                                   void *user_data = nullptr);


  void remove_fatal_error_handler();




  struct ScopedFatalErrorHandler {
    explicit ScopedFatalErrorHandler(fatal_error_handler_t handler,
                                     void *user_data = nullptr) {
      install_fatal_error_handler(handler, user_data);
    }

    ~ScopedFatalErrorHandler() { remove_fatal_error_handler(); }
  };
# 71 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
[[noreturn]] void report_fatal_error(const char *reason,
                                     bool gen_crash_diag = true);
[[noreturn]] void report_fatal_error(StringRef reason,
                                     bool gen_crash_diag = true);
[[noreturn]] void report_fatal_error(const Twine &reason,
                                     bool gen_crash_diag = true);
# 94 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
void install_bad_alloc_error_handler(fatal_error_handler_t handler,
                                     void *user_data = nullptr);


void remove_bad_alloc_error_handler();

void install_out_of_memory_new_handler();
# 114 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorHandling.h"
[[noreturn]] void report_bad_alloc_error(const char *Reason,
                                         bool GenCrashDiag = true);




[[noreturn]] void
llvm_unreachable_internal(const char *msg = nullptr, const char *file = nullptr,
                          unsigned line = 0);
}
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLForwardCompat.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLForwardCompat.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLForwardCompat.h" 2

namespace llvm {





template <typename T>
struct remove_cvref
{
  using type = std::remove_cv_t<std::remove_reference_t<T>>;
};

template <typename T>
using remove_cvref_t
    = typename llvm::remove_cvref<T>::type;







template <typename T, typename Function>
auto transformOptional(const std::optional<T> &O, const Function &F)
    -> std::optional<decltype(F(*O))> {
  if (O)
    return F(*O);
  return std::nullopt;
}



template <typename T, typename Function>
auto transformOptional(std::optional<T> &&O, const Function &F)
    -> std::optional<decltype(F(*std::move(O)))> {
  if (O)
    return F(*std::move(O));
  return std::nullopt;
}



template <typename Enum>
[[nodiscard]] constexpr std::underlying_type_t<Enum> to_underlying(Enum E) {
  return static_cast<std::underlying_type_t<Enum>>(E);
}

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h" 2
# 68 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
namespace llvm {

enum class endianness {
  big,
  little,



  native = little

};




template <
    typename To, typename From,
    typename = std::enable_if_t<sizeof(To) == sizeof(From)>,
    typename = std::enable_if_t<std::is_trivially_constructible<To>::value>,
    typename = std::enable_if_t<std::is_trivially_copyable<To>::value>,
    typename = std::enable_if_t<std::is_trivially_copyable<From>::value>>
[[nodiscard]] inline To bit_cast(const From &from) noexcept {

  return __builtin_bit_cast(To, from);





}


template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
[[nodiscard]] constexpr T byteswap(T V) noexcept {
  if constexpr (sizeof(T) == 1) {
    return V;
  } else if constexpr (sizeof(T) == 2) {
    uint16_t UV = V;





    uint16_t Hi = UV << 8;
    uint16_t Lo = UV >> 8;
    return Hi | Lo;

  } else if constexpr (sizeof(T) == 4) {
    uint32_t UV = V;

    return __builtin_bswap32(UV);
# 128 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
  } else if constexpr (sizeof(T) == 8) {
    uint64_t UV = V;

    return __builtin_bswap64(UV);







  } else {
    static_assert(!sizeof(T *), "Don't know how to handle the given type.");
    return 0;
  }
}

template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr inline bool has_single_bit(T Value) noexcept {
  return (Value != 0) && ((Value & (Value - 1)) == 0);
}

namespace detail {
template <typename T, std::size_t SizeOfT> struct TrailingZerosCounter {
  static unsigned count(T Val) {
    if (!Val)
      return std::numeric_limits<T>::digits;
    if (Val & 0x1)
      return 0;


    unsigned ZeroBits = 0;
    T Shift = std::numeric_limits<T>::digits >> 1;
    T Mask = std::numeric_limits<T>::max() >> Shift;
    while (Shift) {
      if ((Val & Mask) == 0) {
        Val >>= Shift;
        ZeroBits |= Shift;
      }
      Shift >>= 1;
      Mask >>= Shift;
    }
    return ZeroBits;
  }
};


template <typename T> struct TrailingZerosCounter<T, 4> {
  static unsigned count(T Val) {
    if (Val == 0)
      return 32;


    return __builtin_ctz(Val);





  }
};


template <typename T> struct TrailingZerosCounter<T, 8> {
  static unsigned count(T Val) {
    if (Val == 0)
      return 64;


    return __builtin_ctzll(Val);





  }
};


}







template <typename T> [[nodiscard]] int countr_zero(T Val) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::detail::TrailingZerosCounter<T, sizeof(T)>::count(Val);
}

namespace detail {
template <typename T, std::size_t SizeOfT> struct LeadingZerosCounter {
  static unsigned count(T Val) {
    if (!Val)
      return std::numeric_limits<T>::digits;


    unsigned ZeroBits = 0;
    for (T Shift = std::numeric_limits<T>::digits >> 1; Shift; Shift >>= 1) {
      T Tmp = Val >> Shift;
      if (Tmp)
        Val = Tmp;
      else
        ZeroBits |= Shift;
    }
    return ZeroBits;
  }
};


template <typename T> struct LeadingZerosCounter<T, 4> {
  static unsigned count(T Val) {
    if (Val == 0)
      return 32;


    return __builtin_clz(Val);





  }
};


template <typename T> struct LeadingZerosCounter<T, 8> {
  static unsigned count(T Val) {
    if (Val == 0)
      return 64;


    return __builtin_clzll(Val);





  }
};


}







template <typename T> [[nodiscard]] int countl_zero(T Val) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::detail::LeadingZerosCounter<T, sizeof(T)>::count(Val);
}
# 294 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] int countl_one(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::countl_zero<T>(~Value);
}
# 307 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] int countr_one(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return llvm::countr_zero<T>(~Value);
}





template <typename T> [[nodiscard]] int bit_width(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  return std::numeric_limits<T>::digits - llvm::countl_zero(Value);
}





template <typename T> [[nodiscard]] T bit_floor(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (!Value)
    return 0;
  return T(1) << (llvm::bit_width(Value) - 1);
}
# 342 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/bit.h"
template <typename T> [[nodiscard]] T bit_ceil(T Value) {
  static_assert(std::is_unsigned_v<T>,
                "Only unsigned integral types are allowed.");
  if (Value < 2)
    return 1;
  return T(1) << llvm::bit_width<T>(Value - 1u);
}

namespace detail {
template <typename T, std::size_t SizeOfT> struct PopulationCounter {
  static int count(T Value) {

    static_assert(SizeOfT <= 4, "Not implemented!");

    return (int)__builtin_popcount(Value);






  }
};

template <typename T> struct PopulationCounter<T, 8> {
  static int count(T Value) {

    return (int)__builtin_popcountll(Value);







  }
};
}




template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] inline int popcount(T Value) noexcept {
  return detail::PopulationCounter<T, sizeof(T)>::count(Value);
}


template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr T rotr(T V, int R);

template <typename T, typename = std::enable_if_t<std::is_unsigned_v<T>>>
[[nodiscard]] constexpr T rotl(T V, int R) {
  unsigned N = std::numeric_limits<T>::digits;

  R = R % N;
  if (!R)
    return V;

  if (R < 0)
    return llvm::rotr(V, -R);

  return (V << R) | (V >> (N - R));
}

template <typename T, typename> [[nodiscard]] constexpr T rotr(T V, int R) {
  unsigned N = std::numeric_limits<T>::digits;

  R = R % N;
  if (!R)
    return V;

  if (R < 0)
    return llvm::rotl(V, -R);

  return (V >> R) | (V << (N - R));
}

}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/SwapByteOrder.h" 2

namespace llvm {

namespace sys {

constexpr bool IsBigEndianHost =
    llvm::endianness::native == llvm::endianness::big;

static const bool IsLittleEndianHost = !IsBigEndianHost;

inline unsigned char getSwappedBytes(unsigned char C) { return llvm::byteswap(C); }
inline signed char getSwappedBytes( signed char C) { return llvm::byteswap(C); }
inline char getSwappedBytes( char C) { return llvm::byteswap(C); }

inline unsigned short getSwappedBytes(unsigned short C) { return llvm::byteswap(C); }
inline signed short getSwappedBytes( signed short C) { return llvm::byteswap(C); }

inline unsigned int getSwappedBytes(unsigned int C) { return llvm::byteswap(C); }
inline signed int getSwappedBytes( signed int C) { return llvm::byteswap(C); }

inline unsigned long getSwappedBytes(unsigned long C) { return llvm::byteswap(C); }
inline signed long getSwappedBytes( signed long C) { return llvm::byteswap(C); }

inline unsigned long long getSwappedBytes(unsigned long long C) { return llvm::byteswap(C); }
inline signed long long getSwappedBytes( signed long long C) { return llvm::byteswap(C); }

inline float getSwappedBytes(float C) {
  return llvm::bit_cast<float>(llvm::byteswap(llvm::bit_cast<uint32_t>(C)));
}

inline double getSwappedBytes(double C) {
  return llvm::bit_cast<double>(llvm::byteswap(llvm::bit_cast<uint64_t>(C)));
}

template <typename T>
inline std::enable_if_t<std::is_enum_v<T>, T> getSwappedBytes(T C) {
  return static_cast<T>(llvm::byteswap(llvm::to_underlying(C)));
}

template<typename T>
inline void swapByteOrder(T &Value) {
  Value = getSwappedBytes(Value);
}

}
}
# 50 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h" 2


namespace llvm {
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/type_traits.h"
template <typename T> class is_integral_or_enum {
  using UnderlyingT = std::remove_reference_t<T>;

public:
  static const bool value =
      !std::is_class_v<UnderlyingT> &&
      !std::is_pointer_v<UnderlyingT> &&
      !std::is_floating_point_v<UnderlyingT> &&
      (std::is_enum_v<UnderlyingT> ||
       std::is_convertible_v<UnderlyingT, unsigned long long>);
};


template<typename T, typename Enable = void>
struct add_lvalue_reference_if_not_pointer { using type = T &; };

template <typename T>
struct add_lvalue_reference_if_not_pointer<
    T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = T;
};



template<typename T, typename Enable = void>
struct add_const_past_pointer { using type = const T; };

template <typename T>
struct add_const_past_pointer<T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = const std::remove_pointer_t<T> *;
};

template <typename T, typename Enable = void>
struct const_pointer_or_const_ref {
  using type = const T &;
};
template <typename T>
struct const_pointer_or_const_ref<T, std::enable_if_t<std::is_pointer_v<T>>> {
  using type = typename add_const_past_pointer<T>::type;
};

namespace detail {
template<class T>
union trivial_helper {
    T t;
};

}

template <typename T>
struct is_copy_assignable {
  template<class F>
    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<const F &>(), std::true_type{});
    static std::false_type get(...);
    static constexpr bool value = decltype(get((T*)nullptr))::value;
};

template <typename T>
struct is_move_assignable {
  template<class F>
    static auto get(F*) -> decltype(std::declval<F &>() = std::declval<F &&>(), std::true_type{});
    static std::false_type get(...);
    static constexpr bool value = decltype(get((T*)nullptr))::value;
};

}
# 51 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 53 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h" 2






namespace llvm {
template <typename T, typename Enable> struct DenseMapInfo;
# 74 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
class hash_code {
  size_t value;

public:


  hash_code() = default;


  hash_code(size_t value) : value(value) {}


               operator size_t() const { return value; }

  friend bool operator==(const hash_code &lhs, const hash_code &rhs) {
    return lhs.value == rhs.value;
  }
  friend bool operator!=(const hash_code &lhs, const hash_code &rhs) {
    return lhs.value != rhs.value;
  }


  friend size_t hash_value(const hash_code &code) { return code.value; }
};
# 106 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T>
std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value);




template <typename T> hash_code hash_value(const T *ptr);


template <typename T, typename U>
hash_code hash_value(const std::pair<T, U> &arg);


template <typename... Ts>
hash_code hash_value(const std::tuple<Ts...> &arg);


template <typename T>
hash_code hash_value(const std::basic_string<T> &arg);


template <typename T> hash_code hash_value(const std::optional<T> &arg);
# 143 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
void set_fixed_execution_hash_seed(uint64_t fixed_value);





namespace hashing {
namespace detail {

inline uint64_t fetch64(const char *p) {
  uint64_t result;
  memcpy(&result, p, sizeof(result));
  if (sys::IsBigEndianHost)
    sys::swapByteOrder(result);
  return result;
}

inline uint32_t fetch32(const char *p) {
  uint32_t result;
  memcpy(&result, p, sizeof(result));
  if (sys::IsBigEndianHost)
    sys::swapByteOrder(result);
  return result;
}


static constexpr uint64_t k0 = 0xc3a5c85c97cb3127ULL;
static constexpr uint64_t k1 = 0xb492b66fbe98f273ULL;
static constexpr uint64_t k2 = 0x9ae16a3b2f90404fULL;
static constexpr uint64_t k3 = 0xc949d7c7509e6557ULL;




inline uint64_t rotate(uint64_t val, size_t shift) {

  return shift == 0 ? val : ((val >> shift) | (val << (64 - shift)));
}

inline uint64_t shift_mix(uint64_t val) {
  return val ^ (val >> 47);
}

inline uint64_t hash_16_bytes(uint64_t low, uint64_t high) {

  const uint64_t kMul = 0x9ddfea08eb382d69ULL;
  uint64_t a = (low ^ high) * kMul;
  a ^= (a >> 47);
  uint64_t b = (high ^ a) * kMul;
  b ^= (b >> 47);
  b *= kMul;
  return b;
}

inline uint64_t hash_1to3_bytes(const char *s, size_t len, uint64_t seed) {
  uint8_t a = s[0];
  uint8_t b = s[len >> 1];
  uint8_t c = s[len - 1];
  uint32_t y = static_cast<uint32_t>(a) + (static_cast<uint32_t>(b) << 8);
  uint32_t z = static_cast<uint32_t>(len) + (static_cast<uint32_t>(c) << 2);
  return shift_mix(y * k2 ^ z * k3 ^ seed) * k2;
}

inline uint64_t hash_4to8_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch32(s);
  return hash_16_bytes(len + (a << 3), seed ^ fetch32(s + len - 4));
}

inline uint64_t hash_9to16_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch64(s);
  uint64_t b = fetch64(s + len - 8);
  return hash_16_bytes(seed ^ a, rotate(b + len, len)) ^ b;
}

inline uint64_t hash_17to32_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t a = fetch64(s) * k1;
  uint64_t b = fetch64(s + 8);
  uint64_t c = fetch64(s + len - 8) * k2;
  uint64_t d = fetch64(s + len - 16) * k0;
  return hash_16_bytes(llvm::rotr<uint64_t>(a - b, 43) +
                           llvm::rotr<uint64_t>(c ^ seed, 30) + d,
                       a + llvm::rotr<uint64_t>(b ^ k3, 20) - c + len + seed);
}

inline uint64_t hash_33to64_bytes(const char *s, size_t len, uint64_t seed) {
  uint64_t z = fetch64(s + 24);
  uint64_t a = fetch64(s) + (len + fetch64(s + len - 16)) * k0;
  uint64_t b = llvm::rotr<uint64_t>(a + z, 52);
  uint64_t c = llvm::rotr<uint64_t>(a, 37);
  a += fetch64(s + 8);
  c += llvm::rotr<uint64_t>(a, 7);
  a += fetch64(s + 16);
  uint64_t vf = a + z;
  uint64_t vs = b + llvm::rotr<uint64_t>(a, 31) + c;
  a = fetch64(s + 16) + fetch64(s + len - 32);
  z = fetch64(s + len - 8);
  b = llvm::rotr<uint64_t>(a + z, 52);
  c = llvm::rotr<uint64_t>(a, 37);
  a += fetch64(s + len - 24);
  c += llvm::rotr<uint64_t>(a, 7);
  a += fetch64(s + len - 16);
  uint64_t wf = a + z;
  uint64_t ws = b + llvm::rotr<uint64_t>(a, 31) + c;
  uint64_t r = shift_mix((vf + ws) * k2 + (wf + vs) * k0);
  return shift_mix((seed ^ (r * k0)) + vs) * k2;
}

inline uint64_t hash_short(const char *s, size_t length, uint64_t seed) {
  if (length >= 4 && length <= 8)
    return hash_4to8_bytes(s, length, seed);
  if (length > 8 && length <= 16)
    return hash_9to16_bytes(s, length, seed);
  if (length > 16 && length <= 32)
    return hash_17to32_bytes(s, length, seed);
  if (length > 32)
    return hash_33to64_bytes(s, length, seed);
  if (length != 0)
    return hash_1to3_bytes(s, length, seed);

  return k2 ^ seed;
}




struct hash_state {
  uint64_t h0 = 0, h1 = 0, h2 = 0, h3 = 0, h4 = 0, h5 = 0, h6 = 0;




  static hash_state create(const char *s, uint64_t seed) {
    hash_state state = {0,
                        seed,
                        hash_16_bytes(seed, k1),
                        llvm::rotr<uint64_t>(seed ^ k1, 49),
                        seed * k1,
                        shift_mix(seed),
                        0};
    state.h6 = hash_16_bytes(state.h4, state.h5);
    state.mix(s);
    return state;
  }



  static void mix_32_bytes(const char *s, uint64_t &a, uint64_t &b) {
    a += fetch64(s);
    uint64_t c = fetch64(s + 24);
    b = llvm::rotr<uint64_t>(b + a + c, 21);
    uint64_t d = a;
    a += fetch64(s + 8) + fetch64(s + 16);
    b += llvm::rotr<uint64_t>(a, 44) + d;
    a += c;
  }




  void mix(const char *s) {
    h0 = llvm::rotr<uint64_t>(h0 + h1 + h3 + fetch64(s + 8), 37) * k1;
    h1 = llvm::rotr<uint64_t>(h1 + h4 + fetch64(s + 48), 42) * k1;
    h0 ^= h6;
    h1 += h3 + fetch64(s + 40);
    h2 = llvm::rotr<uint64_t>(h2 + h5, 33) * k1;
    h3 = h4 * k1;
    h4 = h0 + h5;
    mix_32_bytes(s, h3, h4);
    h5 = h2 + h6;
    h6 = h1 + fetch64(s + 16);
    mix_32_bytes(s + 32, h5, h6);
    std::swap(h2, h0);
  }



  uint64_t finalize(size_t length) {
    return hash_16_bytes(hash_16_bytes(h3, h5) + shift_mix(h1) * k1 + h2,
                         hash_16_bytes(h4, h6) + shift_mix(length) * k1 + h0);
  }
};







extern uint64_t fixed_seed_override;

inline uint64_t get_execution_seed() {






  const uint64_t seed_prime = 0xff51afd7ed558ccdULL;
  static uint64_t seed = fixed_seed_override ? fixed_seed_override : seed_prime;
  return seed;
}
# 358 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T> struct is_hashable_data
  : std::integral_constant<bool, ((is_integral_or_enum<T>::value ||
                                   std::is_pointer<T>::value) &&
                                  64 % sizeof(T) == 0)> {};





template <typename T, typename U> struct is_hashable_data<std::pair<T, U> >
  : std::integral_constant<bool, (is_hashable_data<T>::value &&
                                  is_hashable_data<U>::value &&
                                  (sizeof(T) + sizeof(U)) ==
                                   sizeof(std::pair<T, U>))> {};



template <typename T>
std::enable_if_t<is_hashable_data<T>::value, T>
get_hashable_data(const T &value) {
  return value;
}



template <typename T>
std::enable_if_t<!is_hashable_data<T>::value, size_t>
get_hashable_data(const T &value) {
  using ::llvm::hash_value;
  return hash_value(value);
}
# 397 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename T>
bool store_and_advance(char *&buffer_ptr, char *buffer_end, const T& value,
                       size_t offset = 0) {
  size_t store_size = sizeof(value) - offset;
  if (buffer_ptr + store_size > buffer_end)
    return false;
  const char *value_data = reinterpret_cast<const char *>(&value);
  memcpy(buffer_ptr, value_data + offset, store_size);
  buffer_ptr += store_size;
  return true;
}






template <typename InputIteratorT>
hash_code hash_combine_range_impl(InputIteratorT first, InputIteratorT last) {
  const uint64_t seed = get_execution_seed();
  char buffer[64], *buffer_ptr = buffer;
  char *const buffer_end = std::end(buffer);
  while (first != last && store_and_advance(buffer_ptr, buffer_end,
                                            get_hashable_data(*first)))
    ++first;
  if (first == last)
    return hash_short(buffer, buffer_ptr - buffer, seed);
  (__builtin_expect(!(buffer_ptr == buffer_end), 0) ? __assert_rtn(__func__, "Hashing.h", 424, "buffer_ptr == buffer_end") : (void)0);

  hash_state state = state.create(buffer, seed);
  size_t length = 64;
  while (first != last) {


    buffer_ptr = buffer;
    while (first != last && store_and_advance(buffer_ptr, buffer_end,
                                              get_hashable_data(*first)))
      ++first;




    std::rotate(buffer, buffer_ptr, buffer_end);


    state.mix(buffer);
    length += buffer_ptr - buffer;
  };

  return state.finalize(length);
}
# 457 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename ValueT>
std::enable_if_t<is_hashable_data<ValueT>::value, hash_code>
hash_combine_range_impl(ValueT *first, ValueT *last) {
  const uint64_t seed = get_execution_seed();
  const char *s_begin = reinterpret_cast<const char *>(first);
  const char *s_end = reinterpret_cast<const char *>(last);
  const size_t length = std::distance(s_begin, s_end);
  if (length <= 64)
    return hash_short(s_begin, length, seed);

  const char *s_aligned_end = s_begin + (length & ~63);
  hash_state state = state.create(s_begin, seed);
  s_begin += 64;
  while (s_begin != s_aligned_end) {
    state.mix(s_begin);
    s_begin += 64;
  }
  if (length & 63)
    state.mix(s_end - 64);

  return state.finalize(length);
}

}
}
# 490 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename InputIteratorT>
hash_code hash_combine_range(InputIteratorT first, InputIteratorT last) {
  return ::llvm::hashing::detail::hash_combine_range_impl(first, last);
}



namespace hashing {
namespace detail {
# 507 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
struct hash_combine_recursive_helper {
  char buffer[64] = {};
  hash_state state;
  const uint64_t seed;

public:




  hash_combine_recursive_helper()
    : seed(get_execution_seed()) {}







  template <typename T>
  char *combine_data(size_t &length, char *buffer_ptr, char *buffer_end, T data) {
    if (!store_and_advance(buffer_ptr, buffer_end, data)) {




      size_t partial_store_size = buffer_end - buffer_ptr;
      memcpy(buffer_ptr, &data, partial_store_size);





      if (length == 0) {
        state = state.create(buffer, seed);
        length = 64;
      } else {

        state.mix(buffer);
        length += 64;
      }


      buffer_ptr = buffer;



      if (!store_and_advance(buffer_ptr, buffer_end, data,
                             partial_store_size))
        ::llvm::llvm_unreachable_internal("buffer smaller than stored type", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h", 556);
    }
    return buffer_ptr;
  }





  template <typename T, typename ...Ts>
  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end,
                    const T &arg, const Ts &...args) {
    buffer_ptr = combine_data(length, buffer_ptr, buffer_end, get_hashable_data(arg));


    return combine(length, buffer_ptr, buffer_end, args...);
  }






  hash_code combine(size_t length, char *buffer_ptr, char *buffer_end) {


    if (length == 0)
      return hash_short(buffer, buffer_ptr - buffer, seed);





    std::rotate(buffer, buffer_ptr, buffer_end);


    state.mix(buffer);
    length += buffer_ptr - buffer;

    return state.finalize(length);
  }
};

}
}
# 613 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Hashing.h"
template <typename ...Ts> hash_code hash_combine(const Ts &...args) {

  ::llvm::hashing::detail::hash_combine_recursive_helper helper;
  return helper.combine(0, helper.buffer, helper.buffer + 64, args...);
}



namespace hashing {
namespace detail {






inline hash_code hash_integer_value(uint64_t value) {

  const uint64_t seed = get_execution_seed();
  const char *s = reinterpret_cast<const char *>(&value);
  const uint64_t a = fetch32(s);
  return hash_16_bytes(seed + (a << 3), fetch32(s + 4));
}

}
}



template <typename T>
std::enable_if_t<is_integral_or_enum<T>::value, hash_code> hash_value(T value) {
  return ::llvm::hashing::detail::hash_integer_value(
      static_cast<uint64_t>(value));
}



template <typename T> hash_code hash_value(const T *ptr) {
  return ::llvm::hashing::detail::hash_integer_value(
    reinterpret_cast<uintptr_t>(ptr));
}



template <typename T, typename U>
hash_code hash_value(const std::pair<T, U> &arg) {
  return hash_combine(arg.first, arg.second);
}

template <typename... Ts> hash_code hash_value(const std::tuple<Ts...> &arg) {
  return std::apply([](const auto &...xs) { return hash_combine(xs...); }, arg);
}



template <typename T>
hash_code hash_value(const std::basic_string<T> &arg) {
  return hash_combine_range(arg.begin(), arg.end());
}

template <typename T> hash_code hash_value(const std::optional<T> &arg) {
  return arg ? hash_combine(true, *arg) : hash_value(false);
}

template <> struct DenseMapInfo<hash_code, void> {
  static inline hash_code getEmptyKey() { return hash_code(-1); }
  static inline hash_code getTombstoneKey() { return hash_code(-2); }
  static unsigned getHashValue(hash_code val) { return val; }
  static bool isEqual(hash_code LHS, hash_code RHS) { return LHS == RHS; }
};

}


namespace std {

template<>
struct hash<llvm::hash_code> {
  size_t operator()(llvm::hash_code const& Val) const {
    return Val;
  }
};

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 2







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 31 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h" 2


namespace llvm {

template <typename T> class ArrayRef;

template <typename IteratorT> class iterator_range;

template <class Iterator>
using EnableIfConvertibleToInputIterator = std::enable_if_t<std::is_convertible<
    typename std::iterator_traits<Iterator>::iterator_category,
    std::input_iterator_tag>::value>;
# 52 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <class Size_T> class SmallVectorBase {
protected:
  void *BeginX;
  Size_T Size = 0, Capacity;


  static constexpr size_t SizeTypeMax() {
    return std::numeric_limits<Size_T>::max();
  }

  SmallVectorBase() = delete;
  SmallVectorBase(void *FirstEl, size_t TotalCapacity)
      : BeginX(FirstEl), Capacity(TotalCapacity) {}




  void *mallocForGrow(void *FirstEl, size_t MinSize, size_t TSize,
                      size_t &NewCapacity);




  void grow_pod(void *FirstEl, size_t MinSize, size_t TSize);
# 87 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
  void *replaceAllocation(void *NewElts, size_t TSize, size_t NewCapacity,
                          size_t VSize = 0);

public:
  size_t size() const { return Size; }
  size_t capacity() const { return Capacity; }

  [[nodiscard]] bool empty() const { return !Size; }

protected:




  void set_size(size_t N) {
    (__builtin_expect(!(N <= capacity()), 0) ? __assert_rtn(__func__, "SmallVector.h", 102, "N <= capacity()") : (void)0);
    Size = N;
  }
};

template <class T>
using SmallVectorSizeType =
    std::conditional_t<sizeof(T) < 4 && sizeof(void *) >= 8, uint64_t,
                       uint32_t>;


template <class T, typename = void> struct SmallVectorAlignmentAndSize {
  alignas(SmallVectorBase<SmallVectorSizeType<T>>) char Base[sizeof(
      SmallVectorBase<SmallVectorSizeType<T>>)];
  alignas(T) char FirstEl[sizeof(T)];
};




template <typename T, typename = void>
class SmallVectorTemplateCommon
    : public SmallVectorBase<SmallVectorSizeType<T>> {
  using Base = SmallVectorBase<SmallVectorSizeType<T>>;

protected:



  void *getFirstEl() const {
    return const_cast<void *>(reinterpret_cast<const void *>(
        reinterpret_cast<const char *>(this) +
        __builtin_offsetof(SmallVectorAlignmentAndSize<T>, FirstEl)));
  }


  SmallVectorTemplateCommon(size_t Size) : Base(getFirstEl(), Size) {}

  void grow_pod(size_t MinSize, size_t TSize) {
    Base::grow_pod(getFirstEl(), MinSize, TSize);
  }



  bool isSmall() const { return this->BeginX == getFirstEl(); }


  void resetToSmall() {
    this->BeginX = getFirstEl();
    this->Size = this->Capacity = 0;
  }


  bool isReferenceToRange(const void *V, const void *First, const void *Last) const {

    std::less<> LessThan;
    return !LessThan(V, First) && LessThan(V, Last);
  }


  bool isReferenceToStorage(const void *V) const {
    return isReferenceToRange(V, this->begin(), this->end());
  }



  bool isRangeInStorage(const void *First, const void *Last) const {

    std::less<> LessThan;
    return !LessThan(First, this->begin()) && !LessThan(Last, First) &&
           !LessThan(this->end(), Last);
  }



  bool isSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {

    if (__builtin_expect((bool)(!isReferenceToStorage(Elt)), true))
      return true;


    if (NewSize <= this->size())
      return Elt < this->begin() + NewSize;


    return NewSize <= this->capacity();
  }


  void assertSafeToReferenceAfterResize(const void *Elt, size_t NewSize) {
    (__builtin_expect(!(isSafeToReferenceAfterResize(Elt, NewSize) && "Attempting to reference an element of the vector in an operation " "that invalidates it"), 0) ? __assert_rtn(__func__, "SmallVector.h", 194, "isSafeToReferenceAfterResize(Elt, NewSize) && \"Attempting to reference an element of the vector in an operation \" \"that invalidates it\"") : (void)0);


  }



  void assertSafeToAdd(const void *Elt, size_t N = 1) {
    this->assertSafeToReferenceAfterResize(Elt, this->size() + N);
  }


  void assertSafeToReferenceAfterClear(const T *From, const T *To) {
    if (From == To)
      return;
    this->assertSafeToReferenceAfterResize(From, 0);
    this->assertSafeToReferenceAfterResize(To - 1, 0);
  }
  template <
      class ItTy,
      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,
                       bool> = false>
  void assertSafeToReferenceAfterClear(ItTy, ItTy) {}


  void assertSafeToAddRange(const T *From, const T *To) {
    if (From == To)
      return;
    this->assertSafeToAdd(From, To - From);
    this->assertSafeToAdd(To - 1, To - From);
  }
  template <
      class ItTy,
      std::enable_if_t<!std::is_same<std::remove_const_t<ItTy>, T *>::value,
                       bool> = false>
  void assertSafeToAddRange(ItTy, ItTy) {}



  template <class U>
  static const T *reserveForParamAndGetAddressImpl(U *This, const T &Elt,
                                                   size_t N) {
    size_t NewSize = This->size() + N;
    if (__builtin_expect((bool)(NewSize <= This->capacity()), true))
      return &Elt;

    bool ReferencesStorage = false;
    int64_t Index = -1;
    if (!U::TakesParamByValue) {
      if (__builtin_expect((bool)(This->isReferenceToStorage(&Elt)), false)) {
        ReferencesStorage = true;
        Index = &Elt - This->begin();
      }
    }
    This->grow(NewSize);
    return ReferencesStorage ? This->begin() + Index : &Elt;
  }

public:
  using size_type = size_t;
  using difference_type = ptrdiff_t;
  using value_type = T;
  using iterator = T *;
  using const_iterator = const T *;

  using const_reverse_iterator = std::reverse_iterator<const_iterator>;
  using reverse_iterator = std::reverse_iterator<iterator>;

  using reference = T &;
  using const_reference = const T &;
  using pointer = T *;
  using const_pointer = const T *;

  using Base::capacity;
  using Base::empty;
  using Base::size;


  iterator begin() { return (iterator)this->BeginX; }
  const_iterator begin() const { return (const_iterator)this->BeginX; }
  iterator end() { return begin() + size(); }
  const_iterator end() const { return begin() + size(); }


  reverse_iterator rbegin() { return reverse_iterator(end()); }
  const_reverse_iterator rbegin() const{ return const_reverse_iterator(end()); }
  reverse_iterator rend() { return reverse_iterator(begin()); }
  const_reverse_iterator rend() const { return const_reverse_iterator(begin());}

  size_type size_in_bytes() const { return size() * sizeof(T); }
  size_type max_size() const {
    return std::min(this->SizeTypeMax(), size_type(-1) / sizeof(T));
  }

  size_t capacity_in_bytes() const { return capacity() * sizeof(T); }


  pointer data() { return pointer(begin()); }

  const_pointer data() const { return const_pointer(begin()); }

  reference operator[](size_type idx) {
    (__builtin_expect(!(idx < size()), 0) ? __assert_rtn(__func__, "SmallVector.h", 294, "idx < size()") : (void)0);
    return begin()[idx];
  }
  const_reference operator[](size_type idx) const {
    (__builtin_expect(!(idx < size()), 0) ? __assert_rtn(__func__, "SmallVector.h", 298, "idx < size()") : (void)0);
    return begin()[idx];
  }

  reference front() {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 303, "!empty()") : (void)0);
    return begin()[0];
  }
  const_reference front() const {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 307, "!empty()") : (void)0);
    return begin()[0];
  }

  reference back() {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 312, "!empty()") : (void)0);
    return end()[-1];
  }
  const_reference back() const {
    (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "SmallVector.h", 316, "!empty()") : (void)0);
    return end()[-1];
  }
};
# 329 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <typename T, bool = (std::is_trivially_copy_constructible<T>::value) &&
                             (std::is_trivially_move_constructible<T>::value) &&
                             std::is_trivially_destructible<T>::value>
class SmallVectorTemplateBase : public SmallVectorTemplateCommon<T> {
  friend class SmallVectorTemplateCommon<T>;

protected:
  static constexpr bool TakesParamByValue = false;
  using ValueParamT = const T &;

  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}

  static void destroy_range(T *S, T *E) {
    while (S != E) {
      --E;
      E->~T();
    }
  }



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {
    std::uninitialized_move(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {
    std::uninitialized_copy(I, E, Dest);
  }




  void grow(size_t MinSize = 0);



  T *mallocForGrow(size_t MinSize, size_t &NewCapacity);



  void moveElementsForGrow(T *NewElts);


  void takeAllocationForGrow(T *NewElts, size_t NewCapacity);



  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {
    return this->reserveForParamAndGetAddressImpl(this, Elt, N);
  }



  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {
    return const_cast<T *>(
        this->reserveForParamAndGetAddressImpl(this, Elt, N));
  }

  static T &&forward_value_param(T &&V) { return std::move(V); }
  static const T &forward_value_param(const T &V) { return V; }

  void growAndAssign(size_t NumElts, const T &Elt) {

    size_t NewCapacity;
    T *NewElts = mallocForGrow(NumElts, NewCapacity);
    std::uninitialized_fill_n(NewElts, NumElts, Elt);
    this->destroy_range(this->begin(), this->end());
    takeAllocationForGrow(NewElts, NewCapacity);
    this->set_size(NumElts);
  }

  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {

    size_t NewCapacity;
    T *NewElts = mallocForGrow(0, NewCapacity);
    ::new ((void *)(NewElts + this->size())) T(std::forward<ArgTypes>(Args)...);
    moveElementsForGrow(NewElts);
    takeAllocationForGrow(NewElts, NewCapacity);
    this->set_size(this->size() + 1);
    return this->back();
  }

public:
  void push_back(const T &Elt) {
    const T *EltPtr = reserveForParamAndGetAddress(Elt);
    ::new ((void *)this->end()) T(*EltPtr);
    this->set_size(this->size() + 1);
  }

  void push_back(T &&Elt) {
    T *EltPtr = reserveForParamAndGetAddress(Elt);
    ::new ((void *)this->end()) T(::std::move(*EltPtr));
    this->set_size(this->size() + 1);
  }

  void pop_back() {
    this->set_size(this->size() - 1);
    this->end()->~T();
  }
};


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::grow(size_t MinSize) {
  size_t NewCapacity;
  T *NewElts = mallocForGrow(MinSize, NewCapacity);
  moveElementsForGrow(NewElts);
  takeAllocationForGrow(NewElts, NewCapacity);
}

template <typename T, bool TriviallyCopyable>
T *SmallVectorTemplateBase<T, TriviallyCopyable>::mallocForGrow(
    size_t MinSize, size_t &NewCapacity) {
  return static_cast<T *>(
      SmallVectorBase<SmallVectorSizeType<T>>::mallocForGrow(
          this->getFirstEl(), MinSize, sizeof(T), NewCapacity));
}


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::moveElementsForGrow(
    T *NewElts) {

  this->uninitialized_move(this->begin(), this->end(), NewElts);


  destroy_range(this->begin(), this->end());
}


template <typename T, bool TriviallyCopyable>
void SmallVectorTemplateBase<T, TriviallyCopyable>::takeAllocationForGrow(
    T *NewElts, size_t NewCapacity) {

  if (!this->isSmall())
    free(this->begin());

  this->BeginX = NewElts;
  this->Capacity = NewCapacity;
}





template <typename T>
class SmallVectorTemplateBase<T, true> : public SmallVectorTemplateCommon<T> {
  friend class SmallVectorTemplateCommon<T>;

protected:


  static constexpr bool TakesParamByValue = sizeof(T) <= 2 * sizeof(void *);



  using ValueParamT = std::conditional_t<TakesParamByValue, T, const T &>;

  SmallVectorTemplateBase(size_t Size) : SmallVectorTemplateCommon<T>(Size) {}


  static void destroy_range(T *, T *) {}



  template<typename It1, typename It2>
  static void uninitialized_move(It1 I, It1 E, It2 Dest) {

    uninitialized_copy(I, E, Dest);
  }



  template<typename It1, typename It2>
  static void uninitialized_copy(It1 I, It1 E, It2 Dest) {

    std::uninitialized_copy(I, E, Dest);
  }



  template <typename T1, typename T2>
  static void uninitialized_copy(
      T1 *I, T1 *E, T2 *Dest,
      std::enable_if_t<std::is_same<std::remove_const_t<T1>, T2>::value> * =
          nullptr) {




    if (I != E)
      memcpy(reinterpret_cast<void *>(Dest), I, (E - I) * sizeof(T));
  }



  void grow(size_t MinSize = 0) { this->grow_pod(MinSize, sizeof(T)); }



  const T *reserveForParamAndGetAddress(const T &Elt, size_t N = 1) {
    return this->reserveForParamAndGetAddressImpl(this, Elt, N);
  }



  T *reserveForParamAndGetAddress(T &Elt, size_t N = 1) {
    return const_cast<T *>(
        this->reserveForParamAndGetAddressImpl(this, Elt, N));
  }


  static ValueParamT forward_value_param(ValueParamT V) { return V; }

  void growAndAssign(size_t NumElts, T Elt) {


    this->set_size(0);
    this->grow(NumElts);
    std::uninitialized_fill_n(this->begin(), NumElts, Elt);
    this->set_size(NumElts);
  }

  template <typename... ArgTypes> T &growAndEmplaceBack(ArgTypes &&... Args) {



    push_back(T(std::forward<ArgTypes>(Args)...));
    return this->back();
  }

public:
  void push_back(ValueParamT Elt) {
    const T *EltPtr = reserveForParamAndGetAddress(Elt);
    memcpy(reinterpret_cast<void *>(this->end()), EltPtr, sizeof(T));
    this->set_size(this->size() + 1);
  }

  void pop_back() { this->set_size(this->size() - 1); }
};



template <typename T>
class SmallVectorImpl : public SmallVectorTemplateBase<T> {
  using SuperClass = SmallVectorTemplateBase<T>;

public:
  using iterator = typename SuperClass::iterator;
  using const_iterator = typename SuperClass::const_iterator;
  using reference = typename SuperClass::reference;
  using size_type = typename SuperClass::size_type;

protected:
  using SmallVectorTemplateBase<T>::TakesParamByValue;
  using ValueParamT = typename SuperClass::ValueParamT;


  explicit SmallVectorImpl(unsigned N)
      : SmallVectorTemplateBase<T>(N) {}

  void assignRemote(SmallVectorImpl &&RHS) {
    this->destroy_range(this->begin(), this->end());
    if (!this->isSmall())
      free(this->begin());
    this->BeginX = RHS.BeginX;
    this->Size = RHS.Size;
    this->Capacity = RHS.Capacity;
    RHS.resetToSmall();
  }

  ~SmallVectorImpl() {


    if (!this->isSmall())
      free(this->begin());
  }

public:
  SmallVectorImpl(const SmallVectorImpl &) = delete;

  void clear() {
    this->destroy_range(this->begin(), this->end());
    this->Size = 0;
  }

private:

  using SuperClass::set_size;

  template <bool ForOverwrite> void resizeImpl(size_type N) {
    if (N == this->size())
      return;

    if (N < this->size()) {
      this->truncate(N);
      return;
    }

    this->reserve(N);
    for (auto I = this->end(), E = this->begin() + N; I != E; ++I)
      if (ForOverwrite)
        new (&*I) T;
      else
        new (&*I) T();
    this->set_size(N);
  }

public:
  void resize(size_type N) { resizeImpl<false>(N); }


  void resize_for_overwrite(size_type N) { resizeImpl<true>(N); }


  void truncate(size_type N) {
    (__builtin_expect(!(this->size() >= N && "Cannot increase size with truncate"), 0) ? __assert_rtn(__func__, "SmallVector.h", 649, "this->size() >= N && \"Cannot increase size with truncate\"") : (void)0);
    this->destroy_range(this->begin() + N, this->end());
    this->set_size(N);
  }

  void resize(size_type N, ValueParamT NV) {
    if (N == this->size())
      return;

    if (N < this->size()) {
      this->truncate(N);
      return;
    }


    this->append(N - this->size(), NV);
  }

  void reserve(size_type N) {
    if (this->capacity() < N)
      this->grow(N);
  }

  void pop_back_n(size_type NumItems) {
    (__builtin_expect(!(this->size() >= NumItems), 0) ? __assert_rtn(__func__, "SmallVector.h", 673, "this->size() >= NumItems") : (void)0);
    truncate(this->size() - NumItems);
  }

  [[nodiscard]] T pop_back_val() {
    T Result = ::std::move(this->back());
    this->pop_back();
    return Result;
  }

  void swap(SmallVectorImpl &RHS);


  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  void append(ItTy in_start, ItTy in_end) {
    this->assertSafeToAddRange(in_start, in_end);
    size_type NumInputs = std::distance(in_start, in_end);
    this->reserve(this->size() + NumInputs);
    this->uninitialized_copy(in_start, in_end, this->end());
    this->set_size(this->size() + NumInputs);
  }


  void append(size_type NumInputs, ValueParamT Elt) {
    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumInputs);
    std::uninitialized_fill_n(this->end(), NumInputs, *EltPtr);
    this->set_size(this->size() + NumInputs);
  }

  void append(std::initializer_list<T> IL) {
    append(IL.begin(), IL.end());
  }

  void append(const SmallVectorImpl &RHS) { append(RHS.begin(), RHS.end()); }

  void assign(size_type NumElts, ValueParamT Elt) {

    if (NumElts > this->capacity()) {
      this->growAndAssign(NumElts, Elt);
      return;
    }


    std::fill_n(this->begin(), std::min(NumElts, this->size()), Elt);
    if (NumElts > this->size())
      std::uninitialized_fill_n(this->end(), NumElts - this->size(), Elt);
    else if (NumElts < this->size())
      this->destroy_range(this->begin() + NumElts, this->end());
    this->set_size(NumElts);
  }




  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  void assign(ItTy in_start, ItTy in_end) {
    this->assertSafeToReferenceAfterClear(in_start, in_end);
    clear();
    append(in_start, in_end);
  }

  void assign(std::initializer_list<T> IL) {
    clear();
    append(IL);
  }

  void assign(const SmallVectorImpl &RHS) { assign(RHS.begin(), RHS.end()); }

  iterator erase(const_iterator CI) {

    iterator I = const_cast<iterator>(CI);

    (__builtin_expect(!(this->isReferenceToStorage(CI) && "Iterator to erase is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 745, "this->isReferenceToStorage(CI) && \"Iterator to erase is out of bounds.\"") : (void)0);

    iterator N = I;

    std::move(I+1, this->end(), I);

    this->pop_back();
    return(N);
  }

  iterator erase(const_iterator CS, const_iterator CE) {

    iterator S = const_cast<iterator>(CS);
    iterator E = const_cast<iterator>(CE);

    (__builtin_expect(!(this->isRangeInStorage(S, E) && "Range to erase is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 760, "this->isRangeInStorage(S, E) && \"Range to erase is out of bounds.\"") : (void)0);

    iterator N = S;

    iterator I = std::move(E, this->end(), S);

    this->destroy_range(I, this->end());
    this->set_size(I - this->begin());
    return(N);
  }

private:
  template <class ArgType> iterator insert_one_impl(iterator I, ArgType &&Elt) {

    static_assert(
        std::is_same<std::remove_const_t<std::remove_reference_t<ArgType>>,
                     T>::value,
        "ArgType must be derived from T!");

    if (I == this->end()) {
      this->push_back(::std::forward<ArgType>(Elt));
      return this->end()-1;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 784, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);


    size_t Index = I - this->begin();
    std::remove_reference_t<ArgType> *EltPtr =
        this->reserveForParamAndGetAddress(Elt);
    I = this->begin() + Index;

    ::new ((void*) this->end()) T(::std::move(this->back()));

    std::move_backward(I, this->end()-1, this->end());
    this->set_size(this->size() + 1);



    static_assert(!TakesParamByValue || std::is_same<ArgType, T>::value,
                  "ArgType must be 'T' when taking by value!");
    if (!TakesParamByValue && this->isReferenceToRange(EltPtr, I, this->end()))
      ++EltPtr;

    *I = ::std::forward<ArgType>(*EltPtr);
    return I;
  }

public:
  iterator insert(iterator I, T &&Elt) {
    return insert_one_impl(I, this->forward_value_param(std::move(Elt)));
  }

  iterator insert(iterator I, const T &Elt) {
    return insert_one_impl(I, this->forward_value_param(Elt));
  }

  iterator insert(iterator I, size_type NumToInsert, ValueParamT Elt) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(NumToInsert, Elt);
      return this->begin()+InsertElt;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 826, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);



    const T *EltPtr = this->reserveForParamAndGetAddress(Elt, NumToInsert);


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(std::move_iterator<iterator>(this->end() - NumToInsert),
             std::move_iterator<iterator>(this->end()));


      std::move_backward(I, OldEnd-NumToInsert, OldEnd);



      if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())
        EltPtr += NumToInsert;

      std::fill_n(I, NumToInsert, *EltPtr);
      return I;
    }





    T *OldEnd = this->end();
    this->set_size(this->size() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);



    if (!TakesParamByValue && I <= EltPtr && EltPtr < this->end())
      EltPtr += NumToInsert;


    std::fill_n(I, NumOverwritten, *EltPtr);


    std::uninitialized_fill_n(OldEnd, NumToInsert - NumOverwritten, *EltPtr);
    return I;
  }

  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  iterator insert(iterator I, ItTy From, ItTy To) {

    size_t InsertElt = I - this->begin();

    if (I == this->end()) {
      append(From, To);
      return this->begin()+InsertElt;
    }

    (__builtin_expect(!(this->isReferenceToStorage(I) && "Insertion iterator is out of bounds."), 0) ? __assert_rtn(__func__, "SmallVector.h", 888, "this->isReferenceToStorage(I) && \"Insertion iterator is out of bounds.\"") : (void)0);


    this->assertSafeToAddRange(From, To);

    size_t NumToInsert = std::distance(From, To);


    reserve(this->size() + NumToInsert);


    I = this->begin()+InsertElt;





    if (size_t(this->end()-I) >= NumToInsert) {
      T *OldEnd = this->end();
      append(std::move_iterator<iterator>(this->end() - NumToInsert),
             std::move_iterator<iterator>(this->end()));


      std::move_backward(I, OldEnd-NumToInsert, OldEnd);

      std::copy(From, To, I);
      return I;
    }





    T *OldEnd = this->end();
    this->set_size(this->size() + NumToInsert);
    size_t NumOverwritten = OldEnd-I;
    this->uninitialized_move(I, OldEnd, this->end()-NumOverwritten);


    for (T *J = I; NumOverwritten > 0; --NumOverwritten) {
      *J = *From;
      ++J; ++From;
    }


    this->uninitialized_copy(From, To, OldEnd);
    return I;
  }

  void insert(iterator I, std::initializer_list<T> IL) {
    insert(I, IL.begin(), IL.end());
  }

  template <typename... ArgTypes> reference emplace_back(ArgTypes &&... Args) {
    if (__builtin_expect((bool)(this->size() >= this->capacity()), false))
      return this->growAndEmplaceBack(std::forward<ArgTypes>(Args)...);

    ::new ((void *)this->end()) T(std::forward<ArgTypes>(Args)...);
    this->set_size(this->size() + 1);
    return this->back();
  }

  SmallVectorImpl &operator=(const SmallVectorImpl &RHS);

  SmallVectorImpl &operator=(SmallVectorImpl &&RHS);

  bool operator==(const SmallVectorImpl &RHS) const {
    if (this->size() != RHS.size()) return false;
    return std::equal(this->begin(), this->end(), RHS.begin());
  }
  bool operator!=(const SmallVectorImpl &RHS) const {
    return !(*this == RHS);
  }

  bool operator<(const SmallVectorImpl &RHS) const {
    return std::lexicographical_compare(this->begin(), this->end(),
                                        RHS.begin(), RHS.end());
  }
  bool operator>(const SmallVectorImpl &RHS) const { return RHS < *this; }
  bool operator<=(const SmallVectorImpl &RHS) const { return !(*this > RHS); }
  bool operator>=(const SmallVectorImpl &RHS) const { return !(*this < RHS); }
};

template <typename T>
void SmallVectorImpl<T>::swap(SmallVectorImpl<T> &RHS) {
  if (this == &RHS) return;


  if (!this->isSmall() && !RHS.isSmall()) {
    std::swap(this->BeginX, RHS.BeginX);
    std::swap(this->Size, RHS.Size);
    std::swap(this->Capacity, RHS.Capacity);
    return;
  }
  this->reserve(RHS.size());
  RHS.reserve(this->size());


  size_t NumShared = this->size();
  if (NumShared > RHS.size()) NumShared = RHS.size();
  for (size_type i = 0; i != NumShared; ++i)
    std::swap((*this)[i], RHS[i]);


  if (this->size() > RHS.size()) {
    size_t EltDiff = this->size() - RHS.size();
    this->uninitialized_copy(this->begin()+NumShared, this->end(), RHS.end());
    RHS.set_size(RHS.size() + EltDiff);
    this->destroy_range(this->begin()+NumShared, this->end());
    this->set_size(NumShared);
  } else if (RHS.size() > this->size()) {
    size_t EltDiff = RHS.size() - this->size();
    this->uninitialized_copy(RHS.begin()+NumShared, RHS.end(), this->end());
    this->set_size(this->size() + EltDiff);
    this->destroy_range(RHS.begin()+NumShared, RHS.end());
    RHS.set_size(NumShared);
  }
}

template <typename T>
SmallVectorImpl<T> &SmallVectorImpl<T>::
  operator=(const SmallVectorImpl<T> &RHS) {

  if (this == &RHS) return *this;



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd;
    if (RHSSize)
      NewEnd = std::copy(RHS.begin(), RHS.begin()+RHSSize, this->begin());
    else
      NewEnd = this->begin();


    this->destroy_range(NewEnd, this->end());


    this->set_size(RHSSize);
    return *this;
  }




  if (this->capacity() < RHSSize) {

    this->clear();
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::copy(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_copy(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->set_size(RHSSize);
  return *this;
}

template <typename T>
SmallVectorImpl<T> &SmallVectorImpl<T>::operator=(SmallVectorImpl<T> &&RHS) {

  if (this == &RHS) return *this;


  if (!RHS.isSmall()) {
    this->assignRemote(std::move(RHS));
    return *this;
  }



  size_t RHSSize = RHS.size();
  size_t CurSize = this->size();
  if (CurSize >= RHSSize) {

    iterator NewEnd = this->begin();
    if (RHSSize)
      NewEnd = std::move(RHS.begin(), RHS.end(), NewEnd);


    this->destroy_range(NewEnd, this->end());
    this->set_size(RHSSize);


    RHS.clear();

    return *this;
  }





  if (this->capacity() < RHSSize) {

    this->clear();
    CurSize = 0;
    this->grow(RHSSize);
  } else if (CurSize) {

    std::move(RHS.begin(), RHS.begin()+CurSize, this->begin());
  }


  this->uninitialized_move(RHS.begin()+CurSize, RHS.end(),
                           this->begin()+CurSize);


  this->set_size(RHSSize);

  RHS.clear();
  return *this;
}



template <typename T, unsigned N>
struct SmallVectorStorage {
  alignas(T) char InlineElts[N * sizeof(T)];
};




template <typename T> struct alignas(T) SmallVectorStorage<T, 0> {};




template <typename T, unsigned N> class [[gsl::Owner]] SmallVector;






template <typename T> struct CalculateSmallVectorDefaultInlinedElements {







  static constexpr size_t kPreferredSmallVectorSizeof = 64;
# 1165 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
  static_assert(
      sizeof(T) <= 256,
      "You are trying to use a default number of inlined elements for "
      "`SmallVector<T>` but `sizeof(T)` is really big! Please use an "
      "explicit number of inlined elements with `SmallVector<T, N>` to make "
      "sure you really want that much inline storage.");



  static constexpr size_t PreferredInlineBytes =
      kPreferredSmallVectorSizeof - sizeof(SmallVector<T, 0>);
  static constexpr size_t NumElementsThatFit = PreferredInlineBytes / sizeof(T);
  static constexpr size_t value =
      NumElementsThatFit == 0 ? 1 : NumElementsThatFit;
};
# 1197 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/SmallVector.h"
template <typename T,
          unsigned N = CalculateSmallVectorDefaultInlinedElements<T>::value>
class [[gsl::Owner]] SmallVector : public SmallVectorImpl<T>,
                                   SmallVectorStorage<T, N> {
public:
  SmallVector() : SmallVectorImpl<T>(N) {}

  ~SmallVector() {

    this->destroy_range(this->begin(), this->end());
  }

  explicit SmallVector(size_t Size)
    : SmallVectorImpl<T>(N) {
    this->resize(Size);
  }

  SmallVector(size_t Size, const T &Value)
    : SmallVectorImpl<T>(N) {
    this->assign(Size, Value);
  }

  template <typename ItTy, typename = EnableIfConvertibleToInputIterator<ItTy>>
  SmallVector(ItTy S, ItTy E) : SmallVectorImpl<T>(N) {
    this->append(S, E);
  }

  template <typename RangeTy>
  explicit SmallVector(const iterator_range<RangeTy> &R)
      : SmallVectorImpl<T>(N) {
    this->append(R.begin(), R.end());
  }

  SmallVector(std::initializer_list<T> IL) : SmallVectorImpl<T>(N) {
    this->append(IL);
  }

  template <typename U,
            typename = std::enable_if_t<std::is_convertible<U, T>::value>>
  explicit SmallVector(ArrayRef<U> A) : SmallVectorImpl<T>(N) {
    this->append(A.begin(), A.end());
  }

  SmallVector(const SmallVector &RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(RHS);
  }

  SmallVector &operator=(const SmallVector &RHS) {
    SmallVectorImpl<T>::operator=(RHS);
    return *this;
  }

  SmallVector(SmallVector &&RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(::std::move(RHS));
  }

  SmallVector(SmallVectorImpl<T> &&RHS) : SmallVectorImpl<T>(N) {
    if (!RHS.empty())
      SmallVectorImpl<T>::operator=(::std::move(RHS));
  }

  SmallVector &operator=(SmallVector &&RHS) {
    if (N) {
      SmallVectorImpl<T>::operator=(::std::move(RHS));
      return *this;
    }


    if (this == &RHS)
      return *this;
    if (RHS.empty()) {
      this->destroy_range(this->begin(), this->end());
      this->Size = 0;
    } else {
      this->assignRemote(std::move(RHS));
    }
    return *this;
  }

  SmallVector &operator=(SmallVectorImpl<T> &&RHS) {
    SmallVectorImpl<T>::operator=(::std::move(RHS));
    return *this;
  }

  SmallVector &operator=(std::initializer_list<T> IL) {
    this->assign(IL);
    return *this;
  }
};

template <typename T, unsigned N>
inline size_t capacity_in_bytes(const SmallVector<T, N> &X) {
  return X.capacity_in_bytes();
}

template <typename RangeType>
using ValueTypeFromRangeType =
    std::remove_const_t<std::remove_reference_t<decltype(*std::begin(
        std::declval<RangeType &>()))>>;




template <unsigned Size, typename R>
SmallVector<ValueTypeFromRangeType<R>, Size> to_vector(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}
template <typename R>
SmallVector<ValueTypeFromRangeType<R>> to_vector(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}

template <typename Out, unsigned Size, typename R>
SmallVector<Out, Size> to_vector_of(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}

template <typename Out, typename R> SmallVector<Out> to_vector_of(R &&Range) {
  return {std::begin(Range), std::end(Range)};
}


extern template class llvm::SmallVectorBase<uint32_t>;

extern template class llvm::SmallVectorBase<uint64_t>;


}

namespace std {


  template<typename T>
  inline void
  swap(llvm::SmallVectorImpl<T> &LHS, llvm::SmallVectorImpl<T> &RHS) {
    LHS.swap(RHS);
  }


  template<typename T, unsigned N>
  inline void
  swap(llvm::SmallVector<T, N> &LHS, llvm::SmallVector<T, N> &RHS) {
    LHS.swap(RHS);
  }

}
# 14 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ADL.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ADL.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ADL.h" 2



namespace llvm {



template <typename T, T> struct SameType;

namespace adl_detail {

using std::begin;

template <typename RangeT>
constexpr auto begin_impl(RangeT &&range)
    -> decltype(begin(std::forward<RangeT>(range))) {
  return begin(std::forward<RangeT>(range));
}

using std::end;

template <typename RangeT>
constexpr auto end_impl(RangeT &&range)
    -> decltype(end(std::forward<RangeT>(range))) {
  return end(std::forward<RangeT>(range));
}

using std::swap;

template <typename T>
constexpr void swap_impl(T &&lhs,
                         T &&rhs) noexcept(noexcept(swap(std::declval<T>(),
                                                         std::declval<T>()))) {
  swap(std::forward<T>(lhs), std::forward<T>(rhs));
}

using std::size;

template <typename RangeT>
constexpr auto size_impl(RangeT &&range)
    -> decltype(size(std::forward<RangeT>(range))) {
  return size(std::forward<RangeT>(range));
}

}



template <typename RangeT>
constexpr auto adl_begin(RangeT &&range)
    -> decltype(adl_detail::begin_impl(std::forward<RangeT>(range))) {
  return adl_detail::begin_impl(std::forward<RangeT>(range));
}



template <typename RangeT>
constexpr auto adl_end(RangeT &&range)
    -> decltype(adl_detail::end_impl(std::forward<RangeT>(range))) {
  return adl_detail::end_impl(std::forward<RangeT>(range));
}



template <typename T>
constexpr void adl_swap(T &&lhs, T &&rhs) noexcept(
    noexcept(adl_detail::swap_impl(std::declval<T>(), std::declval<T>()))) {
  adl_detail::swap_impl(std::forward<T>(lhs), std::forward<T>(rhs));
}



template <typename RangeT>
constexpr auto adl_size(RangeT &&range)
    -> decltype(adl_detail::size_impl(std::forward<RangeT>(range))) {
  return adl_detail::size_impl(std::forward<RangeT>(range));
}

namespace detail {

template <typename RangeT>
using IterOfRange = decltype(adl_begin(std::declval<RangeT &>()));

template <typename RangeT>
using ValueOfRange =
    std::remove_reference_t<decltype(*adl_begin(std::declval<RangeT &>()))>;

}
}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h" 2


namespace llvm {
# 36 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLFunctionalExtras.h"
template<typename Fn> class function_ref;

template<typename Ret, typename ...Params>
class function_ref<Ret(Params...)> {
  Ret (*callback)(intptr_t callable, Params ...params) = nullptr;
  intptr_t callable;

  template<typename Callable>
  static Ret callback_fn(intptr_t callable, Params ...params) {
    return (*reinterpret_cast<Callable*>(callable))(
        std::forward<Params>(params)...);
  }

public:
  function_ref() = default;
  function_ref(std::nullptr_t) {}

  template <typename Callable>
  function_ref(
      Callable &&callable,

      std::enable_if_t<!std::is_same<remove_cvref_t<Callable>,
                                     function_ref>::value> * = nullptr,

      std::enable_if_t<std::is_void<Ret>::value ||
                       std::is_convertible<decltype(std::declval<Callable>()(
                                               std::declval<Params>()...)),
                                           Ret>::value> * = nullptr)
      : callback(callback_fn<std::remove_reference_t<Callable>>),
        callable(reinterpret_cast<intptr_t>(&callable)) {}

  Ret operator()(Params ...params) const {
    return callback(callable, std::forward<Params>(params)...);
  }

  explicit operator bool() const { return callback; }
};

}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator_range.h" 1
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator_range.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator_range.h" 2


namespace llvm {

template <typename From, typename To, typename = void>
struct explicitly_convertible : std::false_type {};

template <typename From, typename To>
struct explicitly_convertible<
    From, To,
    std::void_t<decltype(static_cast<To>(
        std::declval<std::add_rvalue_reference_t<From>>()))>> : std::true_type {
};





template <typename IteratorT>
class iterator_range {
  IteratorT begin_iterator, end_iterator;

public:





  template <typename Container,
            std::enable_if_t<explicitly_convertible<
                detail::IterOfRange<Container>, IteratorT>::value> * = nullptr>

  iterator_range(Container &&c)
      : begin_iterator(adl_begin(c)), end_iterator(adl_end(c)) {
  }
  iterator_range(IteratorT begin_iterator, IteratorT end_iterator)
      : begin_iterator(std::move(begin_iterator)),
        end_iterator(std::move(end_iterator)) {}

  IteratorT begin() const { return begin_iterator; }
  IteratorT end() const { return end_iterator; }
  bool empty() const { return begin_iterator == end_iterator; }
};

template <typename Container>
iterator_range(Container &&) -> iterator_range<detail::IterOfRange<Container>>;





template <class T> iterator_range<T> make_range(T x, T y) {
  return iterator_range<T>(std::move(x), std::move(y));
}

template <typename T> iterator_range<T> make_range(std::pair<T, T> p) {
  return iterator_range<T>(std::move(p.first), std::move(p.second));
}

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h" 2


namespace llvm {
# 77 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
template <typename DerivedT, typename IteratorCategoryT, typename T,
          typename DifferenceTypeT = std::ptrdiff_t, typename PointerT = T *,
          typename ReferenceT = T &>
class iterator_facade_base {
public:
  using iterator_category = IteratorCategoryT;
  using value_type = T;
  using difference_type = DifferenceTypeT;
  using pointer = PointerT;
  using reference = ReferenceT;

protected:
  enum {
    IsRandomAccess = std::is_base_of<std::random_access_iterator_tag,
                                     IteratorCategoryT>::value,
    IsBidirectional = std::is_base_of<std::bidirectional_iterator_tag,
                                      IteratorCategoryT>::value,
  };






  class ReferenceProxy {
    friend iterator_facade_base;

    DerivedT I;

    ReferenceProxy(DerivedT I) : I(std::move(I)) {}

  public:
    operator ReferenceT() const { return *I; }
  };





  class PointerProxy {
    friend iterator_facade_base;

    ReferenceT R;

    template <typename RefT>
    PointerProxy(RefT &&R) : R(std::forward<RefT>(R)) {}

  public:
    PointerT operator->() const { return &R; }
  };

public:
  DerivedT operator+(DifferenceTypeT n) const {
    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
    static_assert(
        IsRandomAccess,
        "The '+' operator is only defined for random access iterators.");
    DerivedT tmp = *static_cast<const DerivedT *>(this);
    tmp += n;
    return tmp;
  }
  friend DerivedT operator+(DifferenceTypeT n, const DerivedT &i) {
    static_assert(
        IsRandomAccess,
        "The '+' operator is only defined for random access iterators.");
    return i + n;
  }
  DerivedT operator-(DifferenceTypeT n) const {
    static_assert(
        IsRandomAccess,
        "The '-' operator is only defined for random access iterators.");
    DerivedT tmp = *static_cast<const DerivedT *>(this);
    tmp -= n;
    return tmp;
  }

  DerivedT &operator++() {
    static_assert(std::is_base_of<iterator_facade_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
    return static_cast<DerivedT *>(this)->operator+=(1);
  }
  DerivedT operator++(int) {
    DerivedT tmp = *static_cast<DerivedT *>(this);
    ++*static_cast<DerivedT *>(this);
    return tmp;
  }
  DerivedT &operator--() {
    static_assert(
        IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    return static_cast<DerivedT *>(this)->operator-=(1);
  }
  DerivedT operator--(int) {
    static_assert(
        IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    DerivedT tmp = *static_cast<DerivedT *>(this);
    --*static_cast<DerivedT *>(this);
    return tmp;
  }


  bool operator!=(const DerivedT &RHS) const {
    return !(static_cast<const DerivedT &>(*this) == RHS);
  }


  bool operator>(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) < RHS) &&
           !(static_cast<const DerivedT &>(*this) == RHS);
  }
  bool operator<=(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) > RHS);
  }
  bool operator>=(const DerivedT &RHS) const {
    static_assert(
        IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return !(static_cast<const DerivedT &>(*this) < RHS);
  }

  PointerProxy operator->() const {
    return static_cast<const DerivedT *>(this)->operator*();
  }
  ReferenceProxy operator[](DifferenceTypeT n) const {
    static_assert(IsRandomAccess,
                  "Subscripting is only defined for random access iterators.");
    return static_cast<const DerivedT *>(this)->operator+(n);
  }
};






template <
    typename DerivedT, typename WrappedIteratorT,
    typename IteratorCategoryT =
        typename std::iterator_traits<WrappedIteratorT>::iterator_category,
    typename T = typename std::iterator_traits<WrappedIteratorT>::value_type,
    typename DifferenceTypeT =
        typename std::iterator_traits<WrappedIteratorT>::difference_type,
    typename PointerT = std::conditional_t<
        std::is_same<T, typename std::iterator_traits<
                            WrappedIteratorT>::value_type>::value,
        typename std::iterator_traits<WrappedIteratorT>::pointer, T *>,
    typename ReferenceT = std::conditional_t<
        std::is_same<T, typename std::iterator_traits<
                            WrappedIteratorT>::value_type>::value,
        typename std::iterator_traits<WrappedIteratorT>::reference, T &>>
class iterator_adaptor_base
    : public iterator_facade_base<DerivedT, IteratorCategoryT, T,
                                  DifferenceTypeT, PointerT, ReferenceT> {
  using BaseT = typename iterator_adaptor_base::iterator_facade_base;

protected:
  WrappedIteratorT I;

  iterator_adaptor_base() = default;

  explicit iterator_adaptor_base(WrappedIteratorT u) : I(std::move(u)) {
    static_assert(std::is_base_of<iterator_adaptor_base, DerivedT>::value,
                  "Must pass the derived type to this template!");
  }

  const WrappedIteratorT &wrapped() const { return I; }

public:
  using difference_type = DifferenceTypeT;

  DerivedT &operator+=(difference_type n) {
    static_assert(
        BaseT::IsRandomAccess,
        "The '+=' operator is only defined for random access iterators.");
    I += n;
    return *static_cast<DerivedT *>(this);
  }
  DerivedT &operator-=(difference_type n) {
    static_assert(
        BaseT::IsRandomAccess,
        "The '-=' operator is only defined for random access iterators.");
    I -= n;
    return *static_cast<DerivedT *>(this);
  }
  using BaseT::operator-;
  difference_type operator-(const DerivedT &RHS) const {
    static_assert(
        BaseT::IsRandomAccess,
        "The '-' operator is only defined for random access iterators.");
    return I - RHS.I;
  }



  using BaseT::operator++;
  DerivedT &operator++() {
    ++I;
    return *static_cast<DerivedT *>(this);
  }
  using BaseT::operator--;
  DerivedT &operator--() {
    static_assert(
        BaseT::IsBidirectional,
        "The decrement operator is only defined for bidirectional iterators.");
    --I;
    return *static_cast<DerivedT *>(this);
  }

  friend bool operator==(const iterator_adaptor_base &LHS,
                         const iterator_adaptor_base &RHS) {
    return LHS.I == RHS.I;
  }
  friend bool operator<(const iterator_adaptor_base &LHS,
                        const iterator_adaptor_base &RHS) {
    static_assert(
        BaseT::IsRandomAccess,
        "Relational operators are only defined for random access iterators.");
    return LHS.I < RHS.I;
  }

  ReferenceT operator*() const { return *I; }
};
# 317 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/iterator.h"
template <typename WrappedIteratorT,
          typename T = std::remove_reference_t<decltype(
              **std::declval<WrappedIteratorT>())>>
struct pointee_iterator
    : iterator_adaptor_base<
          pointee_iterator<WrappedIteratorT, T>, WrappedIteratorT,
          typename std::iterator_traits<WrappedIteratorT>::iterator_category,
          T> {
  pointee_iterator() = default;
  template <typename U>
  pointee_iterator(U &&u)
      : pointee_iterator::iterator_adaptor_base(std::forward<U &&>(u)) {}

  T &operator*() const { return **this->I; }
};

template <typename RangeT, typename WrappedIteratorT =
                               decltype(std::begin(std::declval<RangeT>()))>
iterator_range<pointee_iterator<WrappedIteratorT>>
make_pointee_range(RangeT &&Range) {
  using PointeeIteratorT = pointee_iterator<WrappedIteratorT>;
  return make_range(PointeeIteratorT(std::begin(std::forward<RangeT>(Range))),
                    PointeeIteratorT(std::end(std::forward<RangeT>(Range))));
}

template <typename WrappedIteratorT,
          typename T = decltype(&*std::declval<WrappedIteratorT>())>
class pointer_iterator
    : public iterator_adaptor_base<
          pointer_iterator<WrappedIteratorT, T>, WrappedIteratorT,
          typename std::iterator_traits<WrappedIteratorT>::iterator_category,
          T> {
  mutable T Ptr;

public:
  pointer_iterator() = default;

  explicit pointer_iterator(WrappedIteratorT u)
      : pointer_iterator::iterator_adaptor_base(std::move(u)) {}

  T &operator*() const { return Ptr = &*this->I; }
};

template <typename RangeT, typename WrappedIteratorT =
                               decltype(std::begin(std::declval<RangeT>()))>
iterator_range<pointer_iterator<WrappedIteratorT>>
make_pointer_range(RangeT &&Range) {
  using PointerIteratorT = pointer_iterator<WrappedIteratorT>;
  return make_range(PointerIteratorT(std::begin(std::forward<RangeT>(Range))),
                    PointerIteratorT(std::end(std::forward<RangeT>(Range))));
}

template <typename WrappedIteratorT,
          typename T1 = std::remove_reference_t<decltype(
              **std::declval<WrappedIteratorT>())>,
          typename T2 = std::add_pointer_t<T1>>
using raw_pointer_iterator =
    pointer_iterator<pointee_iterator<WrappedIteratorT, T1>, T2>;

}
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h" 1
# 44 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Config/abi-breaking.h"
namespace llvm {

extern int EnableABIBreakingChecks;
__attribute__ ((visibility("hidden")))
__attribute__((weak)) int *VerifyEnableABIBreakingChecks =
    &EnableABIBreakingChecks;






}
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 38 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 41 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h" 2






namespace llvm {





template <typename T> struct make_const_ptr {
  using type = std::add_pointer_t<std::add_const_t<T>>;
};

template <typename T> struct make_const_ref {
  using type = std::add_lvalue_reference_t<std::add_const_t<T>>;
};

namespace detail {
template <class, template <class...> class Op, class... Args> struct detector {
  using value_t = std::false_type;
};
template <template <class...> class Op, class... Args>
struct detector<std::void_t<Op<Args...>>, Op, Args...> {
  using value_t = std::true_type;
};
}
# 78 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <template <class...> class Op, class... Args>
using is_detected = typename detail::detector<void, Op, Args...>::value_t;





template <typename T, bool isClass = std::is_class<T>::value>
struct function_traits : public function_traits<decltype(&T::operator())> {};


template <typename ClassType, typename ReturnType, typename... Args>
struct function_traits<ReturnType (ClassType::*)(Args...) const, false> {

  enum { num_args = sizeof...(Args) };


  using result_t = ReturnType;


  template <size_t Index>
  using arg_t = std::tuple_element_t<Index, std::tuple<Args...>>;
};

template <typename ClassType, typename ReturnType, typename... Args>
struct function_traits<ReturnType (ClassType::*)(Args...), false>
    : public function_traits<ReturnType (ClassType::*)(Args...) const> {};

template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (*)(Args...), false> {

  enum { num_args = sizeof...(Args) };


  using result_t = ReturnType;


  template <size_t i>
  using arg_t = std::tuple_element_t<i, std::tuple<Args...>>;
};
template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (*const)(Args...), false>
    : public function_traits<ReturnType (*)(Args...)> {};

template <typename ReturnType, typename... Args>
struct function_traits<ReturnType (&)(Args...), false>
    : public function_traits<ReturnType (*)(Args...)> {};



template <typename T, typename... Ts>
using is_one_of = std::disjunction<std::is_same<T, Ts>...>;



template <typename T, typename... Ts>
using are_base_of = std::conjunction<std::is_base_of<T, Ts>...>;

namespace detail {
template <typename T, typename... Us> struct TypesAreDistinct;
template <typename T, typename... Us>
struct TypesAreDistinct
    : std::integral_constant<bool, !is_one_of<T, Us...>::value &&
                                       TypesAreDistinct<Us...>::value> {};
template <typename T> struct TypesAreDistinct<T> : std::true_type {};
}
# 152 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... Ts> struct TypesAreDistinct;
template <> struct TypesAreDistinct<> : std::true_type {};
template <typename... Ts>
struct TypesAreDistinct
    : std::integral_constant<bool, detail::TypesAreDistinct<Ts...>::value> {};
# 168 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T, typename... Us> struct FirstIndexOfType;
template <typename T, typename U, typename... Us>
struct FirstIndexOfType<T, U, Us...>
    : std::integral_constant<size_t, 1 + FirstIndexOfType<T, Us...>::value> {};
template <typename T, typename... Us>
struct FirstIndexOfType<T, T, Us...> : std::integral_constant<size_t, 0> {};




template <size_t I, typename... Ts>
using TypeAtIndex = std::tuple_element_t<I, std::tuple<Ts...>>;



template <typename EnumTy1, typename EnumTy2,
          typename UT1 = std::enable_if_t<std::is_enum<EnumTy1>::value,
                                          std::underlying_type_t<EnumTy1>>,
          typename UT2 = std::enable_if_t<std::is_enum<EnumTy2>::value,
                                          std::underlying_type_t<EnumTy2>>>
constexpr auto addEnumValues(EnumTy1 LHS, EnumTy2 RHS) {
  return static_cast<UT1>(LHS) + static_cast<UT2>(RHS);
}





namespace callable_detail {
# 208 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T,
          bool = std::is_function_v<std::remove_pointer_t<remove_cvref_t<T>>>>
class Callable {
  using value_type = std::remove_reference_t<T>;
  using reference = value_type &;
  using const_reference = value_type const &;

  std::optional<value_type> Obj;

  static_assert(!std::is_pointer_v<value_type>,
                "Pointers to non-functions are not callable.");

public:
  Callable() = default;
  Callable(T const &O) : Obj(std::in_place, O) {}

  Callable(Callable const &Other) = default;
  Callable(Callable &&Other) = default;

  Callable &operator=(Callable const &Other) {
    Obj = std::nullopt;
    if (Other.Obj)
      Obj.emplace(*Other.Obj);
    return *this;
  }

  Callable &operator=(Callable &&Other) {
    Obj = std::nullopt;
    if (Other.Obj)
      Obj.emplace(std::move(*Other.Obj));
    return *this;
  }

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) {
    return (*Obj)(std::forward<Pn>(Params)...);
  }

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T const, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) const {
    return (*Obj)(std::forward<Pn>(Params)...);
  }

  bool valid() const { return Obj != std::nullopt; }
  bool reset() { return Obj = std::nullopt; }

  operator reference() { return *Obj; }
  operator const_reference() const { return *Obj; }
};



template <typename T> class Callable<T, true> {
  static constexpr bool IsPtr = std::is_pointer_v<remove_cvref_t<T>>;

  using StorageT = std::conditional_t<IsPtr, T, std::remove_reference_t<T> *>;
  using CastT = std::conditional_t<IsPtr, T, T &>;

private:
  StorageT Func = nullptr;

private:
  template <typename In> static constexpr auto convertIn(In &&I) {
    if constexpr (IsPtr) {

      return I;
    } else {

      return &I;
    }
  }

public:
  Callable() = default;





  template <
    typename FnPtrOrRef,
    std::enable_if_t<
      !std::is_same_v<remove_cvref_t<FnPtrOrRef>, Callable>, int
    > = 0
  >
  Callable(FnPtrOrRef &&F) : Func(convertIn(F)) {}

  template <typename... Pn,
            std::enable_if_t<std::is_invocable_v<T, Pn...>, int> = 0>
  decltype(auto) operator()(Pn &&...Params) const {
    return Func(std::forward<Pn>(Params)...);
  }

  bool valid() const { return Func != nullptr; }
  void reset() { Func = nullptr; }

  operator T const &() const {
    if constexpr (IsPtr) {

      return Func;
    } else {
      static_assert(std::is_reference_v<T>,
                    "Expected a reference to a function.");

      return *Func;
    }
  }
};

}


template <typename ContainerTy> bool hasSingleElement(ContainerTy &&C) {
  auto B = std::begin(C), E = std::end(C);
  return B != E && std::next(B) == E;
}



template <typename T> auto drop_begin(T &&RangeOrContainer, size_t N = 1) {
  return make_range(std::next(adl_begin(RangeOrContainer), N),
                    adl_end(RangeOrContainer));
}



template <typename T> auto drop_end(T &&RangeOrContainer, size_t N = 1) {
  return make_range(adl_begin(RangeOrContainer),
                    std::prev(adl_end(RangeOrContainer), N));
}




template <typename ItTy, typename FuncTy,
          typename ReferenceTy =
              decltype(std::declval<FuncTy>()(*std::declval<ItTy>()))>
class mapped_iterator
    : public iterator_adaptor_base<
          mapped_iterator<ItTy, FuncTy>, ItTy,
          typename std::iterator_traits<ItTy>::iterator_category,
          std::remove_reference_t<ReferenceTy>,
          typename std::iterator_traits<ItTy>::difference_type,
          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
public:
  mapped_iterator() = default;
  mapped_iterator(ItTy U, FuncTy F)
    : mapped_iterator::iterator_adaptor_base(std::move(U)), F(std::move(F)) {}

  ItTy getCurrent() { return this->I; }

  const FuncTy &getFunction() const { return F; }

  ReferenceTy operator*() const { return F(*this->I); }

private:
  callable_detail::Callable<FuncTy> F{};
};



template <class ItTy, class FuncTy>
inline mapped_iterator<ItTy, FuncTy> map_iterator(ItTy I, FuncTy F) {
  return mapped_iterator<ItTy, FuncTy>(std::move(I), std::move(F));
}

template <class ContainerTy, class FuncTy>
auto map_range(ContainerTy &&C, FuncTy F) {
  return make_range(map_iterator(std::begin(C), F),
                    map_iterator(std::end(C), F));
}






template <typename DerivedT, typename ItTy, typename ReferenceTy>
class mapped_iterator_base
    : public iterator_adaptor_base<
          DerivedT, ItTy,
          typename std::iterator_traits<ItTy>::iterator_category,
          std::remove_reference_t<ReferenceTy>,
          typename std::iterator_traits<ItTy>::difference_type,
          std::remove_reference_t<ReferenceTy> *, ReferenceTy> {
public:
  using BaseT = mapped_iterator_base;

  mapped_iterator_base(ItTy U)
      : mapped_iterator_base::iterator_adaptor_base(std::move(U)) {}

  ItTy getCurrent() { return this->I; }

  ReferenceTy operator*() const {
    return static_cast<const DerivedT &>(*this).mapElement(*this->I);
  }
};


template <typename Ty> class has_rbegin_impl {
  using yes = char[1];
  using no = char[2];

  template <typename Inner>
  static yes& test(Inner *I, decltype(I->rbegin()) * = nullptr);

  template <typename>
  static no& test(...);

public:
  static const bool value = sizeof(test<Ty>(nullptr)) == sizeof(yes);
};


template <typename Ty>
struct has_rbegin : has_rbegin_impl<std::remove_reference_t<Ty>> {};


template <typename ContainerTy> auto reverse(ContainerTy &&C) {
  if constexpr (has_rbegin<ContainerTy>::value)
    return make_range(C.rbegin(), C.rend());
  else
    return make_range(std::make_reverse_iterator(std::end(C)),
                      std::make_reverse_iterator(std::begin(C)));
}
# 452 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename WrappedIteratorT, typename PredicateT, typename IterTag>
class filter_iterator_base
    : public iterator_adaptor_base<
          filter_iterator_base<WrappedIteratorT, PredicateT, IterTag>,
          WrappedIteratorT,
          std::common_type_t<IterTag,
                             typename std::iterator_traits<
                                 WrappedIteratorT>::iterator_category>> {
  using BaseT = typename filter_iterator_base::iterator_adaptor_base;

protected:
  WrappedIteratorT End;
  PredicateT Pred;

  void findNextValid() {
    while (this->I != End && !Pred(*this->I))
      BaseT::operator++();
  }

  filter_iterator_base() = default;




  filter_iterator_base(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : BaseT(Begin), End(End), Pred(Pred) {
    findNextValid();
  }

public:
  using BaseT::operator++;

  filter_iterator_base &operator++() {
    BaseT::operator++();
    findNextValid();
    return *this;
  }

  decltype(auto) operator*() const {
    (__builtin_expect(!(BaseT::wrapped() != End && "Cannot dereference end iterator!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 492, "BaseT::wrapped() != End && \"Cannot dereference end iterator!\"") : (void)0);
    return BaseT::operator*();
  }

  decltype(auto) operator->() const {
    (__builtin_expect(!(BaseT::wrapped() != End && "Cannot dereference end iterator!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 497, "BaseT::wrapped() != End && \"Cannot dereference end iterator!\"") : (void)0);
    return BaseT::operator->();
  }
};


template <typename WrappedIteratorT, typename PredicateT,
          typename IterTag = std::forward_iterator_tag>
class filter_iterator_impl
    : public filter_iterator_base<WrappedIteratorT, PredicateT, IterTag> {
public:
  filter_iterator_impl() = default;

  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : filter_iterator_impl::filter_iterator_base(Begin, End, Pred) {}
};


template <typename WrappedIteratorT, typename PredicateT>
class filter_iterator_impl<WrappedIteratorT, PredicateT,
                           std::bidirectional_iterator_tag>
    : public filter_iterator_base<WrappedIteratorT, PredicateT,
                                  std::bidirectional_iterator_tag> {
  using BaseT = typename filter_iterator_impl::filter_iterator_base;

  void findPrevValid() {
    while (!this->Pred(*this->I))
      BaseT::operator--();
  }

public:
  using BaseT::operator--;

  filter_iterator_impl() = default;

  filter_iterator_impl(WrappedIteratorT Begin, WrappedIteratorT End,
                       PredicateT Pred)
      : BaseT(Begin, End, Pred) {}

  filter_iterator_impl &operator--() {
    BaseT::operator--();
    findPrevValid();
    return *this;
  }
};

namespace detail {

template <bool is_bidirectional> struct fwd_or_bidi_tag_impl {
  using type = std::forward_iterator_tag;
};

template <> struct fwd_or_bidi_tag_impl<true> {
  using type = std::bidirectional_iterator_tag;
};




template <typename IterT> struct fwd_or_bidi_tag {
  using type = typename fwd_or_bidi_tag_impl<std::is_base_of<
      std::bidirectional_iterator_tag,
      typename std::iterator_traits<IterT>::iterator_category>::value>::type;
};

}



template <typename WrappedIteratorT, typename PredicateT>
using filter_iterator = filter_iterator_impl<
    WrappedIteratorT, PredicateT,
    typename detail::fwd_or_bidi_tag<WrappedIteratorT>::type>;
# 579 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename RangeT, typename PredicateT>
iterator_range<filter_iterator<detail::IterOfRange<RangeT>, PredicateT>>
make_filter_range(RangeT &&Range, PredicateT Pred) {
  using FilterIteratorT =
      filter_iterator<detail::IterOfRange<RangeT>, PredicateT>;
  return make_range(
      FilterIteratorT(std::begin(std::forward<RangeT>(Range)),
                      std::end(std::forward<RangeT>(Range)), Pred),
      FilterIteratorT(std::end(std::forward<RangeT>(Range)),
                      std::end(std::forward<RangeT>(Range)), Pred));
}
# 608 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename WrappedIteratorT>
class early_inc_iterator_impl
    : public iterator_adaptor_base<early_inc_iterator_impl<WrappedIteratorT>,
                                   WrappedIteratorT, std::input_iterator_tag> {
  using BaseT = typename early_inc_iterator_impl::iterator_adaptor_base;

  using PointerT = typename std::iterator_traits<WrappedIteratorT>::pointer;

protected:

  bool IsEarlyIncremented = false;


public:
  early_inc_iterator_impl(WrappedIteratorT I) : BaseT(I) {}

  using BaseT::operator*;
  decltype(*std::declval<WrappedIteratorT>()) operator*() {

    (__builtin_expect(!(!IsEarlyIncremented && "Cannot dereference twice!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 627, "!IsEarlyIncremented && \"Cannot dereference twice!\"") : (void)0);
    IsEarlyIncremented = true;

    return *(this->I)++;
  }

  using BaseT::operator++;
  early_inc_iterator_impl &operator++() {

    (__builtin_expect(!(IsEarlyIncremented && "Cannot increment before dereferencing!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 636, "IsEarlyIncremented && \"Cannot increment before dereferencing!\"") : (void)0);
    IsEarlyIncremented = false;

    return *this;
  }

  friend bool operator==(const early_inc_iterator_impl &LHS,
                         const early_inc_iterator_impl &RHS) {

    (__builtin_expect(!(!LHS.IsEarlyIncremented && "Cannot compare after dereferencing!"), 0) ? __assert_rtn(__func__, "STLExtras.h", 645, "!LHS.IsEarlyIncremented && \"Cannot compare after dereferencing!\"") : (void)0);

    return (const BaseT &)LHS == (const BaseT &)RHS;
  }
};
# 663 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename RangeT>
iterator_range<early_inc_iterator_impl<detail::IterOfRange<RangeT>>>
make_early_inc_range(RangeT &&Range) {
  using EarlyIncIteratorT =
      early_inc_iterator_impl<detail::IterOfRange<RangeT>>;
  return make_range(EarlyIncIteratorT(std::begin(std::forward<RangeT>(Range))),
                    EarlyIncIteratorT(std::end(std::forward<RangeT>(Range))));
}


template <typename R, typename UnaryPredicate>
bool all_of(R &&range, UnaryPredicate P);

template <typename R, typename UnaryPredicate>
bool any_of(R &&range, UnaryPredicate P);

template <typename T> bool all_equal(std::initializer_list<T> Values);

template <typename R> constexpr size_t range_size(R &&Range);

namespace detail {

using std::declval;



template<typename... Iters> struct ZipTupleType {
  using type = std::tuple<decltype(*declval<Iters>())...>;
};

template <typename ZipType, typename ReferenceTupleType, typename... Iters>
using zip_traits = iterator_facade_base<
    ZipType,
    std::common_type_t<
        std::bidirectional_iterator_tag,
        typename std::iterator_traits<Iters>::iterator_category...>,

    ReferenceTupleType,
    typename std::iterator_traits<
        std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,




    ReferenceTupleType *, ReferenceTupleType>;

template <typename ZipType, typename ReferenceTupleType, typename... Iters>
struct zip_common : public zip_traits<ZipType, ReferenceTupleType, Iters...> {
  using Base = zip_traits<ZipType, ReferenceTupleType, Iters...>;
  using IndexSequence = std::index_sequence_for<Iters...>;
  using value_type = typename Base::value_type;

  std::tuple<Iters...> iterators;

protected:
  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
    return value_type(*std::get<Ns>(iterators)...);
  }

  template <size_t... Ns> void tup_inc(std::index_sequence<Ns...>) {
    (++std::get<Ns>(iterators), ...);
  }

  template <size_t... Ns> void tup_dec(std::index_sequence<Ns...>) {
    (--std::get<Ns>(iterators), ...);
  }

  template <size_t... Ns>
  bool test_all_equals(const zip_common &other,
                       std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) &&
            ...);
  }

public:
  zip_common(Iters &&... ts) : iterators(std::forward<Iters>(ts)...) {}

  value_type operator*() const { return deref(IndexSequence{}); }

  ZipType &operator++() {
    tup_inc(IndexSequence{});
    return static_cast<ZipType &>(*this);
  }

  ZipType &operator--() {
    static_assert(Base::IsBidirectional,
                  "All inner iterators must be at least bidirectional.");
    tup_dec(IndexSequence{});
    return static_cast<ZipType &>(*this);
  }


  bool all_equals(zip_common &other) {
    return test_all_equals(other, IndexSequence{});
  }
};

template <typename... Iters>
struct zip_first : zip_common<zip_first<Iters...>,
                              typename ZipTupleType<Iters...>::type, Iters...> {
  using zip_common<zip_first, typename ZipTupleType<Iters...>::type,
                   Iters...>::zip_common;

  bool operator==(const zip_first &other) const {
    return std::get<0>(this->iterators) == std::get<0>(other.iterators);
  }
};

template <typename... Iters>
struct zip_shortest
    : zip_common<zip_shortest<Iters...>, typename ZipTupleType<Iters...>::type,
                 Iters...> {
  using zip_common<zip_shortest, typename ZipTupleType<Iters...>::type,
                   Iters...>::zip_common;

  bool operator==(const zip_shortest &other) const {
    return any_iterator_equals(other, std::index_sequence_for<Iters...>{});
  }

private:
  template <size_t... Ns>
  bool any_iterator_equals(const zip_shortest &other,
                           std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) == std::get<Ns>(other.iterators)) ||
            ...);
  }
};


template <template <typename...> class ItType, typename TupleStorageType,
          typename IndexSequence>
struct ZippyIteratorTuple;


template <template <typename...> class ItType, typename... Args,
          std::size_t... Ns>
struct ZippyIteratorTuple<ItType, std::tuple<Args...>,
                          std::index_sequence<Ns...>> {
  using type = ItType<decltype(adl_begin(
      std::get<Ns>(declval<std::tuple<Args...> &>())))...>;
};


template <template <typename...> class ItType, typename... Args,
          std::size_t... Ns>
struct ZippyIteratorTuple<ItType, const std::tuple<Args...>,
                          std::index_sequence<Ns...>> {
  using type = ItType<decltype(adl_begin(
      std::get<Ns>(declval<const std::tuple<Args...> &>())))...>;
};

template <template <typename...> class ItType, typename... Args> class zippy {
private:
  std::tuple<Args...> storage;
  using IndexSequence = std::index_sequence_for<Args...>;

public:
  using iterator = typename ZippyIteratorTuple<ItType, decltype(storage),
                                               IndexSequence>::type;
  using const_iterator =
      typename ZippyIteratorTuple<ItType, const decltype(storage),
                                  IndexSequence>::type;
  using iterator_category = typename iterator::iterator_category;
  using value_type = typename iterator::value_type;
  using difference_type = typename iterator::difference_type;
  using pointer = typename iterator::pointer;
  using reference = typename iterator::reference;
  using const_reference = typename const_iterator::reference;

  zippy(Args &&...args) : storage(std::forward<Args>(args)...) {}

  const_iterator begin() const { return begin_impl(IndexSequence{}); }
  iterator begin() { return begin_impl(IndexSequence{}); }
  const_iterator end() const { return end_impl(IndexSequence{}); }
  iterator end() { return end_impl(IndexSequence{}); }

private:
  template <size_t... Ns>
  const_iterator begin_impl(std::index_sequence<Ns...>) const {
    return const_iterator(adl_begin(std::get<Ns>(storage))...);
  }
  template <size_t... Ns> iterator begin_impl(std::index_sequence<Ns...>) {
    return iterator(adl_begin(std::get<Ns>(storage))...);
  }

  template <size_t... Ns>
  const_iterator end_impl(std::index_sequence<Ns...>) const {
    return const_iterator(adl_end(std::get<Ns>(storage))...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
    return iterator(adl_end(std::get<Ns>(storage))...);
  }
};

}



template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_shortest, T, U, Args...> zip(T &&t, U &&u,
                                                       Args &&...args) {
  return detail::zippy<detail::zip_shortest, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}




template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_first, T, U, Args...> zip_equal(T &&t, U &&u,
                                                          Args &&...args) {
  (__builtin_expect(!(all_equal({range_size(t), range_size(u), range_size(args)...}) && "Iteratees do not have equal length"), 0) ? __assert_rtn(__func__, "STLExtras.h", 875, "all_equal({range_size(t), range_size(u), range_size(args)...}) && \"Iteratees do not have equal length\"") : (void)0);

  return detail::zippy<detail::zip_first, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}





template <typename T, typename U, typename... Args>
detail::zippy<detail::zip_first, T, U, Args...> zip_first(T &&t, U &&u,
                                                          Args &&...args) {
  (__builtin_expect(!(range_size(t) <= std::min({range_size(u), range_size(args)...}) && "First iteratee is not the shortest"), 0) ? __assert_rtn(__func__, "STLExtras.h", 888, "range_size(t) <= std::min({range_size(u), range_size(args)...}) && \"First iteratee is not the shortest\"") : (void)0);


  return detail::zippy<detail::zip_first, T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}

namespace detail {
template <typename Iter>
Iter next_or_end(const Iter &I, const Iter &End) {
  if (I == End)
    return End;
  return std::next(I);
}

template <typename Iter>
auto deref_or_none(const Iter &I, const Iter &End) -> std::optional<
    std::remove_const_t<std::remove_reference_t<decltype(*I)>>> {
  if (I == End)
    return std::nullopt;
  return *I;
}

template <typename Iter> struct ZipLongestItemType {
  using type = std::optional<std::remove_const_t<
      std::remove_reference_t<decltype(*std::declval<Iter>())>>>;
};

template <typename... Iters> struct ZipLongestTupleType {
  using type = std::tuple<typename ZipLongestItemType<Iters>::type...>;
};

template <typename... Iters>
class zip_longest_iterator
    : public iterator_facade_base<
          zip_longest_iterator<Iters...>,
          std::common_type_t<
              std::forward_iterator_tag,
              typename std::iterator_traits<Iters>::iterator_category...>,
          typename ZipLongestTupleType<Iters...>::type,
          typename std::iterator_traits<
              std::tuple_element_t<0, std::tuple<Iters...>>>::difference_type,
          typename ZipLongestTupleType<Iters...>::type *,
          typename ZipLongestTupleType<Iters...>::type> {
public:
  using value_type = typename ZipLongestTupleType<Iters...>::type;

private:
  std::tuple<Iters...> iterators;
  std::tuple<Iters...> end_iterators;

  template <size_t... Ns>
  bool test(const zip_longest_iterator<Iters...> &other,
            std::index_sequence<Ns...>) const {
    return ((std::get<Ns>(this->iterators) != std::get<Ns>(other.iterators)) ||
            ...);
  }

  template <size_t... Ns> value_type deref(std::index_sequence<Ns...>) const {
    return value_type(
        deref_or_none(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
  }

  template <size_t... Ns>
  decltype(iterators) tup_inc(std::index_sequence<Ns...>) const {
    return std::tuple<Iters...>(
        next_or_end(std::get<Ns>(iterators), std::get<Ns>(end_iterators))...);
  }

public:
  zip_longest_iterator(std::pair<Iters &&, Iters &&>... ts)
      : iterators(std::forward<Iters>(ts.first)...),
        end_iterators(std::forward<Iters>(ts.second)...) {}

  value_type operator*() const {
    return deref(std::index_sequence_for<Iters...>{});
  }

  zip_longest_iterator<Iters...> &operator++() {
    iterators = tup_inc(std::index_sequence_for<Iters...>{});
    return *this;
  }

  bool operator==(const zip_longest_iterator<Iters...> &other) const {
    return !test(other, std::index_sequence_for<Iters...>{});
  }
};

template <typename... Args> class zip_longest_range {
public:
  using iterator =
      zip_longest_iterator<decltype(adl_begin(std::declval<Args>()))...>;
  using iterator_category = typename iterator::iterator_category;
  using value_type = typename iterator::value_type;
  using difference_type = typename iterator::difference_type;
  using pointer = typename iterator::pointer;
  using reference = typename iterator::reference;

private:
  std::tuple<Args...> ts;

  template <size_t... Ns>
  iterator begin_impl(std::index_sequence<Ns...>) const {
    return iterator(std::make_pair(adl_begin(std::get<Ns>(ts)),
                                   adl_end(std::get<Ns>(ts)))...);
  }

  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
    return iterator(std::make_pair(adl_end(std::get<Ns>(ts)),
                                   adl_end(std::get<Ns>(ts)))...);
  }

public:
  zip_longest_range(Args &&... ts_) : ts(std::forward<Args>(ts_)...) {}

  iterator begin() const {
    return begin_impl(std::index_sequence_for<Args...>{});
  }
  iterator end() const { return end_impl(std::index_sequence_for<Args...>{}); }
};
}




template <typename T, typename U, typename... Args>
detail::zip_longest_range<T, U, Args...> zip_longest(T &&t, U &&u,
                                                     Args &&... args) {
  return detail::zip_longest_range<T, U, Args...>(
      std::forward<T>(t), std::forward<U>(u), std::forward<Args>(args)...);
}
# 1029 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename ValueT, typename... IterTs>
class concat_iterator
    : public iterator_facade_base<concat_iterator<ValueT, IterTs...>,
                                  std::forward_iterator_tag, ValueT> {
  using BaseT = typename concat_iterator::iterator_facade_base;







  std::tuple<IterTs...> Begins;
  std::tuple<IterTs...> Ends;





  template <size_t Index> bool incrementHelper() {
    auto &Begin = std::get<Index>(Begins);
    auto &End = std::get<Index>(Ends);
    if (Begin == End)
      return false;

    ++Begin;
    return true;
  }




  template <size_t... Ns> void increment(std::index_sequence<Ns...>) {

    bool (concat_iterator::*IncrementHelperFns[])() = {
        &concat_iterator::incrementHelper<Ns>...};


    for (auto &IncrementHelperFn : IncrementHelperFns)
      if ((this->*IncrementHelperFn)())
        return;

    ::llvm::llvm_unreachable_internal("Attempted to increment an end concat iterator!", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h", 1071);
  }




  template <size_t Index> ValueT *getHelper() const {
    auto &Begin = std::get<Index>(Begins);
    auto &End = std::get<Index>(Ends);
    if (Begin == End)
      return nullptr;

    return &*Begin;
  }





  template <size_t... Ns> ValueT &get(std::index_sequence<Ns...>) const {

    ValueT *(concat_iterator::*GetHelperFns[])() const = {
        &concat_iterator::getHelper<Ns>...};


    for (auto &GetHelperFn : GetHelperFns)
      if (ValueT *P = (this->*GetHelperFn)())
        return *P;

    ::llvm::llvm_unreachable_internal("Attempted to get a pointer from an end concat iterator!", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h", 1100);
  }

public:




  template <typename... RangeTs>
  explicit concat_iterator(RangeTs &&... Ranges)
      : Begins(std::begin(Ranges)...), Ends(std::end(Ranges)...) {}

  using BaseT::operator++;

  concat_iterator &operator++() {
    increment(std::index_sequence_for<IterTs...>());
    return *this;
  }

  ValueT &operator*() const {
    return get(std::index_sequence_for<IterTs...>());
  }

  bool operator==(const concat_iterator &RHS) const {
    return Begins == RHS.Begins && Ends == RHS.Ends;
  }
};

namespace detail {






template <typename ValueT, typename... RangeTs> class concat_range {
public:
  using iterator =
      concat_iterator<ValueT,
                      decltype(std::begin(std::declval<RangeTs &>()))...>;

private:
  std::tuple<RangeTs...> Ranges;

  template <size_t... Ns>
  iterator begin_impl(std::index_sequence<Ns...>) {
    return iterator(std::get<Ns>(Ranges)...);
  }
  template <size_t... Ns>
  iterator begin_impl(std::index_sequence<Ns...>) const {
    return iterator(std::get<Ns>(Ranges)...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) {
    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
                               std::end(std::get<Ns>(Ranges)))...);
  }
  template <size_t... Ns> iterator end_impl(std::index_sequence<Ns...>) const {
    return iterator(make_range(std::end(std::get<Ns>(Ranges)),
                               std::end(std::get<Ns>(Ranges)))...);
  }

public:
  concat_range(RangeTs &&... Ranges)
      : Ranges(std::forward<RangeTs>(Ranges)...) {}

  iterator begin() {
    return begin_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator begin() const {
    return begin_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator end() {
    return end_impl(std::index_sequence_for<RangeTs...>{});
  }
  iterator end() const {
    return end_impl(std::index_sequence_for<RangeTs...>{});
  }
};

}




template <typename ValueT, typename... RangeTs>
detail::concat_range<ValueT, RangeTs...> concat(RangeTs &&... Ranges) {
  static_assert(sizeof...(RangeTs) > 1,
                "Need more than one range to concatenate!");
  return detail::concat_range<ValueT, RangeTs...>(
      std::forward<RangeTs>(Ranges)...);
}



template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_iterator
    : public llvm::iterator_facade_base<DerivedT,
                                        std::random_access_iterator_tag, T,
                                        std::ptrdiff_t, PointerT, ReferenceT> {
public:
  ptrdiff_t operator-(const indexed_accessor_iterator &rhs) const {
    (__builtin_expect(!(base == rhs.base && "incompatible iterators"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1202, "base == rhs.base && \"incompatible iterators\"") : (void)0);
    return index - rhs.index;
  }
  bool operator==(const indexed_accessor_iterator &rhs) const {
    return base == rhs.base && index == rhs.index;
  }
  bool operator<(const indexed_accessor_iterator &rhs) const {
    (__builtin_expect(!(base == rhs.base && "incompatible iterators"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1209, "base == rhs.base && \"incompatible iterators\"") : (void)0);
    return index < rhs.index;
  }

  DerivedT &operator+=(ptrdiff_t offset) {
    this->index += offset;
    return static_cast<DerivedT &>(*this);
  }
  DerivedT &operator-=(ptrdiff_t offset) {
    this->index -= offset;
    return static_cast<DerivedT &>(*this);
  }


  ptrdiff_t getIndex() const { return index; }


  const BaseT &getBase() const { return base; }

protected:
  indexed_accessor_iterator(BaseT base, ptrdiff_t index)
      : base(base), index(index) {}
  BaseT base;
  ptrdiff_t index;
};

namespace detail {
# 1246 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_range_base {
public:
  using RangeBaseT = indexed_accessor_range_base;


  class iterator : public indexed_accessor_iterator<iterator, BaseT, T,
                                                    PointerT, ReferenceT> {
  public:

    ReferenceT operator*() const {
      return DerivedT::dereference_iterator(this->getBase(), this->getIndex());
    }

  private:
    iterator(BaseT owner, ptrdiff_t curIndex)
        : iterator::indexed_accessor_iterator(owner, curIndex) {}


    friend indexed_accessor_range_base<DerivedT, BaseT, T, PointerT,
                                       ReferenceT>;
  };

  indexed_accessor_range_base(iterator begin, iterator end)
      : base(offset_base(begin.getBase(), begin.getIndex())),
        count(end.getIndex() - begin.getIndex()) {}
  indexed_accessor_range_base(const iterator_range<iterator> &range)
      : indexed_accessor_range_base(range.begin(), range.end()) {}
  indexed_accessor_range_base(BaseT base, ptrdiff_t count)
      : base(base), count(count) {}

  iterator begin() const { return iterator(base, 0); }
  iterator end() const { return iterator(base, count); }
  ReferenceT operator[](size_t Index) const {
    (__builtin_expect(!(Index < size() && "invalid index for value range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1281, "Index < size() && \"invalid index for value range\"") : (void)0);
    return DerivedT::dereference_iterator(base, static_cast<ptrdiff_t>(Index));
  }
  ReferenceT front() const {
    (__builtin_expect(!(!empty() && "expected non-empty range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1285, "!empty() && \"expected non-empty range\"") : (void)0);
    return (*this)[0];
  }
  ReferenceT back() const {
    (__builtin_expect(!(!empty() && "expected non-empty range"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1289, "!empty() && \"expected non-empty range\"") : (void)0);
    return (*this)[size() - 1];
  }


  template <typename OtherT>
  friend bool operator==(const indexed_accessor_range_base &lhs,
                         const OtherT &rhs) {
    return std::equal(lhs.begin(), lhs.end(), rhs.begin(), rhs.end());
  }
  template <typename OtherT>
  friend bool operator!=(const indexed_accessor_range_base &lhs,
                         const OtherT &rhs) {
    return !(lhs == rhs);
  }


  size_t size() const { return count; }


  bool empty() const { return size() == 0; }


  DerivedT slice(size_t n, size_t m) const {
    (__builtin_expect(!(n + m <= size() && "invalid size specifiers"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1313, "n + m <= size() && \"invalid size specifiers\"") : (void)0);
    return DerivedT(offset_base(base, n), m);
  }


  DerivedT drop_front(size_t n = 1) const {
    (__builtin_expect(!(size() >= n && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1319, "size() >= n && \"Dropping more elements than exist\"") : (void)0);
    return slice(n, size() - n);
  }

  DerivedT drop_back(size_t n = 1) const {
    (__builtin_expect(!(size() >= n && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "STLExtras.h", 1324, "size() >= n && \"Dropping more elements than exist\"") : (void)0);
    return DerivedT(base, size() - n);
  }


  DerivedT take_front(size_t n = 1) const {
    return n < size() ? drop_back(size() - n)
                      : static_cast<const DerivedT &>(*this);
  }


  DerivedT take_back(size_t n = 1) const {
    return n < size() ? drop_front(size() - n)
                      : static_cast<const DerivedT &>(*this);
  }


  template <typename RangeT, typename = std::enable_if_t<std::is_constructible<
                                 RangeT, iterator_range<iterator>>::value>>
  operator RangeT() const {
    return RangeT(iterator_range<iterator>(*this));
  }


  const BaseT &getBase() const { return base; }

private:

  static BaseT offset_base(const BaseT &base, size_t n) {
    return n == 0 ? base : DerivedT::offset_base(base, n);
  }

protected:
  indexed_accessor_range_base(const indexed_accessor_range_base &) = default;
  indexed_accessor_range_base(indexed_accessor_range_base &&) = default;
  indexed_accessor_range_base &
  operator=(const indexed_accessor_range_base &) = default;


  BaseT base;

  ptrdiff_t count;
};
}
# 1376 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename DerivedT, typename BaseT, typename T,
          typename PointerT = T *, typename ReferenceT = T &>
class indexed_accessor_range
    : public detail::indexed_accessor_range_base<
          DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT> {
public:
  indexed_accessor_range(BaseT base, ptrdiff_t startIndex, ptrdiff_t count)
      : detail::indexed_accessor_range_base<
            DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT, ReferenceT>(
            std::make_pair(base, startIndex), count) {}
  using detail::indexed_accessor_range_base<
      DerivedT, std::pair<BaseT, ptrdiff_t>, T, PointerT,
      ReferenceT>::indexed_accessor_range_base;


  const BaseT &getBase() const { return this->base.first; }


  ptrdiff_t getStartIndex() const { return this->base.second; }


  static std::pair<BaseT, ptrdiff_t>
  offset_base(const std::pair<BaseT, ptrdiff_t> &base, ptrdiff_t index) {


    return std::make_pair(base.first, base.second + index);
  }

  static ReferenceT
  dereference_iterator(const std::pair<BaseT, ptrdiff_t> &base,
                       ptrdiff_t index) {
    return DerivedT::dereference(base.first, base.second + index);
  }
};

namespace detail {






template <typename EltTy, typename FirstTy> class first_or_second_type {
public:
  using type = std::conditional_t<std::is_reference<EltTy>::value, FirstTy,
                                  std::remove_reference_t<FirstTy>>;
};
}


template <typename ContainerTy> auto make_first_range(ContainerTy &&c) {
  using EltTy = decltype((*std::begin(c)));
  return llvm::map_range(std::forward<ContainerTy>(c),
                         [](EltTy elt) -> typename detail::first_or_second_type<
                                           EltTy, decltype((elt.first))>::type {
                           return elt.first;
                         });
}


template <typename ContainerTy> auto make_second_range(ContainerTy &&c) {
  using EltTy = decltype((*std::begin(c)));
  return llvm::map_range(
      std::forward<ContainerTy>(c),
      [](EltTy elt) ->
      typename detail::first_or_second_type<EltTy,
                                            decltype((elt.second))>::type {
        return elt.second;
      });
}
# 1454 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
struct less_first {
  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
    return std::less<>()(std::get<0>(lhs), std::get<0>(rhs));
  }
};




struct less_second {
  template <typename T> bool operator()(const T &lhs, const T &rhs) const {
    return std::less<>()(std::get<1>(lhs), std::get<1>(rhs));
  }
};



template<typename FuncTy>
struct on_first {
  FuncTy func;

  template <typename T>
  decltype(auto) operator()(const T &lhs, const T &rhs) const {
    return func(lhs.first, rhs.first);
  }
};



template <int N> struct rank : rank<N - 1> {};
template <> struct rank<0> {};

namespace detail {
template <typename... Ts> struct Visitor;

template <typename HeadT, typename... TailTs>
struct Visitor<HeadT, TailTs...> : remove_cvref_t<HeadT>, Visitor<TailTs...> {
  explicit constexpr Visitor(HeadT &&Head, TailTs &&...Tail)
      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)),
        Visitor<TailTs...>(std::forward<TailTs>(Tail)...) {}
  using remove_cvref_t<HeadT>::operator();
  using Visitor<TailTs...>::operator();
};

template <typename HeadT> struct Visitor<HeadT> : remove_cvref_t<HeadT> {
  explicit constexpr Visitor(HeadT &&Head)
      : remove_cvref_t<HeadT>(std::forward<HeadT>(Head)) {}
  using remove_cvref_t<HeadT>::operator();
};
}
# 1533 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... CallableTs>
constexpr decltype(auto) makeVisitor(CallableTs &&...Callables) {
  return detail::Visitor<CallableTs...>(std::forward<CallableTs>(Callables)...);
}







template <class Iterator, class RNG>
void shuffle(Iterator first, Iterator last, RNG &&g) {


  typedef
      typename std::iterator_traits<Iterator>::difference_type difference_type;
  for (auto size = last - first; size > 1; ++first, (void)--size) {
    difference_type offset = g() % size;


    if (offset != difference_type(0))
      std::iter_swap(first, first + offset);
  }
}


template<typename T>
inline int array_pod_sort_comparator(const void *P1, const void *P2) {
  if (std::less<T>()(*reinterpret_cast<const T*>(P1),
                     *reinterpret_cast<const T*>(P2)))
    return -1;
  if (std::less<T>()(*reinterpret_cast<const T*>(P2),
                     *reinterpret_cast<const T*>(P1)))
    return 1;
  return 0;
}



template<typename T>
inline int (*get_array_pod_sort_comparator(const T &))
             (const void*, const void*) {
  return array_pod_sort_comparator<T>;
}
# 1610 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template<class IteratorTy>
inline void array_pod_sort(IteratorTy Start, IteratorTy End) {


  auto NElts = End - Start;
  if (NElts <= 1) return;



  qsort(&*Start, NElts, sizeof(*Start), get_array_pod_sort_comparator(*Start));
}

template <class IteratorTy>
inline void array_pod_sort(
    IteratorTy Start, IteratorTy End,
    int (*Compare)(
        const typename std::iterator_traits<IteratorTy>::value_type *,
        const typename std::iterator_traits<IteratorTy>::value_type *)) {


  auto NElts = End - Start;
  if (NElts <= 1) return;



  qsort(&*Start, NElts, sizeof(*Start),
        reinterpret_cast<int (*)(const void *, const void *)>(Compare));
}

namespace detail {
template <typename T>


using sort_trivially_copyable = std::conjunction<
    std::is_pointer<T>,
    std::is_trivially_copyable<typename std::iterator_traits<T>::value_type>>;
}



template <typename IteratorTy>
inline void sort(IteratorTy Start, IteratorTy End) {
  if constexpr (detail::sort_trivially_copyable<IteratorTy>::value) {


    array_pod_sort(Start, End);
  } else {



    std::sort(Start, End);
  }
}

template <typename Container> inline void sort(Container &&C) {
  llvm::sort(adl_begin(C), adl_end(C));
}

template <typename IteratorTy, typename Compare>
inline void sort(IteratorTy Start, IteratorTy End, Compare Comp) {



  std::sort(Start, End, Comp);
}

template <typename Container, typename Compare>
inline void sort(Container &&C, Compare Comp) {
  llvm::sort(adl_begin(C), adl_end(C), Comp);
}



template <typename R>
auto size(R &&Range,
          std::enable_if_t<
              std::is_base_of<std::random_access_iterator_tag,
                              typename std::iterator_traits<decltype(
                                  Range.begin())>::iterator_category>::value,
              void> * = nullptr) {
  return std::distance(Range.begin(), Range.end());
}

namespace detail {
template <typename Range>
using check_has_free_function_size =
    decltype(adl_size(std::declval<Range &>()));

template <typename Range>
static constexpr bool HasFreeFunctionSize =
    is_detected<check_has_free_function_size, Range>::value;
}







template <typename R> constexpr size_t range_size(R &&Range) {
  if constexpr (detail::HasFreeFunctionSize<R>)
    return adl_size(Range);
  else
    return static_cast<size_t>(std::distance(adl_begin(Range), adl_end(Range)));
}



template <typename R, typename UnaryFunction>
UnaryFunction for_each(R &&Range, UnaryFunction F) {
  return std::for_each(adl_begin(Range), adl_end(Range), F);
}



template <typename R, typename UnaryPredicate>
bool all_of(R &&Range, UnaryPredicate P) {
  return std::all_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
bool any_of(R &&Range, UnaryPredicate P) {
  return std::any_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
bool none_of(R &&Range, UnaryPredicate P) {
  return std::none_of(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename T> auto find(R &&Range, const T &Val) {
  return std::find(adl_begin(Range), adl_end(Range), Val);
}



template <typename R, typename UnaryPredicate>
auto find_if(R &&Range, UnaryPredicate P) {
  return std::find_if(adl_begin(Range), adl_end(Range), P);
}

template <typename R, typename UnaryPredicate>
auto find_if_not(R &&Range, UnaryPredicate P) {
  return std::find_if_not(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename UnaryPredicate>
auto remove_if(R &&Range, UnaryPredicate P) {
  return std::remove_if(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename OutputIt, typename UnaryPredicate>
OutputIt copy_if(R &&Range, OutputIt Out, UnaryPredicate P) {
  return std::copy_if(adl_begin(Range), adl_end(Range), Out, P);
}






template <typename T, typename R, typename Predicate>
T *find_singleton(R &&Range, Predicate P, bool AllowRepeats = false) {
  T *RC = nullptr;
  for (auto &&A : Range) {
    if (T *PRC = P(A, AllowRepeats)) {
      if (RC) {
        if (!AllowRepeats || PRC != RC)
          return nullptr;
      } else
        RC = PRC;
    }
  }
  return RC;
}
# 1805 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename T, typename R, typename Predicate>
std::pair<T *, bool> find_singleton_nested(R &&Range, Predicate P,
                                           bool AllowRepeats = false) {
  T *RC = nullptr;
  for (auto *A : Range) {
    std::pair<T *, bool> PRC = P(A, AllowRepeats);
    if (PRC.second) {
      (__builtin_expect(!(PRC.first == nullptr && "Inconsistent return values in find_singleton_nested."), 0) ? __assert_rtn(__func__, "STLExtras.h", 1813, "PRC.first == nullptr && \"Inconsistent return values in find_singleton_nested.\"") : (void)0);

      return PRC;
    }
    if (PRC.first) {
      if (RC) {
        if (!AllowRepeats || PRC.first != RC)
          return {nullptr, true};
      } else
        RC = PRC.first;
    }
  }
  return {RC, false};
}

template <typename R, typename OutputIt>
OutputIt copy(R &&Range, OutputIt Out) {
  return std::copy(adl_begin(Range), adl_end(Range), Out);
}



template <typename R, typename OutputIt, typename UnaryPredicate, typename T>
OutputIt replace_copy_if(R &&Range, OutputIt Out, UnaryPredicate P,
                         const T &NewValue) {
  return std::replace_copy_if(adl_begin(Range), adl_end(Range), Out, P,
                              NewValue);
}



template <typename R, typename OutputIt, typename T>
OutputIt replace_copy(R &&Range, OutputIt Out, const T &OldValue,
                      const T &NewValue) {
  return std::replace_copy(adl_begin(Range), adl_end(Range), Out, OldValue,
                           NewValue);
}



template <typename R, typename OutputIt>
OutputIt move(R &&Range, OutputIt Out) {
  return std::move(adl_begin(Range), adl_end(Range), Out);
}

namespace detail {
template <typename Range, typename Element>
using check_has_member_contains_t =
    decltype(std::declval<Range &>().contains(std::declval<const Element &>()));

template <typename Range, typename Element>
static constexpr bool HasMemberContains =
    is_detected<check_has_member_contains_t, Range, Element>::value;

template <typename Range, typename Element>
using check_has_member_find_t =
    decltype(std::declval<Range &>().find(std::declval<const Element &>()) !=
             std::declval<Range &>().end());

template <typename Range, typename Element>
static constexpr bool HasMemberFind =
    is_detected<check_has_member_find_t, Range, Element>::value;

}






template <typename R, typename E>
bool is_contained(R &&Range, const E &Element) {
  if constexpr (detail::HasMemberContains<R, E>)
    return Range.contains(Element);
  else if constexpr (detail::HasMemberFind<R, E>)
    return Range.find(Element) != Range.end();
  else
    return std::find(adl_begin(Range), adl_end(Range), Element) !=
           adl_end(Range);
}



template <typename T, typename E>
constexpr bool is_contained(std::initializer_list<T> Set, const E &Element) {

  for (const T &V : Set)
    if (V == Element)
      return true;
  return false;
}



template <typename R, typename Compare> bool is_sorted(R &&Range, Compare C) {
  return std::is_sorted(adl_begin(Range), adl_end(Range), C);
}



template <typename R> bool is_sorted(R &&Range) {
  return std::is_sorted(adl_begin(Range), adl_end(Range));
}



template <typename R, typename E> auto count(R &&Range, const E &Element) {
  return std::count(adl_begin(Range), adl_end(Range), Element);
}



template <typename R, typename UnaryPredicate>
auto count_if(R &&Range, UnaryPredicate P) {
  return std::count_if(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename OutputIt, typename UnaryFunction>
OutputIt transform(R &&Range, OutputIt d_first, UnaryFunction F) {
  return std::transform(adl_begin(Range), adl_end(Range), d_first, F);
}



template <typename R, typename UnaryPredicate>
auto partition(R &&Range, UnaryPredicate P) {
  return std::partition(adl_begin(Range), adl_end(Range), P);
}



template <typename R, typename T> auto lower_bound(R &&Range, T &&Value) {
  return std::lower_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value));
}

template <typename R, typename T, typename Compare>
auto lower_bound(R &&Range, T &&Value, Compare C) {
  return std::lower_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value), C);
}



template <typename R, typename T> auto upper_bound(R &&Range, T &&Value) {
  return std::upper_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value));
}

template <typename R, typename T, typename Compare>
auto upper_bound(R &&Range, T &&Value, Compare C) {
  return std::upper_bound(adl_begin(Range), adl_end(Range),
                          std::forward<T>(Value), C);
}

template <typename R>
void stable_sort(R &&Range) {
  std::stable_sort(adl_begin(Range), adl_end(Range));
}

template <typename R, typename Compare>
void stable_sort(R &&Range, Compare C) {
  std::stable_sort(adl_begin(Range), adl_end(Range), C);
}



template <typename R, typename Predicate,
          typename Val = decltype(*adl_begin(std::declval<R>()))>
auto partition_point(R &&Range, Predicate P) {
  return std::partition_point(adl_begin(Range), adl_end(Range), P);
}

template<typename Range, typename Predicate>
auto unique(Range &&R, Predicate P) {
  return std::unique(adl_begin(R), adl_end(R), P);
}



template <typename L, typename R> bool equal(L &&LRange, R &&RRange) {
  return std::equal(adl_begin(LRange), adl_end(LRange), adl_begin(RRange),
                    adl_end(RRange));
}


template <typename R> bool all_equal(R &&Range) {
  auto Begin = adl_begin(Range);
  auto End = adl_end(Range);
  return Begin == End || std::equal(Begin + 1, End, Begin);
}



template <typename T> bool all_equal(std::initializer_list<T> Values) {
  return all_equal<std::initializer_list<T>>(std::move(Values));
}
# 2019 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename Container, typename UnaryPredicate>
void erase_if(Container &C, UnaryPredicate P) {
  C.erase(remove_if(C, P), C.end());
}




template <typename Container, typename ValueType>
void erase(Container &C, ValueType V) {
  C.erase(std::remove(C.begin(), C.end(), V), C.end());
}

template <typename Container, typename ValueType>
__attribute__((deprecated("Use erase instead", "erase")))
void erase_value(Container &C, ValueType V) {
  erase(C, V);
}




template <typename Container, typename Range>
void append_range(Container &C, Range &&R) {
  C.insert(C.end(), adl_begin(R), adl_end(R));
}


template <typename Container, typename... Args>
void append_values(Container &C, Args &&...Values) {
  C.reserve(range_size(C) + sizeof...(Args));

  ((void)C.insert(C.end(), std::forward<Args>(Values)), ...);
}



template<typename Container, typename RandomAccessIterator>
void replace(Container &Cont, typename Container::iterator ContIt,
             typename Container::iterator ContEnd, RandomAccessIterator ValIt,
             RandomAccessIterator ValEnd) {
  while (true) {
    if (ValIt == ValEnd) {
      Cont.erase(ContIt, ContEnd);
      return;
    } else if (ContIt == ContEnd) {
      Cont.insert(ContIt, ValIt, ValEnd);
      return;
    }
    *ContIt++ = *ValIt++;
  }
}



template<typename Container, typename Range = std::initializer_list<
                                 typename Container::value_type>>
void replace(Container &Cont, typename Container::iterator ContIt,
             typename Container::iterator ContEnd, Range R) {
  replace(Cont, ContIt, ContEnd, R.begin(), R.end());
}
# 2091 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename ForwardIterator, typename UnaryFunctor,
          typename NullaryFunctor,
          typename = std::enable_if_t<
              !std::is_constructible<StringRef, UnaryFunctor>::value &&
              !std::is_constructible<StringRef, NullaryFunctor>::value>>
inline void interleave(ForwardIterator begin, ForwardIterator end,
                       UnaryFunctor each_fn, NullaryFunctor between_fn) {
  if (begin == end)
    return;
  each_fn(*begin);
  ++begin;
  for (; begin != end; ++begin) {
    between_fn();
    each_fn(*begin);
  }
}

template <typename Container, typename UnaryFunctor, typename NullaryFunctor,
          typename = std::enable_if_t<
              !std::is_constructible<StringRef, UnaryFunctor>::value &&
              !std::is_constructible<StringRef, NullaryFunctor>::value>>
inline void interleave(const Container &c, UnaryFunctor each_fn,
                       NullaryFunctor between_fn) {
  interleave(c.begin(), c.end(), each_fn, between_fn);
}


template <typename Container, typename UnaryFunctor, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleave(const Container &c, StreamT &os, UnaryFunctor each_fn,
                       const StringRef &separator) {
  interleave(c.begin(), c.end(), each_fn, [&] { os << separator; });
}
template <typename Container, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleave(const Container &c, StreamT &os,
                       const StringRef &separator) {
  interleave(
      c, os, [&](const T &a) { os << a; }, separator);
}

template <typename Container, typename UnaryFunctor, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleaveComma(const Container &c, StreamT &os,
                            UnaryFunctor each_fn) {
  interleave(c, os, each_fn, ", ");
}
template <typename Container, typename StreamT,
          typename T = detail::ValueOfRange<Container>>
inline void interleaveComma(const Container &c, StreamT &os) {
  interleaveComma(c, os, [&](const T &a) { os << a; });
}





struct FreeDeleter {
  void operator()(void* v) {
    ::free(v);
  }
};

template<typename First, typename Second>
struct pair_hash {
  size_t operator()(const std::pair<First, Second> &P) const {
    return std::hash<First>()(P.first) * 31 + std::hash<Second>()(P.second);
  }
};



template <typename T> struct deref {
  T func;




  template <typename A, typename B> auto operator()(A &lhs, B &rhs) const {
    (__builtin_expect(!(lhs), 0) ? __assert_rtn(__func__, "STLExtras.h", 2170, "lhs") : (void)0);
    (__builtin_expect(!(rhs), 0) ? __assert_rtn(__func__, "STLExtras.h", 2171, "rhs") : (void)0);
    return func(*lhs, *rhs);
  }
};

namespace detail {


template <typename... Refs> struct enumerator_result;

template <typename... Iters>
using EnumeratorTupleType = enumerator_result<decltype(*declval<Iters>())...>;
# 2195 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename... Iters>
struct zip_enumerator : zip_common<zip_enumerator<Iters...>,
                                   EnumeratorTupleType<Iters...>, Iters...> {
  static_assert(sizeof...(Iters) >= 2, "Expected at least two iteratees");
  using zip_common<zip_enumerator<Iters...>, EnumeratorTupleType<Iters...>,
                   Iters...>::zip_common;

  bool operator==(const zip_enumerator &Other) const {
    return std::get<1>(this->iterators) == std::get<1>(Other.iterators);
  }
};

template <typename... Refs> struct enumerator_result<std::size_t, Refs...> {
  static constexpr std::size_t NumRefs = sizeof...(Refs);
  static_assert(NumRefs != 0);

  static constexpr std::size_t NumValues = NumRefs + 1;


  using range_reference_tuple = std::tuple<Refs...>;


  using value_reference_tuple = std::tuple<std::size_t, Refs...>;

  enumerator_result(std::size_t Index, Refs &&...Rs)
      : Idx(Index), Storage(std::forward<Refs>(Rs)...) {}



  std::size_t index() const { return Idx; }



  decltype(auto) value() const {
    if constexpr (NumRefs == 1)
      return std::get<0>(Storage);
    else
      return Storage;
  }


  template <std::size_t I, typename = std::enable_if_t<I == 0>>
  friend std::size_t get(const enumerator_result &Result) {
    return Result.Idx;
  }



  template <std::size_t I, typename = std::enable_if_t<I != 0>>
  friend decltype(auto) get(const enumerator_result &Result) {



    return std::get<I - 1>(Result.Storage);
  }

  template <typename... Ts>
  friend bool operator==(const enumerator_result &Result,
                         const std::tuple<std::size_t, Ts...> &Other) {
    static_assert(NumRefs == sizeof...(Ts), "Size mismatch");
    if (Result.Idx != std::get<0>(Other))
      return false;
    return Result.is_value_equal(Other, std::make_index_sequence<NumRefs>{});
  }

private:
  template <typename Tuple, std::size_t... Idx>
  bool is_value_equal(const Tuple &Other, std::index_sequence<Idx...>) const {
    return ((std::get<Idx>(Storage) == std::get<Idx + 1>(Other)) && ...);
  }

  std::size_t Idx;







  mutable range_reference_tuple Storage;
};

struct index_iterator
    : llvm::iterator_facade_base<index_iterator,
                                 std::random_access_iterator_tag, std::size_t> {
  index_iterator(std::size_t Index) : Index(Index) {}

  index_iterator &operator+=(std::ptrdiff_t N) {
    Index += N;
    return *this;
  }

  index_iterator &operator-=(std::ptrdiff_t N) {
    Index -= N;
    return *this;
  }

  std::ptrdiff_t operator-(const index_iterator &R) const {
    return Index - R.Index;
  }






  std::size_t operator*() const { return Index; }

  friend bool operator==(const index_iterator &Lhs, const index_iterator &Rhs) {
    return Lhs.Index == Rhs.Index;
  }

  friend bool operator<(const index_iterator &Lhs, const index_iterator &Rhs) {
    return Lhs.Index < Rhs.Index;
  }

private:
  std::size_t Index;
};


struct index_stream {
  index_iterator begin() const { return {0}; }
  index_iterator end() const {


    return index_iterator{std::numeric_limits<std::size_t>::max()};
  }
};

}


class index_range {
  std::size_t Begin;
  std::size_t End;

public:
  index_range(std::size_t Begin, std::size_t End) : Begin(Begin), End(End) {}
  detail::index_iterator begin() const { return {Begin}; }
  detail::index_iterator end() const { return {End}; }
};
# 2374 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <typename FirstRange, typename... RestRanges>
auto enumerate(FirstRange &&First, RestRanges &&...Rest) {
  if constexpr (sizeof...(Rest) != 0) {



    size_t sizes[] = {range_size(First), range_size(Rest)...};
    (__builtin_expect(!(all_equal(sizes) && "Ranges have different length"), 0) ? __assert_rtn(__func__, "STLExtras.h", 2381, "all_equal(sizes) && \"Ranges have different length\"") : (void)0);

  }
  using enumerator = detail::zippy<detail::zip_enumerator, detail::index_stream,
                                   FirstRange, RestRanges...>;
  return enumerator(detail::index_stream{}, std::forward<FirstRange>(First),
                    std::forward<RestRanges>(Rest)...);
}

namespace detail {

template <typename Predicate, typename... Args>
bool all_of_zip_predicate_first(Predicate &&P, Args &&...args) {
  auto z = zip(args...);
  auto it = z.begin();
  auto end = z.end();
  while (it != end) {
    if (!std::apply([&](auto &&...args) { return P(args...); }, *it))
      return false;
    ++it;
  }
  return it.all_equals(end);
}



template <typename... ArgsThenPredicate, size_t... InputIndexes>
bool all_of_zip_predicate_last(
    std::tuple<ArgsThenPredicate...> argsThenPredicate,
    std::index_sequence<InputIndexes...>) {
  auto constexpr OutputIndex =
      std::tuple_size<decltype(argsThenPredicate)>::value - 1;
  return all_of_zip_predicate_first(std::get<OutputIndex>(argsThenPredicate),
                             std::get<InputIndexes>(argsThenPredicate)...);
}

}




template <typename... ArgsAndPredicate>
bool all_of_zip(ArgsAndPredicate &&...argsAndPredicate) {
  return detail::all_of_zip_predicate_last(
      std::forward_as_tuple(argsAndPredicate...),
      std::make_index_sequence<sizeof...(argsAndPredicate) - 1>{});
}




template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItems(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted =
        [](const decltype(*std::declval<IterTy>()) &) { return true; },
    std::enable_if_t<
        !std::is_base_of<std::random_access_iterator_tag,
                         typename std::iterator_traits<std::remove_reference_t<
                             decltype(Begin)>>::iterator_category>::value,
        void> * = nullptr) {
  for (; N; ++Begin) {
    if (Begin == End)
      return false;
    N -= ShouldBeCounted(*Begin);
  }
  for (; Begin != End; ++Begin)
    if (ShouldBeCounted(*Begin))
      return false;
  return true;
}




template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItemsOrMore(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted =
        [](const decltype(*std::declval<IterTy>()) &) { return true; },
    std::enable_if_t<
        !std::is_base_of<std::random_access_iterator_tag,
                         typename std::iterator_traits<std::remove_reference_t<
                             decltype(Begin)>>::iterator_category>::value,
        void> * = nullptr) {
  for (; N; ++Begin) {
    if (Begin == End)
      return false;
    N -= ShouldBeCounted(*Begin);
  }
  return true;
}



template <typename IterTy,
          typename Pred = bool (*)(const decltype(*std::declval<IterTy>()) &)>
bool hasNItemsOrLess(
    IterTy &&Begin, IterTy &&End, unsigned N,
    Pred &&ShouldBeCounted = [](const decltype(*std::declval<IterTy>()) &) {
      return true;
    }) {
  (__builtin_expect(!(N != std::numeric_limits<unsigned>::max()), 0) ? __assert_rtn(__func__, "STLExtras.h", 2485, "N != std::numeric_limits<unsigned>::max()") : (void)0);
  return !hasNItemsOrMore(Begin, End, N + 1, ShouldBeCounted);
}


template <typename ContainerTy> bool hasNItems(ContainerTy &&C, unsigned N) {
  return hasNItems(std::begin(C), std::end(C), N);
}


template <typename ContainerTy>
bool hasNItemsOrMore(ContainerTy &&C, unsigned N) {
  return hasNItemsOrMore(std::begin(C), std::end(C), N);
}


template <typename ContainerTy>
bool hasNItemsOrLess(ContainerTy &&C, unsigned N) {
  return hasNItemsOrLess(std::begin(C), std::end(C), N);
}
# 2513 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/STLExtras.h"
template <class Ptr> auto to_address(const Ptr &P) { return P.operator->(); }
template <class T> constexpr T *to_address(T *P) { return P; }


namespace detail {
template <typename T> using has_sizeof = decltype(sizeof(T));
}



template <typename T>
constexpr bool is_incomplete_v = !is_detected<detail::has_sizeof, T>::value;

}

namespace std {
template <typename... Refs>
struct tuple_size<llvm::detail::enumerator_result<Refs...>>
    : std::integral_constant<std::size_t, sizeof...(Refs)> {};

template <std::size_t I, typename... Refs>
struct tuple_element<I, llvm::detail::enumerator_result<Refs...>>
    : std::tuple_element<I, std::tuple<Refs...>> {};

template <std::size_t I, typename... Refs>
struct tuple_element<I, const llvm::detail::enumerator_result<Refs...>>
    : std::tuple_element<I, std::tuple<Refs...>> {};

}
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h" 2


namespace llvm {
  template<typename T> class [[nodiscard]] MutableArrayRef;
# 40 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class [[gsl::Pointer]] [[nodiscard]] ArrayRef {
  public:
    using value_type = T;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using iterator = const_pointer;
    using const_iterator = const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;

  private:

    const T *Data = nullptr;


    size_type Length = 0;

  public:




                 ArrayRef() = default;


                 ArrayRef(std::nullopt_t) {}


                 ArrayRef(const T &OneElt)
      : Data(&OneElt), Length(1) {}


    constexpr ArrayRef(const T *data, size_t length)
        : Data(data), Length(length) {}


    constexpr ArrayRef(const T *begin, const T *end)
        : Data(begin), Length(end - begin) {
      (__builtin_expect(!(begin <= end), 0) ? __assert_rtn(__func__, "ArrayRef.h", 83, "begin <= end") : (void)0);
    }




    template<typename U>
                 ArrayRef(const SmallVectorTemplateCommon<T, U> &Vec)
      : Data(Vec.data()), Length(Vec.size()) {
    }


    template<typename A>
                 ArrayRef(const std::vector<T, A> &Vec)
      : Data(Vec.data()), Length(Vec.size()) {}


    template <size_t N>
                 constexpr ArrayRef(const std::array<T, N> &Arr)
        : Data(Arr.data()), Length(N) {}


    template <size_t N>
                 constexpr ArrayRef(const T (&Arr)[N]) : Data(Arr), Length(N) {}
# 116 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
    constexpr ArrayRef(const std::initializer_list<T> &Vec)
        : Data(Vec.begin() == Vec.end() ? (T *)nullptr : Vec.begin()),
          Length(Vec.size()) {}






    template <typename U>
    ArrayRef(const ArrayRef<U *> &A,
             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>
                 * = nullptr)
        : Data(A.data()), Length(A.size()) {}




    template <typename U, typename DummyT>
                 ArrayRef(
        const SmallVectorTemplateCommon<U *, DummyT> &Vec,
        std::enable_if_t<std::is_convertible<U *const *, T const *>::value> * =
            nullptr)
        : Data(Vec.data()), Length(Vec.size()) {}



    template <typename U, typename A>
    ArrayRef(const std::vector<U *, A> &Vec,
             std::enable_if_t<std::is_convertible<U *const *, T const *>::value>
                 * = nullptr)
        : Data(Vec.data()), Length(Vec.size()) {}





    iterator begin() const { return Data; }
    iterator end() const { return Data + Length; }

    reverse_iterator rbegin() const { return reverse_iterator(end()); }
    reverse_iterator rend() const { return reverse_iterator(begin()); }


    bool empty() const { return Length == 0; }

    const T *data() const { return Data; }


    size_t size() const { return Length; }


    const T &front() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 169, "!empty()") : (void)0);
      return Data[0];
    }


    const T &back() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 175, "!empty()") : (void)0);
      return Data[Length-1];
    }


    template <typename Allocator> MutableArrayRef<T> copy(Allocator &A) {
      T *Buff = A.template Allocate<T>(Length);
      std::uninitialized_copy(begin(), end(), Buff);
      return MutableArrayRef<T>(Buff, Length);
    }


    bool equals(ArrayRef RHS) const {
      if (Length != RHS.Length)
        return false;
      return std::equal(begin(), end(), RHS.begin());
    }



    ArrayRef<T> slice(size_t N, size_t M) const {
      (__builtin_expect(!(N+M <= size() && "Invalid specifier"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 196, "N+M <= size() && \"Invalid specifier\"") : (void)0);
      return ArrayRef<T>(data()+N, M);
    }


    ArrayRef<T> slice(size_t N) const { return slice(N, size() - N); }


    ArrayRef<T> drop_front(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 205, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(N, size() - N);
    }


    ArrayRef<T> drop_back(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 211, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(0, size() - N);
    }



    template <class PredicateT> ArrayRef<T> drop_while(PredicateT Pred) const {
      return ArrayRef<T>(find_if_not(*this, Pred), end());
    }



    template <class PredicateT> ArrayRef<T> drop_until(PredicateT Pred) const {
      return ArrayRef<T>(find_if(*this, Pred), end());
    }


    ArrayRef<T> take_front(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_back(size() - N);
    }


    ArrayRef<T> take_back(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_front(size() - N);
    }



    template <class PredicateT> ArrayRef<T> take_while(PredicateT Pred) const {
      return ArrayRef<T>(begin(), find_if_not(*this, Pred));
    }



    template <class PredicateT> ArrayRef<T> take_until(PredicateT Pred) const {
      return ArrayRef<T>(begin(), find_if(*this, Pred));
    }




    const T &operator[](size_t Index) const {
      (__builtin_expect(!(Index < Length && "Invalid index!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 257, "Index < Length && \"Invalid index!\"") : (void)0);
      return Data[Index];
    }





    template <typename U>
    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
    operator=(U &&Temporary) = delete;





    template <typename U>
    std::enable_if_t<std::is_same<U, T>::value, ArrayRef<T>> &
    operator=(std::initializer_list<U>) = delete;




    std::vector<T> vec() const {
      return std::vector<T>(Data, Data+Length);
    }




    operator std::vector<T>() const {
      return std::vector<T>(Data, Data+Length);
    }


  };
# 306 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/ArrayRef.h"
  template<typename T>
  class [[nodiscard]] MutableArrayRef : public ArrayRef<T> {
  public:
    using value_type = T;
    using pointer = value_type *;
    using const_pointer = const value_type *;
    using reference = value_type &;
    using const_reference = const value_type &;
    using iterator = pointer;
    using const_iterator = const_pointer;
    using reverse_iterator = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    using size_type = size_t;
    using difference_type = ptrdiff_t;


                 MutableArrayRef() = default;


                 MutableArrayRef(std::nullopt_t) : ArrayRef<T>() {}


                 MutableArrayRef(T &OneElt) : ArrayRef<T>(OneElt) {}


                 MutableArrayRef(T *data, size_t length)
      : ArrayRef<T>(data, length) {}


    MutableArrayRef(T *begin, T *end) : ArrayRef<T>(begin, end) {}


                 MutableArrayRef(SmallVectorImpl<T> &Vec)
    : ArrayRef<T>(Vec) {}


                 MutableArrayRef(std::vector<T> &Vec)
    : ArrayRef<T>(Vec) {}


    template <size_t N>
                 constexpr MutableArrayRef(std::array<T, N> &Arr)
        : ArrayRef<T>(Arr) {}


    template <size_t N>
                 constexpr MutableArrayRef(T (&Arr)[N]) : ArrayRef<T>(Arr) {}

    T *data() const { return const_cast<T*>(ArrayRef<T>::data()); }

    iterator begin() const { return data(); }
    iterator end() const { return data() + this->size(); }

    reverse_iterator rbegin() const { return reverse_iterator(end()); }
    reverse_iterator rend() const { return reverse_iterator(begin()); }


    T &front() const {
      (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 364, "!this->empty()") : (void)0);
      return data()[0];
    }


    T &back() const {
      (__builtin_expect(!(!this->empty()), 0) ? __assert_rtn(__func__, "ArrayRef.h", 370, "!this->empty()") : (void)0);
      return data()[this->size()-1];
    }



    MutableArrayRef<T> slice(size_t N, size_t M) const {
      (__builtin_expect(!(N + M <= this->size() && "Invalid specifier"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 377, "N + M <= this->size() && \"Invalid specifier\"") : (void)0);
      return MutableArrayRef<T>(this->data() + N, M);
    }


    MutableArrayRef<T> slice(size_t N) const {
      return slice(N, this->size() - N);
    }


    MutableArrayRef<T> drop_front(size_t N = 1) const {
      (__builtin_expect(!(this->size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 388, "this->size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(N, this->size() - N);
    }

    MutableArrayRef<T> drop_back(size_t N = 1) const {
      (__builtin_expect(!(this->size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 393, "this->size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return slice(0, this->size() - N);
    }



    template <class PredicateT>
    MutableArrayRef<T> drop_while(PredicateT Pred) const {
      return MutableArrayRef<T>(find_if_not(*this, Pred), end());
    }



    template <class PredicateT>
    MutableArrayRef<T> drop_until(PredicateT Pred) const {
      return MutableArrayRef<T>(find_if(*this, Pred), end());
    }


    MutableArrayRef<T> take_front(size_t N = 1) const {
      if (N >= this->size())
        return *this;
      return drop_back(this->size() - N);
    }


    MutableArrayRef<T> take_back(size_t N = 1) const {
      if (N >= this->size())
        return *this;
      return drop_front(this->size() - N);
    }



    template <class PredicateT>
    MutableArrayRef<T> take_while(PredicateT Pred) const {
      return MutableArrayRef<T>(begin(), find_if_not(*this, Pred));
    }



    template <class PredicateT>
    MutableArrayRef<T> take_until(PredicateT Pred) const {
      return MutableArrayRef<T>(begin(), find_if(*this, Pred));
    }




    T &operator[](size_t Index) const {
      (__builtin_expect(!(Index < this->size() && "Invalid index!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 443, "Index < this->size() && \"Invalid index!\"") : (void)0);
      return data()[Index];
    }
  };


  template <typename T> class OwningArrayRef : public MutableArrayRef<T> {
  public:
    OwningArrayRef() = default;
    OwningArrayRef(size_t Size) : MutableArrayRef<T>(new T[Size], Size) {}

    OwningArrayRef(ArrayRef<T> Data)
        : MutableArrayRef<T>(new T[Data.size()], Data.size()) {
      std::copy(Data.begin(), Data.end(), this->begin());
    }

    OwningArrayRef(OwningArrayRef &&Other) { *this = std::move(Other); }

    OwningArrayRef &operator=(OwningArrayRef &&Other) {
      delete[] this->data();
      this->MutableArrayRef<T>::operator=(Other);
      Other.MutableArrayRef<T>::operator=(MutableArrayRef<T>());
      return *this;
    }

    ~OwningArrayRef() { delete[] this->data(); }
  };




  template <typename T> ArrayRef(const T &OneElt) -> ArrayRef<T>;


  template <typename T> ArrayRef(const T *data, size_t length) -> ArrayRef<T>;


  template <typename T> ArrayRef(const T *data, const T *end) -> ArrayRef<T>;


  template <typename T> ArrayRef(const SmallVectorImpl<T> &Vec) -> ArrayRef<T>;


  template <typename T, unsigned N>
  ArrayRef(const SmallVector<T, N> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(const std::vector<T> &Vec) -> ArrayRef<T>;


  template <typename T, std::size_t N>
  ArrayRef(const std::array<T, N> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(const ArrayRef<T> &Vec) -> ArrayRef<T>;


  template <typename T> ArrayRef(ArrayRef<T> &Vec) -> ArrayRef<T>;


  template <typename T, size_t N> ArrayRef(const T (&Arr)[N]) -> ArrayRef<T>;






  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const T &OneElt) {
    return OneElt;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const T *data, size_t length) {
    return ArrayRef<T>(data, length);
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const T *begin, const T *end) {
    return ArrayRef<T>(begin, end);
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const SmallVectorImpl<T> &Vec) {
    return Vec;
  }


  template <typename T, unsigned N>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const SmallVector<T, N> &Vec) {
    return Vec;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const std::vector<T> &Vec) {
    return Vec;
  }


  template <typename T, std::size_t N>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const std::array<T, N> &Arr) {
    return Arr;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const ArrayRef<T> &Vec) {
    return Vec;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> &makeArrayRef(ArrayRef<T> &Vec) {
    return Vec;
  }


  template <typename T, size_t N>
  __attribute__((deprecated("Use deduction guide instead", "ArrayRef")))
  ArrayRef<T> makeArrayRef(const T (&Arr)[N]) {
    return ArrayRef<T>(Arr);
  }




  template <class T> MutableArrayRef(T &OneElt) -> MutableArrayRef<T>;



  template <class T>
  MutableArrayRef(T *data, size_t length) -> MutableArrayRef<T>;


  template <class T>
  MutableArrayRef(SmallVectorImpl<T> &Vec) -> MutableArrayRef<T>;

  template <class T, unsigned N>
  MutableArrayRef(SmallVector<T, N> &Vec) -> MutableArrayRef<T>;


  template <class T> MutableArrayRef(std::vector<T> &Vec) -> MutableArrayRef<T>;


  template <class T, std::size_t N>
  MutableArrayRef(std::array<T, N> &Vec) -> MutableArrayRef<T>;


  template <typename T, size_t N>
  MutableArrayRef(T (&Arr)[N]) -> MutableArrayRef<T>;




  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(T &OneElt) {
    return OneElt;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(T *data, size_t length) {
    return MutableArrayRef<T>(data, length);
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(SmallVectorImpl<T> &Vec) {
    return Vec;
  }


  template <typename T, unsigned N>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(SmallVector<T, N> &Vec) {
    return Vec;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(std::vector<T> &Vec) {
    return Vec;
  }


  template <typename T, std::size_t N>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(std::array<T, N> &Arr) {
    return Arr;
  }


  template <typename T>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(const MutableArrayRef<T> &Vec) {
    return Vec;
  }


  template <typename T, size_t N>
  __attribute__((deprecated("Use deduction guide instead", "MutableArrayRef")))
  MutableArrayRef<T> makeMutableArrayRef(T (&Arr)[N]) {
    return MutableArrayRef<T>(Arr);
  }





  template<typename T>
  inline bool operator==(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return LHS.equals(RHS);
  }

  template <typename T>
  inline bool operator==(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
    return ArrayRef<T>(LHS).equals(RHS);
  }

  template <typename T>
  inline bool operator!=(ArrayRef<T> LHS, ArrayRef<T> RHS) {
    return !(LHS == RHS);
  }

  template <typename T>
  inline bool operator!=(SmallVectorImpl<T> &LHS, ArrayRef<T> RHS) {
    return !(LHS == RHS);
  }



  template <typename T> hash_code hash_value(ArrayRef<T> S) {
    return hash_combine_range(S.begin(), S.end());
  }


  template <typename T> struct DenseMapInfo<ArrayRef<T>, void> {
    static inline ArrayRef<T> getEmptyKey() {
      return ArrayRef<T>(
          reinterpret_cast<const T *>(~static_cast<uintptr_t>(0)), size_t(0));
    }

    static inline ArrayRef<T> getTombstoneKey() {
      return ArrayRef<T>(
          reinterpret_cast<const T *>(~static_cast<uintptr_t>(1)), size_t(0));
    }

    static unsigned getHashValue(ArrayRef<T> Val) {
      (__builtin_expect(!(Val.data() != getEmptyKey().data() && "Cannot hash the empty key!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 709, "Val.data() != getEmptyKey().data() && \"Cannot hash the empty key!\"") : (void)0);

      (__builtin_expect(!(Val.data() != getTombstoneKey().data() && "Cannot hash the tombstone key!"), 0) ? __assert_rtn(__func__, "ArrayRef.h", 711, "Val.data() != getTombstoneKey().data() && \"Cannot hash the tombstone key!\"") : (void)0);

      return (unsigned)(hash_value(Val));
    }

    static bool isEqual(ArrayRef<T> LHS, ArrayRef<T> RHS) {
      if (RHS.data() == getEmptyKey().data())
        return LHS.data() == getEmptyKey().data();
      if (RHS.data() == getTombstoneKey().data())
        return LHS.data() == getTombstoneKey().data();
      return LHS == RHS;
    }
  };

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/DenseMapInfo.h" 2


namespace llvm {

namespace detail {


static inline unsigned combineHashValue(unsigned a, unsigned b) {
  uint64_t key = (uint64_t)a << 32 | (uint64_t)b;
  key += ~(key << 32);
  key ^= (key >> 22);
  key += ~(key << 13);
  key ^= (key >> 8);
  key += (key << 3);
  key ^= (key >> 15);
  key += ~(key << 27);
  key ^= (key >> 31);
  return (unsigned)key;
}

}






template<typename T, typename Enable = void>
struct DenseMapInfo {




};






template<typename T>
struct DenseMapInfo<T*> {




  static constexpr uintptr_t Log2MaxAlign = 12;

  static inline T* getEmptyKey() {
    uintptr_t Val = static_cast<uintptr_t>(-1);
    Val <<= Log2MaxAlign;
    return reinterpret_cast<T*>(Val);
  }

  static inline T* getTombstoneKey() {
    uintptr_t Val = static_cast<uintptr_t>(-2);
    Val <<= Log2MaxAlign;
    return reinterpret_cast<T*>(Val);
  }

  static unsigned getHashValue(const T *PtrVal) {
    return (unsigned((uintptr_t)PtrVal) >> 4) ^
           (unsigned((uintptr_t)PtrVal) >> 9);
  }

  static bool isEqual(const T *LHS, const T *RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<char> {
  static inline char getEmptyKey() { return ~0; }
  static inline char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const char& Val) { return Val * 37U; }

  static bool isEqual(const char &LHS, const char &RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<unsigned char> {
  static inline unsigned char getEmptyKey() { return ~0; }
  static inline unsigned char getTombstoneKey() { return ~0 - 1; }
  static unsigned getHashValue(const unsigned char &Val) { return Val * 37U; }

  static bool isEqual(const unsigned char &LHS, const unsigned char &RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<unsigned short> {
  static inline unsigned short getEmptyKey() { return 0xFFFF; }
  static inline unsigned short getTombstoneKey() { return 0xFFFF - 1; }
  static unsigned getHashValue(const unsigned short &Val) { return Val * 37U; }

  static bool isEqual(const unsigned short &LHS, const unsigned short &RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned> {
  static inline unsigned getEmptyKey() { return ~0U; }
  static inline unsigned getTombstoneKey() { return ~0U - 1; }
  static unsigned getHashValue(const unsigned& Val) { return Val * 37U; }

  static bool isEqual(const unsigned& LHS, const unsigned& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long> {
  static inline unsigned long getEmptyKey() { return ~0UL; }
  static inline unsigned long getTombstoneKey() { return ~0UL - 1L; }

  static unsigned getHashValue(const unsigned long& Val) {
    return (unsigned)(Val * 37UL);
  }

  static bool isEqual(const unsigned long& LHS, const unsigned long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<unsigned long long> {
  static inline unsigned long long getEmptyKey() { return ~0ULL; }
  static inline unsigned long long getTombstoneKey() { return ~0ULL - 1ULL; }

  static unsigned getHashValue(const unsigned long long& Val) {
    return (unsigned)(Val * 37ULL);
  }

  static bool isEqual(const unsigned long long& LHS,
                      const unsigned long long& RHS) {
    return LHS == RHS;
  }
};


template <> struct DenseMapInfo<short> {
  static inline short getEmptyKey() { return 0x7FFF; }
  static inline short getTombstoneKey() { return -0x7FFF - 1; }
  static unsigned getHashValue(const short &Val) { return Val * 37U; }
  static bool isEqual(const short &LHS, const short &RHS) { return LHS == RHS; }
};


template<> struct DenseMapInfo<int> {
  static inline int getEmptyKey() { return 0x7fffffff; }
  static inline int getTombstoneKey() { return -0x7fffffff - 1; }
  static unsigned getHashValue(const int& Val) { return (unsigned)(Val * 37U); }

  static bool isEqual(const int& LHS, const int& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long> {
  static inline long getEmptyKey() {
    return (1UL << (sizeof(long) * 8 - 1)) - 1UL;
  }

  static inline long getTombstoneKey() { return getEmptyKey() - 1L; }

  static unsigned getHashValue(const long& Val) {
    return (unsigned)(Val * 37UL);
  }

  static bool isEqual(const long& LHS, const long& RHS) {
    return LHS == RHS;
  }
};


template<> struct DenseMapInfo<long long> {
  static inline long long getEmptyKey() { return 0x7fffffffffffffffLL; }
  static inline long long getTombstoneKey() { return -0x7fffffffffffffffLL-1; }

  static unsigned getHashValue(const long long& Val) {
    return (unsigned)(Val * 37ULL);
  }

  static bool isEqual(const long long& LHS,
                      const long long& RHS) {
    return LHS == RHS;
  }
};


template<typename T, typename U>
struct DenseMapInfo<std::pair<T, U>> {
  using Pair = std::pair<T, U>;
  using FirstInfo = DenseMapInfo<T>;
  using SecondInfo = DenseMapInfo<U>;

  static inline Pair getEmptyKey() {
    return std::make_pair(FirstInfo::getEmptyKey(),
                          SecondInfo::getEmptyKey());
  }

  static inline Pair getTombstoneKey() {
    return std::make_pair(FirstInfo::getTombstoneKey(),
                          SecondInfo::getTombstoneKey());
  }

  static unsigned getHashValue(const Pair& PairVal) {
    return detail::combineHashValue(FirstInfo::getHashValue(PairVal.first),
                                    SecondInfo::getHashValue(PairVal.second));
  }




  static unsigned getHashValuePiecewise(const T &First, const U &Second) {
    return detail::combineHashValue(FirstInfo::getHashValue(First),
                                    SecondInfo::getHashValue(Second));
  }

  static bool isEqual(const Pair &LHS, const Pair &RHS) {
    return FirstInfo::isEqual(LHS.first, RHS.first) &&
           SecondInfo::isEqual(LHS.second, RHS.second);
  }
};


template <typename... Ts> struct DenseMapInfo<std::tuple<Ts...>> {
  using Tuple = std::tuple<Ts...>;

  static inline Tuple getEmptyKey() {
    return Tuple(DenseMapInfo<Ts>::getEmptyKey()...);
  }

  static inline Tuple getTombstoneKey() {
    return Tuple(DenseMapInfo<Ts>::getTombstoneKey()...);
  }

  template <unsigned I>
  static unsigned getHashValueImpl(const Tuple &values, std::false_type) {
    using EltType = std::tuple_element_t<I, Tuple>;
    std::integral_constant<bool, I + 1 == sizeof...(Ts)> atEnd;
    return detail::combineHashValue(
        DenseMapInfo<EltType>::getHashValue(std::get<I>(values)),
        getHashValueImpl<I + 1>(values, atEnd));
  }

  template <unsigned I>
  static unsigned getHashValueImpl(const Tuple &, std::true_type) {
    return 0;
  }

  static unsigned getHashValue(const std::tuple<Ts...> &values) {
    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
    return getHashValueImpl<0>(values, atEnd);
  }

  template <unsigned I>
  static bool isEqualImpl(const Tuple &lhs, const Tuple &rhs, std::false_type) {
    using EltType = std::tuple_element_t<I, Tuple>;
    std::integral_constant<bool, I + 1 == sizeof...(Ts)> atEnd;
    return DenseMapInfo<EltType>::isEqual(std::get<I>(lhs), std::get<I>(rhs)) &&
           isEqualImpl<I + 1>(lhs, rhs, atEnd);
  }

  template <unsigned I>
  static bool isEqualImpl(const Tuple &, const Tuple &, std::true_type) {
    return true;
  }

  static bool isEqual(const Tuple &lhs, const Tuple &rhs) {
    std::integral_constant<bool, 0 == sizeof...(Ts)> atEnd;
    return isEqualImpl<0>(lhs, rhs, atEnd);
  }
};

}
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 2




# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 2





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h" 2


namespace llvm {

  class APInt;
  class hash_code;
  template <typename T> class SmallVectorImpl;
  class StringRef;


  bool getAsUnsignedInteger(StringRef Str, unsigned Radix,
                            unsigned long long &Result);

  bool getAsSignedInteger(StringRef Str, unsigned Radix, long long &Result);

  bool consumeUnsignedInteger(StringRef &Str, unsigned Radix,
                              unsigned long long &Result);
  bool consumeSignedInteger(StringRef &Str, unsigned Radix, long long &Result);
# 50 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
  class [[gsl::Pointer]] StringRef {
  public:
    static constexpr size_t npos = ~size_t(0);

    using iterator = const char *;
    using const_iterator = const char *;
    using size_type = size_t;

  private:

    const char *Data = nullptr;


    size_t Length = 0;



    static int compareMemory(const char *Lhs, const char *Rhs, size_t Length) {
      if (Length == 0) { return 0; }
      return ::memcmp(Lhs,Rhs,Length);
    }

  public:




                 StringRef() = default;



    StringRef(std::nullptr_t) = delete;


                 constexpr StringRef(const char *Str)
        : Data(Str), Length(Str ?




                                std::char_traits<char>::length(Str)

                                : 0) {
    }


                 constexpr StringRef(const char *data, size_t length)
        : Data(data), Length(length) {}


                 StringRef(const std::string &Str)
      : Data(Str.data()), Length(Str.length()) {}


                 constexpr StringRef(std::string_view Str)
        : Data(Str.data()), Length(Str.size()) {}





    iterator begin() const { return Data; }

    iterator end() const { return Data + Length; }

    const unsigned char *bytes_begin() const {
      return reinterpret_cast<const unsigned char *>(begin());
    }
    const unsigned char *bytes_end() const {
      return reinterpret_cast<const unsigned char *>(end());
    }
    iterator_range<const unsigned char *> bytes() const {
      return make_range(bytes_begin(), bytes_end());
    }







    [[nodiscard]] const char *data() const { return Data; }


    [[nodiscard]] constexpr bool empty() const { return Length == 0; }


    [[nodiscard]] constexpr size_t size() const { return Length; }


    [[nodiscard]] char front() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "StringRef.h", 141, "!empty()") : (void)0);
      return Data[0];
    }


    [[nodiscard]] char back() const {
      (__builtin_expect(!(!empty()), 0) ? __assert_rtn(__func__, "StringRef.h", 147, "!empty()") : (void)0);
      return Data[Length-1];
    }


    template <typename Allocator>
    [[nodiscard]] StringRef copy(Allocator &A) const {

      if (empty())
        return StringRef();
      char *S = A.template Allocate<char>(Length);
      std::copy(begin(), end(), S);
      return StringRef(S, Length);
    }



    [[nodiscard]] bool equals(StringRef RHS) const {
      return (Length == RHS.Length &&
              compareMemory(Data, RHS.Data, RHS.Length) == 0);
    }


    [[nodiscard]] bool equals_insensitive(StringRef RHS) const {
      return Length == RHS.Length && compare_insensitive(RHS) == 0;
    }




    [[nodiscard]] int compare(StringRef RHS) const {

      if (int Res = compareMemory(Data, RHS.Data, std::min(Length, RHS.Length)))
        return Res < 0 ? -1 : 1;


      if (Length == RHS.Length)
        return 0;
      return Length < RHS.Length ? -1 : 1;
    }


    [[nodiscard]] int compare_insensitive(StringRef RHS) const;



    [[nodiscard]] int compare_numeric(StringRef RHS) const;
# 213 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] unsigned edit_distance(StringRef Other,
                                         bool AllowReplacements = true,
                                         unsigned MaxEditDistance = 0) const;

    [[nodiscard]] unsigned
    edit_distance_insensitive(StringRef Other, bool AllowReplacements = true,
                              unsigned MaxEditDistance = 0) const;


    [[nodiscard]] std::string str() const {
      if (!Data) return std::string();
      return std::string(Data, Length);
    }





    [[nodiscard]] char operator[](size_t Index) const {
      (__builtin_expect(!(Index < Length && "Invalid index!"), 0) ? __assert_rtn(__func__, "StringRef.h", 232, "Index < Length && \"Invalid index!\"") : (void)0);
      return Data[Index];
    }





    template <typename T>
    std::enable_if_t<std::is_same<T, std::string>::value, StringRef> &
    operator=(T &&Str) = delete;





    operator std::string_view() const {
      return std::string_view(data(), size());
    }






    [[nodiscard]] bool starts_with(StringRef Prefix) const {
      return Length >= Prefix.Length &&
             compareMemory(Data, Prefix.Data, Prefix.Length) == 0;
    }
    [[nodiscard]] bool startswith(StringRef Prefix) const {
      return starts_with(Prefix);
    }


    [[nodiscard]] bool starts_with_insensitive(StringRef Prefix) const;
    [[nodiscard]] __attribute__((deprecated("Use starts_with_insensitive instead", "starts_with_insensitive"))) bool startswith_insensitive(StringRef Prefix)


        const {
      return starts_with_insensitive(Prefix);
    }


    [[nodiscard]] bool ends_with(StringRef Suffix) const {
      return Length >= Suffix.Length &&
             compareMemory(end() - Suffix.Length, Suffix.Data, Suffix.Length) ==
                 0;
    }
    [[nodiscard]] bool endswith(StringRef Suffix) const {
      return ends_with(Suffix);
    }


    [[nodiscard]] bool ends_with_insensitive(StringRef Suffix) const;
    [[nodiscard]] __attribute__((deprecated("Use ends_with_insensitive instead", "ends_with_insensitive"))) bool endswith_insensitive(StringRef Suffix)


        const {
      return ends_with_insensitive(Suffix);
    }
# 301 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] size_t find(char C, size_t From = 0) const {
      return std::string_view(*this).find(C, From);
    }





    [[nodiscard]] size_t find_insensitive(char C, size_t From = 0) const;





    [[nodiscard]] size_t find_if(function_ref<bool(char)> F,
                                 size_t From = 0) const {
      StringRef S = drop_front(From);
      while (!S.empty()) {
        if (F(S.front()))
          return size() - S.size();
        S = S.drop_front();
      }
      return npos;
    }





    [[nodiscard]] size_t find_if_not(function_ref<bool(char)> F,
                                     size_t From = 0) const {
      return find_if([F](char c) { return !F(c); }, From);
    }





    [[nodiscard]] size_t find(StringRef Str, size_t From = 0) const;





    [[nodiscard]] size_t find_insensitive(StringRef Str, size_t From = 0) const;





    [[nodiscard]] size_t rfind(char C, size_t From = npos) const {
      size_t I = std::min(From, Length);
      while (I) {
        --I;
        if (Data[I] == C)
          return I;
      }
      return npos;
    }





    [[nodiscard]] size_t rfind_insensitive(char C, size_t From = npos) const;





    [[nodiscard]] size_t rfind(StringRef Str) const;





    [[nodiscard]] size_t rfind_insensitive(StringRef Str) const;



    [[nodiscard]] size_t find_first_of(char C, size_t From = 0) const {
      return find(C, From);
    }





    [[nodiscard]] size_t find_first_of(StringRef Chars, size_t From = 0) const;



    [[nodiscard]] size_t find_first_not_of(char C, size_t From = 0) const;





    [[nodiscard]] size_t find_first_not_of(StringRef Chars,
                                           size_t From = 0) const;



    [[nodiscard]] size_t find_last_of(char C, size_t From = npos) const {
      return rfind(C, From);
    }





    [[nodiscard]] size_t find_last_of(StringRef Chars,
                                      size_t From = npos) const;



    [[nodiscard]] size_t find_last_not_of(char C, size_t From = npos) const;





    [[nodiscard]] size_t find_last_not_of(StringRef Chars,
                                          size_t From = npos) const;



    [[nodiscard]] bool contains(StringRef Other) const {
      return find(Other) != npos;
    }



    [[nodiscard]] bool contains(char C) const {
      return find_first_of(C) != npos;
    }



    [[nodiscard]] bool contains_insensitive(StringRef Other) const {
      return find_insensitive(Other) != npos;
    }



    [[nodiscard]] bool contains_insensitive(char C) const {
      return find_insensitive(C) != npos;
    }






    [[nodiscard]] size_t count(char C) const {
      size_t Count = 0;
      for (size_t I = 0; I != Length; ++I)
        if (Data[I] == C)
          ++Count;
      return Count;
    }



    size_t count(StringRef Str) const;
# 474 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    template <typename T> bool getAsInteger(unsigned Radix, T &Result) const {
      if constexpr (std::numeric_limits<T>::is_signed) {
        long long LLVal;
        if (getAsSignedInteger(*this, Radix, LLVal) ||
            static_cast<T>(LLVal) != LLVal)
          return true;
        Result = LLVal;
      } else {
        unsigned long long ULLVal;



        if (getAsUnsignedInteger(*this, Radix, ULLVal) ||
            static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)
          return true;
        Result = ULLVal;
      }
      return false;
    }
# 503 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    template <typename T> bool consumeInteger(unsigned Radix, T &Result) {
      if constexpr (std::numeric_limits<T>::is_signed) {
        long long LLVal;
        if (consumeSignedInteger(*this, Radix, LLVal) ||
            static_cast<long long>(static_cast<T>(LLVal)) != LLVal)
          return true;
        Result = LLVal;
      } else {
        unsigned long long ULLVal;
        if (consumeUnsignedInteger(*this, Radix, ULLVal) ||
            static_cast<unsigned long long>(static_cast<T>(ULLVal)) != ULLVal)
          return true;
        Result = ULLVal;
      }
      return false;
    }
# 530 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    bool getAsInteger(unsigned Radix, APInt &Result) const;
# 541 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    bool consumeInteger(unsigned Radix, APInt &Result);
# 550 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    bool getAsDouble(double &Result, bool AllowInexact = true) const;






    [[nodiscard]] std::string lower() const;


    [[nodiscard]] std::string upper() const;
# 575 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] constexpr StringRef substr(size_t Start,
                                             size_t N = npos) const {
      Start = std::min(Start, Length);
      return StringRef(Data + Start, std::min(N, Length - Start));
    }




    [[nodiscard]] StringRef take_front(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_back(size() - N);
    }




    [[nodiscard]] StringRef take_back(size_t N = 1) const {
      if (N >= size())
        return *this;
      return drop_front(size() - N);
    }



    [[nodiscard]] StringRef take_while(function_ref<bool(char)> F) const {
      return substr(0, find_if_not(F));
    }



    [[nodiscard]] StringRef take_until(function_ref<bool(char)> F) const {
      return substr(0, find_if(F));
    }



    [[nodiscard]] StringRef drop_front(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "StringRef.h", 614, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return substr(N);
    }



    [[nodiscard]] StringRef drop_back(size_t N = 1) const {
      (__builtin_expect(!(size() >= N && "Dropping more elements than exist"), 0) ? __assert_rtn(__func__, "StringRef.h", 621, "size() >= N && \"Dropping more elements than exist\"") : (void)0);
      return substr(0, size()-N);
    }



    [[nodiscard]] StringRef drop_while(function_ref<bool(char)> F) const {
      return substr(find_if_not(F));
    }



    [[nodiscard]] StringRef drop_until(function_ref<bool(char)> F) const {
      return substr(find_if(F));
    }



    bool consume_front(StringRef Prefix) {
      if (!starts_with(Prefix))
        return false;

      *this = substr(Prefix.size());
      return true;
    }



    bool consume_front_insensitive(StringRef Prefix) {
      if (!starts_with_insensitive(Prefix))
        return false;

      *this = substr(Prefix.size());
      return true;
    }



    bool consume_back(StringRef Suffix) {
      if (!ends_with(Suffix))
        return false;

      *this = substr(0, size() - Suffix.size());
      return true;
    }



    bool consume_back_insensitive(StringRef Suffix) {
      if (!ends_with_insensitive(Suffix))
        return false;

      *this = substr(0, size() - Suffix.size());
      return true;
    }
# 688 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] StringRef slice(size_t Start, size_t End) const {
      Start = std::min(Start, Length);
      End = std::clamp(End, Start, Length);
      return StringRef(Data + Start, End - Start);
    }
# 704 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef> split(char Separator) const {
      return split(StringRef(&Separator, 1));
    }
# 718 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef>
    split(StringRef Separator) const {
      size_t Idx = find(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));
    }
# 736 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef>
    rsplit(StringRef Separator) const {
      size_t Idx = rfind(Separator);
      if (Idx == npos)
        return std::make_pair(*this, StringRef());
      return std::make_pair(slice(0, Idx), slice(Idx + Separator.size(), npos));
    }
# 758 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    void split(SmallVectorImpl<StringRef> &A,
               StringRef Separator, int MaxSplit = -1,
               bool KeepEmpty = true) const;
# 776 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    void split(SmallVectorImpl<StringRef> &A, char Separator, int MaxSplit = -1,
               bool KeepEmpty = true) const;
# 789 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
    [[nodiscard]] std::pair<StringRef, StringRef> rsplit(char Separator) const {
      return rsplit(StringRef(&Separator, 1));
    }



    [[nodiscard]] StringRef ltrim(char Char) const {
      return drop_front(std::min(Length, find_first_not_of(Char)));
    }



    [[nodiscard]] StringRef ltrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_front(std::min(Length, find_first_not_of(Chars)));
    }



    [[nodiscard]] StringRef rtrim(char Char) const {
      return drop_back(Length - std::min(Length, find_last_not_of(Char) + 1));
    }



    [[nodiscard]] StringRef rtrim(StringRef Chars = " \t\n\v\f\r") const {
      return drop_back(Length - std::min(Length, find_last_not_of(Chars) + 1));
    }



    [[nodiscard]] StringRef trim(char Char) const {
      return ltrim(Char).rtrim(Char);
    }



    [[nodiscard]] StringRef trim(StringRef Chars = " \t\n\v\f\r") const {
      return ltrim(Chars).rtrim(Chars);
    }







    [[nodiscard]] StringRef detectEOL() const {
      size_t Pos = find('\r');
      if (Pos == npos) {

        return "\n";
      }
      if (Pos + 1 < Length && Data[Pos + 1] == '\n')
        return "\r\n";
      if (Pos > 0 && Data[Pos - 1] == '\n')
        return "\n\r";
      return "\r";
    }

  };
# 857 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/StringRef.h"
  class StringLiteral : public StringRef {
  private:
    constexpr StringLiteral(const char *Str, size_t N) : StringRef(Str, N) {
    }

  public:
    template <size_t N>
    constexpr StringLiteral(const char (&Str)[N])

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"
        __attribute((enable_if(__builtin_strlen(Str) == N - 1,
                               "invalid string literal")))
#pragma clang diagnostic pop

        : StringRef(Str, N - 1) {
    }


    template <size_t N>
    static constexpr StringLiteral withInnerNUL(const char (&Str)[N]) {
      return StringLiteral(Str, N - 1);
    }
  };




  inline bool operator==(StringRef LHS, StringRef RHS) {
    return LHS.equals(RHS);
  }

  inline bool operator!=(StringRef LHS, StringRef RHS) { return !(LHS == RHS); }

  inline bool operator<(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) < 0;
  }

  inline bool operator<=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) <= 0;
  }

  inline bool operator>(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) > 0;
  }

  inline bool operator>=(StringRef LHS, StringRef RHS) {
    return LHS.compare(RHS) >= 0;
  }

  inline std::string &operator+=(std::string &buffer, StringRef string) {
    return buffer.append(string.data(), string.size());
  }




  [[nodiscard]] hash_code hash_value(StringRef S);


  template <> struct DenseMapInfo<StringRef, void> {
    static inline StringRef getEmptyKey() {
      return StringRef(
          reinterpret_cast<const char *>(~static_cast<uintptr_t>(0)), 0);
    }

    static inline StringRef getTombstoneKey() {
      return StringRef(
          reinterpret_cast<const char *>(~static_cast<uintptr_t>(1)), 0);
    }

    static unsigned getHashValue(StringRef Val);

    static bool isEqual(StringRef LHS, StringRef RHS) {
      if (RHS.data() == getEmptyKey().data())
        return LHS.data() == getEmptyKey().data();
      if (RHS.data() == getTombstoneKey().data())
        return LHS.data() == getTombstoneKey().data();
      return LHS == RHS;
    }
  };

}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h" 2




namespace llvm {

  class formatv_object_base;
  class raw_ostream;
# 81 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h"
  class Twine {

    enum NodeKind : unsigned char {


      NullKind,


      EmptyKind,


      TwineKind,


      CStringKind,


      StdStringKind,




      PtrAndLengthKind,



      StringLiteralKind,


      FormatvObjectKind,


      CharKind,


      DecUIKind,


      DecIKind,



      DecULKind,


      DecLKind,



      DecULLKind,


      DecLLKind,



      UHexKind
    };

    union Child
    {
      const Twine *twine;
      const char *cString;
      const std::string *stdString;
      struct {
        const char *ptr;
        size_t length;
      } ptrAndLength;
      const formatv_object_base *formatvObject;
      char character;
      unsigned int decUI;
      int decI;
      const unsigned long *decUL;
      const long *decL;
      const unsigned long long *decULL;
      const long long *decLL;
      const uint64_t *uHex;
    };



    Child LHS;



    Child RHS;


    NodeKind LHSKind = EmptyKind;


    NodeKind RHSKind = EmptyKind;


    explicit Twine(NodeKind Kind) : LHSKind(Kind) {
      (__builtin_expect(!(isNullary() && "Invalid kind!"), 0) ? __assert_rtn(__func__, "Twine.h", 176, "isNullary() && \"Invalid kind!\"") : (void)0);
    }


    explicit Twine(const Twine &LHS, const Twine &RHS)
        : LHSKind(TwineKind), RHSKind(TwineKind) {
      this->LHS.twine = &LHS;
      this->RHS.twine = &RHS;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 184, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    explicit Twine(Child LHS, NodeKind LHSKind, Child RHS, NodeKind RHSKind)
        : LHS(LHS), RHS(RHS), LHSKind(LHSKind), RHSKind(RHSKind) {
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 190, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    bool isNull() const {
      return getLHSKind() == NullKind;
    }


    bool isEmpty() const {
      return getLHSKind() == EmptyKind;
    }


    bool isNullary() const {
      return isNull() || isEmpty();
    }


    bool isUnary() const {
      return getRHSKind() == EmptyKind && !isNullary();
    }


    bool isBinary() const {
      return getLHSKind() != NullKind && getRHSKind() != EmptyKind;
    }



    bool isValid() const {

      if (isNullary() && getRHSKind() != EmptyKind)
        return false;


      if (getRHSKind() == NullKind)
        return false;


      if (getRHSKind() != EmptyKind && getLHSKind() == EmptyKind)
        return false;


      if (getLHSKind() == TwineKind &&
          !LHS.twine->isBinary())
        return false;
      if (getRHSKind() == TwineKind &&
          !RHS.twine->isBinary())
        return false;

      return true;
    }


    NodeKind getLHSKind() const { return LHSKind; }


    NodeKind getRHSKind() const { return RHSKind; }


    void printOneChild(raw_ostream &OS, Child Ptr, NodeKind Kind) const;


    void printOneChildRepr(raw_ostream &OS, Child Ptr,
                           NodeKind Kind) const;

  public:




                 Twine() {
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 263, "isValid() && \"Invalid twine!\"") : (void)0);
    }

    Twine(const Twine &) = default;






                 Twine(const char *Str) {
      if (Str[0] != '\0') {
        LHS.cString = Str;
        LHSKind = CStringKind;
      } else
        LHSKind = EmptyKind;

      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 280, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(std::nullptr_t) = delete;


                 Twine(const std::string &Str) : LHSKind(StdStringKind) {
      LHS.stdString = &Str;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 289, "isValid() && \"Invalid twine!\"") : (void)0);
    }





                 Twine(const std::string_view &Str)
        : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.length();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 300, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringRef &Str) : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 307, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringLiteral &Str)
        : LHSKind(StringLiteralKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 315, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const SmallVectorImpl<char> &Str)
        : LHSKind(PtrAndLengthKind) {
      LHS.ptrAndLength.ptr = Str.data();
      LHS.ptrAndLength.length = Str.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 323, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const formatv_object_base &Fmt)
        : LHSKind(FormatvObjectKind) {
      LHS.formatvObject = &Fmt;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 330, "isValid() && \"Invalid twine!\"") : (void)0);
    }


    explicit Twine(char Val) : LHSKind(CharKind) {
      LHS.character = Val;
    }


    explicit Twine(signed char Val) : LHSKind(CharKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned char Val) : LHSKind(CharKind) {
      LHS.character = static_cast<char>(Val);
    }


    explicit Twine(unsigned Val) : LHSKind(DecUIKind) {
      LHS.decUI = Val;
    }


    explicit Twine(int Val) : LHSKind(DecIKind) {
      LHS.decI = Val;
    }


    explicit Twine(const unsigned long &Val) : LHSKind(DecULKind) {
      LHS.decUL = &Val;
    }


    explicit Twine(const long &Val) : LHSKind(DecLKind) {
      LHS.decL = &Val;
    }


    explicit Twine(const unsigned long long &Val) : LHSKind(DecULLKind) {
      LHS.decULL = &Val;
    }


    explicit Twine(const long long &Val) : LHSKind(DecLLKind) {
      LHS.decLL = &Val;
    }







                 Twine(const char *LHS, const StringRef &RHS)
        : LHSKind(CStringKind), RHSKind(PtrAndLengthKind) {
      this->LHS.cString = LHS;
      this->RHS.ptrAndLength.ptr = RHS.data();
      this->RHS.ptrAndLength.length = RHS.size();
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 389, "isValid() && \"Invalid twine!\"") : (void)0);
    }


                 Twine(const StringRef &LHS, const char *RHS)
        : LHSKind(PtrAndLengthKind), RHSKind(CStringKind) {
      this->LHS.ptrAndLength.ptr = LHS.data();
      this->LHS.ptrAndLength.length = LHS.size();
      this->RHS.cString = RHS;
      (__builtin_expect(!(isValid() && "Invalid twine!"), 0) ? __assert_rtn(__func__, "Twine.h", 398, "isValid() && \"Invalid twine!\"") : (void)0);
    }



    Twine &operator=(const Twine &) = delete;



    static Twine createNull() {
      return Twine(NullKind);
    }






    static Twine utohexstr(const uint64_t &Val) {
      Child LHS, RHS;
      LHS.uHex = &Val;
      RHS.twine = nullptr;
      return Twine(LHS, UHexKind, RHS, EmptyKind);
    }







    bool isTriviallyEmpty() const {
      return isNullary();
    }


    bool isSingleStringLiteral() const {
      return isUnary() && getLHSKind() == StringLiteralKind;
    }



    bool isSingleStringRef() const {
      if (getRHSKind() != EmptyKind) return false;

      switch (getLHSKind()) {
      case EmptyKind:
      case CStringKind:
      case StdStringKind:
      case PtrAndLengthKind:
      case StringLiteralKind:
        return true;
      default:
        return false;
      }
    }





    Twine concat(const Twine &Suffix) const;






    std::string str() const;


    void toVector(SmallVectorImpl<char> &Out) const;



    StringRef getSingleStringRef() const {
      (__builtin_expect(!(isSingleStringRef() &&"This cannot be had as a single stringref!"), 0) ? __assert_rtn(__func__, "Twine.h", 474, "isSingleStringRef() &&\"This cannot be had as a single stringref!\"") : (void)0);
      switch (getLHSKind()) {
      default: ::llvm::llvm_unreachable_internal("Out of sync with isSingleStringRef", "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/Twine.h", 476);
      case EmptyKind:
        return StringRef();
      case CStringKind:
        return StringRef(LHS.cString);
      case StdStringKind:
        return StringRef(*LHS.stdString);
      case PtrAndLengthKind:
      case StringLiteralKind:
        return StringRef(LHS.ptrAndLength.ptr, LHS.ptrAndLength.length);
      }
    }




    StringRef toStringRef(SmallVectorImpl<char> &Out) const {
      if (isSingleStringRef())
        return getSingleStringRef();
      toVector(Out);
      return StringRef(Out.data(), Out.size());
    }






    StringRef toNullTerminatedStringRef(SmallVectorImpl<char> &Out) const;



    void print(raw_ostream &OS) const;


    void dump() const;


    void printRepr(raw_ostream &OS) const;


    void dumpRepr() const;


  };




  inline Twine Twine::concat(const Twine &Suffix) const {

    if (isNull() || Suffix.isNull())
      return Twine(NullKind);


    if (isEmpty())
      return Suffix;
    if (Suffix.isEmpty())
      return *this;



    Child NewLHS, NewRHS;
    NewLHS.twine = this;
    NewRHS.twine = &Suffix;
    NodeKind NewLHSKind = TwineKind, NewRHSKind = TwineKind;
    if (isUnary()) {
      NewLHS = LHS;
      NewLHSKind = getLHSKind();
    }
    if (Suffix.isUnary()) {
      NewRHS = Suffix.LHS;
      NewRHSKind = Suffix.getLHSKind();
    }

    return Twine(NewLHS, NewLHSKind, NewRHS, NewRHSKind);
  }

  inline Twine operator+(const Twine &LHS, const Twine &RHS) {
    return LHS.concat(RHS);
  }




  inline Twine operator+(const char *LHS, const StringRef &RHS) {
    return Twine(LHS, RHS);
  }




  inline Twine operator+(const StringRef &LHS, const char *RHS) {
    return Twine(LHS, RHS);
  }

  inline raw_ostream &operator<<(raw_ostream &OS, const Twine &RHS) {
    RHS.print(OS);
    return OS;
  }



}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 1
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h" 2




# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h" 2

namespace llvm {


namespace numbers {


constexpr double e = 2.7182818284590452354,
                 egamma = .57721566490153286061,
                 ln2 = .69314718055994530942,
                 ln10 = 2.3025850929940456840,
                 log2e = 1.4426950408889634074,
                 log10e = .43429448190325182765,
                 pi = 3.1415926535897932385,
                 inv_pi = .31830988618379067154,
                 sqrtpi = 1.7724538509055160273,
                 inv_sqrtpi = .56418958354775628695,
                 sqrt2 = 1.4142135623730950488,
                 inv_sqrt2 = .70710678118654752440,
                 sqrt3 = 1.7320508075688772935,
                 inv_sqrt3 = .57735026918962576451,
                 phi = 1.6180339887498948482;
constexpr float ef = 2.71828183F,
                egammaf = .577215665F,
                ln2f = .693147181F,
                ln10f = 2.30258509F,
                log2ef = 1.44269504F,
                log10ef = .434294482F,
                pif = 3.14159265F,
                inv_pif = .318309886F,
                sqrtpif = 1.77245385F,
                inv_sqrtpif = .564189584F,
                sqrt2f = 1.41421356F,
                inv_sqrt2f = .707106781F,
                sqrt3f = 1.73205081F,
                inv_sqrt3f = .577350269F,
                phif = 1.61803399F;
}



template <typename T> T maskTrailingOnes(unsigned N) {
  static_assert(std::is_unsigned_v<T>, "Invalid type!");
  const unsigned Bits = 8 * sizeof(T);
  (__builtin_expect(!(N <= Bits && "Invalid bit index"), 0) ? __assert_rtn(__func__, "MathExtras.h", 68, "N <= Bits && \"Invalid bit index\"") : (void)0);
  return N == 0 ? 0 : (T(-1) >> (Bits - N));
}



template <typename T> T maskLeadingOnes(unsigned N) {
  return ~maskTrailingOnes<T>(8 * sizeof(T) - N);
}



template <typename T> T maskTrailingZeros(unsigned N) {
  return maskLeadingOnes<T>(8 * sizeof(T) - N);
}



template <typename T> T maskLeadingZeros(unsigned N) {
  return maskTrailingOnes<T>(8 * sizeof(T) - N);
}




static const unsigned char BitReverseTable256[256] = {



  0, 0 + 2 * 64, 0 + 1 * 64, 0 + 3 * 64, 0 + 2 * 16, 0 + 2 * 16 + 2 * 64, 0 + 2 * 16 + 1 * 64, 0 + 2 * 16 + 3 * 64, 0 + 1 * 16, 0 + 1 * 16 + 2 * 64, 0 + 1 * 16 + 1 * 64, 0 + 1 * 16 + 3 * 64, 0 + 3 * 16, 0 + 3 * 16 + 2 * 64, 0 + 3 * 16 + 1 * 64, 0 + 3 * 16 + 3 * 64, 0 + 2 * 4, 0 + 2 * 4 + 2 * 64, 0 + 2 * 4 + 1 * 64, 0 + 2 * 4 + 3 * 64, 0 + 2 * 4 + 2 * 16, 0 + 2 * 4 + 2 * 16 + 2 * 64, 0 + 2 * 4 + 2 * 16 + 1 * 64, 0 + 2 * 4 + 2 * 16 + 3 * 64, 0 + 2 * 4 + 1 * 16, 0 + 2 * 4 + 1 * 16 + 2 * 64, 0 + 2 * 4 + 1 * 16 + 1 * 64, 0 + 2 * 4 + 1 * 16 + 3 * 64, 0 + 2 * 4 + 3 * 16, 0 + 2 * 4 + 3 * 16 + 2 * 64, 0 + 2 * 4 + 3 * 16 + 1 * 64, 0 + 2 * 4 + 3 * 16 + 3 * 64, 0 + 1 * 4, 0 + 1 * 4 + 2 * 64, 0 + 1 * 4 + 1 * 64, 0 + 1 * 4 + 3 * 64, 0 + 1 * 4 + 2 * 16, 0 + 1 * 4 + 2 * 16 + 2 * 64, 0 + 1 * 4 + 2 * 16 + 1 * 64, 0 + 1 * 4 + 2 * 16 + 3 * 64, 0 + 1 * 4 + 1 * 16, 0 + 1 * 4 + 1 * 16 + 2 * 64, 0 + 1 * 4 + 1 * 16 + 1 * 64, 0 + 1 * 4 + 1 * 16 + 3 * 64, 0 + 1 * 4 + 3 * 16, 0 + 1 * 4 + 3 * 16 + 2 * 64, 0 + 1 * 4 + 3 * 16 + 1 * 64, 0 + 1 * 4 + 3 * 16 + 3 * 64, 0 + 3 * 4, 0 + 3 * 4 + 2 * 64, 0 + 3 * 4 + 1 * 64, 0 + 3 * 4 + 3 * 64, 0 + 3 * 4 + 2 * 16, 0 + 3 * 4 + 2 * 16 + 2 * 64, 0 + 3 * 4 + 2 * 16 + 1 * 64, 0 + 3 * 4 + 2 * 16 + 3 * 64, 0 + 3 * 4 + 1 * 16, 0 + 3 * 4 + 1 * 16 + 2 * 64, 0 + 3 * 4 + 1 * 16 + 1 * 64, 0 + 3 * 4 + 1 * 16 + 3 * 64, 0 + 3 * 4 + 3 * 16, 0 + 3 * 4 + 3 * 16 + 2 * 64, 0 + 3 * 4 + 3 * 16 + 1 * 64, 0 + 3 * 4 + 3 * 16 + 3 * 64, 2, 2 + 2 * 64, 2 + 1 * 64, 2 + 3 * 64, 2 + 2 * 16, 2 + 2 * 16 + 2 * 64, 2 + 2 * 16 + 1 * 64, 2 + 2 * 16 + 3 * 64, 2 + 1 * 16, 2 + 1 * 16 + 2 * 64, 2 + 1 * 16 + 1 * 64, 2 + 1 * 16 + 3 * 64, 2 + 3 * 16, 2 + 3 * 16 + 2 * 64, 2 + 3 * 16 + 1 * 64, 2 + 3 * 16 + 3 * 64, 2 + 2 * 4, 2 + 2 * 4 + 2 * 64, 2 + 2 * 4 + 1 * 64, 2 + 2 * 4 + 3 * 64, 2 + 2 * 4 + 2 * 16, 2 + 2 * 4 + 2 * 16 + 2 * 64, 2 + 2 * 4 + 2 * 16 + 1 * 64, 2 + 2 * 4 + 2 * 16 + 3 * 64, 2 + 2 * 4 + 1 * 16, 2 + 2 * 4 + 1 * 16 + 2 * 64, 2 + 2 * 4 + 1 * 16 + 1 * 64, 2 + 2 * 4 + 1 * 16 + 3 * 64, 2 + 2 * 4 + 3 * 16, 2 + 2 * 4 + 3 * 16 + 2 * 64, 2 + 2 * 4 + 3 * 16 + 1 * 64, 2 + 2 * 4 + 3 * 16 + 3 * 64, 2 + 1 * 4, 2 + 1 * 4 + 2 * 64, 2 + 1 * 4 + 1 * 64, 2 + 1 * 4 + 3 * 64, 2 + 1 * 4 + 2 * 16, 2 + 1 * 4 + 2 * 16 + 2 * 64, 2 + 1 * 4 + 2 * 16 + 1 * 64, 2 + 1 * 4 + 2 * 16 + 3 * 64, 2 + 1 * 4 + 1 * 16, 2 + 1 * 4 + 1 * 16 + 2 * 64, 2 + 1 * 4 + 1 * 16 + 1 * 64, 2 + 1 * 4 + 1 * 16 + 3 * 64, 2 + 1 * 4 + 3 * 16, 2 + 1 * 4 + 3 * 16 + 2 * 64, 2 + 1 * 4 + 3 * 16 + 1 * 64, 2 + 1 * 4 + 3 * 16 + 3 * 64, 2 + 3 * 4, 2 + 3 * 4 + 2 * 64, 2 + 3 * 4 + 1 * 64, 2 + 3 * 4 + 3 * 64, 2 + 3 * 4 + 2 * 16, 2 + 3 * 4 + 2 * 16 + 2 * 64, 2 + 3 * 4 + 2 * 16 + 1 * 64, 2 + 3 * 4 + 2 * 16 + 3 * 64, 2 + 3 * 4 + 1 * 16, 2 + 3 * 4 + 1 * 16 + 2 * 64, 2 + 3 * 4 + 1 * 16 + 1 * 64, 2 + 3 * 4 + 1 * 16 + 3 * 64, 2 + 3 * 4 + 3 * 16, 2 + 3 * 4 + 3 * 16 + 2 * 64, 2 + 3 * 4 + 3 * 16 + 1 * 64, 2 + 3 * 4 + 3 * 16 + 3 * 64, 1, 1 + 2 * 64, 1 + 1 * 64, 1 + 3 * 64, 1 + 2 * 16, 1 + 2 * 16 + 2 * 64, 1 + 2 * 16 + 1 * 64, 1 + 2 * 16 + 3 * 64, 1 + 1 * 16, 1 + 1 * 16 + 2 * 64, 1 + 1 * 16 + 1 * 64, 1 + 1 * 16 + 3 * 64, 1 + 3 * 16, 1 + 3 * 16 + 2 * 64, 1 + 3 * 16 + 1 * 64, 1 + 3 * 16 + 3 * 64, 1 + 2 * 4, 1 + 2 * 4 + 2 * 64, 1 + 2 * 4 + 1 * 64, 1 + 2 * 4 + 3 * 64, 1 + 2 * 4 + 2 * 16, 1 + 2 * 4 + 2 * 16 + 2 * 64, 1 + 2 * 4 + 2 * 16 + 1 * 64, 1 + 2 * 4 + 2 * 16 + 3 * 64, 1 + 2 * 4 + 1 * 16, 1 + 2 * 4 + 1 * 16 + 2 * 64, 1 + 2 * 4 + 1 * 16 + 1 * 64, 1 + 2 * 4 + 1 * 16 + 3 * 64, 1 + 2 * 4 + 3 * 16, 1 + 2 * 4 + 3 * 16 + 2 * 64, 1 + 2 * 4 + 3 * 16 + 1 * 64, 1 + 2 * 4 + 3 * 16 + 3 * 64, 1 + 1 * 4, 1 + 1 * 4 + 2 * 64, 1 + 1 * 4 + 1 * 64, 1 + 1 * 4 + 3 * 64, 1 + 1 * 4 + 2 * 16, 1 + 1 * 4 + 2 * 16 + 2 * 64, 1 + 1 * 4 + 2 * 16 + 1 * 64, 1 + 1 * 4 + 2 * 16 + 3 * 64, 1 + 1 * 4 + 1 * 16, 1 + 1 * 4 + 1 * 16 + 2 * 64, 1 + 1 * 4 + 1 * 16 + 1 * 64, 1 + 1 * 4 + 1 * 16 + 3 * 64, 1 + 1 * 4 + 3 * 16, 1 + 1 * 4 + 3 * 16 + 2 * 64, 1 + 1 * 4 + 3 * 16 + 1 * 64, 1 + 1 * 4 + 3 * 16 + 3 * 64, 1 + 3 * 4, 1 + 3 * 4 + 2 * 64, 1 + 3 * 4 + 1 * 64, 1 + 3 * 4 + 3 * 64, 1 + 3 * 4 + 2 * 16, 1 + 3 * 4 + 2 * 16 + 2 * 64, 1 + 3 * 4 + 2 * 16 + 1 * 64, 1 + 3 * 4 + 2 * 16 + 3 * 64, 1 + 3 * 4 + 1 * 16, 1 + 3 * 4 + 1 * 16 + 2 * 64, 1 + 3 * 4 + 1 * 16 + 1 * 64, 1 + 3 * 4 + 1 * 16 + 3 * 64, 1 + 3 * 4 + 3 * 16, 1 + 3 * 4 + 3 * 16 + 2 * 64, 1 + 3 * 4 + 3 * 16 + 1 * 64, 1 + 3 * 4 + 3 * 16 + 3 * 64, 3, 3 + 2 * 64, 3 + 1 * 64, 3 + 3 * 64, 3 + 2 * 16, 3 + 2 * 16 + 2 * 64, 3 + 2 * 16 + 1 * 64, 3 + 2 * 16 + 3 * 64, 3 + 1 * 16, 3 + 1 * 16 + 2 * 64, 3 + 1 * 16 + 1 * 64, 3 + 1 * 16 + 3 * 64, 3 + 3 * 16, 3 + 3 * 16 + 2 * 64, 3 + 3 * 16 + 1 * 64, 3 + 3 * 16 + 3 * 64, 3 + 2 * 4, 3 + 2 * 4 + 2 * 64, 3 + 2 * 4 + 1 * 64, 3 + 2 * 4 + 3 * 64, 3 + 2 * 4 + 2 * 16, 3 + 2 * 4 + 2 * 16 + 2 * 64, 3 + 2 * 4 + 2 * 16 + 1 * 64, 3 + 2 * 4 + 2 * 16 + 3 * 64, 3 + 2 * 4 + 1 * 16, 3 + 2 * 4 + 1 * 16 + 2 * 64, 3 + 2 * 4 + 1 * 16 + 1 * 64, 3 + 2 * 4 + 1 * 16 + 3 * 64, 3 + 2 * 4 + 3 * 16, 3 + 2 * 4 + 3 * 16 + 2 * 64, 3 + 2 * 4 + 3 * 16 + 1 * 64, 3 + 2 * 4 + 3 * 16 + 3 * 64, 3 + 1 * 4, 3 + 1 * 4 + 2 * 64, 3 + 1 * 4 + 1 * 64, 3 + 1 * 4 + 3 * 64, 3 + 1 * 4 + 2 * 16, 3 + 1 * 4 + 2 * 16 + 2 * 64, 3 + 1 * 4 + 2 * 16 + 1 * 64, 3 + 1 * 4 + 2 * 16 + 3 * 64, 3 + 1 * 4 + 1 * 16, 3 + 1 * 4 + 1 * 16 + 2 * 64, 3 + 1 * 4 + 1 * 16 + 1 * 64, 3 + 1 * 4 + 1 * 16 + 3 * 64, 3 + 1 * 4 + 3 * 16, 3 + 1 * 4 + 3 * 16 + 2 * 64, 3 + 1 * 4 + 3 * 16 + 1 * 64, 3 + 1 * 4 + 3 * 16 + 3 * 64, 3 + 3 * 4, 3 + 3 * 4 + 2 * 64, 3 + 3 * 4 + 1 * 64, 3 + 3 * 4 + 3 * 64, 3 + 3 * 4 + 2 * 16, 3 + 3 * 4 + 2 * 16 + 2 * 64, 3 + 3 * 4 + 2 * 16 + 1 * 64, 3 + 3 * 4 + 2 * 16 + 3 * 64, 3 + 3 * 4 + 1 * 16, 3 + 3 * 4 + 1 * 16 + 2 * 64, 3 + 3 * 4 + 1 * 16 + 1 * 64, 3 + 3 * 4 + 1 * 16 + 3 * 64, 3 + 3 * 4 + 3 * 16, 3 + 3 * 4 + 3 * 16 + 2 * 64, 3 + 3 * 4 + 3 * 16 + 1 * 64, 3 + 3 * 4 + 3 * 16 + 3 * 64



};


template <typename T> T reverseBits(T Val) {

  if constexpr (std::is_same_v<T, uint8_t>)
    return __builtin_bitreverse8(Val);


  if constexpr (std::is_same_v<T, uint16_t>)
    return __builtin_bitreverse16(Val);


  if constexpr (std::is_same_v<T, uint32_t>)
    return __builtin_bitreverse32(Val);


  if constexpr (std::is_same_v<T, uint64_t>)
    return __builtin_bitreverse64(Val);


  unsigned char in[sizeof(Val)];
  unsigned char out[sizeof(Val)];
  std::memcpy(in, &Val, sizeof(Val));
  for (unsigned i = 0; i < sizeof(Val); ++i)
    out[(sizeof(Val) - i) - 1] = BitReverseTable256[in[i]];
  std::memcpy(&Val, out, sizeof(Val));
  return Val;
}






constexpr inline uint32_t Hi_32(uint64_t Value) {
  return static_cast<uint32_t>(Value >> 32);
}


constexpr inline uint32_t Lo_32(uint64_t Value) {
  return static_cast<uint32_t>(Value);
}


constexpr inline uint64_t Make_64(uint32_t High, uint32_t Low) {
  return ((uint64_t)High << 32) | (uint64_t)Low;
}


template <unsigned N> constexpr inline bool isInt(int64_t x) {
  if constexpr (N == 8)
    return static_cast<int8_t>(x) == x;
  if constexpr (N == 16)
    return static_cast<int16_t>(x) == x;
  if constexpr (N == 32)
    return static_cast<int32_t>(x) == x;
  if constexpr (N < 64)
    return -((1LL) << (N - 1)) <= x && x < ((1LL) << (N - 1));
  (void)x;
  return true;
}


template <unsigned N, unsigned S>
constexpr inline bool isShiftedInt(int64_t x) {
  static_assert(
      N > 0, "isShiftedInt<0> doesn't make sense (refers to a 0-bit number.");
  static_assert(N + S <= 64, "isShiftedInt<N, S> with N + S > 64 is too wide.");
  return isInt<N + S>(x) && (x % ((1ULL) << S) == 0);
}


template <unsigned N> constexpr inline bool isUInt(uint64_t x) {
  static_assert(N > 0, "isUInt<0> doesn't make sense");
  if constexpr (N == 8)
    return static_cast<uint8_t>(x) == x;
  if constexpr (N == 16)
    return static_cast<uint16_t>(x) == x;
  if constexpr (N == 32)
    return static_cast<uint32_t>(x) == x;
  if constexpr (N < 64)
    return x < ((1ULL) << (N));
  (void)x;
  return true;
}


template <unsigned N, unsigned S>
constexpr inline bool isShiftedUInt(uint64_t x) {
  static_assert(
      N > 0, "isShiftedUInt<0> doesn't make sense (refers to a 0-bit number)");
  static_assert(N + S <= 64,
                "isShiftedUInt<N, S> with N + S > 64 is too wide.");


  return isUInt<N + S>(x) && (x % ((1ULL) << S) == 0);
}


inline uint64_t maxUIntN(uint64_t N) {
  (__builtin_expect(!(N > 0 && N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 202, "N > 0 && N <= 64 && \"integer width out of range\"") : (void)0);





  return 18446744073709551615ULL >> (64 - N);
}


inline int64_t minIntN(int64_t N) {
  (__builtin_expect(!(N > 0 && N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 213, "N > 0 && N <= 64 && \"integer width out of range\"") : (void)0);

  return (1ULL) + ~((1ULL) << (N - 1));
}


inline int64_t maxIntN(int64_t N) {
  (__builtin_expect(!(N > 0 && N <= 64 && "integer width out of range"), 0) ? __assert_rtn(__func__, "MathExtras.h", 220, "N > 0 && N <= 64 && \"integer width out of range\"") : (void)0);



  return ((1ULL) << (N - 1)) - 1;
}


inline bool isUIntN(unsigned N, uint64_t x) {
  return N >= 64 || x <= maxUIntN(N);
}


inline bool isIntN(unsigned N, int64_t x) {
  return N >= 64 || (minIntN(N) <= x && x <= maxIntN(N));
}




constexpr inline bool isMask_32(uint32_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}



constexpr inline bool isMask_64(uint64_t Value) {
  return Value && ((Value + 1) & Value) == 0;
}



constexpr inline bool isShiftedMask_32(uint32_t Value) {
  return Value && isMask_32((Value - 1) | Value);
}



constexpr inline bool isShiftedMask_64(uint64_t Value) {
  return Value && isMask_64((Value - 1) | Value);
}



constexpr inline bool isPowerOf2_32(uint32_t Value) {
  return llvm::has_single_bit(Value);
}


constexpr inline bool isPowerOf2_64(uint64_t Value) {
  return llvm::has_single_bit(Value);
}






inline bool isShiftedMask_32(uint32_t Value, unsigned &MaskIdx,
                             unsigned &MaskLen) {
  if (!isShiftedMask_32(Value))
    return false;
  MaskIdx = llvm::countr_zero(Value);
  MaskLen = llvm::popcount(Value);
  return true;
}





inline bool isShiftedMask_64(uint64_t Value, unsigned &MaskIdx,
                             unsigned &MaskLen) {
  if (!isShiftedMask_64(Value))
    return false;
  MaskIdx = llvm::countr_zero(Value);
  MaskLen = llvm::popcount(Value);
  return true;
}



template <size_t kValue> constexpr inline size_t CTLog2() {
  static_assert(kValue > 0 && llvm::isPowerOf2_64(kValue),
                "Value is not a valid power of 2");
  return 1 + CTLog2<kValue / 2>();
}

template <> constexpr inline size_t CTLog2<1>() { return 0; }




inline unsigned Log2_32(uint32_t Value) {
  return 31 - llvm::countl_zero(Value);
}



inline unsigned Log2_64(uint64_t Value) {
  return 63 - llvm::countl_zero(Value);
}




inline unsigned Log2_32_Ceil(uint32_t Value) {
  return 32 - llvm::countl_zero(Value - 1);
}



inline unsigned Log2_64_Ceil(uint64_t Value) {
  return 64 - llvm::countl_zero(Value - 1);
}



constexpr inline uint64_t MinAlign(uint64_t A, uint64_t B) {





  return (A | B) & (1 + ~(A | B));
}



constexpr inline uint64_t NextPowerOf2(uint64_t A) {
  A |= (A >> 1);
  A |= (A >> 2);
  A |= (A >> 4);
  A |= (A >> 8);
  A |= (A >> 16);
  A |= (A >> 32);
  return A + 1;
}



inline uint64_t PowerOf2Ceil(uint64_t A) {
  if (!A)
    return 0;
  return NextPowerOf2(A - 1);
}
# 377 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
inline uint64_t alignTo(uint64_t Value, uint64_t Align) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 378, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  return (Value + Align - 1) / Align * Align;
}

inline uint64_t alignToPowerOf2(uint64_t Value, uint64_t Align) {
  (__builtin_expect(!(Align != 0 && (Align & (Align - 1)) == 0 && "Align must be a power of 2"), 0) ? __assert_rtn(__func__, "MathExtras.h", 384, "Align != 0 && (Align & (Align - 1)) == 0 && \"Align must be a power of 2\"") : (void)0);



  uint64_t negAlign = (~Align) + 1;
  return (Value + Align - 1) & negAlign;
}
# 403 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
inline uint64_t alignTo(uint64_t Value, uint64_t Align, uint64_t Skew) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 404, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  Skew %= Align;
  return alignTo(Value - Skew, Align) + Skew;
}



template <uint64_t Align> constexpr inline uint64_t alignTo(uint64_t Value) {
  static_assert(Align != 0u, "Align must be non-zero");
  return (Value + Align - 1) / Align * Align;
}


inline uint64_t divideCeil(uint64_t Numerator, uint64_t Denominator) {
  return alignTo(Numerator, Denominator) / Denominator;
}


inline uint64_t divideNearest(uint64_t Numerator, uint64_t Denominator) {
  return (Numerator + (Denominator / 2)) / Denominator;
}



inline uint64_t alignDown(uint64_t Value, uint64_t Align, uint64_t Skew = 0) {
  (__builtin_expect(!(Align != 0u && "Align can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 429, "Align != 0u && \"Align can't be 0.\"") : (void)0);
  Skew %= Align;
  return (Value - Skew) / Align * Align + Skew;
}



template <unsigned B> constexpr inline int32_t SignExtend32(uint32_t X) {
  static_assert(B > 0, "Bit width can't be 0.");
  static_assert(B <= 32, "Bit width out of range.");
  return int32_t(X << (32 - B)) >> (32 - B);
}



inline int32_t SignExtend32(uint32_t X, unsigned B) {
  (__builtin_expect(!(B > 0 && "Bit width can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 445, "B > 0 && \"Bit width can't be 0.\"") : (void)0);
  (__builtin_expect(!(B <= 32 && "Bit width out of range."), 0) ? __assert_rtn(__func__, "MathExtras.h", 446, "B <= 32 && \"Bit width out of range.\"") : (void)0);
  return int32_t(X << (32 - B)) >> (32 - B);
}



template <unsigned B> constexpr inline int64_t SignExtend64(uint64_t x) {
  static_assert(B > 0, "Bit width can't be 0.");
  static_assert(B <= 64, "Bit width out of range.");
  return int64_t(x << (64 - B)) >> (64 - B);
}



inline int64_t SignExtend64(uint64_t X, unsigned B) {
  (__builtin_expect(!(B > 0 && "Bit width can't be 0."), 0) ? __assert_rtn(__func__, "MathExtras.h", 461, "B > 0 && \"Bit width can't be 0.\"") : (void)0);
  (__builtin_expect(!(B <= 64 && "Bit width out of range."), 0) ? __assert_rtn(__func__, "MathExtras.h", 462, "B <= 64 && \"Bit width out of range.\"") : (void)0);
  return int64_t(X << (64 - B)) >> (64 - B);
}



template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T> AbsoluteDifference(T X, T Y) {
  return X > Y ? (X - Y) : (Y - X);
}




template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingAdd(T X, T Y, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;

  T Z = X + Y;
  Overflowed = (Z < X || Z < Y);
  if (Overflowed)
    return std::numeric_limits<T>::max();
  else
    return Z;
}



template <class T, class... Ts>
std::enable_if_t<std::is_unsigned_v<T>, T> SaturatingAdd(T X, T Y, T Z,
                                                         Ts... Args) {
  bool Overflowed = false;
  T XY = SaturatingAdd(X, Y, &Overflowed);
  if (Overflowed)
    return SaturatingAdd(std::numeric_limits<T>::max(), T(1), Args...);
  return SaturatingAdd(XY, Z, Args...);
}




template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingMultiply(T X, T Y, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;






  Overflowed = false;




  int Log2Z = Log2_64(X) + Log2_64(Y);
  const T Max = std::numeric_limits<T>::max();
  int Log2Max = Log2_64(Max);
  if (Log2Z < Log2Max) {
    return X * Y;
  }
  if (Log2Z > Log2Max) {
    Overflowed = true;
    return Max;
  }




  T Z = (X >> 1) * Y;
  if (Z & ~(Max >> 1)) {
    Overflowed = true;
    return Max;
  }
  Z <<= 1;
  if (X & 1)
    return SaturatingAdd(Z, Y, ResultOverflowed);

  return Z;
}





template <typename T>
std::enable_if_t<std::is_unsigned_v<T>, T>
SaturatingMultiplyAdd(T X, T Y, T A, bool *ResultOverflowed = nullptr) {
  bool Dummy;
  bool &Overflowed = ResultOverflowed ? *ResultOverflowed : Dummy;

  T Product = SaturatingMultiply(X, Y, &Overflowed);
  if (Overflowed)
    return Product;

  return SaturatingAdd(A, Product, &Overflowed);
}


extern const float huge_valf;




template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> AddOverflow(T X, T Y, T &Result) {

  return __builtin_add_overflow(X, Y, &Result);
# 592 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
}



template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> SubOverflow(T X, T Y, T &Result) {

  return __builtin_sub_overflow(X, Y, &Result);
# 618 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MathExtras.h"
}



template <typename T>
std::enable_if_t<std::is_signed_v<T>, T> MulOverflow(T X, T Y, T &Result) {

  using U = std::make_unsigned_t<T>;
  const U UX = X < 0 ? (0 - static_cast<U>(X)) : static_cast<U>(X);
  const U UY = Y < 0 ? (0 - static_cast<U>(Y)) : static_cast<U>(Y);
  const U UResult = UX * UY;


  const bool IsNegative = (X < 0) ^ (Y < 0);
  Result = IsNegative ? (0 - UResult) : UResult;


  if (UX == 0 || UY == 0)
    return false;




  if (IsNegative)
    return UX > (static_cast<U>(std::numeric_limits<T>::max()) + U(1)) / UY;
  else
    return UX > (static_cast<U>(std::numeric_limits<T>::max())) / UY;
}

}
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h" 2





namespace llvm {







struct Align {
private:
  uint8_t ShiftValue = 0;


  friend struct MaybeAlign;
  friend unsigned Log2(Align);
  friend bool operator==(Align Lhs, Align Rhs);
  friend bool operator!=(Align Lhs, Align Rhs);
  friend bool operator<=(Align Lhs, Align Rhs);
  friend bool operator>=(Align Lhs, Align Rhs);
  friend bool operator<(Align Lhs, Align Rhs);
  friend bool operator>(Align Lhs, Align Rhs);
  friend unsigned encode(struct MaybeAlign A);
  friend struct MaybeAlign decodeMaybeAlign(unsigned Value);
# 62 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
  struct LogValue {
    uint8_t Log;
  };

public:

  constexpr Align() = default;


  constexpr Align(const Align &Other) = default;
  constexpr Align(Align &&Other) = default;
  Align &operator=(const Align &Other) = default;
  Align &operator=(Align &&Other) = default;

  explicit Align(uint64_t Value) {
    (__builtin_expect(!(Value > 0 && "Value must not be 0"), 0) ? __assert_rtn(__func__, "Alignment.h", 77, "Value > 0 && \"Value must not be 0\"") : (void)0);
    (__builtin_expect(!(llvm::isPowerOf2_64(Value) && "Alignment is not a power of 2"), 0) ? __assert_rtn(__func__, "Alignment.h", 78, "llvm::isPowerOf2_64(Value) && \"Alignment is not a power of 2\"") : (void)0);
    ShiftValue = Log2_64(Value);
    (__builtin_expect(!(ShiftValue < 64 && "Broken invariant"), 0) ? __assert_rtn(__func__, "Alignment.h", 80, "ShiftValue < 64 && \"Broken invariant\"") : (void)0);
  }



  uint64_t value() const { return uint64_t(1) << ShiftValue; }


  Align previous() const {
    (__builtin_expect(!(ShiftValue != 0 && "Undefined operation"), 0) ? __assert_rtn(__func__, "Alignment.h", 89, "ShiftValue != 0 && \"Undefined operation\"") : (void)0);
    Align Out;
    Out.ShiftValue = ShiftValue - 1;
    return Out;
  }


  template <size_t kValue> constexpr static Align Constant() {
    return LogValue{static_cast<uint8_t>(CTLog2<kValue>())};
  }



  template <typename T> constexpr static Align Of() {
    return Constant<std::alignment_of_v<T>>();
  }


  constexpr Align(LogValue CA) : ShiftValue(CA.Log) {}
};


inline Align assumeAligned(uint64_t Value) {
  return Value ? Align(Value) : Align();
}



struct MaybeAlign : public std::optional<Align> {
private:
  using UP = std::optional<Align>;

public:

  MaybeAlign() = default;


  MaybeAlign(const MaybeAlign &Other) = default;
  MaybeAlign &operator=(const MaybeAlign &Other) = default;
  MaybeAlign(MaybeAlign &&Other) = default;
  MaybeAlign &operator=(MaybeAlign &&Other) = default;

  constexpr MaybeAlign(std::nullopt_t None) : UP(None) {}
  constexpr MaybeAlign(Align Value) : UP(Value) {}
  explicit MaybeAlign(uint64_t Value) {
    (__builtin_expect(!((Value == 0 || llvm::isPowerOf2_64(Value)) && "Alignment is neither 0 nor a power of 2"), 0) ? __assert_rtn(__func__, "Alignment.h", 135, "(Value == 0 || llvm::isPowerOf2_64(Value)) && \"Alignment is neither 0 nor a power of 2\"") : (void)0);

    if (Value)
      emplace(Value);
  }


  Align valueOrOne() const { return value_or(Align()); }
};


inline bool isAligned(Align Lhs, uint64_t SizeInBytes) {
  return SizeInBytes % Lhs.value() == 0;
}


inline bool isAddrAligned(Align Lhs, const void *Addr) {
  return isAligned(Lhs, reinterpret_cast<uintptr_t>(Addr));
}


inline uint64_t alignTo(uint64_t Size, Align A) {
  const uint64_t Value = A.value();
# 166 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
  return (Size + Value - 1) & ~(Value - 1U);
}
# 180 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Alignment.h"
inline uint64_t alignTo(uint64_t Size, Align A, uint64_t Skew) {
  const uint64_t Value = A.value();
  Skew %= Value;
  return alignTo(Size - Skew, A) + Skew;
}


inline uintptr_t alignAddr(const void *Addr, Align Alignment) {
  uintptr_t ArithAddr = reinterpret_cast<uintptr_t>(Addr);
  (__builtin_expect(!(static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && "Overflow"), 0) ? __assert_rtn(__func__, "Alignment.h", 191, "static_cast<uintptr_t>(ArithAddr + Alignment.value() - 1) >= ArithAddr && \"Overflow\"") : (void)0);


  return alignTo(ArithAddr, Alignment);
}



inline uint64_t offsetToAlignment(uint64_t Value, Align Alignment) {
  return alignTo(Value, Alignment) - Value;
}



inline uint64_t offsetToAlignedAddr(const void *Addr, Align Alignment) {
  return offsetToAlignment(reinterpret_cast<uintptr_t>(Addr), Alignment);
}


inline unsigned Log2(Align A) { return A.ShiftValue; }



inline Align commonAlignment(Align A, uint64_t Offset) {
  return Align(MinAlign(A.value(), Offset));
}


inline unsigned encode(MaybeAlign A) { return A ? A->ShiftValue + 1 : 0; }


inline MaybeAlign decodeMaybeAlign(unsigned Value) {
  if (Value == 0)
    return MaybeAlign();
  Align Out;
  Out.ShiftValue = Value - 1;
  return Out;
}



inline unsigned encode(Align A) { return encode(MaybeAlign(A)); }


inline bool operator==(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 234, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() == Rhs;
}
inline bool operator!=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 238, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() != Rhs;
}
inline bool operator<=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 242, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() <= Rhs;
}
inline bool operator>=(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 246, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() >= Rhs;
}
inline bool operator<(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 250, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() < Rhs;
}
inline bool operator>(Align Lhs, uint64_t Rhs) {
  (__builtin_expect(!(Rhs > 0 && ("Rhs" " should be defined")), 0) ? __assert_rtn(__func__, "Alignment.h", 254, "Rhs > 0 && (\"Rhs\" \" should be defined\")") : (void)0);
  return Lhs.value() > Rhs;
}


inline bool operator==(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue == Rhs.ShiftValue;
}
inline bool operator!=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue != Rhs.ShiftValue;
}
inline bool operator<=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue <= Rhs.ShiftValue;
}
inline bool operator>=(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue >= Rhs.ShiftValue;
}
inline bool operator<(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue < Rhs.ShiftValue;
}
inline bool operator>(Align Lhs, Align Rhs) {
  return Lhs.ShiftValue > Rhs.ShiftValue;
}


bool operator<=(Align Lhs, MaybeAlign Rhs) = delete;
bool operator>=(Align Lhs, MaybeAlign Rhs) = delete;
bool operator<(Align Lhs, MaybeAlign Rhs) = delete;
bool operator>(Align Lhs, MaybeAlign Rhs) = delete;

bool operator<=(MaybeAlign Lhs, Align Rhs) = delete;
bool operator>=(MaybeAlign Lhs, Align Rhs) = delete;
bool operator<(MaybeAlign Lhs, Align Rhs) = delete;
bool operator>(MaybeAlign Lhs, Align Rhs) = delete;

bool operator<=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator>=(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator<(MaybeAlign Lhs, MaybeAlign Rhs) = delete;
bool operator>(MaybeAlign Lhs, MaybeAlign Rhs) = delete;


inline bool operator==(MaybeAlign Lhs, Align Rhs) { return Lhs && *Lhs == Rhs; }
inline bool operator!=(MaybeAlign Lhs, Align Rhs) { return !(Lhs == Rhs); }
inline bool operator==(Align Lhs, MaybeAlign Rhs) { return Rhs == Lhs; }
inline bool operator!=(Align Lhs, MaybeAlign Rhs) { return !(Rhs == Lhs); }

inline bool operator==(MaybeAlign Lhs, MaybeAlign Rhs) {
  return (Lhs && Rhs && (*Lhs == *Rhs)) || (!Lhs && !Rhs);
}
inline bool operator!=(MaybeAlign Lhs, MaybeAlign Rhs) { return !(Lhs == Rhs); }

inline bool operator==(MaybeAlign Lhs, std::nullopt_t) { return !bool(Lhs); }
inline bool operator!=(MaybeAlign Lhs, std::nullopt_t) { return bool(Lhs); }
inline bool operator==(std::nullopt_t, MaybeAlign Rhs) { return !bool(Rhs); }
inline bool operator!=(std::nullopt_t, MaybeAlign Rhs) { return bool(Rhs); }



inline std::string DebugStr(const Align &A) {
  return std::to_string(A.value());
}

inline std::string DebugStr(const MaybeAlign &MA) {
  if (MA)
    return std::to_string(MA->value());
  return "None";
}




}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h" 2

namespace llvm {
# 34 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename From> struct simplify_type {
  using SimpleType = From;


  static SimpleType &getSimplifiedValue(From &Val) { return Val; }
};

template <typename From> struct simplify_type<const From> {
  using NonConstSimpleType = typename simplify_type<From>::SimpleType;
  using SimpleType = typename add_const_past_pointer<NonConstSimpleType>::type;
  using RetType =
      typename add_lvalue_reference_if_not_pointer<SimpleType>::type;

  static RetType getSimplifiedValue(const From &Val) {
    return simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val));
  }
};
# 63 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enabler = void> struct isa_impl {
  static inline bool doit(const From &Val) { return To::classof(&Val); }
};


template <typename To, typename From>
struct isa_impl<To, From, std::enable_if_t<std::is_base_of_v<To, From>>> {
  static inline bool doit(const From &) { return true; }
};

template <typename To, typename From> struct isa_impl_cl {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From> {
  static inline bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template <typename To, typename From>
struct isa_impl_cl<To, const std::unique_ptr<From>> {
  static inline bool doit(const std::unique_ptr<From> &Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 88, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl_cl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From *> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 95, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, From *const> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 102, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From> struct isa_impl_cl<To, const From *> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 109, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From>
struct isa_impl_cl<To, const From *const> {
  static inline bool doit(const From *Val) {
    (__builtin_expect(!(Val && "isa<> used on a null pointer"), 0) ? __assert_rtn(__func__, "Casting.h", 117, "Val && \"isa<> used on a null pointer\"") : (void)0);
    return isa_impl<To, From>::doit(*Val);
  }
};

template <typename To, typename From, typename SimpleFrom>
struct isa_impl_wrap {


  static bool doit(const From &Val) {
    return isa_impl_wrap<To, SimpleFrom,
                         typename simplify_type<SimpleFrom>::SimpleType>::
        doit(simplify_type<const From>::getSimplifiedValue(Val));
  }
};

template <typename To, typename FromTy>
struct isa_impl_wrap<To, FromTy, FromTy> {

  static bool doit(const FromTy &Val) {
    return isa_impl_cl<To, FromTy>::doit(Val);
  }
};





template <class To, class From> struct cast_retty;



template <class To, class From> struct cast_retty_impl {
  using ret_type = To &;
};
template <class To, class From> struct cast_retty_impl<To, const From> {
  using ret_type = const To &;
};

template <class To, class From> struct cast_retty_impl<To, From *> {
  using ret_type = To *;
};

template <class To, class From> struct cast_retty_impl<To, const From *> {
  using ret_type = const To *;
};

template <class To, class From> struct cast_retty_impl<To, const From *const> {
  using ret_type = const To *;
};

template <class To, class From>
struct cast_retty_impl<To, std::unique_ptr<From>> {
private:
  using PointerType = typename cast_retty_impl<To, From *>::ret_type;
  using ResultType = std::remove_pointer_t<PointerType>;

public:
  using ret_type = std::unique_ptr<ResultType>;
};

template <class To, class From, class SimpleFrom> struct cast_retty_wrap {



  using ret_type = typename cast_retty<To, SimpleFrom>::ret_type;
};

template <class To, class FromTy> struct cast_retty_wrap<To, FromTy, FromTy> {

  using ret_type = typename cast_retty_impl<To, FromTy>::ret_type;
};

template <class To, class From> struct cast_retty {
  using ret_type = typename cast_retty_wrap<
      To, From, typename simplify_type<From>::SimpleType>::ret_type;
};
# 202 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <class To, class From, class SimpleFrom> struct cast_convert_val {

  static typename cast_retty<To, From>::ret_type doit(const From &Val) {
    return cast_convert_val<To, SimpleFrom,
                            typename simplify_type<SimpleFrom>::SimpleType>::
        doit(simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val)));
  }
};

template <class To, class FromTy> struct cast_convert_val<To, FromTy, FromTy> {

  static typename cast_retty<To, FromTy>::ret_type doit(const FromTy &Val) {
    return *(std::remove_reference_t<typename cast_retty<To, FromTy>::ret_type>
                 *)&const_cast<FromTy &>(Val);
  }
};

template <class To, class FromTy>
struct cast_convert_val<To, FromTy *, FromTy *> {

  static typename cast_retty<To, FromTy *>::ret_type doit(const FromTy *Val) {
    return (typename cast_retty<To, FromTy *>::ret_type) const_cast<FromTy *>(
        Val);
  }
};





template <class X> struct is_simple_type {
  static const bool value =
      std::is_same_v<X, typename simplify_type<X>::SimpleType>;
};
# 252 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enable = void>
struct CastIsPossible {
  static inline bool isPossible(const From &f) {
    return isa_impl_wrap<
        To, const From,
        typename simplify_type<const From>::SimpleType>::doit(f);
  }
};





template <typename To, typename From>
struct CastIsPossible<To, std::optional<From>> {
  static inline bool isPossible(const std::optional<From> &f) {
    (__builtin_expect(!(f && "CastIsPossible::isPossible called on a nullopt!"), 0) ? __assert_rtn(__func__, "Casting.h", 268, "f && \"CastIsPossible::isPossible called on a nullopt!\"") : (void)0);
    return isa_impl_wrap<
        To, const From,
        typename simplify_type<const From>::SimpleType>::doit(*f);
  }
};



template <typename To, typename From>
struct CastIsPossible<To, From, std::enable_if_t<std::is_base_of_v<To, From>>> {
  static inline bool isPossible(const From &f) { return true; }
};
# 301 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To> struct NullableValueCastFailed {
  static To castFailed() { return To(nullptr); }
};




template <typename To, typename From, typename Derived>
struct DefaultDoCastIfPossible {
  static To doCastIfPossible(From f) {
    if (!Derived::isPossible(f))
      return Derived::castFailed();
    return Derived::doCast(f);
  }
};

namespace detail {


template <typename OptionalDerived, typename Default>
using SelfType = std::conditional_t<std::is_same_v<OptionalDerived, void>,
                                    Default, OptionalDerived>;
}




template <typename To, typename From, typename Derived = void>
struct ValueFromPointerCast
    : public CastIsPossible<To, From *>,
      public NullableValueCastFailed<To>,
      public DefaultDoCastIfPossible<
          To, From *,
          detail::SelfType<Derived, ValueFromPointerCast<To, From>>> {
  static inline To doCast(From *f) { return To(f); }
};





template <typename To, typename From, typename Derived = void>
struct UniquePtrCast : public CastIsPossible<To, From *> {
  using Self = detail::SelfType<Derived, UniquePtrCast<To, From>>;
  using CastResultType = std::unique_ptr<
      std::remove_reference_t<typename cast_retty<To, From>::ret_type>>;

  static inline CastResultType doCast(std::unique_ptr<From> &&f) {
    return CastResultType((typename CastResultType::element_type *)f.release());
  }

  static inline CastResultType castFailed() { return CastResultType(nullptr); }

  static inline CastResultType doCastIfPossible(std::unique_ptr<From> &f) {
    if (!Self::isPossible(f.get()))
      return castFailed();
    return doCast(std::move(f));
  }
};




template <typename To, typename From, typename Derived = void>
struct OptionalValueCast
    : public CastIsPossible<To, From>,
      public DefaultDoCastIfPossible<
          std::optional<To>, From,
          detail::SelfType<Derived, OptionalValueCast<To, From>>> {
  static inline std::optional<To> castFailed() { return std::optional<To>{}; }

  static inline std::optional<To> doCast(const From &f) { return To(f); }
};
# 387 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename ForwardTo>
struct ConstStrippingForwardingCast {

  using DecayedFrom = std::remove_cv_t<std::remove_pointer_t<From>>;

  using NonConstFrom =
      std::conditional_t<std::is_pointer_v<From>, DecayedFrom *, DecayedFrom &>;

  static inline bool isPossible(const From &f) {
    return ForwardTo::isPossible(const_cast<NonConstFrom>(f));
  }

  static inline decltype(auto) castFailed() { return ForwardTo::castFailed(); }

  static inline decltype(auto) doCast(const From &f) {
    return ForwardTo::doCast(const_cast<NonConstFrom>(f));
  }

  static inline decltype(auto) doCastIfPossible(const From &f) {
    return ForwardTo::doCastIfPossible(const_cast<NonConstFrom>(f));
  }
};
# 422 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename ForwardTo>
struct ForwardToPointerCast {
  static inline bool isPossible(const From &f) {
    return ForwardTo::isPossible(&f);
  }

  static inline decltype(auto) doCast(const From &f) {
    return *ForwardTo::doCast(&f);
  }
};
# 475 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From, typename Enable = void>
struct CastInfo : public CastIsPossible<To, From> {
  using Self = CastInfo<To, From, Enable>;

  using CastReturnType = typename cast_retty<To, From>::ret_type;

  static inline CastReturnType doCast(const From &f) {
    return cast_convert_val<
        To, From,
        typename simplify_type<From>::SimpleType>::doit(const_cast<From &>(f));
  }




  static inline CastReturnType castFailed() { return CastReturnType(nullptr); }

  static inline CastReturnType doCastIfPossible(const From &f) {
    if (!Self::isPossible(f))
      return castFailed();
    return doCast(f);
  }
};




template <typename To, typename From>
struct CastInfo<To, From, std::enable_if_t<!is_simple_type<From>::value>> {
  using Self = CastInfo<To, From>;
  using SimpleFrom = typename simplify_type<From>::SimpleType;
  using SimplifiedSelf = CastInfo<To, SimpleFrom>;

  static inline bool isPossible(From &f) {
    return SimplifiedSelf::isPossible(
        simplify_type<From>::getSimplifiedValue(f));
  }

  static inline decltype(auto) doCast(From &f) {
    return SimplifiedSelf::doCast(simplify_type<From>::getSimplifiedValue(f));
  }

  static inline decltype(auto) castFailed() {
    return SimplifiedSelf::castFailed();
  }

  static inline decltype(auto) doCastIfPossible(From &f) {
    return SimplifiedSelf::doCastIfPossible(
        simplify_type<From>::getSimplifiedValue(f));
  }
};






template <typename To, typename From>
struct CastInfo<To, std::unique_ptr<From>> : public UniquePtrCast<To, From> {};




template <typename To, typename From>
struct CastInfo<To, std::optional<From>> : public OptionalValueCast<To, From> {
};






template <typename To, typename From>
[[nodiscard]] inline bool isa(const From &Val) {
  return CastInfo<To, const From>::isPossible(Val);
}

template <typename First, typename Second, typename... Rest, typename From>
[[nodiscard]] inline bool isa(const From &Val) {
  return isa<First>(Val) || isa<Second, Rest...>(Val);
}
# 564 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(const From &Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 566, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, const From>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(From &Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 572, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, From>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(From *Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 578, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, From *>::doCast(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) cast(std::unique_ptr<From> &&Val) {
  (__builtin_expect(!(isa<To>(Val) && "cast<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 584, "isa<To>(Val) && \"cast<Ty>() argument of incompatible type!\"") : (void)0);
  return CastInfo<To, std::unique_ptr<From>>::doCast(std::move(Val));
}





template <typename T>
constexpr bool IsNullable =
    std::is_pointer_v<T> || std::is_constructible_v<T, std::nullptr_t>;







template <typename T, typename Enable = void> struct ValueIsPresent {
  using UnwrappedType = T;
  static inline bool isPresent(const T &t) { return true; }
  static inline decltype(auto) unwrapValue(T &t) { return t; }
};


template <typename T> struct ValueIsPresent<std::optional<T>> {
  using UnwrappedType = T;
  static inline bool isPresent(const std::optional<T> &t) {
    return t.has_value();
  }
  static inline decltype(auto) unwrapValue(std::optional<T> &t) { return *t; }
};



template <typename T>
struct ValueIsPresent<T, std::enable_if_t<IsNullable<T>>> {
  using UnwrappedType = T;
  static inline bool isPresent(const T &t) { return t != T(nullptr); }
  static inline decltype(auto) unwrapValue(T &t) { return t; }
};

namespace detail {


template <typename T> inline bool isPresent(const T &t) {
  return ValueIsPresent<typename simplify_type<T>::SimpleType>::isPresent(
      simplify_type<T>::getSimplifiedValue(const_cast<T &>(t)));
}


template <typename T> inline decltype(auto) unwrapValue(T &t) {
  return ValueIsPresent<T>::unwrapValue(t);
}
}
# 648 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/Casting.h"
template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(const From &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 650, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, const From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 656, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, From>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(From *Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 662, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, From *>::doCastIfPossible(Val);
}

template <typename To, typename From>
[[nodiscard]] inline decltype(auto) dyn_cast(std::unique_ptr<From> &Val) {
  (__builtin_expect(!(detail::isPresent(Val) && "dyn_cast on a non-existent value"), 0) ? __assert_rtn(__func__, "Casting.h", 668, "detail::isPresent(Val) && \"dyn_cast on a non-existent value\"") : (void)0);
  return CastInfo<To, std::unique_ptr<From>>::doCastIfPossible(Val);
}



template <typename... X, class Y>
[[nodiscard]] inline bool isa_and_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return false;
  return isa<X...>(Val);
}

template <typename... X, class Y>
[[nodiscard]] inline bool isa_and_nonnull(const Y &Val) {
  return isa_and_present<X...>(Val);
}



template <class X, class Y>
[[nodiscard]] inline auto cast_if_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, const Y>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 692, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 699, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y> [[nodiscard]] inline auto cast_if_present(Y *Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y *>::castFailed();
  (__builtin_expect(!(isa<X>(Val) && "cast_if_present<Ty>() argument of incompatible type!"), 0) ? __assert_rtn(__func__, "Casting.h", 706, "isa<X>(Val) && \"cast_if_present<Ty>() argument of incompatible type!\"") : (void)0);
  return cast<X>(detail::unwrapValue(Val));
}

template <class X, class Y>
[[nodiscard]] inline auto cast_if_present(std::unique_ptr<Y> &&Val) {
  if (!detail::isPresent(Val))
    return UniquePtrCast<X, Y>::castFailed();
  return UniquePtrCast<X, Y>::doCast(std::move(Val));
}




template <class X, class Y> auto cast_or_null(const Y &Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(Y &Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(Y *Val) {
  return cast_if_present<X>(Val);
}

template <class X, class Y> auto cast_or_null(std::unique_ptr<Y> &&Val) {
  return cast_if_present<X>(std::move(Val));
}



template <class X, class Y> auto dyn_cast_if_present(const Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, const Y>::castFailed();
  return CastInfo<X, const Y>::doCastIfPossible(detail::unwrapValue(Val));
}

template <class X, class Y> auto dyn_cast_if_present(Y &Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y>::castFailed();
  return CastInfo<X, Y>::doCastIfPossible(detail::unwrapValue(Val));
}

template <class X, class Y> auto dyn_cast_if_present(Y *Val) {
  if (!detail::isPresent(Val))
    return CastInfo<X, Y *>::castFailed();
  return CastInfo<X, Y *>::doCastIfPossible(detail::unwrapValue(Val));
}




template <class X, class Y> auto dyn_cast_or_null(const Y &Val) {
  return dyn_cast_if_present<X>(Val);
}

template <class X, class Y> auto dyn_cast_or_null(Y &Val) {
  return dyn_cast_if_present<X>(Val);
}

template <class X, class Y> auto dyn_cast_or_null(Y *Val) {
  return dyn_cast_if_present<X>(Val);
}






template <class X, class Y>
[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
unique_dyn_cast(std::unique_ptr<Y> &Val) {
  if (!isa<X>(Val))
    return nullptr;
  return cast<X>(std::move(Val));
}

template <class X, class Y>
[[nodiscard]] inline auto unique_dyn_cast(std::unique_ptr<Y> &&Val) {
  return unique_dyn_cast<X, Y>(Val);
}



template <class X, class Y>
[[nodiscard]] inline typename CastInfo<X, std::unique_ptr<Y>>::CastResultType
unique_dyn_cast_or_null(std::unique_ptr<Y> &Val) {
  if (!Val)
    return nullptr;
  return unique_dyn_cast<X, Y>(Val);
}

template <class X, class Y>
[[nodiscard]] inline auto unique_dyn_cast_or_null(std::unique_ptr<Y> &&Val) {
  return unique_dyn_cast_or_null<X, Y>(Val);
}

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/CBindingWrapping.h" 2
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/AlignOf.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/AlignOf.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/AlignOf.h" 2

namespace llvm {
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/AlignOf.h"
template <typename T, typename... Ts> struct AlignedCharArrayUnion {
  using AlignedUnion = std::aligned_union_t<1, T, Ts...>;
  alignas(alignof(AlignedUnion)) char buffer[sizeof(AlignedUnion)];
};

}
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 1 3
# 146 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 1 3
# 104 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 1 3
# 30 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cerrno" 3
# 105 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 2 3
# 108 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__errc" 3


namespace std { inline namespace __1 {





enum class __attribute__ ((__type_visibility__("default"))) errc
{
    address_family_not_supported = 47,
    address_in_use = 48,
    address_not_available = 49,
    already_connected = 56,
    argument_list_too_long = 7,
    argument_out_of_domain = 33,
    bad_address = 14,
    bad_file_descriptor = 9,
    bad_message = 94,
    broken_pipe = 32,
    connection_aborted = 53,
    connection_already_in_progress = 37,
    connection_refused = 61,
    connection_reset = 54,
    cross_device_link = 18,
    destination_address_required = 39,
    device_or_resource_busy = 16,
    directory_not_empty = 66,
    executable_format_error = 8,
    file_exists = 17,
    file_too_large = 27,
    filename_too_long = 63,
    function_not_supported = 78,
    host_unreachable = 65,
    identifier_removed = 90,
    illegal_byte_sequence = 92,
    inappropriate_io_control_operation = 25,
    interrupted = 4,
    invalid_argument = 22,
    invalid_seek = 29,
    io_error = 5,
    is_a_directory = 21,
    message_size = 40,
    network_down = 50,
    network_reset = 52,
    network_unreachable = 51,
    no_buffer_space = 55,
    no_child_process = 10,
    no_link = 97,
    no_lock_available = 77,

    no_message_available = 96,



    no_message = 91,
    no_protocol_option = 42,
    no_space_on_device = 28,

    no_stream_resources = 98,



    no_such_device_or_address = 6,
    no_such_device = 19,
    no_such_file_or_directory = 2,
    no_such_process = 3,
    not_a_directory = 20,
    not_a_socket = 38,

    not_a_stream = 99,



    not_connected = 57,
    not_enough_memory = 12,
    not_supported = 45,
    operation_canceled = 89,
    operation_in_progress = 36,
    operation_not_permitted = 1,
    operation_not_supported = 102,
    operation_would_block = 35,
    owner_dead = 105,
    permission_denied = 13,
    protocol_error = 100,
    protocol_not_supported = 43,
    read_only_file_system = 30,
    resource_deadlock_would_occur = 11,
    resource_unavailable_try_again = 35,
    result_out_of_range = 34,
    state_not_recoverable = 104,

    stream_timeout = 101,



    text_file_busy = 26,
    timed_out = 60,
    too_many_files_open_in_system = 23,
    too_many_files_open = 24,
    too_many_links = 31,
    too_many_symbolic_link_levels = 62,
    value_too_large = 84,
    wrong_protocol_type = 41
};


} }
# 147 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 2 3





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 153 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 2 3
# 156 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/system_error" 3


namespace std { inline namespace __1 {



template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_code_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_code_enum_v = is_error_code_enum<_Tp>::value;




template <class _Tp>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum
    : public false_type {};


template <class _Tp>
inline constexpr size_t is_error_condition_enum_v = is_error_condition_enum<_Tp>::value;


template <>
struct __attribute__ ((__type_visibility__("default"))) is_error_condition_enum<errc>
    : true_type { };







class __attribute__ ((__visibility__("default"))) error_condition;
class __attribute__ ((__visibility__("default"))) error_code;



class __attribute__ ((__visibility__("hidden"))) __do_message;

class __attribute__ ((__visibility__("default"))) error_category
{
public:
    virtual ~error_category() noexcept;





    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr error_category() noexcept = default;

private:
    error_category(const error_category&);
    error_category& operator=(const error_category&);

public:
    virtual const char* name() const noexcept = 0;
    virtual error_condition default_error_condition(int __ev) const noexcept;
    virtual bool equivalent(int __code, const error_condition& __condition) const noexcept;
    virtual bool equivalent(const error_code& __code, int __condition) const noexcept;
    virtual string message(int __ev) const = 0;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const error_category& __rhs) const noexcept {return this == &__rhs;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const error_category& __rhs) const noexcept {return !(*this == __rhs);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator< (const error_category& __rhs) const noexcept {return this < &__rhs;}

    friend class __attribute__ ((__visibility__("hidden"))) __do_message;
};

class __attribute__ ((__visibility__("hidden"))) __do_message
    : public error_category
{
public:
    virtual string message(int ev) const;
};

__attribute__ ((__visibility__("default"))) const error_category& generic_category() noexcept;
__attribute__ ((__visibility__("default"))) const error_category& system_category() noexcept;

class __attribute__ ((__visibility__("default"))) error_condition
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition() noexcept : __val_(0), __cat_(&generic_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        error_condition(_Ep __e,
              typename enable_if<is_error_condition_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_condition(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_error_condition_enum<_Ep>::value,
            error_condition&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_condition(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &generic_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_category& category() const noexcept {return *__cat_;}
    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_condition
make_error_condition(errc __e) noexcept
{
    return error_condition(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}



class __attribute__ ((__visibility__("default"))) error_code
{
    int __val_;
    const error_category* __cat_;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code() noexcept : __val_(0), __cat_(&system_category()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_code(int __val, const error_category& __cat) noexcept
        : __val_(__val), __cat_(&__cat) {}

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        error_code(_Ep __e,
                   typename enable_if<is_error_code_enum<_Ep>::value>::type* = nullptr
                                                                     ) noexcept
            {*this = make_error_code(__e);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(int __val, const error_category& __cat) noexcept
    {
        __val_ = __val;
        __cat_ = &__cat;
    }

    template <class _Ep>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            is_error_code_enum<_Ep>::value,
            error_code&
        >::type
        operator=(_Ep __e) noexcept
            {*this = make_error_code(__e); return *this;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept
    {
        __val_ = 0;
        __cat_ = &system_category();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    int value() const noexcept {return __val_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_category& category() const noexcept {return *__cat_;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    error_condition default_error_condition() const noexcept
        {return __cat_->default_error_condition(__val_);}

    string message() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const noexcept {return __val_ != 0;}
};

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
error_code
make_error_code(errc __e) noexcept
{
    return error_code(static_cast<int>(__e), generic_category());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() < __y.category()
        || (__x.category() == __y.category() && __x.value() < __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_code& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_code& __x, const error_condition& __y) noexcept
{
    return __x.category().equivalent(__x.value(), __y)
        || __y.category().equivalent(__x, __y.value());
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_code& __y) noexcept
{
    return __y == __x;
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const error_condition& __x, const error_condition& __y) noexcept
{
    return __x.category() == __y.category() && __x.value() == __y.value();
}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_code& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_code& __y) noexcept
{return !(__x == __y);}

inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const error_condition& __x, const error_condition& __y) noexcept
{return !(__x == __y);}

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_code>
    : public unary_function<error_code, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_code& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};

template <>
struct __attribute__ ((__type_visibility__("default"))) hash<error_condition>
    : public unary_function<error_condition, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const error_condition& __ec) const noexcept
    {
        return static_cast<size_t>(__ec.value());
    }
};



class __attribute__ ((__visibility__("default"))) system_error
    : public runtime_error
{
    error_code __ec_;
public:
    system_error(error_code __ec, const string& __what_arg);
    system_error(error_code __ec, const char* __what_arg);
    system_error(error_code __ec);
    system_error(int __ev, const error_category& __ecat, const string& __what_arg);
    system_error(int __ev, const error_category& __ecat, const char* __what_arg);
    system_error(int __ev, const error_category& __ecat);
    system_error(const system_error&) noexcept = default;
    ~system_error() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const error_code& code() const noexcept {return __ec_;}

private:
    static string __init(const error_code&, string);
};

[[noreturn]] __attribute__ ((__visibility__("default")))
void __throw_system_error(int ev, const char* what_arg);

} }
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h" 2


namespace llvm {
# 55 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/ErrorOr.h"
template<class T>
class ErrorOr {
  template <class OtherT> friend class ErrorOr;

  static constexpr bool isRef = std::is_reference_v<T>;

  using wrap = std::reference_wrapper<std::remove_reference_t<T>>;

public:
  using storage_type = std::conditional_t<isRef, wrap, T>;

private:
  using reference = std::remove_reference_t<T> &;
  using const_reference = const std::remove_reference_t<T> &;
  using pointer = std::remove_reference_t<T> *;
  using const_pointer = const std::remove_reference_t<T> *;

public:
  template <class E>
  ErrorOr(E ErrorCode,
          std::enable_if_t<std::is_error_code_enum<E>::value ||
                               std::is_error_condition_enum<E>::value,
                           void *> = nullptr)
      : HasError(true) {
    new (getErrorStorage()) std::error_code(make_error_code(ErrorCode));
  }

  ErrorOr(std::error_code EC) : HasError(true) {
    new (getErrorStorage()) std::error_code(EC);
  }

  template <class OtherT>
  ErrorOr(OtherT &&Val,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr)
      : HasError(false) {
    new (getStorage()) storage_type(std::forward<OtherT>(Val));
  }

  ErrorOr(const ErrorOr &Other) {
    copyConstruct(Other);
  }

  template <class OtherT>
  ErrorOr(const ErrorOr<OtherT> &Other,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr) {
    copyConstruct(Other);
  }

  template <class OtherT>
  explicit ErrorOr(
      const ErrorOr<OtherT> &Other,
      std::enable_if_t<!std::is_convertible_v<OtherT, const T &>> * = nullptr) {
    copyConstruct(Other);
  }

  ErrorOr(ErrorOr &&Other) {
    moveConstruct(std::move(Other));
  }

  template <class OtherT>
  ErrorOr(ErrorOr<OtherT> &&Other,
          std::enable_if_t<std::is_convertible_v<OtherT, T>> * = nullptr) {
    moveConstruct(std::move(Other));
  }



  template <class OtherT>
  explicit ErrorOr(
      ErrorOr<OtherT> &&Other,
      std::enable_if_t<!std::is_convertible_v<OtherT, T>> * = nullptr) {
    moveConstruct(std::move(Other));
  }

  ErrorOr &operator=(const ErrorOr &Other) {
    copyAssign(Other);
    return *this;
  }

  ErrorOr &operator=(ErrorOr &&Other) {
    moveAssign(std::move(Other));
    return *this;
  }

  ~ErrorOr() {
    if (!HasError)
      getStorage()->~storage_type();
  }


  explicit operator bool() const {
    return !HasError;
  }

  reference get() { return *getStorage(); }
  const_reference get() const { return const_cast<ErrorOr<T> *>(this)->get(); }

  std::error_code getError() const {
    return HasError ? *getErrorStorage() : std::error_code();
  }

  pointer operator ->() {
    return toPointer(getStorage());
  }

  const_pointer operator->() const { return toPointer(getStorage()); }

  reference operator *() {
    return *getStorage();
  }

  const_reference operator*() const { return *getStorage(); }

private:
  template <class OtherT>
  void copyConstruct(const ErrorOr<OtherT> &Other) {
    if (!Other.HasError) {

      HasError = false;
      new (getStorage()) storage_type(*Other.getStorage());
    } else {

      HasError = true;
      new (getErrorStorage()) std::error_code(Other.getError());
    }
  }

  template <class T1>
  static bool compareThisIfSameType(const T1 &a, const T1 &b) {
    return &a == &b;
  }

  template <class T1, class T2>
  static bool compareThisIfSameType(const T1 &a, const T2 &b) {
    return false;
  }

  template <class OtherT>
  void copyAssign(const ErrorOr<OtherT> &Other) {
    if (compareThisIfSameType(*this, Other))
      return;

    this->~ErrorOr();
    new (this) ErrorOr(Other);
  }

  template <class OtherT>
  void moveConstruct(ErrorOr<OtherT> &&Other) {
    if (!Other.HasError) {

      HasError = false;
      new (getStorage()) storage_type(std::move(*Other.getStorage()));
    } else {

      HasError = true;
      new (getErrorStorage()) std::error_code(Other.getError());
    }
  }

  template <class OtherT>
  void moveAssign(ErrorOr<OtherT> &&Other) {
    if (compareThisIfSameType(*this, Other))
      return;

    this->~ErrorOr();
    new (this) ErrorOr(std::move(Other));
  }

  pointer toPointer(pointer Val) {
    return Val;
  }

  const_pointer toPointer(const_pointer Val) const { return Val; }

  pointer toPointer(wrap *Val) {
    return &Val->get();
  }

  const_pointer toPointer(const wrap *Val) const { return &Val->get(); }

  storage_type *getStorage() {
    (__builtin_expect(!(!HasError && "Cannot get value when an error exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 236, "!HasError && \"Cannot get value when an error exists!\"") : (void)0);
    return reinterpret_cast<storage_type *>(&TStorage);
  }

  const storage_type *getStorage() const {
    (__builtin_expect(!(!HasError && "Cannot get value when an error exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 241, "!HasError && \"Cannot get value when an error exists!\"") : (void)0);
    return reinterpret_cast<const storage_type *>(&TStorage);
  }

  std::error_code *getErrorStorage() {
    (__builtin_expect(!(HasError && "Cannot get error when a value exists!"), 0) ? __assert_rtn(__func__, "ErrorOr.h", 246, "HasError && \"Cannot get error when a value exists!\"") : (void)0);
    return reinterpret_cast<std::error_code *>(&ErrorStorage);
  }

  const std::error_code *getErrorStorage() const {
    return const_cast<ErrorOr<T> *>(this)->getErrorStorage();
  }

  union {
    AlignedCharArrayUnion<storage_type> TStorage;
    AlignedCharArrayUnion<std::error_code> ErrorStorage;
  };
  bool HasError : 1;
};

template <class T, class E>
std::enable_if_t<std::is_error_code_enum<E>::value ||
                     std::is_error_condition_enum<E>::value,
                 bool>
operator==(const ErrorOr<T> &Err, E Code) {
  return Err.getError() == Code;
}

}
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBufferRef.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBufferRef.h"
namespace llvm {

class MemoryBuffer;

class MemoryBufferRef {
  StringRef Buffer;
  StringRef Identifier;

public:
  MemoryBufferRef() = default;
  MemoryBufferRef(const MemoryBuffer &Buffer);
  MemoryBufferRef(StringRef Buffer, StringRef Identifier)
      : Buffer(Buffer), Identifier(Identifier) {}

  StringRef getBuffer() const { return Buffer; }
  StringRef getBufferIdentifier() const { return Identifier; }

  const char *getBufferStart() const { return Buffer.begin(); }
  const char *getBufferEnd() const { return Buffer.end(); }
  size_t getBufferSize() const { return Buffer.size(); }


  friend bool operator==(const MemoryBufferRef &LHS,
                         const MemoryBufferRef &RHS) {
    return LHS.Buffer.begin() == RHS.Buffer.begin() &&
           LHS.Buffer.end() == RHS.Buffer.end() &&
           LHS.Identifier.begin() == RHS.Identifier.begin() &&
           LHS.Identifier.end() == RHS.Identifier.end();
  }

  friend bool operator!=(const MemoryBufferRef &LHS,
                         const MemoryBufferRef &RHS) {
    return !(LHS == RHS);
  }
};

}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 27 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h" 2

namespace llvm {
namespace sys {
namespace fs {





using file_t = int;

}
}
# 51 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
class MemoryBuffer {
  const char *BufferStart;
  const char *BufferEnd;

protected:
  MemoryBuffer() = default;

  void init(const char *BufStart, const char *BufEnd,
            bool RequiresNullTerminator);

public:
  MemoryBuffer(const MemoryBuffer &) = delete;
  MemoryBuffer &operator=(const MemoryBuffer &) = delete;
  virtual ~MemoryBuffer();

  const char *getBufferStart() const { return BufferStart; }
  const char *getBufferEnd() const { return BufferEnd; }
  size_t getBufferSize() const { return BufferEnd-BufferStart; }

  StringRef getBuffer() const {
    return StringRef(BufferStart, getBufferSize());
  }



  virtual StringRef getBufferIdentifier() const { return "Unknown buffer"; }






  virtual void dontNeedIfMmap() {}
# 97 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFile(const Twine &Filename, bool IsText = false,
          bool RequiresNullTerminator = true, bool IsVolatile = false,
          std::optional<Align> Alignment = std::nullopt);




  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileAsStream(const Twine &Filename);




  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getOpenFileSlice(sys::fs::file_t FD, const Twine &Filename, uint64_t MapSize,
                   int64_t Offset, bool IsVolatile = false,
                   std::optional<Align> Alignment = std::nullopt);
# 125 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/MemoryBuffer.h"
  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getOpenFile(sys::fs::file_t FD, const Twine &Filename, uint64_t FileSize,
              bool RequiresNullTerminator = true, bool IsVolatile = false,
              std::optional<Align> Alignment = std::nullopt);



  static std::unique_ptr<MemoryBuffer>
  getMemBuffer(StringRef InputData, StringRef BufferName = "",
               bool RequiresNullTerminator = true);

  static std::unique_ptr<MemoryBuffer>
  getMemBuffer(MemoryBufferRef Ref, bool RequiresNullTerminator = true);



  static std::unique_ptr<MemoryBuffer>
  getMemBufferCopy(StringRef InputData, const Twine &BufferName = "");


  static ErrorOr<std::unique_ptr<MemoryBuffer>> getSTDIN();



  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileOrSTDIN(const Twine &Filename, bool IsText = false,
                 bool RequiresNullTerminator = true,
                 std::optional<Align> Alignment = std::nullopt);


  static ErrorOr<std::unique_ptr<MemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
               bool IsVolatile = false,
               std::optional<Align> Alignment = std::nullopt);






  enum BufferKind {
    MemoryBuffer_Malloc,
    MemoryBuffer_MMap
  };



  virtual BufferKind getBufferKind() const = 0;

  MemoryBufferRef getMemBufferRef() const;
};





class WritableMemoryBuffer : public MemoryBuffer {
protected:
  WritableMemoryBuffer() = default;

public:
  using MemoryBuffer::getBuffer;
  using MemoryBuffer::getBufferEnd;
  using MemoryBuffer::getBufferStart;



  char *getBufferStart() {
    return const_cast<char *>(MemoryBuffer::getBufferStart());
  }
  char *getBufferEnd() {
    return const_cast<char *>(MemoryBuffer::getBufferEnd());
  }
  MutableArrayRef<char> getBuffer() {
    return {getBufferStart(), getBufferEnd()};
  }

  static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
  getFile(const Twine &Filename, bool IsVolatile = false,
          std::optional<Align> Alignment = std::nullopt);


  static ErrorOr<std::unique_ptr<WritableMemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset,
               bool IsVolatile = false,
               std::optional<Align> Alignment = std::nullopt);







  static std::unique_ptr<WritableMemoryBuffer>
  getNewUninitMemBuffer(size_t Size, const Twine &BufferName = "",
                        std::optional<Align> Alignment = std::nullopt);




  static std::unique_ptr<WritableMemoryBuffer>
  getNewMemBuffer(size_t Size, const Twine &BufferName = "");

private:



  using MemoryBuffer::getFileAsStream;
  using MemoryBuffer::getFileOrSTDIN;
  using MemoryBuffer::getMemBuffer;
  using MemoryBuffer::getMemBufferCopy;
  using MemoryBuffer::getOpenFile;
  using MemoryBuffer::getOpenFileSlice;
  using MemoryBuffer::getSTDIN;
};





class WriteThroughMemoryBuffer : public MemoryBuffer {
protected:
  WriteThroughMemoryBuffer() = default;

public:
  using MemoryBuffer::getBuffer;
  using MemoryBuffer::getBufferEnd;
  using MemoryBuffer::getBufferStart;



  char *getBufferStart() {
    return const_cast<char *>(MemoryBuffer::getBufferStart());
  }
  char *getBufferEnd() {
    return const_cast<char *>(MemoryBuffer::getBufferEnd());
  }
  MutableArrayRef<char> getBuffer() {
    return {getBufferStart(), getBufferEnd()};
  }

  static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
  getFile(const Twine &Filename, int64_t FileSize = -1);


  static ErrorOr<std::unique_ptr<WriteThroughMemoryBuffer>>
  getFileSlice(const Twine &Filename, uint64_t MapSize, uint64_t Offset);

private:



  using MemoryBuffer::getFileAsStream;
  using MemoryBuffer::getFileOrSTDIN;
  using MemoryBuffer::getMemBuffer;
  using MemoryBuffer::getMemBufferCopy;
  using MemoryBuffer::getOpenFile;
  using MemoryBuffer::getOpenFileSlice;
  using MemoryBuffer::getSTDIN;
};


inline MemoryBuffer *unwrap(LLVMMemoryBufferRef P) { return reinterpret_cast<MemoryBuffer*>(P); } inline LLVMMemoryBufferRef wrap(const MemoryBuffer *P) { return reinterpret_cast<LLVMMemoryBufferRef>(const_cast<MemoryBuffer*>(P)); }

}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h" 1
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h" 2







# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 28 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h" 2

namespace llvm {

class Duration;
class formatv_object_base;
class format_object_base;
class FormattedString;
class FormattedNumber;
class FormattedBytes;
template <class T> class [[nodiscard]] Expected;

namespace sys {
namespace fs {
enum FileAccess : unsigned;
enum OpenFlags : unsigned;
enum CreationDisposition : unsigned;
class FileLocker;
}
}





class raw_ostream {
public:

  enum class OStreamKind {
    OK_OStream,
    OK_FDStream,
  };

private:
  OStreamKind Kind;
# 81 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  char *OutBufStart, *OutBufEnd, *OutBufCur;
  bool ColorEnabled = false;



  raw_ostream *TiedStream = nullptr;

  enum class BufferKind {
    Unbuffered = 0,
    InternalBuffer,
    ExternalBuffer
  } BufferMode;

public:

  enum class Colors {
    BLACK = 0,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    MAGENTA,
    CYAN,
    WHITE,
    SAVEDCOLOR,
    RESET,
  };

  static constexpr Colors BLACK = Colors::BLACK;
  static constexpr Colors RED = Colors::RED;
  static constexpr Colors GREEN = Colors::GREEN;
  static constexpr Colors YELLOW = Colors::YELLOW;
  static constexpr Colors BLUE = Colors::BLUE;
  static constexpr Colors MAGENTA = Colors::MAGENTA;
  static constexpr Colors CYAN = Colors::CYAN;
  static constexpr Colors WHITE = Colors::WHITE;
  static constexpr Colors SAVEDCOLOR = Colors::SAVEDCOLOR;
  static constexpr Colors RESET = Colors::RESET;

  explicit raw_ostream(bool unbuffered = false,
                       OStreamKind K = OStreamKind::OK_OStream)
      : Kind(K), BufferMode(unbuffered ? BufferKind::Unbuffered
                                       : BufferKind::InternalBuffer) {

    OutBufStart = OutBufEnd = OutBufCur = nullptr;
  }

  raw_ostream(const raw_ostream &) = delete;
  void operator=(const raw_ostream &) = delete;

  virtual ~raw_ostream();


  uint64_t tell() const { return current_pos() + GetNumBytesInBuffer(); }

  OStreamKind get_kind() const { return Kind; }
# 147 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual void reserveExtraSpace(uint64_t ExtraSize) {}



  void SetBuffered();


  void SetBufferSize(size_t Size) {
    flush();
    SetBufferAndMode(new char[Size], Size, BufferKind::InternalBuffer);
  }

  size_t GetBufferSize() const {


    if (BufferMode != BufferKind::Unbuffered && OutBufStart == nullptr)
      return preferred_buffer_size();


    return OutBufEnd - OutBufStart;
  }




  void SetUnbuffered() {
    flush();
    SetBufferAndMode(nullptr, 0, BufferKind::Unbuffered);
  }

  size_t GetNumBytesInBuffer() const {
    return OutBufCur - OutBufStart;
  }





  void flush() {
    if (OutBufCur != OutBufStart)
      flush_nonempty();
  }

  raw_ostream &operator<<(char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(unsigned char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(signed char C) {
    if (OutBufCur >= OutBufEnd)
      return write(C);
    *OutBufCur++ = C;
    return *this;
  }

  raw_ostream &operator<<(StringRef Str) {

    size_t Size = Str.size();


    if (Size > (size_t)(OutBufEnd - OutBufCur))
      return write(Str.data(), Size);

    if (Size) {
      memcpy(OutBufCur, Str.data(), Size);
      OutBufCur += Size;
    }
    return *this;
  }
# 240 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  raw_ostream &operator<<(const char *Str) {



    return this->operator<<(StringRef(Str));
  }

  raw_ostream &operator<<(const std::string &Str) {

    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(const std::string_view &Str) {
    return write(Str.data(), Str.length());
  }

  raw_ostream &operator<<(const SmallVectorImpl<char> &Str) {
    return write(Str.data(), Str.size());
  }

  raw_ostream &operator<<(unsigned long N);
  raw_ostream &operator<<(long N);
  raw_ostream &operator<<(unsigned long long N);
  raw_ostream &operator<<(long long N);
  raw_ostream &operator<<(const void *P);

  raw_ostream &operator<<(unsigned int N) {
    return this->operator<<(static_cast<unsigned long>(N));
  }

  raw_ostream &operator<<(int N) {
    return this->operator<<(static_cast<long>(N));
  }

  raw_ostream &operator<<(double N);


  raw_ostream &write_hex(unsigned long long N);


  raw_ostream &operator<<(Colors C);


  using uuid_t = uint8_t[16];
  raw_ostream &write_uuid(const uuid_t UUID);



  raw_ostream &write_escaped(StringRef Str, bool UseHexEscapes = false);

  raw_ostream &write(unsigned char C);
  raw_ostream &write(const char *Ptr, size_t Size);


  raw_ostream &operator<<(const format_object_base &Fmt);


  raw_ostream &operator<<(const FormattedString &);


  raw_ostream &operator<<(const FormattedNumber &);


  raw_ostream &operator<<(const formatv_object_base &);


  raw_ostream &operator<<(const FormattedBytes &);


  raw_ostream &indent(unsigned NumSpaces);


  raw_ostream &write_zeros(unsigned NumZeros);
# 321 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual raw_ostream &changeColor(enum Colors Color, bool Bold = false,
                                   bool BG = false);



  virtual raw_ostream &resetColor();


  virtual raw_ostream &reverseColor();




  virtual bool is_displayed() const { return false; }



  virtual bool has_colors() const { return is_displayed(); }



  virtual void enable_colors(bool enable) { ColorEnabled = enable; }

  bool colors_enabled() const { return ColorEnabled; }



  void tie(raw_ostream *TieTo) { TiedStream = TieTo; }





private:
# 368 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  virtual void write_impl(const char *Ptr, size_t Size) = 0;



  virtual uint64_t current_pos() const = 0;

protected:



  void SetBuffer(char *BufferStart, size_t Size) {
    SetBufferAndMode(BufferStart, Size, BufferKind::ExternalBuffer);
  }


  virtual size_t preferred_buffer_size() const;



  const char *getBufferStart() const { return OutBufStart; }




private:

  void SetBufferAndMode(char *BufferStart, size_t Size, BufferKind Mode);



  void flush_nonempty();



  void copy_to_buffer(const char *Ptr, size_t Size);



  bool prepare_colors();


  void flush_tied_then_write(const char *Ptr, size_t Size);

  virtual void anchor();
};



template <typename OStream, typename T>
std::enable_if_t<!std::is_reference_v<OStream> &&
                     std::is_base_of_v<raw_ostream, OStream>,
                 OStream &&>
operator<<(OStream &&OS, const T &Value) {
  OS << Value;
  return std::move(OS);
}




class raw_pwrite_stream : public raw_ostream {
  virtual void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) = 0;
  void anchor() override;

public:
  explicit raw_pwrite_stream(bool Unbuffered = false,
                             OStreamKind K = OStreamKind::OK_OStream)
      : raw_ostream(Unbuffered, K) {}
  void pwrite(const char *Ptr, size_t Size, uint64_t Offset) {

    uint64_t Pos = tell();


    if (Pos)
      (__builtin_expect(!(Size + Offset <= Pos && "We don't support extending the stream"), 0) ? __assert_rtn(__func__, "raw_ostream.h", 442, "Size + Offset <= Pos && \"We don't support extending the stream\"") : (void)0);

    pwrite_impl(Ptr, Size, Offset);
  }
};







class raw_fd_ostream : public raw_pwrite_stream {
  int FD;
  bool ShouldClose;
  bool SupportsSeeking = false;
  bool IsRegularFile = false;
  mutable std::optional<bool> HasColors;







  std::error_code EC;

  uint64_t pos = 0;


  void write_impl(const char *Ptr, size_t Size) override;

  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;



  uint64_t current_pos() const override { return pos; }


  size_t preferred_buffer_size() const override;

  void anchor() override;

protected:

  void error_detected(std::error_code EC) { this->EC = EC; }


  int get_fd() const { return FD; }


  void inc_pos(uint64_t Delta) { pos += Delta; }

public:
# 504 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  raw_fd_ostream(StringRef Filename, std::error_code &EC);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::CreationDisposition Disp);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::FileAccess Access);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::OpenFlags Flags);
  raw_fd_ostream(StringRef Filename, std::error_code &EC,
                 sys::fs::CreationDisposition Disp, sys::fs::FileAccess Access,
                 sys::fs::OpenFlags Flags);




  raw_fd_ostream(int fd, bool shouldClose, bool unbuffered = false,
                 OStreamKind K = OStreamKind::OK_OStream);

  ~raw_fd_ostream() override;



  void close();

  bool supportsSeeking() const { return SupportsSeeking; }

  bool isRegularFile() const { return IsRegularFile; }



  uint64_t seek(uint64_t off);

  bool is_displayed() const override;

  bool has_colors() const override;

  std::error_code error() const { return EC; }





  bool has_error() const { return bool(EC); }
# 556 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  void clear_error() { EC = std::error_code(); }
# 578 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  [[nodiscard]] Expected<sys::fs::FileLocker> lock();
# 587 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  [[nodiscard]] Expected<sys::fs::FileLocker>
  tryLockFor(Duration const &Timeout);
};



raw_fd_ostream &outs();






raw_fd_ostream &errs();


raw_ostream &nulls();







class raw_fd_stream : public raw_fd_ostream {
public:



  raw_fd_stream(StringRef Filename, std::error_code &EC);
# 627 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
  ssize_t read(char *Ptr, size_t Size);


  static bool classof(const raw_ostream *OS);
};
# 642 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Support/raw_ostream.h"
class raw_string_ostream : public raw_ostream {
  std::string &OS;


  void write_impl(const char *Ptr, size_t Size) override;



  uint64_t current_pos() const override { return OS.size(); }

public:
  explicit raw_string_ostream(std::string &O) : OS(O) {
    SetUnbuffered();
  }




  std::string &str() { return OS; }

  void reserveExtraSpace(uint64_t ExtraSize) override {
    OS.reserve(tell() + ExtraSize);
  }
};






class raw_svector_ostream : public raw_pwrite_stream {
  SmallVectorImpl<char> &OS;


  void write_impl(const char *Ptr, size_t Size) override;

  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;


  uint64_t current_pos() const override;

public:




  explicit raw_svector_ostream(SmallVectorImpl<char> &O) : OS(O) {
    SetUnbuffered();
  }

  ~raw_svector_ostream() override = default;

  void flush() = delete;


  StringRef str() const { return StringRef(OS.data(), OS.size()); }

  void reserveExtraSpace(uint64_t ExtraSize) override {
    OS.reserve(tell() + ExtraSize);
  }
};


class raw_null_ostream : public raw_pwrite_stream {

  void write_impl(const char *Ptr, size_t size) override;
  void pwrite_impl(const char *Ptr, size_t Size, uint64_t Offset) override;



  uint64_t current_pos() const override;

public:
  explicit raw_null_ostream() = default;
  ~raw_null_ostream() override;
};

class buffer_ostream : public raw_svector_ostream {
  raw_ostream &OS;
  SmallVector<char, 0> Buffer;

  void anchor() override;

public:
  buffer_ostream(raw_ostream &OS) : raw_svector_ostream(Buffer), OS(OS) {}
  ~buffer_ostream() override { OS << str(); }
};

class buffer_unique_ostream : public raw_svector_ostream {
  std::unique_ptr<raw_ostream> OS;
  SmallVector<char, 0> Buffer;

  void anchor() override;

public:
  buffer_unique_ostream(std::unique_ptr<raw_ostream> OS)
      : raw_svector_ostream(Buffer), OS(std::move(OS)) {


    this->OS->SetUnbuffered();
  }
  ~buffer_unique_ostream() override { *OS << str(); }
};

class Error;







Error writeToOutput(StringRef OutputFileName,
                    std::function<Error(raw_ostream &)> Write);

raw_ostream &operator<<(raw_ostream &OS, std::nullopt_t);

template <typename T, typename = decltype(std::declval<raw_ostream &>()
                                          << std::declval<const T &>())>
raw_ostream &operator<<(raw_ostream &OS, const std::optional<T> &O) {
  if (O)
    OS << *O;
  else
    OS << std::nullopt;
  return OS;
}

}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 1 3
# 494 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 1 3
# 14 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 2 3
# 18 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__functional/is_transparent.h" 3


namespace std { inline namespace __1 {



template <class _Tp, class, class = void>
struct __is_transparent : false_type {};

template <class _Tp, class _Up>
struct __is_transparent<_Tp, _Up,
                        typename __void_t<typename _Tp::is_transparent>::type>
   : true_type {};



} }
# 495 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 1 3
# 15 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 16 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__node_handle" 2 3

namespace std { inline namespace __1 {




template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;

template <class _NodeType, class _Alloc,
          template <class, class> class _MapOrSetSpecifics>
class __attribute__ ((__type_visibility__("default"))) __basic_node_handle
    : public _MapOrSetSpecifics<
          _NodeType,
          __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>
{
    template <class _Tp, class _Compare, class _Allocator>
        friend class __tree;
    template <class _Tp, class _Hash, class _Equal, class _Allocator>
        friend class __hash_table;
    friend struct _MapOrSetSpecifics<
        _NodeType, __basic_node_handle<_NodeType, _Alloc, _MapOrSetSpecifics>>;

    typedef allocator_traits<_Alloc> __alloc_traits;
    typedef typename __rebind_pointer<typename __alloc_traits::void_pointer,
                                      _NodeType>::type
        __node_pointer_type;

public:
    typedef _Alloc allocator_type;

private:
    __node_pointer_type __ptr_ = nullptr;
    optional<allocator_type> __alloc_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __release_ptr()
    {
        __ptr_ = nullptr;
        __alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __destroy_node_pointer()
    {
        if (__ptr_ != nullptr)
        {
            typedef typename __allocator_traits_rebind<
                allocator_type, _NodeType>::type __node_alloc_type;
            __node_alloc_type __alloc(*__alloc_);
            __generic_container_node_destructor<_NodeType, __node_alloc_type>(
                __alloc, true)(__ptr_);
            __ptr_ = nullptr;
        }
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle(__node_pointer_type __ptr,
                        allocator_type const& __alloc)
            : __ptr_(__ptr), __alloc_(__alloc)
    {
    }

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle() = default;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle(__basic_node_handle&& __other) noexcept
            : __ptr_(__other.__ptr_),
              __alloc_(std::__1::move(__other.__alloc_))
    {
        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __basic_node_handle& operator=(__basic_node_handle&& __other)
    {
        ((void)0);






        __destroy_node_pointer();
        __ptr_ = __other.__ptr_;

        if (__alloc_traits::propagate_on_container_move_assignment::value ||
            __alloc_ == std::__1::nullopt)
            __alloc_ = std::__1::move(__other.__alloc_);

        __other.__ptr_ = nullptr;
        __other.__alloc_ = std::__1::nullopt;

        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const { return *__alloc_; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit operator bool() const { return __ptr_ != nullptr; }

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const { return __ptr_ == nullptr; }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__basic_node_handle& __other) noexcept(
        __alloc_traits::propagate_on_container_swap::value ||
        __alloc_traits::is_always_equal::value)
    {
        using std::__1::swap;
        swap(__ptr_, __other.__ptr_);
        if (__alloc_traits::propagate_on_container_swap::value ||
            __alloc_ == std::__1::nullopt || __other.__alloc_ == std::__1::nullopt)
            swap(__alloc_, __other.__alloc_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    friend void swap(__basic_node_handle& __a, __basic_node_handle& __b)
        noexcept(noexcept(__a.swap(__b))) { __a.swap(__b); }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~__basic_node_handle()
    {
        __destroy_node_pointer();
    }
};

template <class _NodeType, class _Derived>
struct __set_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type value_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& value() const
    {
        return static_cast<_Derived const*>(this)->__ptr_->__value_;
    }
};

template <class _NodeType, class _Derived>
struct __map_node_handle_specifics
{
    typedef typename _NodeType::__node_value_type::key_type key_type;
    typedef typename _NodeType::__node_value_type::mapped_type mapped_type;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_type& key() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    mapped_type& mapped() const
    {
        return static_cast<_Derived const*>(this)->
            __ptr_->__value_.__ref().second;
    }
};

template <class _NodeType, class _Alloc>
using __set_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __set_node_handle_specifics>;

template <class _NodeType, class _Alloc>
using __map_node_handle =
    __basic_node_handle< _NodeType, _Alloc, __map_node_handle_specifics>;

template <class _Iterator, class _NodeType>
struct __attribute__ ((__type_visibility__("default"))) __insert_return_type
{
    _Iterator position;
    bool inserted;
    _NodeType node;
};



} }
# 496 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 1 3
# 18 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 19 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 2 3
# 23 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 27 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 2 3


namespace std { inline namespace __1 {
# 38 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator> class __tree;
template <class _Tp, class _NodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_iterator;
template <class _Tp, class _ConstNodePtr, class _DiffType>
    class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;

template <class _Pointer> class __tree_end_node;
template <class _VoidPtr> class __tree_node_base;
template <class _Tp, class _VoidPtr> class __tree_node;

template <class _Key, class _Value>
struct __value_type;

template <class _Allocator> class __map_node_destructor;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_iterator;
template <class _TreeIterator> class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
# 78 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
__tree_is_left_child(_NodePtr __x) noexcept
{
    return __x == __x->__parent_->__left_;
}




template <class _NodePtr>
unsigned
__tree_sub_invariant(_NodePtr __x)
{
    if (__x == nullptr)
        return 1;


    if (__x->__left_ != nullptr && __x->__left_->__parent_ != __x)
        return 0;

    if (__x->__right_ != nullptr && __x->__right_->__parent_ != __x)
        return 0;

    if (__x->__left_ == __x->__right_ && __x->__left_ != nullptr)
        return 0;

    if (!__x->__is_black_)
    {
        if (__x->__left_ && !__x->__left_->__is_black_)
            return 0;
        if (__x->__right_ && !__x->__right_->__is_black_)
            return 0;
    }
    unsigned __h = std::__1::__tree_sub_invariant(__x->__left_);
    if (__h == 0)
        return 0;
    if (__h != std::__1::__tree_sub_invariant(__x->__right_))
        return 0;
    return __h + __x->__is_black_;
}




template <class _NodePtr>
bool
__tree_invariant(_NodePtr __root)
{
    if (__root == nullptr)
        return true;

    if (__root->__parent_ == nullptr)
        return false;
    if (!std::__1::__tree_is_left_child(__root))
        return false;

    if (!__root->__is_black_)
        return false;

    return std::__1::__tree_sub_invariant(__root) != 0;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_min(_NodePtr __x) noexcept
{
    while (__x->__left_ != nullptr)
        __x = __x->__left_;
    return __x;
}



template <class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_max(_NodePtr __x) noexcept
{
    while (__x->__right_ != nullptr)
        __x = __x->__right_;
    return __x;
}



template <class _NodePtr>
_NodePtr
__tree_next(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return std::__1::__tree_min(__x->__right_);
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return __x->__parent_unsafe();
}

template <class _EndNodePtr, class _NodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_EndNodePtr
__tree_next_iter(_NodePtr __x) noexcept
{
    if (__x->__right_ != nullptr)
        return static_cast<_EndNodePtr>(std::__1::__tree_min(__x->__right_));
    while (!std::__1::__tree_is_left_child(__x))
        __x = __x->__parent_unsafe();
    return static_cast<_EndNodePtr>(__x->__parent_);
}




template <class _NodePtr, class _EndNodePtr>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodePtr
__tree_prev_iter(_EndNodePtr __x) noexcept
{
    if (__x->__left_ != nullptr)
        return std::__1::__tree_max(__x->__left_);
    _NodePtr __xx = static_cast<_NodePtr>(__x);
    while (std::__1::__tree_is_left_child(__xx))
        __xx = __xx->__parent_unsafe();
    return __xx->__parent_unsafe();
}



template <class _NodePtr>
_NodePtr
__tree_leaf(_NodePtr __x) noexcept
{
    while (true)
    {
        if (__x->__left_ != nullptr)
        {
            __x = __x->__left_;
            continue;
        }
        if (__x->__right_ != nullptr)
        {
            __x = __x->__right_;
            continue;
        }
        break;
    }
    return __x;
}




template <class _NodePtr>
void
__tree_left_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__right_;
    __x->__right_ = __y->__left_;
    if (__x->__right_ != nullptr)
        __x->__right_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__left_ = __x;
    __x->__set_parent(__y);
}




template <class _NodePtr>
void
__tree_right_rotate(_NodePtr __x) noexcept
{
    _NodePtr __y = __x->__left_;
    __x->__left_ = __y->__right_;
    if (__x->__left_ != nullptr)
        __x->__left_->__set_parent(__x);
    __y->__parent_ = __x->__parent_;
    if (std::__1::__tree_is_left_child(__x))
        __x->__parent_->__left_ = __y;
    else
        __x->__parent_unsafe()->__right_ = __y;
    __y->__right_ = __x;
    __x->__set_parent(__y);
}
# 278 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
void
__tree_balance_after_insert(_NodePtr __root, _NodePtr __x) noexcept
{
    __x->__is_black_ = __x == __root;
    while (__x != __root && !__x->__parent_unsafe()->__is_black_)
    {

        if (std::__1::__tree_is_left_child(__x->__parent_unsafe()))
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_unsafe()->__right_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (!std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_left_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_right_rotate(__x);
                break;
            }
        }
        else
        {
            _NodePtr __y = __x->__parent_unsafe()->__parent_->__left_;
            if (__y != nullptr && !__y->__is_black_)
            {
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = __x == __root;
                __y->__is_black_ = true;
            }
            else
            {
                if (std::__1::__tree_is_left_child(__x))
                {
                    __x = __x->__parent_unsafe();
                    std::__1::__tree_right_rotate(__x);
                }
                __x = __x->__parent_unsafe();
                __x->__is_black_ = true;
                __x = __x->__parent_unsafe();
                __x->__is_black_ = false;
                std::__1::__tree_left_rotate(__x);
                break;
            }
        }
    }
}
# 348 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _NodePtr>
void
__tree_remove(_NodePtr __root, _NodePtr __z) noexcept
{




    _NodePtr __y = (__z->__left_ == nullptr || __z->__right_ == nullptr) ?
                    __z : std::__1::__tree_next(__z);

    _NodePtr __x = __y->__left_ != nullptr ? __y->__left_ : __y->__right_;

    _NodePtr __w = nullptr;

    if (__x != nullptr)
        __x->__parent_ = __y->__parent_;
    if (std::__1::__tree_is_left_child(__y))
    {
        __y->__parent_->__left_ = __x;
        if (__y != __root)
            __w = __y->__parent_unsafe()->__right_;
        else
            __root = __x;
    }
    else
    {
        __y->__parent_unsafe()->__right_ = __x;

        __w = __y->__parent_->__left_;
    }
    bool __removed_black = __y->__is_black_;


    if (__y != __z)
    {

        __y->__parent_ = __z->__parent_;
        if (std::__1::__tree_is_left_child(__z))
            __y->__parent_->__left_ = __y;
        else
            __y->__parent_unsafe()->__right_ = __y;
        __y->__left_ = __z->__left_;
        __y->__left_->__set_parent(__y);
        __y->__right_ = __z->__right_;
        if (__y->__right_ != nullptr)
            __y->__right_->__set_parent(__y);
        __y->__is_black_ = __z->__is_black_;
        if (__root == __z)
            __root = __y;
    }


    if (__removed_black && __root != nullptr)
    {
# 415 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
        if (__x != nullptr)
            __x->__is_black_ = true;
        else
        {





            while (true)
            {
                if (!std::__1::__tree_is_left_child(__w))
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());


                        if (__root == __w->__left_)
                            __root = __w;

                        __w = __w->__left_->__right_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (__x == __root || !__x->__is_black_)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__right_ == nullptr || __w->__right_->__is_black_)
                        {

                            __w->__left_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_right_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__right_->__is_black_ = true;
                        std::__1::__tree_left_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
                else
                {
                    if (!__w->__is_black_)
                    {
                        __w->__is_black_ = true;
                        __w->__parent_unsafe()->__is_black_ = false;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());


                        if (__root == __w->__right_)
                            __root = __w;

                        __w = __w->__right_->__left_;
                    }

                    if ((__w->__left_ == nullptr || __w->__left_->__is_black_) &&
                        (__w->__right_ == nullptr || __w->__right_->__is_black_))
                    {
                        __w->__is_black_ = false;
                        __x = __w->__parent_unsafe();

                        if (!__x->__is_black_ || __x == __root)
                        {
                            __x->__is_black_ = true;
                            break;
                        }

                        __w = std::__1::__tree_is_left_child(__x) ?
                                    __x->__parent_unsafe()->__right_ :
                                    __x->__parent_->__left_;

                    }
                    else
                    {
                        if (__w->__left_ == nullptr || __w->__left_->__is_black_)
                        {

                            __w->__right_->__is_black_ = true;
                            __w->__is_black_ = false;
                            std::__1::__tree_left_rotate(__w);


                            __w = __w->__parent_unsafe();
                        }

                        __w->__is_black_ = __w->__parent_unsafe()->__is_black_;
                        __w->__parent_unsafe()->__is_black_ = true;
                        __w->__left_->__is_black_ = true;
                        std::__1::__tree_right_rotate(__w->__parent_unsafe());
                        break;
                    }
                }
            }
        }
    }
}




template <class _Tp>
struct __is_tree_value_type_imp : false_type {};

template <class _Key, class _Value>
struct __is_tree_value_type_imp<__value_type<_Key, _Value> > : true_type {};

template <class ..._Args>
struct __is_tree_value_type : false_type {};

template <class _One>
struct __is_tree_value_type<_One> : __is_tree_value_type_imp<typename __uncvref<_One>::type> {};

template <class _Tp>
struct __tree_key_value_types {
  typedef _Tp key_type;
  typedef _Tp __node_value_type;
  typedef _Tp __container_value_type;
  static const bool __is_map = false;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const& __get_key(_Tp const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type const& __get_value(__node_value_type const& __v) {
    return __v;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n);
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type&& __move(__node_value_type& __v) {
    return std::__1::move(__v);
  }
};

template <class _Key, class _Tp>
struct __tree_key_value_types<__value_type<_Key, _Tp> > {
  typedef _Key key_type;
  typedef _Tp mapped_type;
  typedef __value_type<_Key, _Tp> __node_value_type;
  typedef pair<const _Key, _Tp> __container_value_type;
  typedef __container_value_type __map_value_type;
  static const bool __is_map = true;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static key_type const&
  __get_key(__node_value_type const& __t) {
    return __t.__get_value().first;
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      key_type const&>::type
  __get_key(_Up& __t) {
    return __t.first;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type const&
  __get_value(__node_value_type const& __t) {
    return __t.__get_value();
  }

  template <class _Up>
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static typename enable_if<__is_same_uncvref<_Up, __container_value_type>::value,
      __container_value_type const&>::type
  __get_value(_Up& __t) {
    return __t;
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __container_value_type* __get_ptr(__node_value_type& __n) {
    return std::__1::addressof(__n.__get_value());
  }

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static pair<key_type&&, mapped_type&&> __move(__node_value_type& __v) {
    return __v.__move();
  }
};

template <class _VoidPtr>
struct __tree_node_base_types {
  typedef _VoidPtr __void_pointer;

  typedef __tree_node_base<__void_pointer> __node_base_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_base_type>::type
                                                             __node_base_pointer;

  typedef __tree_end_node<__node_base_pointer> __end_node_type;
  typedef typename __rebind_pointer<_VoidPtr, __end_node_type>::type
                                                             __end_node_pointer;



  typedef typename conditional<
      is_pointer<__end_node_pointer>::value,
        __end_node_pointer,
        __node_base_pointer>::type __parent_pointer;


private:
  static_assert((is_same<typename pointer_traits<_VoidPtr>::element_type, void>::value),
                  "_VoidPtr does not point to unqualified void type");
};

template <class _Tp, class _AllocPtr, class _KVTypes = __tree_key_value_types<_Tp>,
         bool = _KVTypes::__is_map>
struct __tree_map_pointer_types {};

template <class _Tp, class _AllocPtr, class _KVTypes>
struct __tree_map_pointer_types<_Tp, _AllocPtr, _KVTypes, true> {
  typedef typename _KVTypes::__map_value_type _Mv;
  typedef typename __rebind_pointer<_AllocPtr, _Mv>::type
                                                       __map_value_type_pointer;
  typedef typename __rebind_pointer<_AllocPtr, const _Mv>::type
                                                 __const_map_value_type_pointer;
};

template <class _NodePtr, class _NodeT = typename pointer_traits<_NodePtr>::element_type>
struct __tree_node_types;

template <class _NodePtr, class _Tp, class _VoidPtr>
struct __tree_node_types<_NodePtr, __tree_node<_Tp, _VoidPtr> >
    : public __tree_node_base_types<_VoidPtr>,
             __tree_key_value_types<_Tp>,
             __tree_map_pointer_types<_Tp, _VoidPtr>
{
  typedef __tree_node_base_types<_VoidPtr> __base;
  typedef __tree_key_value_types<_Tp> __key_base;
  typedef __tree_map_pointer_types<_Tp, _VoidPtr> __map_pointer_base;
public:

  typedef typename pointer_traits<_NodePtr>::element_type __node_type;
  typedef _NodePtr __node_pointer;

  typedef _Tp __node_value_type;
  typedef typename __rebind_pointer<_VoidPtr, __node_value_type>::type
                                                      __node_value_type_pointer;
  typedef typename __rebind_pointer<_VoidPtr, const __node_value_type>::type
                                                __const_node_value_type_pointer;



  typedef typename conditional<
      is_pointer<__node_pointer>::value,
        typename __base::__end_node_pointer,
        __node_pointer>::type __iter_pointer;

private:
    static_assert(!is_const<__node_type>::value,
                "_NodePtr should never be a pointer to const");
    static_assert((is_same<typename __rebind_pointer<_VoidPtr, __node_type>::type,
                          _NodePtr>::value), "_VoidPtr does not rebind to _NodePtr.");
};

template <class _ValueTp, class _VoidPtr>
struct __make_tree_node_types {
  typedef typename __rebind_pointer<_VoidPtr, __tree_node<_ValueTp, _VoidPtr> >::type
                                                                        _NodePtr;
  typedef __tree_node_types<_NodePtr> type;
};



template <class _Pointer>
class __tree_end_node
{
public:
    typedef _Pointer pointer;
    pointer __left_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_end_node() noexcept : __left_() {}
};

template <class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node_base
    : public __tree_node_base_types<_VoidPtr>::__end_node_type
{
    typedef __tree_node_base_types<_VoidPtr> _NodeBaseTypes;

public:
    typedef typename _NodeBaseTypes::__node_base_pointer pointer;
    typedef typename _NodeBaseTypes::__parent_pointer __parent_pointer;

    pointer __right_;
    __parent_pointer __parent_;
    bool __is_black_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer __parent_unsafe() const { return static_cast<pointer>(__parent_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __set_parent(pointer __p) {
        __parent_ = static_cast<__parent_pointer>(__p);
    }

private:
  ~__tree_node_base() = delete;
  __tree_node_base(__tree_node_base const&) = delete;
  __tree_node_base& operator=(__tree_node_base const&) = delete;
};

template <class _Tp, class _VoidPtr>
class __attribute__((__standalone_debug__)) __tree_node
    : public __tree_node_base<_VoidPtr>
{
public:
    typedef _Tp __node_value_type;

    __node_value_type __value_;

private:
  ~__tree_node() = delete;
  __tree_node(__tree_node const&) = delete;
  __tree_node& operator=(__tree_node const&) = delete;
};


template <class _Allocator>
class __tree_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;
private:
    typedef __tree_node_types<pointer> _NodeTypes;
    allocator_type& __na_;


public:
    bool __value_constructed;


    __tree_node_destructor(const __tree_node_destructor &) = default;
    __tree_node_destructor& operator=(const __tree_node_destructor&) = delete;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_node_destructor(allocator_type& __na, bool __val = false) noexcept
        : __na_(__na),
          __value_constructed(__val)
        {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__value_constructed)
            __alloc_traits::destroy(__na_, _NodeTypes::__get_ptr(__p->__value_));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }

    template <class> friend class __map_node_destructor;
};


template <class _NodeType, class _Alloc>
struct __generic_container_node_destructor;
template <class _Tp, class _VoidPtr, class _Alloc>
struct __generic_container_node_destructor<__tree_node<_Tp, _VoidPtr>, _Alloc>
    : __tree_node_destructor<_Alloc>
{
    using __tree_node_destructor<_Alloc>::__tree_node_destructor;
};


template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef _NodePtr __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __tree_iterator() noexcept

    : __ptr_(nullptr)

    {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator operator++(int)
        {__tree_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_iterator operator--(int)
        {__tree_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __tree_iterator& __x, const __tree_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __tree_iterator& __x, const __tree_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_iterator(__node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_iterator(__end_node_pointer __p) noexcept : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }
    template <class, class, class> friend class __tree;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_iterator;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
};

template <class _Tp, class _NodePtr, class _DiffType>
class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator
{
    typedef __tree_node_types<_NodePtr> _NodeTypes;
    typedef typename _NodeTypes::__node_pointer __node_pointer;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;
    typedef typename _NodeTypes::__end_node_pointer __end_node_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;
    typedef pointer_traits<__node_pointer> __pointer_traits;

    __iter_pointer __ptr_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef _Tp value_type;
    typedef _DiffType difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_node_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __tree_const_iterator() noexcept

    : __ptr_(nullptr)

    {}

private:
    typedef __tree_iterator<value_type, __node_pointer, difference_type>
                                                           __non_const_iterator;
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator(__non_const_iterator __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator*() const
        {return __get_np()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) pointer operator->() const
        {return pointer_traits<pointer>::pointer_to(__get_np()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator& operator++() {
      __ptr_ = static_cast<__iter_pointer>(
          std::__1::__tree_next_iter<__end_node_pointer>(static_cast<__node_base_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator operator++(int)
        {__tree_const_iterator __t(*this); ++(*this); return __t;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator& operator--() {
      __ptr_ = static_cast<__iter_pointer>(std::__1::__tree_prev_iter<__node_base_pointer>(
          static_cast<__end_node_pointer>(__ptr_)));
      return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __tree_const_iterator operator--(int)
        {__tree_const_iterator __t(*this); --(*this); return __t;}

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator==(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator!=(const __tree_const_iterator& __x, const __tree_const_iterator& __y)
        {return !(__x == __y);}

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __tree_const_iterator(__end_node_pointer __p) noexcept
        : __ptr_(__p) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_np() const { return static_cast<__node_pointer>(__ptr_); }

    template <class, class, class> friend class __tree;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multiset;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;

};

template<class _Tp, class _Compare>

    __attribute__((diagnose_if(!__invokable<_Compare const&, _Tp const&, _Tp const&>::value, "the specified comparator type does not provide a viable const call operator", "warning")))


int __diagnose_non_const_comparator();

template <class _Tp, class _Compare, class _Allocator>
class __tree
{
public:
    typedef _Tp value_type;
    typedef _Compare value_compare;
    typedef _Allocator allocator_type;

private:
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __make_tree_node_types<value_type,
        typename __alloc_traits::void_pointer>::type
                                                    _NodeTypes;
    typedef typename _NodeTypes::key_type key_type;
public:
    typedef typename _NodeTypes::__node_value_type __node_value_type;
    typedef typename _NodeTypes::__container_value_type __container_value_type;

    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;

public:
    typedef typename _NodeTypes::__void_pointer __void_pointer;

    typedef typename _NodeTypes::__node_type __node;
    typedef typename _NodeTypes::__node_pointer __node_pointer;

    typedef typename _NodeTypes::__node_base_type __node_base;
    typedef typename _NodeTypes::__node_base_pointer __node_base_pointer;

    typedef typename _NodeTypes::__end_node_type __end_node_t;
    typedef typename _NodeTypes::__end_node_pointer __end_node_ptr;

    typedef typename _NodeTypes::__parent_pointer __parent_pointer;
    typedef typename _NodeTypes::__iter_pointer __iter_pointer;

    typedef typename __rebind_alloc_helper<__alloc_traits, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;

private:



    static_assert((is_same<__node_pointer, typename __node_traits::pointer>::value),
                  "Allocator does not rebind pointers in a sane manner.");
    typedef typename __rebind_alloc_helper<__node_traits, __node_base>::type
        __node_base_allocator;
    typedef allocator_traits<__node_base_allocator> __node_base_traits;
    static_assert((is_same<__node_base_pointer, typename __node_base_traits::pointer>::value),
                 "Allocator does not rebind pointers in a sane manner.");

private:
    __iter_pointer __begin_node_;
    __compressed_pair<__end_node_t, __node_allocator> __pair1_;
    __compressed_pair<size_type, value_compare> __pair3_;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iter_pointer __end_node() noexcept
    {
        return static_cast<__iter_pointer>(
                pointer_traits<__end_node_ptr>::pointer_to(__pair1_.first())
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __iter_pointer __end_node() const noexcept
    {
        return static_cast<__iter_pointer>(
            pointer_traits<__end_node_ptr>::pointer_to(
                const_cast<__end_node_t&>(__pair1_.first())
            )
        );
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __node_alloc() noexcept {return __pair1_.second();}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __node_alloc() const noexcept
        {return __pair1_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __iter_pointer& __begin_node() noexcept {return __begin_node_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __iter_pointer& __begin_node() const noexcept {return __begin_node_;}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type __alloc() const noexcept
        {return allocator_type(__node_alloc());}
private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          size_type& size() noexcept {return __pair3_.first();}
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const size_type& size() const noexcept {return __pair3_.first();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          value_compare& value_comp() noexcept {return __pair3_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_compare& value_comp() const noexcept
        {return __pair3_.second();}
public:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __root() const noexcept
        {return static_cast<__node_pointer>(__end_node()->__left_);}

    __node_base_pointer* __root_ptr() const noexcept {
        return std::__1::addressof(__end_node()->__left_);
    }

    typedef __tree_iterator<value_type, __node_pointer, difference_type> iterator;
    typedef __tree_const_iterator<value_type, __node_pointer, difference_type> const_iterator;

    explicit __tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value);


    explicit __tree(const allocator_type& __a);
    __tree(const value_compare& __comp, const allocator_type& __a);
    __tree(const __tree& __t);
    __tree& operator=(const __tree& __t);
    template <class _ForwardIterator>
        void __assign_unique(_ForwardIterator __first, _ForwardIterator __last);
    template <class _InputIterator>
        void __assign_multi(_InputIterator __first, _InputIterator __last);
    __tree(__tree&& __t)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value);


    __tree(__tree&& __t, const allocator_type& __a);
    __tree& operator=(__tree&& __t)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);



    ~__tree();

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return const_iterator(__begin_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return iterator(__end_node());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return const_iterator(__end_node());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept
        {return std::__1::min<size_type>(
                __node_traits::max_size(__node_alloc()),
                numeric_limits<difference_type >::max());}

    void clear() noexcept;

    void swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value);


    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_unique_key_args(_Key const&, _Args&&... __args);
    template <class _Key, class ..._Args>
    pair<iterator, bool>
    __emplace_hint_unique_key_args(const_iterator, _Key const&, _Args&&...);

    template <class... _Args>
    pair<iterator, bool> __emplace_unique_impl(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_unique_impl(const_iterator __p, _Args&&... __args);

    template <class... _Args>
    iterator __emplace_multi(_Args&&... __args);

    template <class... _Args>
    iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Pp&& __x) {
        return __emplace_unique_extract_key(std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        pair<iterator, bool>
    >::type __emplace_unique(_First&& __f, _Second&& __s) {
        return __emplace_unique_key_args(__f, std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s));
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __emplace_unique(_Args&&... __args) {
        return __emplace_unique_impl(std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_fail_tag) {
      return __emplace_unique_impl(std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_self_tag) {
      return __emplace_unique_key_args(__x, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    __emplace_unique_extract_key(_Pp&& __x, __extract_key_first_tag) {
      return __emplace_unique_key_args(__x.first, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_hint_unique(const_iterator __p, _Pp&& __x) {
        return __emplace_hint_unique_extract_key(__p, std::__1::forward<_Pp>(__x),
                                            __can_extract_key<_Pp, key_type>());
    }

    template <class _First, class _Second>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<
        __can_extract_map_key<_First, key_type, __container_value_type>::value,
        iterator
    >::type __emplace_hint_unique(const_iterator __p, _First&& __f, _Second&& __s) {
        return __emplace_hint_unique_key_args(__p, __f,
                                              std::__1::forward<_First>(__f),
                                              std::__1::forward<_Second>(__s)).first;
    }

    template <class... _Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __emplace_hint_unique(const_iterator __p, _Args&&... __args) {
        return __emplace_hint_unique_impl(__p, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_fail_tag) {
      return __emplace_hint_unique_impl(__p, std::__1::forward<_Pp>(__x));
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_self_tag) {
      return __emplace_hint_unique_key_args(__p, __x, std::__1::forward<_Pp>(__x)).first;
    }

    template <class _Pp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
    __emplace_hint_unique_extract_key(const_iterator __p, _Pp&& __x, __extract_key_first_tag) {
      return __emplace_hint_unique_key_args(__p, __x.first, std::__1::forward<_Pp>(__x)).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(const __container_value_type& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), __v);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, const __container_value_type& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), __v).first;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(__container_value_type&& __v) {
        return __emplace_unique_key_args(_NodeTypes::__get_key(__v), std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_unique_key_args(__p, _NodeTypes::__get_key(__v), std::__1::move(__v)).first;
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __insert_unique(_Vp&& __v) {
        return __emplace_unique(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp, class = typename enable_if<
            !is_same<typename __unconstref<_Vp>::type,
                     __container_value_type
            >::value
        >::type>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_unique(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_unique(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(__container_value_type&& __v) {
        return __emplace_multi(std::__1::move(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(const_iterator __p, __container_value_type&& __v) {
        return __emplace_hint_multi(__p, std::__1::move(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(_Vp&& __v) {
        return __emplace_multi(std::__1::forward<_Vp>(__v));
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __insert_multi(const_iterator __p, _Vp&& __v) {
        return __emplace_hint_multi(__p, std::__1::forward<_Vp>(__v));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> __node_assign_unique(const __container_value_type& __v, __node_pointer __dest);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(__node_pointer __nd);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_insert_multi(const_iterator __p, __node_pointer __nd);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator
    __remove_node_pointer(__node_pointer) noexcept;


    template <class _NodeHandle, class _InsertReturnType>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _InsertReturnType __node_handle_insert_unique(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_unique(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_unique(_Tree& __source);

    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(_NodeHandle&&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator __node_handle_insert_multi(const_iterator, _NodeHandle&&);
    template <class _Tree>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __node_handle_merge_multi(_Tree& __source);


    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(key_type const&);
    template <class _NodeHandle>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    _NodeHandle __node_handle_extract(const_iterator);


    iterator erase(const_iterator __p);
    iterator erase(const_iterator __f, const_iterator __l);
    template <class _Key>
        size_type __erase_unique(const _Key& __k);
    template <class _Key>
        size_type __erase_multi(const _Key& __k);

    void __insert_node_at(__parent_pointer __parent,
                          __node_base_pointer& __child,
                          __node_base_pointer __new_node) noexcept;

    template <class _Key>
        iterator find(const _Key& __v);
    template <class _Key>
        const_iterator find(const _Key& __v) const;

    template <class _Key>
        size_type __count_unique(const _Key& __k) const;
    template <class _Key>
        size_type __count_multi(const _Key& __k) const;

    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator lower_bound(const _Key& __v)
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __lower_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        const_iterator lower_bound(const _Key& __v) const
            {return __lower_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __lower_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator upper_bound(const _Key& __v)
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        iterator __upper_bound(const _Key& __v,
                               __node_pointer __root,
                               __iter_pointer __result);
    template <class _Key>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        const_iterator upper_bound(const _Key& __v) const
            {return __upper_bound(__v, __root(), __end_node());}
    template <class _Key>
        const_iterator __upper_bound(const _Key& __v,
                                     __node_pointer __root,
                                     __iter_pointer __result) const;
    template <class _Key>
        pair<iterator, iterator>
        __equal_range_unique(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_unique(const _Key& __k) const;

    template <class _Key>
        pair<iterator, iterator>
        __equal_range_multi(const _Key& __k);
    template <class _Key>
        pair<const_iterator, const_iterator>
        __equal_range_multi(const _Key& __k) const;

    typedef __tree_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;

    __node_holder remove(const_iterator __p) noexcept;
private:
    __node_base_pointer&
        __find_leaf_low(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf_high(__parent_pointer& __parent, const key_type& __v);
    __node_base_pointer&
        __find_leaf(const_iterator __hint,
                    __parent_pointer& __parent, const key_type& __v);


    template <class _Key>
    __node_base_pointer&
        __find_equal(__parent_pointer& __parent, const _Key& __v);
    template <class _Key>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __node_base_pointer&
    __find_equal(__parent_pointer& __parent, const _Key& __v) const {
      return const_cast<__tree*>(this)->__find_equal(__parent, __v);
    }
    template <class _Key>
    __node_base_pointer&
        __find_equal(const_iterator __hint, __parent_pointer& __parent,
                     __node_base_pointer& __dummy,
                     const _Key& __v);

    template <class ..._Args>
    __node_holder __construct_node(_Args&& ...__args);

    void destroy(__node_pointer __nd) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree& __t)
        {__copy_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree& __t, true_type)
        {
        if (__node_alloc() != __t.__node_alloc())
            clear();
        __node_alloc() = __t.__node_alloc();
        }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __tree&, false_type) {}

    void __move_assign(__tree& __t, false_type);
    void __move_assign(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree& __t)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)


        {__move_assign_alloc(__t, integral_constant<bool,
             __node_traits::propagate_on_container_move_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree& __t, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__node_alloc() = std::__1::move(__t.__node_alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__tree&, false_type) noexcept {}

    struct _DetachedTreeCache {
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      explicit _DetachedTreeCache(__tree *__t) noexcept : __t_(__t),
        __cache_root_(__detach_from_tree(__t)) {
          __advance();
        }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      __node_pointer __get() const noexcept {
        return __cache_elem_;
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      void __advance() noexcept {
        __cache_elem_ = __cache_root_;
        if (__cache_root_) {
          __cache_root_ = __detach_next(__cache_root_);
        }
      }

      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      ~_DetachedTreeCache() {
        __t_->destroy(__cache_elem_);
        if (__cache_root_) {
          while (__cache_root_->__parent_ != nullptr)
            __cache_root_ = static_cast<__node_pointer>(__cache_root_->__parent_);
          __t_->destroy(__cache_root_);
        }
      }

       _DetachedTreeCache(_DetachedTreeCache const&) = delete;
       _DetachedTreeCache& operator=(_DetachedTreeCache const&) = delete;

    private:
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      static __node_pointer __detach_from_tree(__tree *__t) noexcept;
      __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
      static __node_pointer __detach_next(__node_pointer) noexcept;

      __tree *__t_;
      __node_pointer __cache_root_;
      __node_pointer __cache_elem_;
    };


    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
};

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<__node_allocator>::value && is_nothrow_copy_constructible<value_compare>::value)


    : __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __default_init_tag())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const value_compare& __comp,
                                           const allocator_type& __a)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, __comp)
{
    __begin_node() = __end_node();
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_from_tree(__tree *__t) noexcept
{
    __node_pointer __cache = static_cast<__node_pointer>(__t->__begin_node());
    __t->__begin_node() = __t->__end_node();
    __t->__end_node()->__left_->__parent_ = nullptr;
    __t->__end_node()->__left_ = nullptr;
    __t->size() = 0;

    if (__cache->__right_ != nullptr)
        __cache = static_cast<__node_pointer>(__cache->__right_);


    return __cache;
}





template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_pointer
__tree<_Tp, _Compare, _Allocator>::_DetachedTreeCache::__detach_next(__node_pointer __cache) noexcept
{
    if (__cache->__parent_ == nullptr)
        return nullptr;
    if (std::__1::__tree_is_left_child(static_cast<__node_base_pointer>(__cache)))
    {
        __cache->__parent_->__left_ = nullptr;
        __cache = static_cast<__node_pointer>(__cache->__parent_);
        if (__cache->__right_ == nullptr)
            return __cache;
        return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__right_));
    }

    __cache->__parent_unsafe()->__right_ = nullptr;
    __cache = static_cast<__node_pointer>(__cache->__parent_);
    if (__cache->__left_ == nullptr)
        return __cache;
    return static_cast<__node_pointer>(std::__1::__tree_leaf(__cache->__left_));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(const __tree& __t)
{
    if (this != &__t)
    {
        value_comp() = __t.value_comp();
        __copy_assign_alloc(__t);
        __assign_multi(__t.begin(), __t.end());
    }
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _ForwardIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_unique(_ForwardIterator __first, _ForwardIterator __last)
{
    typedef iterator_traits<_ForwardIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value),
                  "__assign_unique may only be called with the containers value type");
    static_assert(__is_cpp17_forward_iterator<_ForwardIterator>::value,
                  "__assign_unique requires a forward iterator");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
          for (; __cache.__get() != nullptr && __first != __last; ++__first) {
              if (__node_assign_unique(*__first, __cache.__get()).second)
                  __cache.__advance();
            }
    }
    for (; __first != __last; ++__first)
        __insert_unique(*__first);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _InputIterator>
void
__tree<_Tp, _Compare, _Allocator>::__assign_multi(_InputIterator __first, _InputIterator __last)
{
    typedef iterator_traits<_InputIterator> _ITraits;
    typedef typename _ITraits::value_type _ItValueType;
    static_assert((is_same<_ItValueType, __container_value_type>::value ||
                  is_same<_ItValueType, __node_value_type>::value),
                  "__assign_multi may only be called with the containers value type"
                  " or the nodes value type");
    if (size() != 0)
    {
        _DetachedTreeCache __cache(this);
        for (; __cache.__get() && __first != __last; ++__first) {
            __cache.__get()->__value_ = *__first;
            __node_insert_multi(__cache.__get());
            __cache.__advance();
        }
    }
    for (; __first != __last; ++__first)
        __insert_multi(_NodeTypes::__get_value(*__first));
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(const __tree& __t)
    : __begin_node_(__iter_pointer()),
      __pair1_(__default_init_tag(), __node_traits::select_on_container_copy_construction(__t.__node_alloc())),
      __pair3_(0, __t.value_comp())
{
    __begin_node() = __end_node();
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t)
    noexcept(is_nothrow_move_constructible<__node_allocator>::value && is_nothrow_move_constructible<value_compare>::value)


    : __begin_node_(std::__1::move(__t.__begin_node_)),
      __pair1_(std::__1::move(__t.__pair1_)),
      __pair3_(std::__1::move(__t.__pair3_))
{
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::__tree(__tree&& __t, const allocator_type& __a)
    : __pair1_(__default_init_tag(), __node_allocator(__a)),
      __pair3_(0, std::__1::move(__t.value_comp()))
{
    if (__a == __t.__alloc())
    {
        if (__t.size() == 0)
            __begin_node() = __end_node();
        else
        {
            __begin_node() = __t.__begin_node();
            __end_node()->__left_ = __t.__end_node()->__left_;
            __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
            size() = __t.size();
            __t.__begin_node() = __t.__end_node();
            __t.__end_node()->__left_ = nullptr;
            __t.size() = 0;
        }
    }
    else
    {
        __begin_node() = __end_node();
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, true_type)
    noexcept(is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)

{
    destroy(static_cast<__node_pointer>(__end_node()->__left_));
    __begin_node_ = __t.__begin_node_;
    __pair1_.first() = __t.__pair1_.first();
    __move_assign_alloc(__t);
    __pair3_ = std::__1::move(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
    {
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
        __t.__begin_node() = __t.__end_node();
        __t.__end_node()->__left_ = nullptr;
        __t.size() = 0;
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::__move_assign(__tree& __t, false_type)
{
    if (__node_alloc() == __t.__node_alloc())
        __move_assign(__t, true_type());
    else
    {
        value_comp() = std::__1::move(__t.value_comp());
        const_iterator __e = end();
        if (size() != 0)
        {
            _DetachedTreeCache __cache(this);
            while (__cache.__get() != nullptr && __t.size() != 0) {
              __cache.__get()->__value_ = std::__1::move(__t.remove(__t.begin())->__value_);
              __node_insert_multi(__cache.__get());
              __cache.__advance();
            }
        }
        while (__t.size() != 0)
            __insert_multi(__e, _NodeTypes::__move(__t.remove(__t.begin())->__value_));
    }
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>&
__tree<_Tp, _Compare, _Allocator>::operator=(__tree&& __t)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<value_compare>::value && is_nothrow_move_assignable<__node_allocator>::value)




{
    __move_assign(__t, integral_constant<bool,
                  __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Compare, class _Allocator>
__tree<_Tp, _Compare, _Allocator>::~__tree()
{
    static_assert((is_copy_constructible<value_compare>::value),
                 "Comparator must be copy-constructible.");
  destroy(__root());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::destroy(__node_pointer __nd) noexcept
{
    if (__nd != nullptr)
    {
        destroy(static_cast<__node_pointer>(__nd->__left_));
        destroy(static_cast<__node_pointer>(__nd->__right_));
        __node_allocator& __na = __node_alloc();
        __node_traits::destroy(__na, _NodeTypes::__get_ptr(__nd->__value_));
        __node_traits::deallocate(__na, __nd, 1);
    }
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::swap(__tree& __t)







        noexcept(__is_nothrow_swappable<value_compare>::value)

{
    using std::__1::swap;
    swap(__begin_node_, __t.__begin_node_);
    swap(__pair1_.first(), __t.__pair1_.first());
    std::__1::__swap_allocator(__node_alloc(), __t.__node_alloc());
    __pair3_.swap(__t.__pair3_);
    if (size() == 0)
        __begin_node() = __end_node();
    else
        __end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__end_node());
    if (__t.size() == 0)
        __t.__begin_node() = __t.__end_node();
    else
        __t.__end_node()->__left_->__parent_ = static_cast<__parent_pointer>(__t.__end_node());
}

template <class _Tp, class _Compare, class _Allocator>
void
__tree<_Tp, _Compare, _Allocator>::clear() noexcept
{
    destroy(__root());
    size() = 0;
    __begin_node() = __end_node();
    __end_node()->__left_ = nullptr;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_low(__parent_pointer& __parent,
                                                   const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}




template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf_high(__parent_pointer& __parent,
                                                    const key_type& __v)
{
    __node_pointer __nd = __root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}







template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_leaf(const_iterator __hint,
                                               __parent_pointer& __parent,
                                               const key_type& __v)
{
    if (__hint == end() || !value_comp()(*__hint, __v))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || !value_comp()(__v, *--__prior))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_leaf_high(__parent, __v);
    }

    return __find_leaf_low(__parent, __v);
}





template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(__parent_pointer& __parent,
                                                const _Key& __v)
{
    __node_pointer __nd = __root();
    __node_base_pointer* __nd_ptr = __root_ptr();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (value_comp()(__v, __nd->__value_))
            {
                if (__nd->__left_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__left_);
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __parent->__left_;
                }
            }
            else if (value_comp()(__nd->__value_, __v))
            {
                if (__nd->__right_ != nullptr) {
                    __nd_ptr = std::__1::addressof(__nd->__right_);
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                } else {
                    __parent = static_cast<__parent_pointer>(__nd);
                    return __nd->__right_;
                }
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__nd);
                return *__nd_ptr;
            }
        }
    }
    __parent = static_cast<__parent_pointer>(__end_node());
    return __parent->__left_;
}
# 2015 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__tree" 3
template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::__node_base_pointer&
__tree<_Tp, _Compare, _Allocator>::__find_equal(const_iterator __hint,
                                                __parent_pointer& __parent,
                                                __node_base_pointer& __dummy,
                                                const _Key& __v)
{
    if (__hint == end() || value_comp()(__v, *__hint))
    {

        const_iterator __prior = __hint;
        if (__prior == begin() || value_comp()(*--__prior, __v))
        {

            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__prior.__ptr_);
                return static_cast<__node_base_pointer>(__prior.__ptr_)->__right_;
            }
        }

        return __find_equal(__parent, __v);
    }
    else if (value_comp()(*__hint, __v))
    {

        const_iterator __next = std::__1::next(__hint);
        if (__next == end() || value_comp()(__v, *__next))
        {

            if (__hint.__get_np()->__right_ == nullptr)
            {
                __parent = static_cast<__parent_pointer>(__hint.__ptr_);
                return static_cast<__node_base_pointer>(__hint.__ptr_)->__right_;
            }
            else
            {
                __parent = static_cast<__parent_pointer>(__next.__ptr_);
                return __parent->__left_;
            }
        }

        return __find_equal(__parent, __v);
    }

    __parent = static_cast<__parent_pointer>(__hint.__ptr_);
    __dummy = static_cast<__node_base_pointer>(__hint.__ptr_);
    return __dummy;
}

template <class _Tp, class _Compare, class _Allocator>
void __tree<_Tp, _Compare, _Allocator>::__insert_node_at(
    __parent_pointer __parent, __node_base_pointer& __child,
    __node_base_pointer __new_node) noexcept
{
    __new_node->__left_ = nullptr;
    __new_node->__right_ = nullptr;
    __new_node->__parent_ = __parent;

    __child = __new_node;
    if (__begin_node()->__left_ != nullptr)
        __begin_node() = static_cast<__iter_pointer>(__begin_node()->__left_);
    std::__1::__tree_balance_after_insert(__end_node()->__left_, __child);
    ++size();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_key_args(_Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key, class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_key_args(
    const_iterator __p, _Key const& __k, _Args&&... __args)
{
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class ..._Args>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::__construct_node(_Args&& ...__args)
{
    static_assert(!__is_tree_value_type<_Args...>::value,
                  "Cannot construct from __value_type");
    __node_allocator& __na = __node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));
    __node_traits::construct(__na, _NodeTypes::__get_ptr(__h->__value_), std::__1::forward<_Args>(__args)...);
    __h.get_deleter().__value_constructed = true;
    return __h;
}


template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__emplace_unique_impl(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_unique_impl(const_iterator __p, _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__p, __parent, __dummy, __h->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
        __r = __h.release();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_multi(_Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
template <class... _Args>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__emplace_hint_multi(const_iterator __p,
                                                        _Args&&... __args)
{
    __node_holder __h = __construct_node(std::__1::forward<_Args>(__args)...);
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__h->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__h.get()));
    return iterator(static_cast<__node_pointer>(__h.release()));
}

template <class _Tp, class _Compare, class _Allocator>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator, bool>
__tree<_Tp, _Compare, _Allocator>::__node_assign_unique(const __container_value_type& __v, __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent, _NodeTypes::__get_key(__v));
    __node_pointer __r = static_cast<__node_pointer>(__child);
    bool __inserted = false;
    if (__child == nullptr)
    {
        __nd->__value_ = __v;
        __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
        __r = __nd;
        __inserted = true;
    }
    return pair<iterator, bool>(iterator(__r), __inserted);
}


template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(__node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(__parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_insert_multi(const_iterator __p,
                                                       __node_pointer __nd)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__p, __parent, _NodeTypes::__get_key(__nd->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__nd));
    return iterator(__nd);
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__remove_node_pointer(__node_pointer __ptr) noexcept
{
    iterator __r(__ptr);
    ++__r;
    if (__begin_node() == __ptr)
        __begin_node() = __r.__ptr_;
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__ptr));
    return __r;
}


template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle, class _InsertReturnType>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_InsertReturnType
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    _NodeHandle&& __nh)
{
    if (__nh.empty())
        return _InsertReturnType{end(), false, _NodeHandle()};

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_equal(__parent,
                                                __ptr->__value_);
    if (__child != nullptr)
        return _InsertReturnType{
            iterator(static_cast<__node_pointer>(__child)),
            false, std::__1::move(__nh)};

    __insert_node_at(__parent, __child,
                     static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return _InsertReturnType{iterator(__ptr), true, _NodeHandle()};
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_unique(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer __dummy;
    __node_base_pointer& __child = __find_equal(__hint, __parent, __dummy,
                                                __ptr->__value_);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__ptr));
        __r = __ptr;
        __nh.__release_ptr();
    }
    return iterator(__r);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(key_type const& __key)
{
    iterator __it = find(__key);
    if (__it == end())
        return _NodeHandle();
    return __node_handle_extract<_NodeHandle>(__it);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
_NodeHandle
__tree<_Tp, _Compare, _Allocator>::__node_handle_extract(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    __remove_node_pointer(__np);
    return _NodeHandle(__np, __alloc());
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_unique(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child =
            __find_equal(__parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        if (__child != nullptr)
            continue;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(_NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();
    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf_high(
        __parent, _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _NodeHandle>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__node_handle_insert_multi(
    const_iterator __hint, _NodeHandle&& __nh)
{
    if (__nh.empty())
        return end();

    __node_pointer __ptr = __nh.__ptr_;
    __parent_pointer __parent;
    __node_base_pointer& __child = __find_leaf(__hint, __parent,
                                               _NodeTypes::__get_key(__ptr->__value_));
    __insert_node_at(__parent, __child, static_cast<__node_base_pointer>(__ptr));
    __nh.__release_ptr();
    return iterator(__ptr);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Tree>
__attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
__tree<_Tp, _Compare, _Allocator>::__node_handle_merge_multi(_Tree& __source)
{
    static_assert(is_same<typename _Tree::__node_pointer, __node_pointer>::value, "");

    for (typename _Tree::iterator __i = __source.begin();
         __i != __source.end();)
    {
        __node_pointer __src_ptr = __i.__get_np();
        __parent_pointer __parent;
        __node_base_pointer& __child = __find_leaf_high(
            __parent, _NodeTypes::__get_key(__src_ptr->__value_));
        ++__i;
        __source.__remove_node_pointer(__src_ptr);
        __insert_node_at(__parent, __child,
                         static_cast<__node_base_pointer>(__src_ptr));
    }
}



template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __p)
{
    __node_pointer __np = __p.__get_np();
    iterator __r = __remove_node_pointer(__np);
    __node_allocator& __na = __node_alloc();
    __node_traits::destroy(__na, _NodeTypes::__get_ptr(
        const_cast<__node_value_type&>(*__p)));
    __node_traits::deallocate(__na, __np, 1);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::erase(const_iterator __f, const_iterator __l)
{
    while (__f != __l)
        __f = erase(__f);
    return iterator(__l.__ptr_);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_unique(const _Key& __k)
{
    iterator __i = find(__k);
    if (__i == end())
        return 0;
    erase(__i);
    return 1;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__erase_multi(const _Key& __k)
{
    pair<iterator, iterator> __p = __equal_range_multi(__k);
    size_type __r = 0;
    for (; __p.first != __p.second; ++__r)
        __p.first = erase(__p.first);
    return __r;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v)
{
    iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::find(const _Key& __v) const
{
    const_iterator __p = __lower_bound(__v, __root(), __end_node());
    if (__p != end() && !value_comp()(__v, *__p))
        return __p;
    return end();
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_unique(const _Key& __k) const
{
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return 1;
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::size_type
__tree<_Tp, _Compare, _Allocator>::__count_multi(const _Key& __k) const
{
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return std::__1::distance(
                __lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result)
            );
    }
    return 0;
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__lower_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (!value_comp()(__root->__value_, __v))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result)
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
typename __tree<_Tp, _Compare, _Allocator>::const_iterator
__tree<_Tp, _Compare, _Allocator>::__upper_bound(const _Key& __v,
                                                 __node_pointer __root,
                                                 __iter_pointer __result) const
{
    while (__root != nullptr)
    {
        if (value_comp()(__v, __root->__value_))
        {
            __result = static_cast<__iter_pointer>(__root);
            __root = static_cast<__node_pointer>(__root->__left_);
        }
        else
            __root = static_cast<__node_pointer>(__root->__right_);
    }
    return const_iterator(__result);
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(iterator(__rt),
                      iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_unique(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(const_iterator(__rt),
                      const_iterator(
                          __rt->__right_ != nullptr ?
                              static_cast<__iter_pointer>(std::__1::__tree_min(__rt->__right_))
                            : __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::iterator,
     typename __tree<_Tp, _Compare, _Allocator>::iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k)
{
    typedef pair<iterator, iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(iterator(__result), iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
template <class _Key>
pair<typename __tree<_Tp, _Compare, _Allocator>::const_iterator,
     typename __tree<_Tp, _Compare, _Allocator>::const_iterator>
__tree<_Tp, _Compare, _Allocator>::__equal_range_multi(const _Key& __k) const
{
    typedef pair<const_iterator, const_iterator> _Pp;
    __iter_pointer __result = __end_node();
    __node_pointer __rt = __root();
    while (__rt != nullptr)
    {
        if (value_comp()(__k, __rt->__value_))
        {
            __result = static_cast<__iter_pointer>(__rt);
            __rt = static_cast<__node_pointer>(__rt->__left_);
        }
        else if (value_comp()(__rt->__value_, __k))
            __rt = static_cast<__node_pointer>(__rt->__right_);
        else
            return _Pp(__lower_bound(__k, static_cast<__node_pointer>(__rt->__left_), static_cast<__iter_pointer>(__rt)),
                      __upper_bound(__k, static_cast<__node_pointer>(__rt->__right_), __result));
    }
    return _Pp(const_iterator(__result), const_iterator(__result));
}

template <class _Tp, class _Compare, class _Allocator>
typename __tree<_Tp, _Compare, _Allocator>::__node_holder
__tree<_Tp, _Compare, _Allocator>::remove(const_iterator __p) noexcept
{
    __node_pointer __np = __p.__get_np();
    if (__begin_node() == __p.__ptr_)
    {
        if (__np->__right_ != nullptr)
            __begin_node() = static_cast<__iter_pointer>(__np->__right_);
        else
            __begin_node() = static_cast<__iter_pointer>(__np->__parent_);
    }
    --size();
    std::__1::__tree_remove(__end_node()->__left_,
                         static_cast<__node_base_pointer>(__np));
    return __node_holder(__np, _Dp(__node_alloc(), true));
}

template <class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__tree<_Tp, _Compare, _Allocator>& __x,
     __tree<_Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

} }
# 497 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3





# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 503 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 504 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 2 3
# 509 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3


namespace std { inline namespace __1 {

template <class _Key, class _CP, class _Compare,
          bool = is_empty<_Compare>::value && !__libcpp_is_final<_Compare>::value>
class __map_value_compare
    : private _Compare
{
public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : _Compare() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : _Compare(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Compare& key_comp() const noexcept {return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
      using std::__1::swap;
      swap(static_cast<_Compare&>(*this), static_cast<_Compare&>(__y));
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return static_cast<const _Compare&>(*this) (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return static_cast<const _Compare&>(*this) (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare>
class __map_value_compare<_Key, _CP, _Compare, false>
{
    _Compare comp;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare()
        noexcept(is_nothrow_default_constructible<_Compare>::value)
        : comp() {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_value_compare(_Compare c)
        noexcept(is_nothrow_copy_constructible<_Compare>::value)
        : comp(c) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const _Compare& key_comp() const noexcept {return comp;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.__get_value().first, __y.__get_value().first);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.__get_value().first, __y);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.__get_value().first);}
    void swap(__map_value_compare&__y)
        noexcept(__is_nothrow_swappable<_Compare>::value)
    {
        using std::__1::swap;
        swap(comp, __y.comp);
    }


    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () ( const _K2& __x, const _CP& __y ) const
        {return comp (__x, __y.__get_value().first);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value, bool>::type
    operator () (const _CP& __x, const _K2& __y) const
        {return comp (__x.__get_value().first, __y);}

};

template <class _Key, class _CP, class _Compare, bool __b>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(__map_value_compare<_Key, _CP, _Compare, __b>& __x,
     __map_value_compare<_Key, _CP, _Compare, __b>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator allocator_type;
    typedef allocator_traits<allocator_type> __alloc_traits;

public:
    typedef typename __alloc_traits::pointer pointer;

private:
    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __map_node_destructor(allocator_type& __na) noexcept
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x) noexcept
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator()(pointer __p) noexcept
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, std::__1::addressof(__p->__value_.__get_value().first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class _Key, class _Tp, class _Compare, class _Allocator>
    class map;
template <class _Key, class _Tp, class _Compare, class _Allocator>
    class multimap;
template <class _TreeIterator> class __map_const_iterator;



template <class _Key, class _Tp>
struct __attribute__((__standalone_debug__)) __value_type
{
    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef pair<key_type&, mapped_type&> __nc_ref_pair_type;
    typedef pair<key_type&&, mapped_type&&> __nc_rref_pair_type;

private:
    value_type __cc;

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_type& __get_value()
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const value_type& __get_value() const
    {

        return *std::__1::launder(std::__1::addressof(__cc));



    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_ref_pair_type __ref()
    {
        value_type& __v = __get_value();
        return __nc_ref_pair_type(const_cast<key_type&>(__v.first), __v.second);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __nc_rref_pair_type __move()
    {
        value_type& __v = __get_value();
        return __nc_rref_pair_type(
            std::__1::move(const_cast<key_type&>(__v.first)),
            std::__1::move(__v.second));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(const __value_type& __v)
    {
        __ref() = __v.__get_value();
        return *this;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(__value_type&& __v)
    {
        __ref() = __v.__move();
        return *this;
    }

    template <class _ValueTp,
              class = typename enable_if<
                    __is_same_uncvref<_ValueTp, value_type>::value
                 >::type
             >
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __value_type& operator=(_ValueTp&& __v)
    {
        __ref() = std::__1::forward<_ValueTp>(__v);
        return *this;
    }

private:
    __value_type() = delete;
    ~__value_type() = delete;
    __value_type(const __value_type& __v) = delete;
    __value_type(__value_type&& __v) = delete;
};
# 783 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Tp>
struct __extract_key_value_types;

template <class _Key, class _Tp>
struct __extract_key_value_types<__value_type<_Key, _Tp> >
{
  typedef _Key const __key_type;
  typedef _Tp __mapped_type;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef value_type& reference;
    typedef typename _NodeTypes::__map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator(_TreeIterator __i) noexcept : __i_(__i) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class> friend class __attribute__ ((__type_visibility__("default"))) __map_const_iterator;
};

template <class _TreeIterator>
class __attribute__ ((__type_visibility__("default"))) __map_const_iterator
{
    typedef typename _TreeIterator::_NodeTypes _NodeTypes;
    typedef typename _TreeIterator::__pointer_traits __pointer_traits;

    _TreeIterator __i_;

public:
    typedef bidirectional_iterator_tag iterator_category;
    typedef typename _NodeTypes::__map_value_type value_type;
    typedef typename _TreeIterator::difference_type difference_type;
    typedef const value_type& reference;
    typedef typename _NodeTypes::__const_map_value_type_pointer pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator(_TreeIterator __i) noexcept : __i_(__i) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator(__map_iterator<
        typename _TreeIterator::__non_const_iterator> __i) noexcept
        : __i_(__i.__i_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __i_->__get_value();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__get_value());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator& operator++() {++__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator& operator--() {--__i_; return *this;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class, class, class, class> friend class __attribute__ ((__type_visibility__("default"))) multimap;
    template <class, class, class> friend class __attribute__ ((__type_visibility__("default"))) __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) map
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef __identity_t<_Compare> key_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

#pragma GCC diagnostic push
# 931 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 931 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    class __attribute__ ((__type_visibility__("default"))) value_compare



    {
#pragma GCC diagnostic pop
        friend class map;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) value_compare(key_compare c) : comp(c) {}
    public:

        __attribute__ ((deprecated)) typedef bool result_type;
        __attribute__ ((deprecated)) typedef value_type first_argument_type;
        __attribute__ ((deprecated)) typedef value_type second_argument_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : map(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(const map& __m)
        {

            __tree_ = __m.__tree_;
# 1050 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(map&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(map&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(initializer_list<value_type> __il, const allocator_type& __a)
        : map(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit map(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~map() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);

    mapped_type& operator[](key_type&& __k);


          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return value_compare(__tree_.value_comp().key_comp());}


    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool> emplace(_Args&& ...__args) {
        return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_unique(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert(_Pp&& __p)
            {return __tree_.__insert_unique(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_unique(__pos.__i_, std::__1::forward<_Pp>(__p));}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator, bool>
    insert(value_type&& __v) {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
    {return __tree_.__insert_unique(__p.__i_, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> try_emplace(key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_unique_key_args(__k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...));
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, const key_type& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(__k),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator try_emplace(const_iterator __h, key_type&& __k, _Args&&... __args)
    {
        return __tree_.__emplace_hint_unique_key_args(__h.__i_, __k,
            std::__1::piecewise_construct,
            std::__1::forward_as_tuple(std::__1::move(__k)),
            std::__1::forward_as_tuple(std::__1::forward<_Args>(__args)...)).first;
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(const key_type& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, __k, std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> insert_or_assign(key_type&& __k, _Vp&& __v)
    {
        iterator __p = lower_bound(__k);
        if ( __p != end() && !key_comp()(__k, __p->first))
        {
            __p->second = std::__1::forward<_Vp>(__v);
            return std::__1::make_pair(__p, false);
        }
        return std::__1::make_pair(emplace_hint(__p, std::__1::move(__k), std::__1::forward<_Vp>(__v)), true);
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator insert_or_assign(const_iterator __h,
                                                        const key_type& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, __k, std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }

    template <class _Vp>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator insert_or_assign(const_iterator __h,
                                                        key_type&& __k,
                                                        _Vp&& __v) {
      auto [__r, __inserted] = __tree_.__emplace_hint_unique_key_args(
          __h.__i_, __k, std::__1::move(__k), std::__1::forward<_Vp>(__v));

      if (!__inserted)
        __r->__get_value().second = std::__1::forward<_Vp>(__v);

      return __r;
    }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(map& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 1438 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;
    typedef typename __base::__node_base_pointer __node_base_pointer;
    typedef typename __base::__parent_pointer __parent_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;




};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> map<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(_InputIterator, _InputIterator, _Allocator)
  -> map<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
map(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> map<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    __m.__tree_.remove(__m.begin().__i_)->__value_.__move());
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(__k),
        std::__1::forward_as_tuple()).first->__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    return __tree_.__emplace_unique_key_args(__k,
        std::__1::piecewise_construct,
        std::__1::forward_as_tuple(std::__1::move(__k)),
        std::__1::forward_as_tuple()).first->__get_value().second;
}
# 1599 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __parent_pointer __parent;
    __node_base_pointer& __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __parent_pointer __parent;
    __node_base_pointer __child = __tree_.__find_equal(__parent, __k);
    if (__child == nullptr)
        __throw_out_of_range("map::at:  key not found");
    return static_cast<__node_pointer>(__child)->__value_.__get_value().second;
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1697 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class __attribute__ ((__type_visibility__("default"))) multimap
{
public:

    typedef _Key key_type;
    typedef _Tp mapped_type;
    typedef pair<const key_type, mapped_type> value_type;
    typedef __identity_t<_Compare> key_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

#pragma GCC diagnostic push
# 1714 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated"
# 1714 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
    class __attribute__ ((__type_visibility__("default"))) value_compare



    {
#pragma GCC diagnostic pop
        friend class multimap;
    protected:
        key_compare comp;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        value_compare(key_compare c) : comp(c) {}
    public:

        __attribute__ ((deprecated)) typedef bool result_type;
        __attribute__ ((deprecated)) typedef value_type first_argument_type;
        __attribute__ ((deprecated)) typedef value_type second_argument_type;

        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:

    typedef std::__1::__value_type<key_type, mapped_type> __value_type;
    typedef __map_value_compare<key_type, __value_type, key_compare> __vc;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>,
                                                 __value_type>::type __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type> __base;
    typedef typename __base::__node_traits __node_traits;
    typedef allocator_traits<allocator_type> __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer pointer;
    typedef typename __alloc_traits::const_pointer const_pointer;
    typedef typename __alloc_traits::size_type size_type;
    typedef typename __alloc_traits::difference_type difference_type;
    typedef __map_iterator<typename __base::iterator> iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __map_node_handle<typename __base::__node, allocator_type> node_type;


    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) map;
    template <class _Key2, class _Value2, class _Comp2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multimap;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(__vc(key_compare())) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const key_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__vc(__comp)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a)) {}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__f, __l);
        }


    template <class _InputIterator>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
        : multimap(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(const multimap& __m)
        {

            __tree_ = __m.__tree_;
# 1834 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(multimap&& __m)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(multimap&& __m)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__m.__tree_);
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), typename __base::allocator_type(__a))
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(initializer_list<value_type> __il, const allocator_type& __a)
        : multimap(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multimap(const allocator_type& __a)
        : __tree_(typename __base::allocator_type(__a))
        {
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), typename __base::allocator_type(__a))
        {
            insert(__m.begin(), __m.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~multimap() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return allocator_type(__tree_.__alloc());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp().key_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const
        {return value_compare(__tree_.value_comp().key_comp());}



    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace(_Args&& ...__args) {
        return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);
    }

    template <class ..._Args>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator emplace_hint(const_iterator __p, _Args&& ...__args) {
        return __tree_.__emplace_hint_multi(__p.__i_, std::__1::forward<_Args>(__args)...);
    }

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(_Pp&& __p)
            {return __tree_.__insert_multi(std::__1::forward<_Pp>(__p));}

    template <class _Pp,
              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator insert(const_iterator __pos, _Pp&& __p)
            {return __tree_.__insert_multi(__pos.__i_, std::__1::forward<_Pp>(__p));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p.__i_, std::__1::move(__v));}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(iterator __p) {return __tree_.erase(__p.__i_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            __hint.__i_, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(
            __it.__i_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multimap<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(map<key_type, mapped_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        return __tree_.__node_handle_merge_multi(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(multimap& __m)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__m.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 2117 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}


private:
    typedef typename __base::__node __node;
    typedef typename __base::__node_allocator __node_allocator;
    typedef typename __base::__node_pointer __node_pointer;

    typedef __map_node_destructor<__node_allocator> _Dp;
    typedef unique_ptr<__node, _Dp> __node_holder;
};


template<class _InputIterator, class _Compare = less<__iter_key_type<_InputIterator>>,
         class _Allocator = allocator<__iter_to_alloc_type<_InputIterator>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Tp, class _Compare = less<remove_const_t<_Key>>,
         class _Allocator = allocator<pair<const _Key, _Tp>>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Compare = _Compare(), _Allocator = _Allocator())
  -> multimap<remove_const_t<_Key>, _Tp, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(_InputIterator, _InputIterator, _Allocator)
  -> multimap<__iter_key_type<_InputIterator>, __iter_mapped_type<_InputIterator>,
         less<__iter_key_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Tp, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multimap(initializer_list<pair<_Key, _Tp>>, _Allocator)
  -> multimap<remove_const_t<_Key>, _Tp, less<remove_const_t<_Key>>, _Allocator>;



template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(std::__1::move(__m.__tree_), typename __base::allocator_type(__a))
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    std::__1::move(__m.__tree_.remove(__m.begin().__i_)->__value_.__move()));
    }
}


template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 2295 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/map" 3
} }
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 1 3
# 450 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3


namespace std { inline namespace __1 {

template <class _Key, class _Compare, class _Allocator>
class multiset;

template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) set
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;
    typedef __insert_return_type<iterator, node_type> insert_return_type;


    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l,
            const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l, const value_compare& __comp,
            const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        set(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : set(__f, __l, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(const set& __s)
        : __tree_(__s.__tree_)
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(const set& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(set&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit set(const allocator_type& __a)
        : __tree_(__a) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(const set& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    set(set&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set(initializer_list<value_type> __il, const allocator_type& __a)
        : set(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    set& operator=(set&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~set() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        pair<iterator, bool> emplace(_Args&&... __args)
            {return __tree_.__emplace_unique(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_unique(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,bool> insert(const value_type& __v)
        {return __tree_.__insert_unique(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_unique(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_unique(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,bool> insert(value_type&& __v)
        {return __tree_.__insert_unique(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_unique(__p, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    insert_return_type insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<
            node_type, insert_return_type>(std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_unique<node_type>(
            __hint, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_unique(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(set& __s) noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 818 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}

};


template<class _InputIterator,
         class _Compare = less<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
set(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> set<__iter_value_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Compare = less<_Key>,
         class _Allocator = allocator<_Key>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
set(initializer_list<_Key>, _Compare = _Compare(), _Allocator = _Allocator())
  -> set<_Key, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
set(_InputIterator, _InputIterator, _Allocator)
  -> set<__iter_value_type<_InputIterator>,
         less<__iter_value_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
set(initializer_list<_Key>, _Allocator)
  -> set<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
set<_Key, _Compare, _Allocator>::set(set&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const set<_Key, _Compare, _Allocator>& __x,
           const set<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}


template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(set<_Key, _Compare, _Allocator>& __x,
     set<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 989 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
template <class _Key, class _Compare = less<_Key>,
          class _Allocator = allocator<_Key> >
class __attribute__ ((__type_visibility__("default"))) multiset
{
public:

    typedef _Key key_type;
    typedef key_type value_type;
    typedef _Compare key_compare;
    typedef key_compare value_compare;
    typedef __identity_t<_Allocator> allocator_type;
    typedef value_type& reference;
    typedef const value_type& const_reference;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

private:
    typedef __tree<value_type, value_compare, allocator_type> __base;
    typedef allocator_traits<allocator_type> __alloc_traits;
    typedef typename __base::__node_holder __node_holder;

    __base __tree_;

public:
    typedef typename __base::pointer pointer;
    typedef typename __base::const_pointer const_pointer;
    typedef typename __base::size_type size_type;
    typedef typename __base::difference_type difference_type;
    typedef typename __base::const_iterator iterator;
    typedef typename __base::const_iterator const_iterator;
    typedef std::__1::reverse_iterator<iterator> reverse_iterator;
    typedef std::__1::reverse_iterator<const_iterator> const_reverse_iterator;


    typedef __set_node_handle<typename __base::__node, allocator_type> node_type;


    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) set;
    template <class _Key2, class _Compare2, class _Alloc2>
        friend class __attribute__ ((__type_visibility__("default"))) multiset;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset()
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_default_constructible<key_compare>::value && is_nothrow_copy_constructible<key_compare>::value)



        : __tree_(value_compare()) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const value_compare& __comp)
        noexcept(is_nothrow_default_constructible<allocator_type>::value && is_nothrow_copy_constructible<key_compare>::value)


        : __tree_(__comp) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a) {}
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__f, __l);
        }


        template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l, const allocator_type& __a)
            : multiset(__f, __l, key_compare(), __a) {}


    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        multiset(_InputIterator __f, _InputIterator __l,
                 const value_compare& __comp, const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__f, __l);
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(const multiset& __s)
        : __tree_(__s.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__s.__tree_.__alloc()))
        {
            insert(__s.begin(), __s.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(const multiset& __s)
        {
            __tree_ = __s.__tree_;
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(multiset&& __s)
        noexcept(is_nothrow_move_constructible<__base>::value)
        : __tree_(std::__1::move(__s.__tree_)) {}

    multiset(multiset&& __s, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit multiset(const allocator_type& __a)
        : __tree_(__a) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(const multiset& __s, const allocator_type& __a)
        : __tree_(__s.__tree_.value_comp(), __a)
        {
            insert(__s.begin(), __s.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const value_compare& __comp = value_compare())
        : __tree_(__comp)
        {
            insert(__il.begin(), __il.end());
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const value_compare& __comp,
        const allocator_type& __a)
        : __tree_(__comp, __a)
        {
            insert(__il.begin(), __il.end());
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset(initializer_list<value_type> __il, const allocator_type& __a)
        : multiset(__il, key_compare(), __a) {}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    multiset& operator=(multiset&& __s)
        noexcept(is_nothrow_move_assignable<__base>::value)
        {
            __tree_ = std::__1::move(__s.__tree_);
            return *this;
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    ~multiset() {
        static_assert(sizeof(__diagnose_non_const_comparator<_Key, _Compare>()), "");
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator begin() noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept {return __tree_.begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          iterator end() noexcept {return __tree_.end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept {return __tree_.end();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rbegin() noexcept
            {return reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rbegin() const noexcept
        {return const_reverse_iterator(end());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          reverse_iterator rend() noexcept
            {return reverse_iterator(begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator rend() const noexcept
        {return const_reverse_iterator(begin());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept {return begin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept {return end();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crbegin() const noexcept {return rbegin();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reverse_iterator crend() const noexcept {return rend();}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept {return __tree_.size() == 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type size() const noexcept {return __tree_.size();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {return __tree_.max_size();}



    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace(_Args&&... __args)
            {return __tree_.__emplace_multi(std::__1::forward<_Args>(__args)...);}
    template <class... _Args>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        iterator emplace_hint(const_iterator __p, _Args&&... __args)
            {return __tree_.__emplace_hint_multi(__p, std::__1::forward<_Args>(__args)...);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const value_type& __v)
        {return __tree_.__insert_multi(__v);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, const value_type& __v)
        {return __tree_.__insert_multi(__p, __v);}

    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e, *__f);
        }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(value_type&& __v)
        {return __tree_.__insert_multi(std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __p, value_type&& __v)
        {return __tree_.__insert_multi(__p, std::__1::move(__v));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __p) {return __tree_.erase(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f, __l);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {__tree_.clear();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator insert(const_iterator __hint, node_type&& __nh)
    {
        ((void)0);

        return __tree_.template __node_handle_insert_multi<node_type>(
            __hint, std::__1::move(__nh));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(key_type const& __key)
    {
        return __tree_.template __node_handle_extract<node_type>(__key);
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    node_type extract(const_iterator __it)
    {
        return __tree_.template __node_handle_extract<node_type>(__it);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(multiset<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }
    template <class _Compare2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(set<key_type, _Compare2, allocator_type>&& __source)
    {
        ((void)0);

        __tree_.__node_handle_merge_multi(__source.__tree_);
    }


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(multiset& __s)
        noexcept(__is_nothrow_swappable<__base>::value)
        {__tree_.swap(__s.__tree_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept {return __tree_.__alloc();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    key_compare key_comp() const {return __tree_.value_comp();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    value_compare value_comp() const {return __tree_.value_comp();}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator find(const key_type& __k) {return __tree_.find(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    find(const _K2& __k) {return __tree_.find(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    find(const _K2& __k) const {return __tree_.find(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,size_type>::type
    count(const _K2& __k) const {return __tree_.__count_multi(__k);}
# 1349 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    lower_bound(const _K2& __k) {return __tree_.lower_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    lower_bound(const _K2& __k) const {return __tree_.lower_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,iterator>::type
    upper_bound(const _K2& __k) {return __tree_.upper_bound(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,const_iterator>::type
    upper_bound(const _K2& __k) const {return __tree_.upper_bound(__k);}


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<iterator,iterator> equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<iterator,iterator>>::type
    equal_range(const _K2& __k) {return __tree_.__equal_range_multi(__k);}
    template <typename _K2>
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    typename enable_if<__is_transparent<_Compare, _K2>::value,pair<const_iterator,const_iterator>>::type
    equal_range(const _K2& __k) const {return __tree_.__equal_range_multi(__k);}

};


template<class _InputIterator,
         class _Compare = less<__iter_value_type<_InputIterator>>,
         class _Allocator = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
multiset(_InputIterator, _InputIterator, _Compare = _Compare(), _Allocator = _Allocator())
  -> multiset<__iter_value_type<_InputIterator>, _Compare, _Allocator>;

template<class _Key, class _Compare = less<_Key>,
         class _Allocator = allocator<_Key>,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>,
         class = _EnableIf<!__is_allocator<_Compare>::value, void>>
multiset(initializer_list<_Key>, _Compare = _Compare(), _Allocator = _Allocator())
  -> multiset<_Key, _Compare, _Allocator>;

template<class _InputIterator, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multiset(_InputIterator, _InputIterator, _Allocator)
  -> multiset<__iter_value_type<_InputIterator>,
         less<__iter_value_type<_InputIterator>>, _Allocator>;

template<class _Key, class _Allocator,
         class = _EnableIf<__is_allocator<_Allocator>::value, void>>
multiset(initializer_list<_Key>, _Allocator)
  -> multiset<_Key, less<_Key>, _Allocator>;




template <class _Key, class _Compare, class _Allocator>
multiset<_Key, _Compare, _Allocator>::multiset(multiset&& __s, const allocator_type& __a)
    : __tree_(std::__1::move(__s.__tree_), __a)
{
    if (__a != __s.get_allocator())
    {
        const_iterator __e = cend();
        while (!__s.empty())
            insert(__e, std::__1::move(__s.__tree_.remove(__s.begin())->__value_));
    }
}



template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator==(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && std::__1::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator< (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator!=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator> (const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator>=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool
operator<=(const multiset<_Key, _Compare, _Allocator>& __x,
           const multiset<_Key, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Compare, class _Allocator>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(multiset<_Key, _Compare, _Allocator>& __x,
     multiset<_Key, _Compare, _Allocator>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1519 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/set" 3
} }
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/source.h" 2




namespace llvm {
class raw_ostream;
}

namespace Fortran::parser {

std::string DirectoryName(std::string path);
std::optional<std::string> LocateSourceFile(
    std::string name, const std::list<std::string> &searchPath);

class SourceFile;

struct SourcePosition {
  common::Reference<const SourceFile> sourceFile;
  common::Reference<const std::string>
      path;
  int line, column;
  int trueLineNumber;
};

class SourceFile {
public:
  explicit SourceFile(Encoding e) : encoding_{e} {}
  ~SourceFile();
  const std::string &path() const { return path_; }
  llvm::ArrayRef<char> content() const {
    return buf_->getBuffer().slice(bom_end_, buf_end_ - bom_end_);
  }
  std::size_t bytes() const { return content().size(); }
  std::size_t lines() const { return lineStart_.size(); }
  Encoding encoding() const { return encoding_; }

  bool Open(std::string path, llvm::raw_ostream &error);
  bool ReadStandardInput(llvm::raw_ostream &error);
  void Close();
  SourcePosition GetSourcePosition(std::size_t) const;
  std::size_t GetLineStartOffset(int lineNumber) const {
    return lineStart_.at(lineNumber - 1);
  }
  const std::string &SavePath(std::string &&);
  void LineDirective(int trueLineNumber, const std::string &, int);
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct SourcePositionOrigin {
    const std::string &path;
    int line;
  };

  void ReadFile();
  void IdentifyPayload();
  void RecordLineStarts();

  std::string path_;
  std::unique_ptr<llvm::WritableMemoryBuffer> buf_;
  std::vector<std::size_t> lineStart_;
  std::size_t bom_end_{0};
  std::size_t buf_end_;
  Encoding encoding_;
  std::set<std::string> distinctPaths_;
  std::map<std::size_t, SourcePositionOrigin> origins_;
};
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 2






# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" 2






namespace Fortran::parser {
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h"
class AllSources;
class AllCookedSources;

class Provenance {
public:
  Provenance() {}
  Provenance(std::size_t offset) : offset_{offset} { ((offset > 0) || (Fortran::common::die("CHECK(" "offset > 0" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 55), false)); }
  Provenance(const Provenance &that) = default;
  Provenance(Provenance &&that) = default;
  Provenance &operator=(const Provenance &that) = default;
  Provenance &operator=(Provenance &&that) = default;

  std::size_t offset() const { return offset_; }

  Provenance operator+(ptrdiff_t n) const {
    ((n > -static_cast<ptrdiff_t>(offset_)) || (Fortran::common::die("CHECK(" "n > -static_cast<ptrdiff_t>(offset_)" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 64), false));
    return {offset_ + static_cast<std::size_t>(n)};
  }
  Provenance operator+(std::size_t n) const { return {offset_ + n}; }
  std::size_t operator-(Provenance that) const {
    ((that <= *this) || (Fortran::common::die("CHECK(" "that <= *this" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/provenance.h" "(%d)", 69), false));
    return offset_ - that.offset_;
  }
  bool operator<(Provenance that) const { return offset_ < that.offset_; }
  bool operator<=(Provenance that) const { return !(that < *this); }
  bool operator==(Provenance that) const { return offset_ == that.offset_; }
  bool operator!=(Provenance that) const { return !(*this == that); }

private:
  std::size_t offset_{0};
};

using ProvenanceRange = common::Interval<Provenance>;






class ProvenanceRangeToOffsetMappings {
public:
  ProvenanceRangeToOffsetMappings();
  ~ProvenanceRangeToOffsetMappings();
  bool empty() const { return map_.empty(); }
  void Put(ProvenanceRange, std::size_t offset);
  std::optional<std::size_t> Map(ProvenanceRange) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:



  struct WhollyPrecedes {
    bool operator()(ProvenanceRange, ProvenanceRange) const;
  };

  std::multimap<ProvenanceRange, std::size_t, WhollyPrecedes> map_;
};





class OffsetToProvenanceMappings {
public:
  OffsetToProvenanceMappings() {}
  void clear();
  void swap(OffsetToProvenanceMappings &);
  void shrink_to_fit();
  std::size_t SizeInBytes() const;
  void Put(ProvenanceRange);
  void Put(const OffsetToProvenanceMappings &);
  ProvenanceRange Map(std::size_t at) const;
  void RemoveLastBytes(std::size_t);
  ProvenanceRangeToOffsetMappings Invert(const AllSources &) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct ContiguousProvenanceMapping {
    std::size_t start;
    ProvenanceRange range;
  };



  std::vector<ContiguousProvenanceMapping> provenanceMap_;
};



class AllSources {
public:
  AllSources();
  ~AllSources();

  std::size_t size() const { return range_.size(); }
  const char &operator[](Provenance) const;
  Encoding encoding() const { return encoding_; }
  AllSources &set_encoding(Encoding e) {
    encoding_ = e;
    return *this;
  }

  void ClearSearchPath();
  void AppendSearchPathDirectory(std::string);
  const SourceFile *Open(std::string path, llvm::raw_ostream &error,
      std::optional<std::string> &&prependPath = std::nullopt);
  const SourceFile *ReadStandardInput(llvm::raw_ostream &error);

  ProvenanceRange AddIncludedFile(
      const SourceFile &, ProvenanceRange, bool isModule = false);
  ProvenanceRange AddMacroCall(
      ProvenanceRange def, ProvenanceRange use, const std::string &expansion);
  ProvenanceRange AddCompilerInsertion(std::string);

  bool IsValid(Provenance at) const { return range_.Contains(at); }
  bool IsValid(ProvenanceRange range) const {
    return range.size() > 0 && range_.Contains(range);
  }
  void setShowColors(bool showColors) { showColors_ = showColors; }
  bool getShowColors() const { return showColors_; }
  void EmitMessage(llvm::raw_ostream &, const std::optional<ProvenanceRange> &,
      const std::string &message, const std::string &prefix,
      llvm::raw_ostream::Colors color, bool echoSourceLine = false) const;
  const SourceFile *GetSourceFile(
      Provenance, std::size_t *offset = nullptr) const;
  const char *GetSource(ProvenanceRange) const;
  std::optional<SourcePosition> GetSourcePosition(Provenance) const;
  std::optional<ProvenanceRange> GetFirstFileProvenance() const;
  std::string GetPath(Provenance) const;
  int GetLineNumber(Provenance) const;
  Provenance CompilerInsertionProvenance(char ch);
  ProvenanceRange IntersectionWithSourceFiles(ProvenanceRange) const;
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  struct Inclusion {
    const SourceFile &source;
    bool isModule{false};
  };
  struct Macro {
    ProvenanceRange definition;
    std::string expansion;
  };
  struct CompilerInsertion {
    std::string text;
  };

  struct Origin {
    Origin(ProvenanceRange, const SourceFile &);
    Origin(ProvenanceRange, const SourceFile &, ProvenanceRange,
        bool isModule = false);
    Origin(ProvenanceRange, ProvenanceRange def, ProvenanceRange use,
        const std::string &expansion);
    Origin(ProvenanceRange, const std::string &);

    const char &operator[](std::size_t) const;

    std::variant<Inclusion, Macro, CompilerInsertion> u;
    ProvenanceRange covers, replaces;
  };

  const Origin &MapToOrigin(Provenance) const;


  std::vector<Origin> origin_;
  ProvenanceRange range_;
  std::map<char, Provenance> compilerInsertionProvenance_;
  std::vector<std::unique_ptr<SourceFile>> ownedSourceFiles_;
  std::list<std::string> searchPath_;
  Encoding encoding_{Encoding::UTF_8};
  bool showColors_{false};
};




class CookedSource {
public:
  int number() const { return number_; }
  void set_number(int n) { number_ = n; }

  CharBlock AsCharBlock() const { return CharBlock{data_}; }
  std::optional<ProvenanceRange> GetProvenanceRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlock(ProvenanceRange) const;



  std::size_t Put(const char *data, std::size_t bytes) {
    return buffer_.Put(data, bytes);
  }
  std::size_t Put(const std::string &s) { return buffer_.Put(s); }
  std::size_t Put(char ch) { return buffer_.Put(&ch, 1); }
  std::size_t Put(char ch, Provenance p) {
    provenanceMap_.Put(ProvenanceRange{p, 1});
    return buffer_.Put(&ch, 1);
  }

  void PutProvenance(Provenance p) { provenanceMap_.Put(ProvenanceRange{p}); }
  void PutProvenance(ProvenanceRange pr) { provenanceMap_.Put(pr); }
  void PutProvenanceMappings(const OffsetToProvenanceMappings &pm) {
    provenanceMap_.Put(pm);
  }

  std::size_t BufferedBytes() const;
  void Marshal(AllCookedSources &);
  void CompileProvenanceRangeToOffsetMappings(AllSources &);
  llvm::raw_ostream &Dump(llvm::raw_ostream &) const;

private:
  int number_{0};
  CharBuffer buffer_;
  std::string data_;
  OffsetToProvenanceMappings provenanceMap_;
  ProvenanceRangeToOffsetMappings invertedMap_;
};

class AllCookedSources {
public:
  explicit AllCookedSources(AllSources &);
  ~AllCookedSources();

  AllSources &allSources() { return allSources_; }
  const AllSources &allSources() const { return allSources_; }

  CookedSource &NewCookedSource();

  const CookedSource *Find(CharBlock) const;
  const CookedSource *Find(const char *p) const { return Find(CharBlock{p}); }

  bool IsValid(ProvenanceRange r) const { return allSources_.IsValid(r); }

  std::optional<ProvenanceRange> GetProvenanceRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlockFromLineAndColumns(
      int line, int startColumn, int endColumn) const;
  std::optional<std::pair<SourcePosition, SourcePosition>>
      GetSourcePositionRange(CharBlock) const;
  std::optional<CharBlock> GetCharBlock(ProvenanceRange) const;
  void Dump(llvm::raw_ostream &) const;


  bool Precedes(CharBlock, CharBlock) const;


  void Register(CookedSource &);

private:
  AllSources &allSources_;
  std::list<CookedSource> cooked_;
  std::map<CharBlock, const CookedSource &, CharBlockPointerComparator> index_;
};

}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference-counted.h" 1
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/reference-counted.h"
namespace Fortran::common {


template <typename A> class ReferenceCounted {
public:
  ReferenceCounted() {}
  int references() const { return references_; }
  void TakeReference() { ++references_; }
  void DropReference() {
    if (--references_ == 0) {
      delete static_cast<A *>(this);
    }
  }

private:
  int references_{0};
};


template <typename A> class CountedReference {
public:
  using type = A;
  CountedReference() {}
  CountedReference(type *m) : p_{m} { Take(); }
  CountedReference(const CountedReference &c) : p_{c.p_} { Take(); }
  CountedReference(CountedReference &&c) : p_{c.p_} { c.p_ = nullptr; }
  CountedReference &operator=(const CountedReference &c) {
    c.Take();
    Drop();
    p_ = c.p_;
    return *this;
  }
  CountedReference &operator=(CountedReference &&c) {
    A *p{c.p_};
    c.p_ = nullptr;
    Drop();
    p_ = p;
    return *this;
  }
  ~CountedReference() { Drop(); }
  operator bool() const { return p_ != nullptr; }
  type *get() const { return p_; }
  type &operator*() const { return *p_; }
  type *operator->() const { return p_; }

private:
  void Take() const {
    if (p_) {
      p_->TakeReference();
    }
  }
  void Drop() {
    if (p_) {
      p_->DropReference();
      p_ = nullptr;
    }
  }

  type *p_{nullptr};
};
}
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/restorer.h" 1
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/restorer.h"
namespace Fortran::common {
template <typename A> class Restorer {
public:
  explicit Restorer(A &p, A original) : p_{p}, original_{std::move(original)} {}
  ~Restorer() { p_ = std::move(original_); }



  Restorer(const Restorer &) = delete;
  Restorer(Restorer &&that) = delete;
  const Restorer &operator=(const Restorer &) = delete;
  const Restorer &operator=(Restorer &&that) = delete;

private:
  A &p_;
  A original_;
};

template <typename A, typename B>
common::IfNoLvalue<Restorer<A>, B> ScopedSet(A &to, B &&from) {
  A original{std::move(to)};
  to = std::move(from);
  return Restorer<A>{to, std::move(original)};
}
template <typename A, typename B>
common::IfNoLvalue<Restorer<A>, B> ScopedSet(A &to, const B &from) {
  A original{std::move(to)};
  to = from;
  return Restorer<A>{to, std::move(original)};
}
}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 1 3
# 188 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 189 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 2 3
# 193 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 197 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 2 3


namespace std { inline namespace __1 {

template <class _Tp, class _VoidPtr> struct __forward_list_node;
template <class _NodePtr> struct __forward_begin_node;


template <class>
struct __forward_list_node_value_type;

template <class _Tp, class _VoidPtr>
struct __forward_list_node_value_type<__forward_list_node<_Tp, _VoidPtr> > {
  typedef _Tp type;
};

template <class _NodePtr>
struct __forward_node_traits {

  typedef typename remove_cv<
        typename pointer_traits<_NodePtr>::element_type>::type __node;
  typedef typename __forward_list_node_value_type<__node>::type __node_value_type;
  typedef _NodePtr __node_pointer;
  typedef __forward_begin_node<_NodePtr> __begin_node;
  typedef typename __rebind_pointer<_NodePtr, __begin_node>::type
                                                                __begin_node_pointer;
  typedef typename __rebind_pointer<_NodePtr, void>::type __void_pointer;




  typedef typename conditional<
          is_pointer<__void_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __iter_node_pointer;


  typedef typename conditional<
          is_same<__iter_node_pointer, __node_pointer>::value,
          __begin_node_pointer,
          __node_pointer
    >::type __non_iter_node_pointer;

  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __iter_node_pointer __as_iter_node(__iter_node_pointer __p) {
      return __p;
  }
  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
  static __iter_node_pointer __as_iter_node(__non_iter_node_pointer __p) {
      return static_cast<__iter_node_pointer>(static_cast<__void_pointer>(__p));
  }
};

template <class _NodePtr>
struct __forward_begin_node
{
    typedef _NodePtr pointer;
    typedef typename __rebind_pointer<_NodePtr, __forward_begin_node>::type __begin_node_pointer;

    pointer __next_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) __forward_begin_node() : __next_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __next_as_begin() const {
        return static_cast<__begin_node_pointer>(__next_);
    }
};

template <class _Tp, class _VoidPtr>
struct __attribute__ ((__visibility__("hidden"))) __begin_node_of
{
    typedef __forward_begin_node<
        typename __rebind_pointer<_VoidPtr, __forward_list_node<_Tp, _VoidPtr> >::type
    > type;
};

template <class _Tp, class _VoidPtr>
struct __attribute__((__standalone_debug__)) __forward_list_node
    : public __begin_node_of<_Tp, _VoidPtr>::type
{
    typedef _Tp value_type;

    value_type __value_;
};


template <class _Tp, class _Alloc = allocator<_Tp> > class __attribute__ ((__type_visibility__("default"))) forward_list;
template<class _NodeConstPtr> class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator;

template <class _NodePtr>
class __attribute__ ((__type_visibility__("default"))) __forward_list_iterator
{
    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(nullptr_t) noexcept : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    template<class, class> friend class __attribute__ ((__type_visibility__("default"))) forward_list;
    template<class> friend class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, value_type>::type pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator() noexcept : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {
        return pointer_traits<pointer>::pointer_to(__get_unsafe_node_pointer()->__value_);
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_iterator operator++(int)
    {
        __forward_list_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __forward_list_iterator& __x,
                    const __forward_list_iterator& __y)
        {return !(__x == __y);}
};

template <class _NodeConstPtr>
class __attribute__ ((__type_visibility__("default"))) __forward_list_const_iterator
{
    static_assert((!is_const<typename pointer_traits<_NodeConstPtr>::element_type>::value), "");
    typedef _NodeConstPtr _NodePtr;

    typedef __forward_node_traits<_NodePtr> __traits;
    typedef typename __traits::__node __node;
    typedef typename __traits::__node_pointer __node_pointer;
    typedef typename __traits::__begin_node_pointer __begin_node_pointer;
    typedef typename __traits::__iter_node_pointer __iter_node_pointer;
    typedef typename __traits::__void_pointer __void_pointer;

    __iter_node_pointer __ptr_;

    __begin_node_pointer __get_begin() const {
        return static_cast<__begin_node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }
    __node_pointer __get_unsafe_node_pointer() const {
        return static_cast<__node_pointer>(
                static_cast<__void_pointer>(__ptr_));
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(nullptr_t) noexcept
        : __ptr_(nullptr) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(__begin_node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_const_iterator(__node_pointer __p) noexcept
        : __ptr_(__traits::__as_iter_node(__p)) {}


    template<class, class> friend class forward_list;

public:
    typedef forward_iterator_tag iterator_category;
    typedef typename __traits::__node_value_type value_type;
    typedef const value_type& reference;
    typedef typename pointer_traits<__node_pointer>::difference_type
                                                              difference_type;
    typedef typename __rebind_pointer<__node_pointer, const value_type>::type
                                                              pointer;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator() noexcept : __ptr_(nullptr) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator(__forward_list_iterator<__node_pointer> __p) noexcept
        : __ptr_(__p.__ptr_) {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference operator*() const {return __get_unsafe_node_pointer()->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    pointer operator->() const {return pointer_traits<pointer>::pointer_to(
                __get_unsafe_node_pointer()->__value_);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator& operator++()
    {
        __ptr_ = __traits::__as_iter_node(__ptr_->__next_);
        return *this;
    }
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_const_iterator operator++(int)
    {
        __forward_list_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const __forward_list_const_iterator& __x,
                    const __forward_list_const_iterator& __y)
        {return __x.__ptr_ == __y.__ptr_;}
    friend __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const __forward_list_const_iterator& __x,
                           const __forward_list_const_iterator& __y)
        {return !(__x == __y);}
};

template <class _Tp, class _Alloc>
class __forward_list_base
{
protected:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    typedef typename allocator_traits<allocator_type>::void_pointer void_pointer;
    typedef __forward_list_node<value_type, void_pointer> __node;
    typedef typename __begin_node_of<value_type, void_pointer>::type __begin_node;
    typedef typename __rebind_alloc_helper<allocator_traits<allocator_type>, __node>::type __node_allocator;
    typedef allocator_traits<__node_allocator> __node_traits;
    typedef typename __node_traits::pointer __node_pointer;

    typedef typename __rebind_alloc_helper<
        allocator_traits<allocator_type>, __begin_node
    >::type __begin_node_allocator;
    typedef typename allocator_traits<__begin_node_allocator>::pointer
                                                      __begin_node_pointer;

    static_assert((!is_same<allocator_type, __node_allocator>::value),
                  "internal allocator type must differ from user-specified "
                  "type; otherwise overload resolution breaks");

    __compressed_pair<__begin_node, __node_allocator> __before_begin_;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __before_begin() noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(__before_begin_.first());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __begin_node_pointer __before_begin() const noexcept
        {return pointer_traits<__begin_node_pointer>::pointer_to(const_cast<__begin_node&>(__before_begin_.first()));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
          __node_allocator& __alloc() noexcept
            {return __before_begin_.second();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const __node_allocator& __alloc() const noexcept
        {return __before_begin_.second();}

    typedef __forward_list_iterator<__node_pointer> iterator;
    typedef __forward_list_const_iterator<__node_pointer> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        : __before_begin_(__begin_node(), __default_init_tag()) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_base(const allocator_type& __a)
        : __before_begin_(__begin_node(), __node_allocator(__a)) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit __forward_list_base(const __node_allocator& __a)
        : __before_begin_(__begin_node(), __a) {}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __forward_list_base(__forward_list_base&& __x, const allocator_type& __a);


private:
    __forward_list_base(const __forward_list_base&);
    __forward_list_base& operator=(const __forward_list_base&);

public:
    ~__forward_list_base();

protected:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base& __x)
        {__copy_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_copy_assignment::value>());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base& __x)
        noexcept(!__node_traits::propagate_on_container_move_assignment::value || is_nothrow_move_assignable<__node_allocator>::value)

        {__move_assign_alloc(__x, integral_constant<bool,
              __node_traits::propagate_on_container_move_assignment::value>());}

public:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(__forward_list_base& __x)

        noexcept;




protected:
    void clear() noexcept;

private:
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base&, false_type) {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __copy_assign_alloc(const __forward_list_base& __x, true_type)
    {
        if (__alloc() != __x.__alloc())
            clear();
        __alloc() = __x.__alloc();
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base&, false_type) noexcept
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void __move_assign_alloc(__forward_list_base& __x, true_type)
        noexcept(is_nothrow_move_assignable<__node_allocator>::value)
        {__alloc() = std::__1::move(__x.__alloc());}
};



template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x)
        noexcept(is_nothrow_move_constructible<__node_allocator>::value)
    : __before_begin_(std::__1::move(__x.__before_begin_))
{
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
inline
__forward_list_base<_Tp, _Alloc>::__forward_list_base(__forward_list_base&& __x,
                                                      const allocator_type& __a)
    : __before_begin_(__begin_node(), __node_allocator(__a))
{
    if (__alloc() == __x.__alloc())
    {
        __before_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}



template <class _Tp, class _Alloc>
__forward_list_base<_Tp, _Alloc>::~__forward_list_base()
{
    clear();
}

template <class _Tp, class _Alloc>
inline
void
__forward_list_base<_Tp, _Alloc>::swap(__forward_list_base& __x)

        noexcept




{
    std::__1::__swap_allocator(__alloc(), __x.__alloc(),
            integral_constant<bool, __node_traits::propagate_on_container_swap::value>());
    using std::__1::swap;
    swap(__before_begin()->__next_, __x.__before_begin()->__next_);
}

template <class _Tp, class _Alloc>
void
__forward_list_base<_Tp, _Alloc>::clear() noexcept
{
    __node_allocator& __a = __alloc();
    for (__node_pointer __p = __before_begin()->__next_; __p != nullptr;)
    {
        __node_pointer __next = __p->__next_;
        __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
        __node_traits::deallocate(__a, __p, 1);
        __p = __next;
    }
    __before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc >
class __attribute__ ((__type_visibility__("default"))) forward_list
    : private __forward_list_base<_Tp, _Alloc>
{
    typedef __forward_list_base<_Tp, _Alloc> base;
    typedef typename base::__node_allocator __node_allocator;
    typedef typename base::__node __node;
    typedef typename base::__node_traits __node_traits;
    typedef typename base::__node_pointer __node_pointer;
    typedef typename base::__begin_node_pointer __begin_node_pointer;

public:
    typedef _Tp value_type;
    typedef _Alloc allocator_type;

    static_assert((is_same<typename allocator_type::value_type, value_type>::value),
                  "Allocator::value_type must be same type as value_type");

    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef typename allocator_traits<allocator_type>::pointer pointer;
    typedef typename allocator_traits<allocator_type>::const_pointer const_pointer;
    typedef typename allocator_traits<allocator_type>::size_type size_type;
    typedef typename allocator_traits<allocator_type>::difference_type difference_type;

    typedef typename base::iterator iterator;
    typedef typename base::const_iterator const_iterator;



    typedef void __remove_return_type;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list()
        noexcept(is_nothrow_default_constructible<__node_allocator>::value)
        {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit forward_list(const allocator_type& __a);
    explicit forward_list(size_type __n);

    explicit forward_list(size_type __n, const allocator_type& __a);

    forward_list(size_type __n, const value_type& __v);
    forward_list(size_type __n, const value_type& __v, const allocator_type& __a);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     typename enable_if<
                       __is_cpp17_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    template <class _InputIterator>
        forward_list(_InputIterator __f, _InputIterator __l,
                     const allocator_type& __a,
                     typename enable_if<
                       __is_cpp17_input_iterator<_InputIterator>::value
                     >::type* = nullptr);
    forward_list(const forward_list& __x);
    forward_list(const forward_list& __x, const __identity_t<allocator_type>& __a);

    forward_list& operator=(const forward_list& __x);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list(forward_list&& __x)
        noexcept(is_nothrow_move_constructible<base>::value)
        : base(std::__1::move(__x)) {}
    forward_list(forward_list&& __x, const __identity_t<allocator_type>& __a);

    forward_list(initializer_list<value_type> __il);
    forward_list(initializer_list<value_type> __il, const allocator_type& __a);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list& operator=(forward_list&& __x)
        noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value);



    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    forward_list& operator=(initializer_list<value_type> __il);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void assign(initializer_list<value_type> __il);




    template <class _InputIterator>
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            void
        >::type
        assign(_InputIterator __f, _InputIterator __l);
    void assign(size_type __n, const value_type& __v);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    allocator_type get_allocator() const noexcept
        {return allocator_type(base::__alloc());}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator begin() noexcept
        {return iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator begin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator end() noexcept
        {return iterator(nullptr);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator end() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbegin() const noexcept
        {return const_iterator(base::__before_begin()->__next_);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cend() const noexcept
        {return const_iterator(nullptr);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    iterator before_begin() noexcept
        {return iterator(base::__before_begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator before_begin() const noexcept
        {return const_iterator(base::__before_begin());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_iterator cbefore_begin() const noexcept
        {return const_iterator(base::__before_begin());}

                                  __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool empty() const noexcept
        {return base::__before_begin()->__next_ == nullptr;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_type max_size() const noexcept {
        return std::__1::min<size_type>(
            __node_traits::max_size(base::__alloc()),
            numeric_limits<difference_type>::max());
    }

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    reference front() {return base::__before_begin()->__next_->__value_;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    const_reference front() const {return base::__before_begin()->__next_->__value_;}



    template <class... _Args> reference emplace_front(_Args&&... __args);



    void push_front(value_type&& __v);

    void push_front(const value_type& __v);

    void pop_front();


    template <class... _Args>
        iterator emplace_after(const_iterator __p, _Args&&... __args);

    iterator insert_after(const_iterator __p, value_type&& __v);
    iterator insert_after(const_iterator __p, initializer_list<value_type> __il)
        {return insert_after(__p, __il.begin(), __il.end());}

    iterator insert_after(const_iterator __p, const value_type& __v);
    iterator insert_after(const_iterator __p, size_type __n, const value_type& __v);
    template <class _InputIterator>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        typename enable_if
        <
            __is_cpp17_input_iterator<_InputIterator>::value,
            iterator
        >::type
        insert_after(const_iterator __p, _InputIterator __f, _InputIterator __l);

    iterator erase_after(const_iterator __p);
    iterator erase_after(const_iterator __f, const_iterator __l);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void swap(forward_list& __x)

        noexcept




        {base::swap(__x);}

    void resize(size_type __n);
    void resize(size_type __n, const value_type& __v);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void clear() noexcept {base::clear();}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x, const_iterator __i);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void splice_after(const_iterator __p, forward_list&& __x,
                      const_iterator __f, const_iterator __l);
    void splice_after(const_iterator __p, forward_list& __x);
    void splice_after(const_iterator __p, forward_list& __x, const_iterator __i);
    void splice_after(const_iterator __p, forward_list& __x,
                      const_iterator __f, const_iterator __l);
    __remove_return_type remove(const value_type& __v);
    template <class _Predicate> __remove_return_type remove_if(_Predicate __pred);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    __remove_return_type unique() {return unique(__equal_to<value_type>());}
    template <class _BinaryPredicate> __remove_return_type unique(_BinaryPredicate __binary_pred);

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(forward_list&& __x) {merge(__x, __less<value_type>());}
    template <class _Compare>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        void merge(forward_list&& __x, _Compare __comp)
        {merge(__x, std::__1::move(__comp));}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void merge(forward_list& __x) {merge(__x, __less<value_type>());}
    template <class _Compare> void merge(forward_list& __x, _Compare __comp);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void sort() {sort(__less<value_type>());}
    template <class _Compare> __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void sort(_Compare __comp);
    void reverse() noexcept;

private:


    void __move_assign(forward_list& __x, true_type)
        noexcept(is_nothrow_move_assignable<allocator_type>::value);
    void __move_assign(forward_list& __x, false_type);


    template <class _Compare>
        static
        __node_pointer
        __merge(__node_pointer __f1, __node_pointer __f2, _Compare& __comp);

    template <class _Compare>
        static
        __node_pointer
        __sort(__node_pointer __f, difference_type __sz, _Compare& __comp);
};



template<class _InputIterator,
         class _Alloc = allocator<__iter_value_type<_InputIterator>>,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
forward_list(_InputIterator, _InputIterator)
  -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;

template<class _InputIterator,
         class _Alloc,
         class = _EnableIf<__is_allocator<_Alloc>::value>
         >
forward_list(_InputIterator, _InputIterator, _Alloc)
  -> forward_list<__iter_value_type<_InputIterator>, _Alloc>;


template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>::forward_list(const allocator_type& __a)
    : base(__a)
{
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n)
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n,
                                        const allocator_type& __base_alloc)
    : base ( __base_alloc )
{
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
        for (__begin_node_pointer __p = base::__before_begin(); __n > 0; --__n,
                                                             __p = __p->__next_as_begin())
        {
            __h.reset(__node_traits::allocate(__a, 1));
            __node_traits::construct(__a, std::__1::addressof(__h->__value_));
            __h->__next_ = nullptr;
            __p->__next_ = __h.release();
        }
    }
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(size_type __n, const value_type& __v,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __n, __v);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        typename enable_if<
                                          __is_cpp17_input_iterator<_InputIterator>::value
                                        >::type*)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
forward_list<_Tp, _Alloc>::forward_list(_InputIterator __f, _InputIterator __l,
                                        const allocator_type& __a,
                                        typename enable_if<
                                          __is_cpp17_input_iterator<_InputIterator>::value
                                        >::type*)
    : base(__a)
{
    insert_after(cbefore_begin(), __f, __l);
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x)
    : base(
          __node_traits::select_on_container_copy_construction(__x.__alloc())) {
  insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(const forward_list& __x,
                                        const __identity_t<allocator_type>& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __x.begin(), __x.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(const forward_list& __x)
{
    if (this != &__x)
    {
        base::__copy_assign_alloc(__x);
        assign(__x.begin(), __x.end());
    }
    return *this;
}


template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(forward_list&& __x,
                                        const __identity_t<allocator_type>& __a)
    : base(std::__1::move(__x), __a)
{
    if (base::__alloc() != __x.__alloc())
    {
        typedef move_iterator<iterator> _Ip;
        insert_after(cbefore_begin(), _Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
forward_list<_Tp, _Alloc>::forward_list(initializer_list<value_type> __il,
                                        const allocator_type& __a)
    : base(__a)
{
    insert_after(cbefore_begin(), __il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, true_type)
    noexcept(is_nothrow_move_assignable<allocator_type>::value)
{
    clear();
    base::__move_assign_alloc(__x);
    base::__before_begin()->__next_ = __x.__before_begin()->__next_;
    __x.__before_begin()->__next_ = nullptr;
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::__move_assign(forward_list& __x, false_type)
{
    if (base::__alloc() == __x.__alloc())
        __move_assign(__x, true_type());
    else
    {
        typedef move_iterator<iterator> _Ip;
        assign(_Ip(__x.begin()), _Ip(__x.end()));
    }
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(forward_list&& __x)
    noexcept(__node_traits::propagate_on_container_move_assignment::value && is_nothrow_move_assignable<allocator_type>::value)


{
    __move_assign(__x, integral_constant<bool,
          __node_traits::propagate_on_container_move_assignment::value>());
    return *this;
}

template <class _Tp, class _Alloc>
inline
forward_list<_Tp, _Alloc>&
forward_list<_Tp, _Alloc>::operator=(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
    return *this;
}



template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    void
>::type
forward_list<_Tp, _Alloc>::assign(_InputIterator __f, _InputIterator __l)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __f != __l; ++__i, (void) ++__j, ++__f)
        *__j = *__f;
    if (__j == __e)
        insert_after(__i, __f, __l);
    else
        erase_after(__i, __e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::assign(size_type __n, const value_type& __v)
{
    iterator __i = before_begin();
    iterator __j = std::__1::next(__i);
    iterator __e = end();
    for (; __j != __e && __n > 0; --__n, ++__i, ++__j)
        *__j = __v;
    if (__j == __e)
        insert_after(__i, __n, __v);
    else
        erase_after(__i, __e);
}



template <class _Tp, class _Alloc>
inline
void
forward_list<_Tp, _Alloc>::assign(initializer_list<value_type> __il)
{
    assign(__il.begin(), __il.end());
}

template <class _Tp, class _Alloc>
template <class... _Args>

typename forward_list<_Tp, _Alloc>::reference



forward_list<_Tp, _Alloc>::emplace_front(_Args&&... __args)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();

    return base::__before_begin()->__next_->__value_;

}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(value_type&& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}



template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::push_front(const value_type& __v)
{
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __h.release();
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::pop_front()
{
    __node_allocator& __a = base::__alloc();
    __node_pointer __p = base::__before_begin()->__next_;
    base::__before_begin()->__next_ = __p->__next_;
    __node_traits::destroy(__a, std::__1::addressof(__p->__value_));
    __node_traits::deallocate(__a, __p, 1);
}



template <class _Tp, class _Alloc>
template <class... _Args>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::emplace_after(const_iterator __p, _Args&&... __args)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_),
                                  std::__1::forward<_Args>(__args)...);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, value_type&& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), std::__1::move(__v));
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}



template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, const value_type& __v)
{
    __begin_node_pointer const __r = __p.__get_begin();
    __node_allocator& __a = base::__alloc();
    typedef __allocator_destructor<__node_allocator> _Dp;
    unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
    __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
    __h->__next_ = __r->__next_;
    __r->__next_ = __h.release();
    return iterator(__r->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p, size_type __n,
                                        const value_type& __v)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__n > 0)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;

        try
        {

            for (--__n; __n != 0; --__n, __last = __last->__next_)
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __last->__next_ = __h.release();
            }

        }
        catch (...)
        {
            while (__first != nullptr)
            {
                __node_pointer __next = __first->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__first->__value_));
                __node_traits::deallocate(__a, __first, 1);
                __first = __next;
            }
            throw;
        }

        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
template <class _InputIterator>
typename enable_if
<
    __is_cpp17_input_iterator<_InputIterator>::value,
    typename forward_list<_Tp, _Alloc>::iterator
>::type
forward_list<_Tp, _Alloc>::insert_after(const_iterator __p,
                                        _InputIterator __f, _InputIterator __l)
{
    __begin_node_pointer __r = __p.__get_begin();
    if (__f != __l)
    {
        __node_allocator& __a = base::__alloc();
        typedef __allocator_destructor<__node_allocator> _Dp;
        unique_ptr<__node, _Dp> __h(__node_traits::allocate(__a, 1), _Dp(__a, 1));
        __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
        __node_pointer __first = __h.release();
        __node_pointer __last = __first;

        try
        {

            for (++__f; __f != __l; ++__f, ((void)(__last = __last->__next_)))
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), *__f);
                __last->__next_ = __h.release();
            }

        }
        catch (...)
        {
            while (__first != nullptr)
            {
                __node_pointer __next = __first->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__first->__value_));
                __node_traits::deallocate(__a, __first, 1);
                __first = __next;
            }
            throw;
        }

        __last->__next_ = __r->__next_;
        __r->__next_ = __first;
        __r = static_cast<__begin_node_pointer>(__last);
    }
    return iterator(__r);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f)
{
    __begin_node_pointer __p = __f.__get_begin();
    __node_pointer __n = __p->__next_;
    __p->__next_ = __n->__next_;
    __node_allocator& __a = base::__alloc();
    __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
    __node_traits::deallocate(__a, __n, 1);
    return iterator(__p->__next_);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::iterator
forward_list<_Tp, _Alloc>::erase_after(const_iterator __f, const_iterator __l)
{
    __node_pointer __e = __l.__get_unsafe_node_pointer();
    if (__f != __l)
    {
        __begin_node_pointer __bp = __f.__get_begin();

        __node_pointer __n = __bp->__next_;
        if (__n != __e)
        {
            __bp->__next_ = __e;
            __node_allocator& __a = base::__alloc();
            do
            {
                __node_pointer __tmp = __n->__next_;
                __node_traits::destroy(__a, std::__1::addressof(__n->__value_));
                __node_traits::deallocate(__a, __n, 1);
                __n = __tmp;
            } while (__n != __e);
        }
    }
    return iterator(__e);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_));
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::resize(size_type __n, const value_type& __v)
{
    size_type __sz = 0;
    iterator __p = before_begin();
    iterator __i = begin();
    iterator __e = end();
    for (; __i != __e && __sz < __n; ++__p, ++__i, ++__sz)
        ;
    if (__i != __e)
        erase_after(__p, __e);
    else
    {
        __n -= __sz;
        if (__n > 0)
        {
            __node_allocator& __a = base::__alloc();
            typedef __allocator_destructor<__node_allocator> _Dp;
            unique_ptr<__node, _Dp> __h(nullptr, _Dp(__a, 1));
            for (__begin_node_pointer __ptr = __p.__get_begin(); __n > 0; --__n,
                                                         __ptr = __ptr->__next_as_begin())
            {
                __h.reset(__node_traits::allocate(__a, 1));
                __node_traits::construct(__a, std::__1::addressof(__h->__value_), __v);
                __h->__next_ = nullptr;
                __ptr->__next_ = __h.release();
            }
        }
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& __x)
{
    if (!__x.empty())
    {
        if (__p.__get_begin()->__next_ != nullptr)
        {
            const_iterator __lm1 = __x.before_begin();
            while (__lm1.__get_begin()->__next_ != nullptr)
                ++__lm1;
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        }
        __p.__get_begin()->__next_ = __x.__before_begin()->__next_;
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __i)
{
    const_iterator __lm1 = std::__1::next(__i);
    if (__p != __i && __p != __lm1)
    {
        __i.__get_begin()->__next_ = __lm1.__get_begin()->__next_;
        __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
        __p.__get_begin()->__next_ = __lm1.__get_unsafe_node_pointer();
    }
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list& ,
                                        const_iterator __f, const_iterator __l)
{
    if (__f != __l && __p != __f)
    {
        const_iterator __lm1 = __f;
        while (__lm1.__get_begin()->__next_ != __l.__get_begin())
            ++__lm1;
        if (__f != __lm1)
        {
            __lm1.__get_begin()->__next_ = __p.__get_begin()->__next_;
            __p.__get_begin()->__next_ = __f.__get_begin()->__next_;
            __f.__get_begin()->__next_ = __l.__get_unsafe_node_pointer();
        }
    }
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x)
{
    splice_after(__p, __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __i)
{
    splice_after(__p, __x, __i);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
forward_list<_Tp, _Alloc>::splice_after(const_iterator __p,
                                        forward_list&& __x,
                                        const_iterator __f, const_iterator __l)
{
    splice_after(__p, __x, __f, __l);
}

template <class _Tp, class _Alloc>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::remove(const value_type& __v)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    const iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__i.__get_begin()->__next_->__value_ == __v)
        {
            ++__count_removed;
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && *__j == __v; ++__j)
                ++__count_removed;
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _Predicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::remove_if(_Predicate __pred)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    const iterator __e = end();
    for (iterator __i = before_begin(); __i.__get_begin()->__next_ != nullptr;)
    {
        if (__pred(__i.__get_begin()->__next_->__value_))
        {
            ++__count_removed;
            iterator __j = std::__1::next(__i, 2);
            for (; __j != __e && __pred(*__j); ++__j)
                ++__count_removed;
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
            if (__j == __e)
                break;
            __i = __j;
        }
        else
            ++__i;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _BinaryPredicate>
typename forward_list<_Tp, _Alloc>::__remove_return_type
forward_list<_Tp, _Alloc>::unique(_BinaryPredicate __binary_pred)
{
    forward_list<_Tp, _Alloc> __deleted_nodes(get_allocator());
    typename forward_list<_Tp, _Alloc>::size_type __count_removed = 0;
    for (iterator __i = begin(), __e = end(); __i != __e;)
    {
        iterator __j = std::__1::next(__i);
        for (; __j != __e && __binary_pred(*__i, *__j); ++__j)
            ++__count_removed;
        if (__i.__get_begin()->__next_ != __j.__get_unsafe_node_pointer())
            __deleted_nodes.splice_after(__deleted_nodes.before_begin(), *this, __i, __j);
        __i = __j;
    }

    return (__remove_return_type) __count_removed;
}

template <class _Tp, class _Alloc>
template <class _Compare>
void
forward_list<_Tp, _Alloc>::merge(forward_list& __x, _Compare __comp)
{
    if (this != &__x)
    {
        base::__before_begin()->__next_ = __merge(base::__before_begin()->__next_,
                                                    __x.__before_begin()->__next_,
                                                    __comp);
        __x.__before_begin()->__next_ = nullptr;
    }
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__merge(__node_pointer __f1, __node_pointer __f2,
                                   _Compare& __comp)
{
    if (__f1 == nullptr)
        return __f2;
    if (__f2 == nullptr)
        return __f1;
    __node_pointer __r;
    if (__comp(__f2->__value_, __f1->__value_))
    {
        __node_pointer __t = __f2;
        while (__t->__next_ != nullptr &&
                             __comp(__t->__next_->__value_, __f1->__value_))
            __t = __t->__next_;
        __r = __f2;
        __f2 = __t->__next_;
        __t->__next_ = __f1;
    }
    else
        __r = __f1;
    __node_pointer __p = __f1;
    __f1 = __f1->__next_;
    while (__f1 != nullptr && __f2 != nullptr)
    {
        if (__comp(__f2->__value_, __f1->__value_))
        {
            __node_pointer __t = __f2;
            while (__t->__next_ != nullptr &&
                                 __comp(__t->__next_->__value_, __f1->__value_))
                __t = __t->__next_;
            __p->__next_ = __f2;
            __f2 = __t->__next_;
            __t->__next_ = __f1;
        }
        __p = __f1;
        __f1 = __f1->__next_;
    }
    if (__f2 != nullptr)
        __p->__next_ = __f2;
    return __r;
}

template <class _Tp, class _Alloc>
template <class _Compare>
inline
void
forward_list<_Tp, _Alloc>::sort(_Compare __comp)
{
    base::__before_begin()->__next_ = __sort(base::__before_begin()->__next_,
                                       std::__1::distance(begin(), end()), __comp);
}

template <class _Tp, class _Alloc>
template <class _Compare>
typename forward_list<_Tp, _Alloc>::__node_pointer
forward_list<_Tp, _Alloc>::__sort(__node_pointer __f1, difference_type __sz,
                                  _Compare& __comp)
{
    switch (__sz)
    {
    case 0:
    case 1:
        return __f1;
    case 2:
        if (__comp(__f1->__next_->__value_, __f1->__value_))
        {
            __node_pointer __t = __f1->__next_;
            __t->__next_ = __f1;
            __f1->__next_ = nullptr;
            __f1 = __t;
        }
        return __f1;
    }
    difference_type __sz1 = __sz / 2;
    difference_type __sz2 = __sz - __sz1;
    __node_pointer __t = std::__1::next(iterator(__f1), __sz1 - 1).__get_unsafe_node_pointer();
    __node_pointer __f2 = __t->__next_;
    __t->__next_ = nullptr;
    return __merge(__sort(__f1, __sz1, __comp),
                   __sort(__f2, __sz2, __comp), __comp);
}

template <class _Tp, class _Alloc>
void
forward_list<_Tp, _Alloc>::reverse() noexcept
{
    __node_pointer __p = base::__before_begin()->__next_;
    if (__p != nullptr)
    {
        __node_pointer __f = __p->__next_;
        __p->__next_ = nullptr;
        while (__f != nullptr)
        {
            __node_pointer __t = __f->__next_;
            __f->__next_ = __p;
            __p = __f;
            __f = __t;
        }
        base::__before_begin()->__next_ = __p;
    }
}

template <class _Tp, class _Alloc>
bool operator==(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    typedef forward_list<_Tp, _Alloc> _Cp;
    typedef typename _Cp::const_iterator _Ip;
    _Ip __ix = __x.begin();
    _Ip __ex = __x.end();
    _Ip __iy = __y.begin();
    _Ip __ey = __y.end();
    for (; __ix != __ex && __iy != __ey; ++__ix, ++__iy)
        if (!(*__ix == *__iy))
            return false;
    return (__ix == __ex) == (__iy == __ey);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator!=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x == __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator< (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return std::__1::lexicographical_compare(__x.begin(), __x.end(),
                                         __y.begin(), __y.end());
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator> (const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return __y < __x;
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator>=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__x < __y);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bool operator<=(const forward_list<_Tp, _Alloc>& __x,
                const forward_list<_Tp, _Alloc>& __y)
{
    return !(__y < __x);
}

template <class _Tp, class _Alloc>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
void
swap(forward_list<_Tp, _Alloc>& __x, forward_list<_Tp, _Alloc>& __y)
    noexcept(noexcept(__x.swap(__y)))
{
    __x.swap(__y);
}
# 1784 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/forward_list" 3
} }
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/message.h" 2






namespace Fortran::parser {




enum class Severity {
  Error,
  Warning,
  Portability,
  Because,
  Context,
  Todo,
  None
};

class MessageFixedText {
public:
  constexpr MessageFixedText() {}
  constexpr MessageFixedText(
      const char str[], std::size_t n, Severity severity = Severity::None)
      : text_{str, n}, severity_{severity} {}
  constexpr MessageFixedText(const MessageFixedText &) = default;
  constexpr MessageFixedText(MessageFixedText &&) = default;
  constexpr MessageFixedText &operator=(const MessageFixedText &) = default;
  constexpr MessageFixedText &operator=(MessageFixedText &&) = default;

  CharBlock text() const { return text_; }
  bool empty() const { return text_.empty(); }
  Severity severity() const { return severity_; }
  MessageFixedText &set_severity(Severity severity) {
    severity_ = severity;
    return *this;
  }
  bool IsFatal() const {
    return severity_ == Severity::Error || severity_ == Severity::Todo;
  }

private:
  CharBlock text_;
  Severity severity_{Severity::None};
};

inline namespace literals {
constexpr MessageFixedText operator""_err_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Error};
}
constexpr MessageFixedText operator""_warn_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Warning};
}
constexpr MessageFixedText operator""_port_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Portability};
}
constexpr MessageFixedText operator""_because_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Because};
}
constexpr MessageFixedText operator""_todo_en_US(
    const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::Todo};
}
constexpr MessageFixedText operator""_en_US(const char str[], std::size_t n) {
  return MessageFixedText{str, n, Severity::None};
}
}






class MessageFormattedText {
public:
  template <typename... A>
  MessageFormattedText(const MessageFixedText &text, A &&...x)
      : severity_{text.severity()} {
    Format(&text, Convert(std::forward<A>(x))...);
  }
  MessageFormattedText(const MessageFormattedText &) = default;
  MessageFormattedText(MessageFormattedText &&) = default;
  MessageFormattedText &operator=(const MessageFormattedText &) = default;
  MessageFormattedText &operator=(MessageFormattedText &&) = default;
  const std::string &string() const { return string_; }
  bool IsFatal() const {
    return severity_ == Severity::Error || severity_ == Severity::Todo;
  }
  Severity severity() const { return severity_; }
  MessageFormattedText &set_severity(Severity severity) {
    severity_ = severity;
    return *this;
  }
  std::string MoveString() { return std::move(string_); }
  bool operator==(const MessageFormattedText &that) const {
    return severity_ == that.severity_ && string_ == that.string_;
  }
  bool operator!=(const MessageFormattedText &that) const {
    return !(*this == that);
  }

private:
  void Format(const MessageFixedText *, ...);

  template <typename A> A Convert(const A &x) {
    static_assert(!std::is_class_v<std::decay_t<A>>);
    return x;
  }
  template <typename A> common::IfNoLvalue<A, A> Convert(A &&x) {
    static_assert(!std::is_class_v<std::decay_t<A>>);
    return std::move(x);
  }
  const char *Convert(const char *s) { return s; }
  const char *Convert(char *s) { return s; }
  const char *Convert(const std::string &);
  const char *Convert(std::string &&);
  const char *Convert(const std::string_view &);
  const char *Convert(std::string_view &&);
  const char *Convert(CharBlock);
  std::intmax_t Convert(std::int64_t x) { return x; }
  std::uintmax_t Convert(std::uint64_t x) { return x; }

  Severity severity_;
  std::string string_;
  std::forward_list<std::string> conversions_;
};



class MessageExpectedText {
public:
  MessageExpectedText(const char *s, std::size_t n) {
    if (n == std::string::npos) {
      n = std::strlen(s);
    }
    if (n == 1) {

      u_ = SetOfChars{*s};
    } else {
      u_ = CharBlock{s, n};
    }
  }
  constexpr explicit MessageExpectedText(CharBlock cb) : u_{cb} {}
  constexpr explicit MessageExpectedText(char ch) : u_{SetOfChars{ch}} {}
  constexpr explicit MessageExpectedText(SetOfChars set) : u_{set} {}
  MessageExpectedText(const MessageExpectedText &) = default;
  MessageExpectedText(MessageExpectedText &&) = default;
  MessageExpectedText &operator=(const MessageExpectedText &) = default;
  MessageExpectedText &operator=(MessageExpectedText &&) = default;

  std::string ToString() const;
  bool Merge(const MessageExpectedText &);

private:
  std::variant<CharBlock, SetOfChars> u_;
};

class Message : public common::ReferenceCounted<Message> {
public:
  using Reference = common::CountedReference<Message>;

  Message(const Message &) = default;
  Message(Message &&) = default;
  Message &operator=(const Message &) = default;
  Message &operator=(Message &&) = default;

  Message(ProvenanceRange pr, const MessageFixedText &t)
      : location_{pr}, text_{t} {}
  Message(ProvenanceRange pr, const MessageFormattedText &s)
      : location_{pr}, text_{s} {}
  Message(ProvenanceRange pr, MessageFormattedText &&s)
      : location_{pr}, text_{std::move(s)} {}
  Message(ProvenanceRange pr, const MessageExpectedText &t)
      : location_{pr}, text_{t} {}

  Message(CharBlock csr, const MessageFixedText &t)
      : location_{csr}, text_{t} {}
  Message(CharBlock csr, const MessageFormattedText &s)
      : location_{csr}, text_{s} {}
  Message(CharBlock csr, MessageFormattedText &&s)
      : location_{csr}, text_{std::move(s)} {}
  Message(CharBlock csr, const MessageExpectedText &t)
      : location_{csr}, text_{t} {}

  template <typename RANGE, typename A, typename... As>
  Message(RANGE r, const MessageFixedText &t, A &&x, As &&...xs)
      : location_{r}, text_{MessageFormattedText{
                          t, std::forward<A>(x), std::forward<As>(xs)...}} {}

  Reference attachment() const { return attachment_; }

  void SetContext(Message *c) {
    attachment_ = c;
    attachmentIsContext_ = true;
  }
  Message &Attach(Message *);
  Message &Attach(std::unique_ptr<Message> &&);
  template <typename... A> Message &Attach(A &&...args) {
    return Attach(new Message{std::forward<A>(args)...});
  }

  bool SortBefore(const Message &that) const;
  bool IsFatal() const;
  Severity severity() const;
  Message &set_severity(Severity);
  std::string ToString() const;
  std::optional<ProvenanceRange> GetProvenanceRange(
      const AllCookedSources &) const;
  void Emit(llvm::raw_ostream &, const AllCookedSources &,
      bool echoSourceLine = true) const;



  void ResolveProvenances(const AllCookedSources &);

  bool IsMergeable() const {
    return std::holds_alternative<MessageExpectedText>(text_);
  }
  bool Merge(const Message &);
  bool operator==(const Message &that) const;
  bool operator!=(const Message &that) const { return !(*this == that); }

private:
  bool AtSameLocation(const Message &) const;
  std::variant<ProvenanceRange, CharBlock> location_;
  std::variant<MessageFixedText, MessageFormattedText, MessageExpectedText>
      text_;
  bool attachmentIsContext_{false};
  Reference attachment_;
};

class Messages {
public:
  Messages() {}
  Messages(Messages &&that) : messages_{std::move(that.messages_)} {}
  Messages &operator=(Messages &&that) {
    messages_ = std::move(that.messages_);
    return *this;
  }

  std::list<Message> &messages() { return messages_; }
  bool empty() const { return messages_.empty(); }
  void clear() { messages_.clear(); }

  template <typename... A> Message &Say(A &&...args) {
    return messages_.emplace_back(std::forward<A>(args)...);
  }

  void Annex(Messages &&that) {
    messages_.splice(messages_.end(), that.messages_);
  }

  bool Merge(const Message &);
  void Merge(Messages &&);
  void Copy(const Messages &);
  void ResolveProvenances(const AllCookedSources &);
  void Emit(llvm::raw_ostream &, const AllCookedSources &,
      bool echoSourceLines = true) const;
  void AttachTo(Message &, std::optional<Severity> = std::nullopt);
  bool AnyFatalError() const;

private:
  std::list<Message> messages_;
};

class ContextualMessages {
public:
  ContextualMessages() = default;
  ContextualMessages(CharBlock at, Messages *m) : at_{at}, messages_{m} {}
  explicit ContextualMessages(Messages *m) : messages_{m} {}
  ContextualMessages(const ContextualMessages &that)
      : at_{that.at_}, messages_{that.messages_} {}

  CharBlock at() const { return at_; }
  Messages *messages() const { return messages_; }
  Message::Reference contextMessage() const { return contextMessage_; }
  bool empty() const { return !messages_ || messages_->empty(); }


  common::Restorer<CharBlock> SetLocation(CharBlock at) {
    if (at.empty()) {
      at = at_;
    }
    return common::ScopedSet(at_, std::move(at));
  }

  common::Restorer<Message::Reference> SetContext(Message *m) {
    if (!m) {
      m = contextMessage_.get();
    }
    return common::ScopedSet(contextMessage_, m);
  }



  common::Restorer<Messages *> SetMessages(Messages &buffer) {
    return common::ScopedSet(messages_, &buffer);
  }

  common::Restorer<Messages *> DiscardMessages() {
    return common::ScopedSet(messages_, nullptr);
  }

  template <typename... A> Message *Say(CharBlock at, A &&...args) {
    if (messages_ != nullptr) {
      auto &msg{messages_->Say(at, std::forward<A>(args)...)};
      if (contextMessage_) {
        msg.SetContext(contextMessage_.get());
      }
      return &msg;
    } else {
      return nullptr;
    }
  }

  template <typename... A>
  Message *Say(std::optional<CharBlock> at, A &&...args) {
    return Say(at.value_or(at_), std::forward<A>(args)...);
  }

  template <typename... A> Message *Say(A &&...args) {
    return Say(at_, std::forward<A>(args)...);
  }

  Message *Say(Message &&msg) {
    if (messages_ != nullptr) {
      if (contextMessage_) {
        msg.SetContext(contextMessage_.get());
      }
      return &messages_->Say(std::move(msg));
    } else {
      return nullptr;
    }
  }

private:
  CharBlock at_;
  Messages *messages_{nullptr};
  Message::Reference contextMessage_;
};
}
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 1
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 1
# 15 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/bit-population-count.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/bit-population-count.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 19 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/bit-population-count.h" 2

namespace Fortran::common {

template <typename INT,
    std::enable_if_t<(sizeof(INT) > 4 && sizeof(INT) <= 8), int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x5555555555555555) + ((x >> 1) & 0x5555555555555555);

  x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333);

  x = (x & 0x0f0f0f0f0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f0f0f0f0f);

  x = (x & 0x001f001f001f001f) + ((x >> 8) & 0x001f001f001f001f);

  x = (x & 0x0000003f0000003f) + ((x >> 16) & 0x0000003f0000003f);

  return (x & 0x7f) + (x >> 32);
}

template <typename INT,
    std::enable_if_t<(sizeof(INT) > 2 && sizeof(INT) <= 4), int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x55555555) + ((x >> 1) & 0x55555555);

  x = (x & 0x33333333) + ((x >> 2) & 0x33333333);

  x = (x & 0x0f0f0f0f) + ((x >> 4) & 0x0f0f0f0f);

  x = (x & 0x001f001f) + ((x >> 8) & 0x001f001f);

  return (x & 0x3f) + (x >> 16);
}

template <typename INT, std::enable_if_t<sizeof(INT) == 2, int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x5555) + ((x >> 1) & 0x5555);

  x = (x & 0x3333) + ((x >> 2) & 0x3333);

  x = (x & 0x0f0f) + ((x >> 4) & 0x0f0f);

  return (x & 0x1f) + (x >> 8);
}

template <typename INT, std::enable_if_t<sizeof(INT) == 1, int> = 0>
inline constexpr int BitPopulationCount(INT x) {


  x = (x & 0x55) + ((x >> 1) & 0x55);

  x = (x & 0x33) + ((x >> 2) & 0x33);

  return (x & 0xf) + (x >> 4);
}

template <typename INT> inline constexpr bool Parity(INT x) {
  return BitPopulationCount(x) & 1;
}



template <typename INT> inline constexpr int TrailingZeroBitCount(INT x) {
  if ((x & 1) != 0) {
    return 0;
  } else if (x == 0) {
    return 8 * sizeof x;
  } else {
    return BitPopulationCount(static_cast<INT>(x ^ (x - 1))) - 1;
  }
}
}
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h" 1
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h" 1
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h"
namespace Fortran::common {
namespace {
# 38 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/leading-zero-bit-count.h"
static constexpr std::uint64_t deBruijn{0x07edd5e59a4e28c2};
static constexpr std::uint8_t mapping[64]{63, 0, 58, 1, 59, 47, 53, 2, 60, 39,
    48, 27, 54, 33, 42, 3, 61, 51, 37, 40, 49, 18, 28, 20, 55, 30, 34, 11, 43,
    14, 22, 4, 62, 57, 46, 52, 38, 26, 32, 41, 50, 36, 17, 19, 29, 10, 13, 21,
    56, 45, 25, 31, 35, 16, 9, 12, 44, 24, 15, 8, 23, 7, 6, 5};
}

inline constexpr int LeadingZeroBitCount(std::uint64_t x) {
  if (x == 0) {
    return 64;
  } else {
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;

    x -= x >> 1;




    int base2Log{mapping[(x * deBruijn) >> 58]};
    return 63 - base2Log;
  }
}

inline constexpr int LeadingZeroBitCount(std::uint32_t x) {
  return LeadingZeroBitCount(static_cast<std::uint64_t>(x)) - 32;
}

inline constexpr int LeadingZeroBitCount(std::uint16_t x) {
  return LeadingZeroBitCount(static_cast<std::uint64_t>(x)) - 48;
}

namespace {
static constexpr std::uint8_t eightBitLeadingZeroBitCount[256]{8, 7, 6, 6, 5, 5,
    5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    3, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
}

inline constexpr int LeadingZeroBitCount(std::uint8_t x) {
  return eightBitLeadingZeroBitCount[x];
}

template <typename A> inline constexpr int BitsNeededFor(A x) {
  return 8 * sizeof x - LeadingZeroBitCount(x);
}
}
# 23 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/uint128.h" 2

namespace Fortran::common {

template <bool IS_SIGNED = false> class Int128 {
public:
  constexpr Int128() {}


  constexpr Int128(unsigned n) : low_{n} {}
  constexpr Int128(unsigned long n) : low_{n} {}
  constexpr Int128(unsigned long long n) : low_{n} {}
  constexpr Int128(int n)
      : low_{static_cast<std::uint64_t>(n)}, high_{-static_cast<std::uint64_t>(
                                                 n < 0)} {}
  constexpr Int128(long n)
      : low_{static_cast<std::uint64_t>(n)}, high_{-static_cast<std::uint64_t>(
                                                 n < 0)} {}
  constexpr Int128(long long n)
      : low_{static_cast<std::uint64_t>(n)}, high_{-static_cast<std::uint64_t>(
                                                 n < 0)} {}
  constexpr Int128(const Int128 &) = default;
  constexpr Int128(Int128 &&) = default;
  constexpr Int128 &operator=(const Int128 &) = default;
  constexpr Int128 &operator=(Int128 &&) = default;

  explicit constexpr Int128(const Int128<!IS_SIGNED> &n)
      : low_{n.low()}, high_{n.high()} {}
  explicit constexpr Int128(Int128<!IS_SIGNED> &&n)
      : low_{n.low()}, high_{n.high()} {}

  constexpr Int128 operator+() const { return *this; }
  constexpr Int128 operator~() const { return {~high_, ~low_}; }
  constexpr Int128 operator-() const { return ~*this + 1; }
  constexpr bool operator!() const { return !low_ && !high_; }
  constexpr explicit operator bool() const { return low_ || high_; }
  constexpr explicit operator std::uint64_t() const { return low_; }
  constexpr explicit operator std::int64_t() const { return low_; }
  constexpr explicit operator int() const { return static_cast<int>(low_); }

  constexpr std::uint64_t high() const { return high_; }
  constexpr std::uint64_t low() const { return low_; }

  constexpr Int128 operator++( ) {
    *this += 1;
    return *this;
  }
  constexpr Int128 operator++(int ) {
    Int128 result{*this};
    *this += 1;
    return result;
  }
  constexpr Int128 operator--( ) {
    *this -= 1;
    return *this;
  }
  constexpr Int128 operator--(int ) {
    Int128 result{*this};
    *this -= 1;
    return result;
  }

  constexpr Int128 operator&(Int128 that) const {
    return {high_ & that.high_, low_ & that.low_};
  }
  constexpr Int128 operator|(Int128 that) const {
    return {high_ | that.high_, low_ | that.low_};
  }
  constexpr Int128 operator^(Int128 that) const {
    return {high_ ^ that.high_, low_ ^ that.low_};
  }

  constexpr Int128 operator<<(Int128 that) const {
    if (that >= 128) {
      return {};
    } else if (that == 0) {
      return *this;
    } else {
      std::uint64_t n{that.low_};
      if (n >= 64) {
        return {low_ << (n - 64), 0};
      } else {
        return {(high_ << n) | (low_ >> (64 - n)), low_ << n};
      }
    }
  }
  constexpr Int128 operator>>(Int128 that) const {
    if (that >= 128) {
      return {};
    } else if (that == 0) {
      return *this;
    } else {
      std::uint64_t n{that.low_};
      if (n >= 64) {
        return {0, high_ >> (n - 64)};
      } else {
        return {high_ >> n, (high_ << (64 - n)) | (low_ >> n)};
      }
    }
  }

  constexpr Int128 operator+(Int128 that) const {
    std::uint64_t lower{(low_ & ~topBit) + (that.low_ & ~topBit)};
    bool carry{((lower >> 63) + (low_ >> 63) + (that.low_ >> 63)) > 1};
    return {high_ + that.high_ + carry, low_ + that.low_};
  }
  constexpr Int128 operator-(Int128 that) const { return *this + -that; }

  constexpr Int128 operator*(Int128 that) const {
    std::uint64_t mask32{0xffffffff};
    if (high_ == 0 && that.high_ == 0) {
      std::uint64_t x0{low_ & mask32}, x1{low_ >> 32};
      std::uint64_t y0{that.low_ & mask32}, y1{that.low_ >> 32};
      Int128 x0y0{x0 * y0}, x0y1{x0 * y1};
      Int128 x1y0{x1 * y0}, x1y1{x1 * y1};
      return x0y0 + ((x0y1 + x1y0) << 32) + (x1y1 << 64);
    } else {
      std::uint64_t x0{low_ & mask32}, x1{low_ >> 32}, x2{high_ & mask32},
          x3{high_ >> 32};
      std::uint64_t y0{that.low_ & mask32}, y1{that.low_ >> 32},
          y2{that.high_ & mask32}, y3{that.high_ >> 32};
      Int128 x0y0{x0 * y0}, x0y1{x0 * y1}, x0y2{x0 * y2}, x0y3{x0 * y3};
      Int128 x1y0{x1 * y0}, x1y1{x1 * y1}, x1y2{x1 * y2};
      Int128 x2y0{x2 * y0}, x2y1{x2 * y1};
      Int128 x3y0{x3 * y0};
      return x0y0 + ((x0y1 + x1y0) << 32) + ((x0y2 + x1y1 + x2y0) << 64) +
          ((x0y3 + x1y2 + x2y1 + x3y0) << 96);
    }
  }

  constexpr Int128 operator/(Int128 that) const {
    int j{LeadingZeroes()};
    Int128 bits{*this};
    bits <<= j;
    Int128 numerator{};
    Int128 quotient{};
    for (; j < 128; ++j) {
      numerator <<= 1;
      if (bits.high_ & topBit) {
        numerator.low_ |= 1;
      }
      bits <<= 1;
      quotient <<= 1;
      if (numerator >= that) {
        ++quotient;
        numerator -= that;
      }
    }
    return quotient;
  }

  constexpr Int128 operator%(Int128 that) const {
    int j{LeadingZeroes()};
    Int128 bits{*this};
    bits <<= j;
    Int128 remainder{};
    for (; j < 128; ++j) {
      remainder <<= 1;
      if (bits.high_ & topBit) {
        remainder.low_ |= 1;
      }
      bits <<= 1;
      if (remainder >= that) {
        remainder -= that;
      }
    }
    return remainder;
  }

  constexpr bool operator<(Int128 that) const {
    if (IS_SIGNED && (high_ ^ that.high_) & topBit) {
      return (high_ & topBit) != 0;
    }
    return high_ < that.high_ || (high_ == that.high_ && low_ < that.low_);
  }
  constexpr bool operator<=(Int128 that) const { return !(*this > that); }
  constexpr bool operator==(Int128 that) const {
    return low_ == that.low_ && high_ == that.high_;
  }
  constexpr bool operator!=(Int128 that) const { return !(*this == that); }
  constexpr bool operator>=(Int128 that) const { return that <= *this; }
  constexpr bool operator>(Int128 that) const { return that < *this; }

  constexpr Int128 &operator&=(const Int128 &that) {
    *this = *this & that;
    return *this;
  }
  constexpr Int128 &operator|=(const Int128 &that) {
    *this = *this | that;
    return *this;
  }
  constexpr Int128 &operator^=(const Int128 &that) {
    *this = *this ^ that;
    return *this;
  }
  constexpr Int128 &operator<<=(const Int128 &that) {
    *this = *this << that;
    return *this;
  }
  constexpr Int128 &operator>>=(const Int128 &that) {
    *this = *this >> that;
    return *this;
  }
  constexpr Int128 &operator+=(const Int128 &that) {
    *this = *this + that;
    return *this;
  }
  constexpr Int128 &operator-=(const Int128 &that) {
    *this = *this - that;
    return *this;
  }
  constexpr Int128 &operator*=(const Int128 &that) {
    *this = *this * that;
    return *this;
  }
  constexpr Int128 &operator/=(const Int128 &that) {
    *this = *this / that;
    return *this;
  }
  constexpr Int128 &operator%=(const Int128 &that) {
    *this = *this % that;
    return *this;
  }

private:
  constexpr Int128(std::uint64_t hi, std::uint64_t lo) : low_{lo}, high_{hi} {}
  constexpr int LeadingZeroes() const {
    if (high_ == 0) {
      return 64 + LeadingZeroBitCount(low_);
    } else {
      return LeadingZeroBitCount(high_);
    }
  }
  static constexpr std::uint64_t topBit{std::uint64_t{1} << 63};
  std::uint64_t low_{0}, high_{0};
};

using UnsignedInt128 = Int128<false>;
using SignedInt128 = Int128<true>;



using uint128_t = __uint128_t;
using int128_t = __int128_t;





template <int BITS> struct HostUnsignedIntTypeHelper {
  using type = std::conditional_t<(BITS <= 8), std::uint8_t,
      std::conditional_t<(BITS <= 16), std::uint16_t,
          std::conditional_t<(BITS <= 32), std::uint32_t,
              std::conditional_t<(BITS <= 64), std::uint64_t, uint128_t>>>>;
};
template <int BITS> struct HostSignedIntTypeHelper {
  using type = std::conditional_t<(BITS <= 8), std::int8_t,
      std::conditional_t<(BITS <= 16), std::int16_t,
          std::conditional_t<(BITS <= 32), std::int32_t,
              std::conditional_t<(BITS <= 64), std::int64_t, int128_t>>>>;
};
template <int BITS>
using HostUnsignedIntType = typename HostUnsignedIntTypeHelper<BITS>::type;
template <int BITS>
using HostSignedIntType = typename HostSignedIntTypeHelper<BITS>::type;

}
# 17 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 2




# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 22 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/constexpr-bitset.h" 2

namespace Fortran::common {

template <int BITS> class BitSet {
  static_assert(BITS > 0 && BITS <= 128);
  using Word = HostUnsignedIntType<(BITS <= 32 ? 32 : BITS)>;
  static constexpr Word allBits{
      ~static_cast<Word>(0) >> (8 * sizeof(Word) - BITS)};

  constexpr BitSet(Word b) : bits_{b} {}

public:
  constexpr BitSet() {}
  constexpr BitSet(const std::initializer_list<int> &xs) {
    for (auto x : xs) {
      set(x);
    }
  }
  constexpr BitSet(const BitSet &) = default;
  constexpr BitSet(BitSet &&) = default;
  constexpr BitSet &operator=(const BitSet &) = default;
  constexpr BitSet &operator=(BitSet &&) = default;

  constexpr BitSet &operator&=(const BitSet &that) {
    bits_ &= that.bits_;
    return *this;
  }
  constexpr BitSet &operator&=(BitSet &&that) {
    bits_ &= that.bits_;
    return *this;
  }
  constexpr BitSet &operator^=(const BitSet &that) {
    bits_ ^= that.bits_;
    return *this;
  }
  constexpr BitSet &operator^=(BitSet &&that) {
    bits_ ^= that.bits_;
    return *this;
  }
  constexpr BitSet &operator|=(const BitSet &that) {
    bits_ |= that.bits_;
    return *this;
  }
  constexpr BitSet &operator|=(BitSet &&that) {
    bits_ |= that.bits_;
    return *this;
  }

  constexpr BitSet operator~() const { return ~bits_; }
  constexpr BitSet operator&(const BitSet &that) const {
    return bits_ & that.bits_;
  }
  constexpr BitSet operator&(BitSet &&that) const { return bits_ & that.bits_; }
  constexpr BitSet operator^(const BitSet &that) const {
    return bits_ ^ that.bits_;
  }
  constexpr BitSet operator^(BitSet &&that) const { return bits_ & that.bits_; }
  constexpr BitSet operator|(const BitSet &that) const {
    return bits_ | that.bits_;
  }
  constexpr BitSet operator|(BitSet &&that) const { return bits_ | that.bits_; }

  constexpr bool operator==(const BitSet &that) const {
    return bits_ == that.bits_;
  }
  constexpr bool operator==(BitSet &&that) const { return bits_ == that.bits_; }
  constexpr bool operator!=(const BitSet &that) const {
    return bits_ != that.bits_;
  }
  constexpr bool operator!=(BitSet &&that) const { return bits_ != that.bits_; }

  static constexpr std::size_t size() { return BITS; }
  constexpr bool test(std::size_t x) const {
    return x < BITS && ((bits_ >> x) & 1) != 0;
  }

  constexpr bool all() const { return bits_ == allBits; }
  constexpr bool any() const { return bits_ != 0; }
  constexpr bool none() const { return bits_ == 0; }

  constexpr std::size_t count() const { return BitPopulationCount(bits_); }

  constexpr BitSet &set() {
    bits_ = allBits;
    return *this;
  }
  constexpr BitSet set(std::size_t x, bool value = true) {
    if (!value) {
      return reset(x);
    } else {
      bits_ |= static_cast<Word>(1) << x;
      return *this;
    }
  }
  constexpr BitSet &reset() {
    bits_ = 0;
    return *this;
  }
  constexpr BitSet &reset(std::size_t x) {
    bits_ &= ~(static_cast<Word>(1) << x);
    return *this;
  }
  constexpr BitSet &flip() {
    bits_ ^= allBits;
    return *this;
  }
  constexpr BitSet &flip(std::size_t x) {
    bits_ ^= static_cast<Word>(1) << x;
    return *this;
  }

  constexpr std::optional<std::size_t> LeastElement() const {
    if (bits_ == 0) {
      return std::nullopt;
    } else {
      return {TrailingZeroBitCount(bits_)};
    }
  }

  Word bits() const { return bits_; }

private:
  Word bits_{0};
};
}
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 2

# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 1 3
# 126 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/__undef_macros" 1 3
# 130 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 2 3


namespace std { inline namespace __1 {

template <size_t _N_words, size_t _Size>
class __bitset;

template <size_t _N_words, size_t _Size>
struct __has_storage_type<__bitset<_N_words, _Size> >
{
    static const bool value = true;
};

template <size_t _N_words, size_t _Size>
class __bitset
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_[_N_words];

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t __pos) noexcept
        {return reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(__first_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator^=(const __bitset& __v) noexcept;

    void flip() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long to_ulong() const
        {return to_ulong(integral_constant<bool, _Size < sizeof(unsigned long) * 8>());}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long long to_ullong() const
        {return to_ullong(integral_constant<bool, _Size < sizeof(unsigned long long) * 8>());}

    bool all() const noexcept;
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept;
private:





    unsigned long to_ulong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong(true_type) const;
    unsigned long long to_ullong(false_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong(true_type) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong(true_type, false_type) const;
    unsigned long long to_ullong(true_type, true_type) const;
};

template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset() noexcept

    : __first_{0}

{



}
# 263 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
template <size_t _N_words, size_t _Size>
inline
constexpr
__bitset<_N_words, _Size>::__bitset(unsigned long long __v) noexcept


    : __first_{__v}
# 278 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/bitset" 3
{



}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator&=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] &= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator|=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] |= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
inline
void
__bitset<_N_words, _Size>::operator^=(const __bitset& __v) noexcept
{
    for (size_type __i = 0; __i < _N_words; ++__i)
        __first_[__i] ^= __v.__first_[__i];
}

template <size_t _N_words, size_t _Size>
void
__bitset<_N_words, _Size>::flip() noexcept
{

    size_type __n = _Size;
    __storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        *__p = ~*__p;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        __storage_type __b = *__p & __m;
        *__p &= ~__m;
        *__p |= ~__b & __m;
    }
}

template <size_t _N_words, size_t _Size>
unsigned long
__bitset<_N_words, _Size>::to_ulong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ulong overflow error");

    return __first_[0];
}

template <size_t _N_words, size_t _Size>
inline
unsigned long
__bitset<_N_words, _Size>::to_ulong(true_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(false_type) const
{
    const_iterator __e = __make_iter(_Size);
    const_iterator __i = std::__1::find(__make_iter(sizeof(unsigned long long) * 8), __e, true);
    if (__i != __e)
        __throw_overflow_error("bitset to_ullong overflow error");

    return to_ullong(true_type());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type) const
{
    return to_ullong(true_type(), integral_constant<bool, sizeof(__storage_type) < sizeof(unsigned long long)>());
}

template <size_t _N_words, size_t _Size>
inline
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, false_type) const
{
    return __first_[0];
}

template <size_t _N_words, size_t _Size>
unsigned long long
__bitset<_N_words, _Size>::to_ullong(true_type, true_type) const
{
    unsigned long long __r = __first_[0];
    for (size_t __i = 1; __i < sizeof(unsigned long long) / sizeof(__storage_type); ++__i)
        __r |= static_cast<unsigned long long>(__first_[__i]) << (sizeof(__storage_type) * 8);
    return __r;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::all() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (~*__p)
            return false;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (~*__p & __m)
            return false;
    }
    return true;
}

template <size_t _N_words, size_t _Size>
bool
__bitset<_N_words, _Size>::any() const noexcept
{

    size_type __n = _Size;
    __const_storage_pointer __p = __first_;
    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)
        if (*__p)
            return true;

    if (__n > 0)
    {
        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);
        if (*__p & __m)
            return true;
    }
    return false;
}

template <size_t _N_words, size_t _Size>
inline
size_t
__bitset<_N_words, _Size>::__hash_code() const noexcept
{
    size_t __h = 0;
    for (size_type __i = 0; __i < _N_words; ++__i)
        __h ^= __first_[__i];
    return __h;
}

template <size_t _Size>
class __bitset<1, _Size>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    __storage_type __first_;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t __pos) noexcept
        {return reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t __pos) const noexcept
        {return const_reference(&__first_, __storage_type(1) << __pos);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t __pos) noexcept
        {return iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t __pos) const noexcept
        {return const_iterator(&__first_ + __pos / __bits_per_word, __pos % __bits_per_word);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator&=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator|=(const __bitset& __v) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void operator^=(const __bitset& __v) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    void flip() noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong() const;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool any() const noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept;
};

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset() noexcept
    : __first_(0)
{
}

template <size_t _Size>
inline
constexpr
__bitset<1, _Size>::__bitset(unsigned long long __v) noexcept
    : __first_(
        _Size == __bits_per_word ? static_cast<__storage_type>(__v)
                                 : static_cast<__storage_type>(__v) & ((__storage_type(1) << _Size) - 1)
    )
{
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator&=(const __bitset& __v) noexcept
{
    __first_ &= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator|=(const __bitset& __v) noexcept
{
    __first_ |= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::operator^=(const __bitset& __v) noexcept
{
    __first_ ^= __v.__first_;
}

template <size_t _Size>
inline
void
__bitset<1, _Size>::flip() noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    __first_ = ~__first_;
    __first_ &= __m;
}

template <size_t _Size>
inline
unsigned long
__bitset<1, _Size>::to_ulong() const
{
    return __first_;
}

template <size_t _Size>
inline
unsigned long long
__bitset<1, _Size>::to_ullong() const
{
    return __first_;
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::all() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return !(~__first_ & __m);
}

template <size_t _Size>
inline
bool
__bitset<1, _Size>::any() const noexcept
{
    __storage_type __m = ~__storage_type(0) >> (__bits_per_word - _Size);
    return __first_ & __m;
}

template <size_t _Size>
inline
size_t
__bitset<1, _Size>::__hash_code() const noexcept
{
    return __first_;
}

template <>
class __bitset<0, 0>
{
public:
    typedef ptrdiff_t difference_type;
    typedef size_t size_type;
    typedef size_type __storage_type;
protected:
    typedef __bitset __self;
    typedef __storage_type* __storage_pointer;
    typedef const __storage_type* __const_storage_pointer;
    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * 8);

    friend class __bit_reference<__bitset>;
    friend class __bit_const_reference<__bitset>;
    friend class __bit_iterator<__bitset, false>;
    friend class __bit_iterator<__bitset, true>;
    friend struct __bit_array<__bitset>;

    typedef __bit_reference<__bitset> reference;
    typedef __bit_const_reference<__bitset> const_reference;
    typedef __bit_iterator<__bitset, false> iterator;
    typedef __bit_iterator<__bitset, true> const_iterator;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    constexpr __bitset() noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    explicit constexpr __bitset(unsigned long long) noexcept;

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference __make_ref(size_t) noexcept
        {return reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr const_reference __make_ref(size_t) const noexcept
        {return const_reference(nullptr, 1);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) iterator __make_iter(size_t) noexcept
        {return iterator(nullptr, 0);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) const_iterator __make_iter(size_t) const noexcept
        {return const_iterator(nullptr, 0);}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator&=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator|=(const __bitset&) noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void operator^=(const __bitset&) noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) void flip() noexcept {}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long to_ulong() const {return 0;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) unsigned long long to_ullong() const {return 0;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool all() const noexcept {return true;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool any() const noexcept {return false;}

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) size_t __hash_code() const noexcept {return 0;}
};

inline
constexpr
__bitset<0, 0>::__bitset() noexcept
{
}

inline
constexpr
__bitset<0, 0>::__bitset(unsigned long long) noexcept
{
}

template <size_t _Size> class __attribute__ ((__type_visibility__("default"))) bitset;
template <size_t _Size> struct hash<bitset<_Size> >;

template <size_t _Size>
class __attribute__ ((__type_visibility__("default"))) bitset
    : private __bitset<_Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1, _Size>
{
public:
    static const unsigned __n_words = _Size == 0 ? 0 : (_Size - 1) / (sizeof(size_t) * 8) + 1;
    typedef __bitset<__n_words, _Size> base;

public:
    typedef typename base::reference reference;
    typedef typename base::const_reference const_reference;


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr bitset() noexcept {}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
        bitset(unsigned long long __v) noexcept : base(__v) {}
    template<class _CharT, class = _EnableIf<_IsCharLikeType<_CharT>::value> >
        explicit bitset(const _CharT* __str,
                        typename basic_string<_CharT>::size_type __n = basic_string<_CharT>::npos,
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));
    template<class _CharT, class _Traits, class _Allocator>
        explicit bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos = 0,
                        typename basic_string<_CharT,_Traits,_Allocator>::size_type __n =
                                (basic_string<_CharT,_Traits,_Allocator>::npos),
                        _CharT __zero = _CharT('0'), _CharT __one = _CharT('1'));


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator&=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator|=(const bitset& __rhs) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& operator^=(const bitset& __rhs) noexcept;
    bitset& operator<<=(size_t __pos) noexcept;
    bitset& operator>>=(size_t __pos) noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& set() noexcept;
    bitset& set(size_t __pos, bool __val = true);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& reset() noexcept;
    bitset& reset(size_t __pos);
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator~() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset& flip() noexcept;
    bitset& flip(size_t __pos);


    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr
                              const_reference operator[](size_t __p) const {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) reference operator[](size_t __p) {return base::__make_ref(__p);}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long to_ulong() const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    unsigned long long to_ullong() const;
    template <class _CharT, class _Traits, class _Allocator>
        basic_string<_CharT, _Traits, _Allocator> to_string(_CharT __zero = _CharT('0'),
                                                            _CharT __one = _CharT('1')) const;
    template <class _CharT, class _Traits>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string<_CharT, _Traits, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                    _CharT __one = _CharT('1')) const;
    template <class _CharT>
        __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
        basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> > to_string(_CharT __zero = _CharT('0'),
                                                                                _CharT __one = _CharT('1')) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    basic_string<char, char_traits<char>, allocator<char> > to_string(char __zero = '0',
                                                                      char __one = '1') const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t count() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) constexpr size_t size() const noexcept {return _Size;}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator==(const bitset& __rhs) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool operator!=(const bitset& __rhs) const noexcept;
    bool test(size_t __pos) const;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool all() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bool any() const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage)) bool none() const noexcept {return !any();}
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator<<(size_t __pos) const noexcept;
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    bitset operator>>(size_t __pos) const noexcept;

private:

    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t __hash_code() const noexcept {return base::__hash_code();}

    friend struct hash<bitset>;
};

template <size_t _Size>
template<class _CharT, class>
bitset<_Size>::bitset(const _CharT* __str,
                      typename basic_string<_CharT>::size_type __n,
                      _CharT __zero, _CharT __one)
{
    size_t __rlen = std::__1::min(__n, char_traits<_CharT>::length(__str));
    for (size_t __i = 0; __i < __rlen; ++__i)
        if (__str[__i] != __zero && __str[__i] != __one)
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[_Mp - 1 - __i];
        (*this)[__i] = (__c == __one);
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
template<class _CharT, class _Traits, class _Allocator>
bitset<_Size>::bitset(const basic_string<_CharT,_Traits,_Allocator>& __str,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __pos,
       typename basic_string<_CharT,_Traits,_Allocator>::size_type __n,
       _CharT __zero, _CharT __one)
{
    if (__pos > __str.size())
        __throw_out_of_range("bitset string pos out of range");

    size_t __rlen = std::__1::min(__n, __str.size() - __pos);
    for (size_t __i = __pos; __i < __pos + __rlen; ++__i)
        if (!_Traits::eq(__str[__i], __zero) && !_Traits::eq(__str[__i], __one))
            __throw_invalid_argument("bitset string ctor has invalid argument");

    size_t _Mp = std::__1::min(__rlen, _Size);
    size_t __i = 0;
    for (; __i < _Mp; ++__i)
    {
        _CharT __c = __str[__pos + _Mp - 1 - __i];
        (*this)[__i] = _Traits::eq(__c, __one);
    }
    std::__1::fill(base::__make_iter(__i), base::__make_iter(_Size), false);
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator&=(const bitset& __rhs) noexcept
{
    base::operator&=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator|=(const bitset& __rhs) noexcept
{
    base::operator|=(__rhs);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::operator^=(const bitset& __rhs) noexcept
{
    base::operator^=(__rhs);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator<<=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy_backward(base::__make_iter(0), base::__make_iter(_Size - __pos), base::__make_iter(_Size));
    std::__1::fill_n(base::__make_iter(0), __pos, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::operator>>=(size_t __pos) noexcept
{
    __pos = std::__1::min(__pos, _Size);
    std::__1::copy(base::__make_iter(__pos), base::__make_iter(_Size), base::__make_iter(0));
    std::__1::fill_n(base::__make_iter(_Size - __pos), __pos, false);
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::set() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, true);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::set(size_t __pos, bool __val)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset set argument out of range");

    (*this)[__pos] = __val;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::reset() noexcept
{
    std::__1::fill_n(base::__make_iter(0), _Size, false);
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::reset(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset reset argument out of range");

    (*this)[__pos] = false;
    return *this;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator~() const noexcept
{
    bitset __x(*this);
    __x.flip();
    return __x;
}

template <size_t _Size>
inline
bitset<_Size>&
bitset<_Size>::flip() noexcept
{
    base::flip();
    return *this;
}

template <size_t _Size>
bitset<_Size>&
bitset<_Size>::flip(size_t __pos)
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset flip argument out of range");

    reference r = base::__make_ref(__pos);
    r = ~r;
    return *this;
}

template <size_t _Size>
inline
unsigned long
bitset<_Size>::to_ulong() const
{
    return base::to_ulong();
}

template <size_t _Size>
inline
unsigned long long
bitset<_Size>::to_ullong() const
{
    return base::to_ullong();
}

template <size_t _Size>
template <class _CharT, class _Traits, class _Allocator>
basic_string<_CharT, _Traits, _Allocator>
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    basic_string<_CharT, _Traits, _Allocator> __r(_Size, __zero);
    for (size_t __i = 0; __i < _Size; ++__i)
    {
        if ((*this)[__i])
            __r[_Size - 1 - __i] = __one;
    }
    return __r;
}

template <size_t _Size>
template <class _CharT, class _Traits>
inline
basic_string<_CharT, _Traits, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, _Traits, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
template <class _CharT>
inline
basic_string<_CharT, char_traits<_CharT>, allocator<_CharT> >
bitset<_Size>::to_string(_CharT __zero, _CharT __one) const
{
    return to_string<_CharT, char_traits<_CharT>, allocator<_CharT> >(__zero, __one);
}

template <size_t _Size>
inline
basic_string<char, char_traits<char>, allocator<char> >
bitset<_Size>::to_string(char __zero, char __one) const
{
    return to_string<char, char_traits<char>, allocator<char> >(__zero, __one);
}

template <size_t _Size>
inline
size_t
bitset<_Size>::count() const noexcept
{
    return static_cast<size_t>(std::__1::__count_bool_true(base::__make_iter(0), _Size));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator==(const bitset& __rhs) const noexcept
{
    return std::__1::equal(base::__make_iter(0), base::__make_iter(_Size), __rhs.__make_iter(0));
}

template <size_t _Size>
inline
bool
bitset<_Size>::operator!=(const bitset& __rhs) const noexcept
{
    return !(*this == __rhs);
}

template <size_t _Size>
bool
bitset<_Size>::test(size_t __pos) const
{
    if (__pos >= _Size)
        __throw_out_of_range("bitset test argument out of range");

    return (*this)[__pos];
}

template <size_t _Size>
inline
bool
bitset<_Size>::all() const noexcept
{
    return base::all();
}

template <size_t _Size>
inline
bool
bitset<_Size>::any() const noexcept
{
    return base::any();
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator<<(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r <<= __pos;
    return __r;
}

template <size_t _Size>
inline
bitset<_Size>
bitset<_Size>::operator>>(size_t __pos) const noexcept
{
    bitset __r = *this;
    __r >>= __pos;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator&(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r &= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator|(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r |= __y;
    return __r;
}

template <size_t _Size>
inline __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
bitset<_Size>
operator^(const bitset<_Size>& __x, const bitset<_Size>& __y) noexcept
{
    bitset<_Size> __r = __x;
    __r ^= __y;
    return __r;
}

template <size_t _Size>
struct __attribute__ ((__type_visibility__("default"))) hash<bitset<_Size> >
    : public unary_function<bitset<_Size>, size_t>
{
    __attribute__ ((__visibility__("hidden"))) __attribute__ ((internal_linkage))
    size_t operator()(const bitset<_Size>& __bs) const noexcept
        {return __bs.__hash_code();}
};

template <class _CharT, class _Traits, size_t _Size>
basic_istream<_CharT, _Traits>&
operator>>(basic_istream<_CharT, _Traits>& __is, bitset<_Size>& __x);

template <class _CharT, class _Traits, size_t _Size>
basic_ostream<_CharT, _Traits>&
operator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x);

} }
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 2




# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/enum-set.h" 2

namespace Fortran::common {

template <typename ENUM, std::size_t BITS> class EnumSet {
  static_assert(BITS > 0);

public:


  using bitsetType =
      std::conditional_t<(BITS <= 64), common::BitSet<BITS>, std::bitset<BITS>>;
  using enumerationType = ENUM;

  constexpr EnumSet() {}
  constexpr EnumSet(const std::initializer_list<enumerationType> &enums) {
    for (auto it{enums.begin()}; it != enums.end(); ++it) {
      set(*it);
    }
  }
  constexpr EnumSet(const EnumSet &) = default;
  constexpr EnumSet(EnumSet &&) = default;

  constexpr EnumSet &operator=(const EnumSet &) = default;
  constexpr EnumSet &operator=(EnumSet &&) = default;

  const bitsetType &bitset() const { return bitset_; }

  constexpr EnumSet &operator&=(const EnumSet &that) {
    bitset_ &= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator&=(EnumSet &&that) {
    bitset_ &= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator|=(const EnumSet &that) {
    bitset_ |= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator|=(EnumSet &&that) {
    bitset_ |= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator^=(const EnumSet &that) {
    bitset_ ^= that.bitset_;
    return *this;
  }
  constexpr EnumSet &operator^=(EnumSet &&that) {
    bitset_ ^= that.bitset_;
    return *this;
  }

  constexpr EnumSet operator~() const {
    EnumSet result;
    result.bitset_ = ~bitset_;
    return result;
  }
  constexpr EnumSet operator&(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ &= that.bitset_;
    return result;
  }
  constexpr EnumSet operator&(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ &= that.bitset_;
    return result;
  }
  constexpr EnumSet operator|(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ |= that.bitset_;
    return result;
  }
  constexpr EnumSet operator|(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ |= that.bitset_;
    return result;
  }
  constexpr EnumSet operator^(const EnumSet &that) const {
    EnumSet result{*this};
    result.bitset_ ^= that.bitset_;
    return result;
  }
  constexpr EnumSet operator^(EnumSet &&that) const {
    EnumSet result{*this};
    result.bitset_ ^= that.bitset_;
    return result;
  }

  constexpr EnumSet operator+(enumerationType v) const {
    return {*this | EnumSet{v}};
  }
  constexpr EnumSet operator-(enumerationType v) const {
    return {*this & ~EnumSet{v}};
  }

  constexpr bool operator==(const EnumSet &that) const {
    return bitset_ == that.bitset_;
  }
  constexpr bool operator==(EnumSet &&that) const {
    return bitset_ == that.bitset_;
  }
  constexpr bool operator!=(const EnumSet &that) const {
    return bitset_ != that.bitset_;
  }
  constexpr bool operator!=(EnumSet &&that) const {
    return bitset_ != that.bitset_;
  }



  static constexpr std::size_t max_size() { return BITS; }
  constexpr bool test(enumerationType x) const {
    return bitset_.test(static_cast<std::size_t>(x));
  }
  constexpr bool all() const { return bitset_.all(); }
  constexpr bool any() const { return bitset_.any(); }
  constexpr bool none() const { return bitset_.none(); }



  constexpr std::size_t count() const { return bitset_.count(); }
  constexpr std::size_t count(enumerationType x) const {
    return test(x) ? 1 : 0;
  }

  constexpr EnumSet &set() {
    bitset_.set();
    return *this;
  }
  constexpr EnumSet &set(enumerationType x, bool value = true) {
    bitset_.set(static_cast<std::size_t>(x), value);
    return *this;
  }
  constexpr EnumSet &reset() {
    bitset_.reset();
    return *this;
  }
  constexpr EnumSet &reset(enumerationType x) {
    bitset_.reset(static_cast<std::size_t>(x));
    return *this;
  }
  constexpr EnumSet &flip() {
    bitset_.flip();
    return *this;
  }
  constexpr EnumSet &flip(enumerationType x) {
    bitset_.flip(static_cast<std::size_t>(x));
    return *this;
  }

  constexpr bool empty() const { return none(); }
  void clear() { reset(); }
  void insert(enumerationType x) { set(x); }
  void insert(enumerationType &&x) { set(x); }
  void emplace(enumerationType &&x) { set(x); }
  void erase(enumerationType x) { reset(x); }
  void erase(enumerationType &&x) { reset(x); }

  constexpr std::optional<enumerationType> LeastElement() const {
    if (empty()) {
      return std::nullopt;
    } else if constexpr (std::is_same_v<bitsetType, common::BitSet<BITS>>) {
      return {static_cast<enumerationType>(bitset_.LeastElement().value())};
    } else {

      for (std::size_t j{0}; j < BITS; ++j) {
        auto enumerator{static_cast<enumerationType>(j)};
        if (bitset_.test(j)) {
          return {enumerator};
        }
      }
      die("EnumSet::LeastElement(): no bit found in non-empty std::bitset");
    }
  }

  template <typename FUNC> void IterateOverMembers(const FUNC &f) const {
    EnumSet copy{*this};
    while (auto least{copy.LeastElement()}) {
      f(*least);
      copy.erase(*least);
    }
  }

  template <typename STREAM>
  STREAM &Dump(
      STREAM &o, std::string_view EnumToString(enumerationType)) const {
    char sep{'{'};
    IterateOverMembers([&](auto e) {
      o << sep << EnumToString(e);
      sep = ',';
    });
    return o << (sep == '{' ? "{}" : "}");
  }

private:
  bitsetType bitset_{};
};
}

template <typename ENUM, std::size_t values>
struct std::hash<Fortran::common::EnumSet<ENUM, values>> {
  std::size_t operator()(
      const Fortran::common::EnumSet<ENUM, values> &x) const {
    return std::hash(x.bitset());
  }
};
# 16 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran.h" 2





namespace Fortran::common {


enum class TypeCategory { Integer, Real, Complex, Character, Logical, Derived }; [[maybe_unused]] static constexpr std::size_t TypeCategory_enumSize{ ::Fortran::common::CountEnumNames("Integer, Real, Complex, Character, Logical, Derived")}; [[maybe_unused]] static inline std::string_view EnumToString(TypeCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<TypeCategory_enumSize>("Integer, Real, Complex, Character, Logical, Derived")}; return names[static_cast<std::size_t>(e)]; }
enum class VectorElementCategory { Integer, Unsigned, Real }; [[maybe_unused]] static constexpr std::size_t VectorElementCategory_enumSize{ ::Fortran::common::CountEnumNames("Integer, Unsigned, Real")}; [[maybe_unused]] static inline std::string_view EnumToString(VectorElementCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<VectorElementCategory_enumSize>("Integer, Unsigned, Real")}; return names[static_cast<std::size_t>(e)]; }

constexpr bool IsNumericTypeCategory(TypeCategory category) {
  return category == TypeCategory::Integer || category == TypeCategory::Real ||
      category == TypeCategory::Complex;
}


enum class ImportKind { Default, Only, None, All }; [[maybe_unused]] static constexpr std::size_t ImportKind_enumSize{ ::Fortran::common::CountEnumNames("Default, Only, None, All")}; [[maybe_unused]] static inline std::string_view EnumToString(ImportKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImportKind_enumSize>("Default, Only, None, All")}; return names[static_cast<std::size_t>(e)]; }


enum class TypeParamAttr { Kind, Len }; [[maybe_unused]] static constexpr std::size_t TypeParamAttr_enumSize{ ::Fortran::common::CountEnumNames("Kind, Len")}; [[maybe_unused]] static inline std::string_view EnumToString(TypeParamAttr e) { static const constexpr auto names{ ::Fortran::common::EnumNames<TypeParamAttr_enumSize>("Kind, Len")}; return names[static_cast<std::size_t>(e)]; }

enum class NumericOperator { Power, Multiply, Divide, Add, Subtract }; [[maybe_unused]] static constexpr std::size_t NumericOperator_enumSize{ ::Fortran::common::CountEnumNames("Power, Multiply, Divide, Add, Subtract")}; [[maybe_unused]] static inline std::string_view EnumToString(NumericOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<NumericOperator_enumSize>("Power, Multiply, Divide, Add, Subtract")}; return names[static_cast<std::size_t>(e)]; }
const char *AsFortran(NumericOperator);

enum class LogicalOperator { And, Or, Eqv, Neqv, Not }; [[maybe_unused]] static constexpr std::size_t LogicalOperator_enumSize{ ::Fortran::common::CountEnumNames("And, Or, Eqv, Neqv, Not")}; [[maybe_unused]] static inline std::string_view EnumToString(LogicalOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<LogicalOperator_enumSize>("And, Or, Eqv, Neqv, Not")}; return names[static_cast<std::size_t>(e)]; }
const char *AsFortran(LogicalOperator);

enum class RelationalOperator { LT, LE, EQ, NE, GE, GT }; [[maybe_unused]] static constexpr std::size_t RelationalOperator_enumSize{ ::Fortran::common::CountEnumNames("LT, LE, EQ, NE, GE, GT")}; [[maybe_unused]] static inline std::string_view EnumToString(RelationalOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<RelationalOperator_enumSize>("LT, LE, EQ, NE, GE, GT")}; return names[static_cast<std::size_t>(e)]; }
const char *AsFortran(RelationalOperator);

enum class Intent { Default, In, Out, InOut }; [[maybe_unused]] static constexpr std::size_t Intent_enumSize{ ::Fortran::common::CountEnumNames("Default, In, Out, InOut")}; [[maybe_unused]] static inline std::string_view EnumToString(Intent e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Intent_enumSize>("Default, In, Out, InOut")}; return names[static_cast<std::size_t>(e)]; }

enum class IoStmtKind { None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write }; [[maybe_unused]] static constexpr std::size_t IoStmtKind_enumSize{ ::Fortran::common::CountEnumNames("None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write")}; [[maybe_unused]] static inline std::string_view EnumToString(IoStmtKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IoStmtKind_enumSize>("None, Backspace, Close, Endfile, Flush, Inquire, Open, Print, Read, Rewind, Wait, Write")}; return names[static_cast<std::size_t>(e)]; }



enum class IoSpecKind { Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose, }; [[maybe_unused]] static constexpr std::size_t IoSpecKind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose,")}; [[maybe_unused]] static inline std::string_view EnumToString(IoSpecKind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IoSpecKind_enumSize>("Access, Action, Advance, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, End, Eor, Err, Exist, File, Fmt, Form, Formatted, Id, Iomsg, Iostat, Name, Named, Newunit, Nextrec, Nml, Number, Opened, Pad, Pending, Pos, Position, Read, Readwrite, Rec, Recl, Round, Sequential, Sign, Size, Status, Stream, Unformatted, Unit, Write, Carriagecontrol, Convert, Dispose,")}; return names[static_cast<std::size_t>(e)]; }
# 64 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/Fortran.h"
enum class DefinedIo { ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted }; [[maybe_unused]] static constexpr std::size_t DefinedIo_enumSize{ ::Fortran::common::CountEnumNames("ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted")}; [[maybe_unused]] static inline std::string_view EnumToString(DefinedIo e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DefinedIo_enumSize>("ReadFormatted, ReadUnformatted, WriteFormatted, WriteUnformatted")}; return names[static_cast<std::size_t>(e)]; }

const char *AsFortran(DefinedIo);



enum class RoundingMode : std::uint8_t {
  TiesToEven,
  ToZero,
  Down,
  Up,
  TiesAwayFromZero,
};


using Label = std::uint64_t;


static constexpr int maxRank{15};


enum class CUDASubprogramAttrs { Host, Device, HostDevice, Global, Grid_Global }; [[maybe_unused]] static constexpr std::size_t CUDASubprogramAttrs_enumSize{ ::Fortran::common::CountEnumNames("Host, Device, HostDevice, Global, Grid_Global")}; [[maybe_unused]] static inline std::string_view EnumToString(CUDASubprogramAttrs e) { static const constexpr auto names{ ::Fortran::common::EnumNames<CUDASubprogramAttrs_enumSize>("Host, Device, HostDevice, Global, Grid_Global")}; return names[static_cast<std::size_t>(e)]; }


enum class CUDADataAttr { Constant, Device, Managed, Pinned, Shared, Texture }; [[maybe_unused]] static constexpr std::size_t CUDADataAttr_enumSize{ ::Fortran::common::CountEnumNames("Constant, Device, Managed, Pinned, Shared, Texture")}; [[maybe_unused]] static inline std::string_view EnumToString(CUDADataAttr e) { static const constexpr auto names{ ::Fortran::common::EnumNames<CUDADataAttr_enumSize>("Constant, Device, Managed, Pinned, Shared, Texture")}; return names[static_cast<std::size_t>(e)]; }


enum class OmpAtomicDefaultMemOrderType { SeqCst, AcqRel, Relaxed }; [[maybe_unused]] static constexpr std::size_t OmpAtomicDefaultMemOrderType_enumSize{ ::Fortran::common::CountEnumNames("SeqCst, AcqRel, Relaxed")}; [[maybe_unused]] static inline std::string_view EnumToString(OmpAtomicDefaultMemOrderType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<OmpAtomicDefaultMemOrderType_enumSize>("SeqCst, AcqRel, Relaxed")}; return names[static_cast<std::size_t>(e)]; }


static constexpr int maxNameLen{63};



enum class IgnoreTKR { Type, Kind, Rank, Device, Managed, Contiguous }; [[maybe_unused]] static constexpr std::size_t IgnoreTKR_enumSize{ ::Fortran::common::CountEnumNames("Type, Kind, Rank, Device, Managed, Contiguous")}; [[maybe_unused]] static inline std::string_view EnumToString(IgnoreTKR e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IgnoreTKR_enumSize>("Type, Kind, Rank, Device, Managed, Contiguous")}; return names[static_cast<std::size_t>(e)]; }







using IgnoreTKRSet = EnumSet<IgnoreTKR, 8>;

static constexpr IgnoreTKRSet ignoreTKRAll{IgnoreTKR::Type, IgnoreTKR::Kind,
    IgnoreTKR::Rank, IgnoreTKR::Device, IgnoreTKR::Managed};
std::string AsFortran(IgnoreTKRSet);

bool AreCompatibleCUDADataAttrs(
    std::optional<CUDADataAttr>, std::optional<CUDADataAttr>, IgnoreTKRSet);

static constexpr char blankCommonObjectName[] = "__BLNK__";



inline std::string GetExternalAssemblyName(
    std::string symbolName, bool underscoring) {
  return underscoring ? std::move(symbolName) + "_" : std::move(symbolName);
}

}
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" 1
# 24 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 25 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 26 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" 2


namespace Fortran::common {


template <typename A, bool COPY = false> class Indirection {
public:
  using element_type = A;
  Indirection() = delete;
  Indirection(A *&&p) : p_{p} {
    ((p_ && "assigning null pointer to Indirection") || (Fortran::common::die("CHECK(" "p_ && \"assigning null pointer to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 36), false));
    p = nullptr;
  }
  Indirection(A &&x) : p_{new A(std::move(x))} {}
  Indirection(Indirection &&that) : p_{that.p_} {
    ((p_ && "move construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "p_ && \"move construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 41), false));
    that.p_ = nullptr;
  }
  ~Indirection() {
    delete p_;
    p_ = nullptr;
  }
  Indirection &operator=(Indirection &&that) {
    ((that.p_ && "move assignment of null Indirection to Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"move assignment of null Indirection to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 49), false));
    auto tmp{p_};
    p_ = that.p_;
    that.p_ = tmp;
    return *this;
  }

  A &value() { return *p_; }
  const A &value() const { return *p_; }

  bool operator==(const A &that) const { return *p_ == that; }
  bool operator==(const Indirection &that) const { return *p_ == *that.p_; }

  template <typename... ARGS>
  static common::IfNoLvalue<Indirection, ARGS...> Make(ARGS &&...args) {
    return {new A(std::move(args)...)};
  }

private:
  A *p_{nullptr};
};


template <typename A> class Indirection<A, true> {
public:
  using element_type = A;

  Indirection() = delete;
  Indirection(A *&&p) : p_{p} {
    ((p_ && "assigning null pointer to Indirection") || (Fortran::common::die("CHECK(" "p_ && \"assigning null pointer to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 78), false));
    p = nullptr;
  }
  Indirection(const A &x) : p_{new A(x)} {}
  Indirection(A &&x) : p_{new A(std::move(x))} {}
  Indirection(const Indirection &that) {
    ((that.p_ && "copy construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"copy construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 84), false));
    p_ = new A(*that.p_);
  }
  Indirection(Indirection &&that) : p_{that.p_} {
    ((p_ && "move construction of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "p_ && \"move construction of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 88), false));
    that.p_ = nullptr;
  }
  ~Indirection() {
    delete p_;
    p_ = nullptr;
  }
  Indirection &operator=(const Indirection &that) {
    ((that.p_ && "copy assignment of Indirection from null Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"copy assignment of Indirection from null Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 96), false));
    *p_ = *that.p_;
    return *this;
  }
  Indirection &operator=(Indirection &&that) {
    ((that.p_ && "move assignment of null Indirection to Indirection") || (Fortran::common::die("CHECK(" "that.p_ && \"move assignment of null Indirection to Indirection\"" ") failed" " at " "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Common/indirection.h" "(%d)", 101), false));
    auto tmp{p_};
    p_ = that.p_;
    that.p_ = tmp;
    return *this;
  }

  A &value() { return *p_; }
  const A &value() const { return *p_; }

  bool operator==(const A &that) const { return *p_ == that; }
  bool operator==(const Indirection &that) const { return *p_ == *that.p_; }

  template <typename... ARGS>
  static common::IfNoLvalue<Indirection, ARGS...> Make(ARGS &&...args) {
    return {new A(std::move(args)...)};
  }

private:
  A *p_{nullptr};
};

template <typename A> using CopyableIndirection = Indirection<A, true>;



template <typename A> class ForwardOwningPointer {
public:
  ForwardOwningPointer() {}
  ForwardOwningPointer(A *p, void (*del)(A *)) : p_{p}, deleter_{del} {}
  ForwardOwningPointer(ForwardOwningPointer &&that)
      : p_{that.p_}, deleter_{that.deleter_} {
    that.p_ = nullptr;
  }
  ForwardOwningPointer &operator=(ForwardOwningPointer &&that) {
    p_ = that.p_;
    that.p_ = nullptr;
    deleter_ = that.deleter_;
    return *this;
  }
  ~ForwardOwningPointer() {
    if (p_) {
      deleter_(p_);
    }
  }

  A &operator*() const { return *p_; }
  A *operator->() const { return p_; }
  operator bool() const { return p_ != nullptr; }
  A *get() { return p_; }
  auto get() const { return reinterpret_cast<std::add_const_t<A> *>(p_); }
  A *release() {
    A *result{p_};
    p_ = nullptr;
    return result;
  }

  void Reset(A *p = nullptr) {
    if (p_) {
      deleter_(p_);
    }
    p_ = p;
  }
  void Reset(A *p, void (*del)(A *)) {
    Reset(p);
    deleter_ = del;
  }

private:
  A *p_{nullptr};
  void (*deleter_)(A *){nullptr};
};
}
# 28 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 1



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h" 1
# 12 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h"
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 13 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h" 2
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 14 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h" 2
# 94 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/ADT/BitmaskEnum.h"
namespace llvm {



template <typename E, typename Enable = void>
struct is_bitmask_enum : std::false_type {};

template <typename E>
struct is_bitmask_enum<
    E, std::enable_if_t<sizeof(E::LLVM_BITMASK_LARGEST_ENUMERATOR) >= 0>>
    : std::true_type {};


template <typename E, typename Enable = void> struct largest_bitmask_enum_bit;

template <typename E>
struct largest_bitmask_enum_bit<
    E, std::enable_if_t<sizeof(E::LLVM_BITMASK_LARGEST_ENUMERATOR) >= 0>> {
  using UnderlyingTy = std::underlying_type_t<E>;
  static constexpr UnderlyingTy value =
      static_cast<UnderlyingTy>(E::LLVM_BITMASK_LARGEST_ENUMERATOR);
};

namespace BitmaskEnumDetail {



template <typename E> constexpr std::underlying_type_t<E> Mask() {


  return NextPowerOf2(largest_bitmask_enum_bit<E>::value) - 1;
}



template <typename E> constexpr std::underlying_type_t<E> Underlying(E Val) {
  auto U = llvm::to_underlying(Val);
  (__builtin_expect(!(U >= 0 && "Negative enum values are not allowed."), 0) ? __assert_rtn(__func__, "BitmaskEnum.h", 131, "U >= 0 && \"Negative enum values are not allowed.\"") : (void)0);
  (__builtin_expect(!(U <= Mask<E>() && "Enum value too large (or largest val too small?)"), 0) ? __assert_rtn(__func__, "BitmaskEnum.h", 132, "U <= Mask<E>() && \"Enum value too large (or largest val too small?)\"") : (void)0);
  return U;
}

constexpr unsigned bitWidth(uint64_t Value) {
  return Value ? 1 + bitWidth(Value >> 1) : 0;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr bool any(E Val) {
  return Val != static_cast<E>(0);
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator~(E Val) {
  return static_cast<E>(~Underlying(Val) & Mask<E>());
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator|(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) | Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator&(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) & Underlying(RHS));
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr E operator^(E LHS, E RHS) {
  return static_cast<E>(Underlying(LHS) ^ Underlying(RHS));
}




template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator|=(E &LHS, E RHS) {
  LHS = LHS | RHS;
  return LHS;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator&=(E &LHS, E RHS) {
  LHS = LHS & RHS;
  return LHS;
}

template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
E &operator^=(E &LHS, E RHS) {
  LHS = LHS ^ RHS;
  return LHS;
}

}


using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::any;
template <typename E, typename = std::enable_if_t<is_bitmask_enum<E>::value>>
constexpr unsigned BitWidth = BitmaskEnumDetail::bitWidth(
    uint64_t{llvm::to_underlying(E::LLVM_BITMASK_LARGEST_ENUMERATOR)});

}
# 5 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.h.inc" 2

namespace llvm {
class StringRef;
namespace acc {

using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::any;

enum class Directive {
  ACCD_atomic,
  ACCD_cache,
  ACCD_data,
  ACCD_declare,
  ACCD_enter_data,
  ACCD_exit_data,
  ACCD_host_data,
  ACCD_init,
  ACCD_kernels,
  ACCD_kernels_loop,
  ACCD_loop,
  ACCD_parallel,
  ACCD_parallel_loop,
  ACCD_routine,
  ACCD_serial,
  ACCD_serial_loop,
  ACCD_set,
  ACCD_shutdown,
  ACCD_unknown,
  ACCD_update,
  ACCD_wait,
};

static constexpr std::size_t Directive_enumSize = 21;

constexpr auto ACCD_atomic = llvm::acc::Directive::ACCD_atomic;
constexpr auto ACCD_cache = llvm::acc::Directive::ACCD_cache;
constexpr auto ACCD_data = llvm::acc::Directive::ACCD_data;
constexpr auto ACCD_declare = llvm::acc::Directive::ACCD_declare;
constexpr auto ACCD_enter_data = llvm::acc::Directive::ACCD_enter_data;
constexpr auto ACCD_exit_data = llvm::acc::Directive::ACCD_exit_data;
constexpr auto ACCD_host_data = llvm::acc::Directive::ACCD_host_data;
constexpr auto ACCD_init = llvm::acc::Directive::ACCD_init;
constexpr auto ACCD_kernels = llvm::acc::Directive::ACCD_kernels;
constexpr auto ACCD_kernels_loop = llvm::acc::Directive::ACCD_kernels_loop;
constexpr auto ACCD_loop = llvm::acc::Directive::ACCD_loop;
constexpr auto ACCD_parallel = llvm::acc::Directive::ACCD_parallel;
constexpr auto ACCD_parallel_loop = llvm::acc::Directive::ACCD_parallel_loop;
constexpr auto ACCD_routine = llvm::acc::Directive::ACCD_routine;
constexpr auto ACCD_serial = llvm::acc::Directive::ACCD_serial;
constexpr auto ACCD_serial_loop = llvm::acc::Directive::ACCD_serial_loop;
constexpr auto ACCD_set = llvm::acc::Directive::ACCD_set;
constexpr auto ACCD_shutdown = llvm::acc::Directive::ACCD_shutdown;
constexpr auto ACCD_unknown = llvm::acc::Directive::ACCD_unknown;
constexpr auto ACCD_update = llvm::acc::Directive::ACCD_update;
constexpr auto ACCD_wait = llvm::acc::Directive::ACCD_wait;

enum class Clause {
  ACCC_async,
  ACCC_attach,
  ACCC_auto,
  ACCC_bind,
  ACCC_capture,
  ACCC_collapse,
  ACCC_copy,
  ACCC_copyin,
  ACCC_copyout,
  ACCC_create,
  ACCC_default,
  ACCC_default_async,
  ACCC_delete,
  ACCC_detach,
  ACCC_device,
  ACCC_device_num,
  ACCC_deviceptr,
  ACCC_device_resident,
  ACCC_device_type,
  ACCC_finalize,
  ACCC_firstprivate,
  ACCC_gang,
  ACCC_host,
  ACCC_if,
  ACCC_if_present,
  ACCC_independent,
  ACCC_link,
  ACCC_no_create,
  ACCC_nohost,
  ACCC_num_gangs,
  ACCC_num_workers,
  ACCC_present,
  ACCC_private,
  ACCC_read,
  ACCC_reduction,
  ACCC_self,
  ACCC_seq,
  ACCC_tile,
  ACCC_unknown,
  ACCC_use_device,
  ACCC_vector,
  ACCC_vector_length,
  ACCC_wait,
  ACCC_worker,
  ACCC_write,
};

static constexpr std::size_t Clause_enumSize = 45;

constexpr auto ACCC_async = llvm::acc::Clause::ACCC_async;
constexpr auto ACCC_attach = llvm::acc::Clause::ACCC_attach;
constexpr auto ACCC_auto = llvm::acc::Clause::ACCC_auto;
constexpr auto ACCC_bind = llvm::acc::Clause::ACCC_bind;
constexpr auto ACCC_capture = llvm::acc::Clause::ACCC_capture;
constexpr auto ACCC_collapse = llvm::acc::Clause::ACCC_collapse;
constexpr auto ACCC_copy = llvm::acc::Clause::ACCC_copy;
constexpr auto ACCC_copyin = llvm::acc::Clause::ACCC_copyin;
constexpr auto ACCC_copyout = llvm::acc::Clause::ACCC_copyout;
constexpr auto ACCC_create = llvm::acc::Clause::ACCC_create;
constexpr auto ACCC_default = llvm::acc::Clause::ACCC_default;
constexpr auto ACCC_default_async = llvm::acc::Clause::ACCC_default_async;
constexpr auto ACCC_delete = llvm::acc::Clause::ACCC_delete;
constexpr auto ACCC_detach = llvm::acc::Clause::ACCC_detach;
constexpr auto ACCC_device = llvm::acc::Clause::ACCC_device;
constexpr auto ACCC_device_num = llvm::acc::Clause::ACCC_device_num;
constexpr auto ACCC_deviceptr = llvm::acc::Clause::ACCC_deviceptr;
constexpr auto ACCC_device_resident = llvm::acc::Clause::ACCC_device_resident;
constexpr auto ACCC_device_type = llvm::acc::Clause::ACCC_device_type;
constexpr auto ACCC_finalize = llvm::acc::Clause::ACCC_finalize;
constexpr auto ACCC_firstprivate = llvm::acc::Clause::ACCC_firstprivate;
constexpr auto ACCC_gang = llvm::acc::Clause::ACCC_gang;
constexpr auto ACCC_host = llvm::acc::Clause::ACCC_host;
constexpr auto ACCC_if = llvm::acc::Clause::ACCC_if;
constexpr auto ACCC_if_present = llvm::acc::Clause::ACCC_if_present;
constexpr auto ACCC_independent = llvm::acc::Clause::ACCC_independent;
constexpr auto ACCC_link = llvm::acc::Clause::ACCC_link;
constexpr auto ACCC_no_create = llvm::acc::Clause::ACCC_no_create;
constexpr auto ACCC_nohost = llvm::acc::Clause::ACCC_nohost;
constexpr auto ACCC_num_gangs = llvm::acc::Clause::ACCC_num_gangs;
constexpr auto ACCC_num_workers = llvm::acc::Clause::ACCC_num_workers;
constexpr auto ACCC_present = llvm::acc::Clause::ACCC_present;
constexpr auto ACCC_private = llvm::acc::Clause::ACCC_private;
constexpr auto ACCC_read = llvm::acc::Clause::ACCC_read;
constexpr auto ACCC_reduction = llvm::acc::Clause::ACCC_reduction;
constexpr auto ACCC_self = llvm::acc::Clause::ACCC_self;
constexpr auto ACCC_seq = llvm::acc::Clause::ACCC_seq;
constexpr auto ACCC_tile = llvm::acc::Clause::ACCC_tile;
constexpr auto ACCC_unknown = llvm::acc::Clause::ACCC_unknown;
constexpr auto ACCC_use_device = llvm::acc::Clause::ACCC_use_device;
constexpr auto ACCC_vector = llvm::acc::Clause::ACCC_vector;
constexpr auto ACCC_vector_length = llvm::acc::Clause::ACCC_vector_length;
constexpr auto ACCC_wait = llvm::acc::Clause::ACCC_wait;
constexpr auto ACCC_worker = llvm::acc::Clause::ACCC_worker;
constexpr auto ACCC_write = llvm::acc::Clause::ACCC_write;

enum class DefaultValue {
  ACC_Default_present=0,
  ACC_Default_none=1,
};

constexpr auto ACC_Default_present = llvm::acc::DefaultValue::ACC_Default_present;
constexpr auto ACC_Default_none = llvm::acc::DefaultValue::ACC_Default_none;


Directive getOpenACCDirectiveKind(llvm::StringRef Str);

llvm::StringRef getOpenACCDirectiveName(Directive D);

Clause getOpenACCClauseKind(llvm::StringRef Str);

llvm::StringRef getOpenACCClauseName(Clause C);


bool isAllowedClauseForDirective(Directive D, Clause C, unsigned Version);

DefaultValue getDefaultValue(StringRef);
llvm::StringRef getOpenACCDefaultValueName(DefaultValue);

}
}
# 29 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 1
# 20 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h"
# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.h.inc" 1





namespace llvm {
class StringRef;
namespace omp {

using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::any;

enum class Directive {
  OMPD_allocate,
  OMPD_allocators,
  OMPD_assumes,
  OMPD_atomic,
  OMPD_barrier,
  OMPD_begin_assumes,
  OMPD_begin_declare_target,
  OMPD_begin_declare_variant,
  OMPD_cancel,
  OMPD_cancellation_point,
  OMPD_critical,
  OMPD_declare_mapper,
  OMPD_declare_reduction,
  OMPD_declare_simd,
  OMPD_declare_target,
  OMPD_declare_variant,
  OMPD_depobj,
  OMPD_distribute,
  OMPD_distribute_parallel_do,
  OMPD_distribute_parallel_do_simd,
  OMPD_distribute_parallel_for,
  OMPD_distribute_parallel_for_simd,
  OMPD_distribute_simd,
  OMPD_do,
  OMPD_do_simd,
  OMPD_end_assumes,
  OMPD_end_declare_target,
  OMPD_end_declare_variant,
  OMPD_end_do,
  OMPD_end_do_simd,
  OMPD_end_sections,
  OMPD_end_single,
  OMPD_end_workshare,
  OMPD_error,
  OMPD_flush,
  OMPD_for,
  OMPD_for_simd,
  OMPD_masked_taskloop,
  OMPD_masked_taskloop_simd,
  OMPD_master,
  OMPD_master_taskloop,
  OMPD_master_taskloop_simd,
  OMPD_metadirective,
  OMPD_nothing,
  OMPD_ordered,
  OMPD_parallel,
  OMPD_parallel_do,
  OMPD_parallel_do_simd,
  OMPD_parallel_for,
  OMPD_parallel_for_simd,
  OMPD_parallel_masked,
  OMPD_parallel_masked_taskloop,
  OMPD_parallel_masked_taskloop_simd,
  OMPD_parallel_master,
  OMPD_parallel_master_taskloop,
  OMPD_parallel_master_taskloop_simd,
  OMPD_parallel_sections,
  OMPD_parallel_workshare,
  OMPD_requires,
  OMPD_scan,
  OMPD_section,
  OMPD_sections,
  OMPD_simd,
  OMPD_single,
  OMPD_target,
  OMPD_target_data,
  OMPD_target_enter_data,
  OMPD_target_exit_data,
  OMPD_target_parallel,
  OMPD_target_parallel_do,
  OMPD_target_parallel_do_simd,
  OMPD_target_parallel_for,
  OMPD_target_parallel_for_simd,
  OMPD_target_simd,
  OMPD_target_teams,
  OMPD_target_teams_distribute,
  OMPD_target_teams_distribute_parallel_do,
  OMPD_target_teams_distribute_parallel_do_simd,
  OMPD_target_teams_distribute_parallel_for,
  OMPD_target_teams_distribute_parallel_for_simd,
  OMPD_target_teams_distribute_simd,
  OMPD_target_update,
  OMPD_task,
  OMPD_taskgroup,
  OMPD_taskloop,
  OMPD_taskloop_simd,
  OMPD_taskwait,
  OMPD_taskyield,
  OMPD_teams,
  OMPD_teams_distribute,
  OMPD_teams_distribute_parallel_do,
  OMPD_teams_distribute_parallel_do_simd,
  OMPD_teams_distribute_parallel_for,
  OMPD_teams_distribute_parallel_for_simd,
  OMPD_teams_distribute_simd,
  OMPD_threadprivate,
  OMPD_tile,
  OMPD_unknown,
  OMPD_unroll,
  OMPD_workshare,
  OMPD_dispatch,
  OMPD_interop,
  OMPD_loop,
  OMPD_masked,
  OMPD_parallel_loop,
  OMPD_scope,
  OMPD_target_parallel_loop,
  OMPD_target_teams_loop,
  OMPD_teams_loop,
};

static constexpr std::size_t Directive_enumSize = 109;

constexpr auto OMPD_allocate = llvm::omp::Directive::OMPD_allocate;
constexpr auto OMPD_allocators = llvm::omp::Directive::OMPD_allocators;
constexpr auto OMPD_assumes = llvm::omp::Directive::OMPD_assumes;
constexpr auto OMPD_atomic = llvm::omp::Directive::OMPD_atomic;
constexpr auto OMPD_barrier = llvm::omp::Directive::OMPD_barrier;
constexpr auto OMPD_begin_assumes = llvm::omp::Directive::OMPD_begin_assumes;
constexpr auto OMPD_begin_declare_target = llvm::omp::Directive::OMPD_begin_declare_target;
constexpr auto OMPD_begin_declare_variant = llvm::omp::Directive::OMPD_begin_declare_variant;
constexpr auto OMPD_cancel = llvm::omp::Directive::OMPD_cancel;
constexpr auto OMPD_cancellation_point = llvm::omp::Directive::OMPD_cancellation_point;
constexpr auto OMPD_critical = llvm::omp::Directive::OMPD_critical;
constexpr auto OMPD_declare_mapper = llvm::omp::Directive::OMPD_declare_mapper;
constexpr auto OMPD_declare_reduction = llvm::omp::Directive::OMPD_declare_reduction;
constexpr auto OMPD_declare_simd = llvm::omp::Directive::OMPD_declare_simd;
constexpr auto OMPD_declare_target = llvm::omp::Directive::OMPD_declare_target;
constexpr auto OMPD_declare_variant = llvm::omp::Directive::OMPD_declare_variant;
constexpr auto OMPD_depobj = llvm::omp::Directive::OMPD_depobj;
constexpr auto OMPD_distribute = llvm::omp::Directive::OMPD_distribute;
constexpr auto OMPD_distribute_parallel_do = llvm::omp::Directive::OMPD_distribute_parallel_do;
constexpr auto OMPD_distribute_parallel_do_simd = llvm::omp::Directive::OMPD_distribute_parallel_do_simd;
constexpr auto OMPD_distribute_parallel_for = llvm::omp::Directive::OMPD_distribute_parallel_for;
constexpr auto OMPD_distribute_parallel_for_simd = llvm::omp::Directive::OMPD_distribute_parallel_for_simd;
constexpr auto OMPD_distribute_simd = llvm::omp::Directive::OMPD_distribute_simd;
constexpr auto OMPD_do = llvm::omp::Directive::OMPD_do;
constexpr auto OMPD_do_simd = llvm::omp::Directive::OMPD_do_simd;
constexpr auto OMPD_end_assumes = llvm::omp::Directive::OMPD_end_assumes;
constexpr auto OMPD_end_declare_target = llvm::omp::Directive::OMPD_end_declare_target;
constexpr auto OMPD_end_declare_variant = llvm::omp::Directive::OMPD_end_declare_variant;
constexpr auto OMPD_end_do = llvm::omp::Directive::OMPD_end_do;
constexpr auto OMPD_end_do_simd = llvm::omp::Directive::OMPD_end_do_simd;
constexpr auto OMPD_end_sections = llvm::omp::Directive::OMPD_end_sections;
constexpr auto OMPD_end_single = llvm::omp::Directive::OMPD_end_single;
constexpr auto OMPD_end_workshare = llvm::omp::Directive::OMPD_end_workshare;
constexpr auto OMPD_error = llvm::omp::Directive::OMPD_error;
constexpr auto OMPD_flush = llvm::omp::Directive::OMPD_flush;
constexpr auto OMPD_for = llvm::omp::Directive::OMPD_for;
constexpr auto OMPD_for_simd = llvm::omp::Directive::OMPD_for_simd;
constexpr auto OMPD_masked_taskloop = llvm::omp::Directive::OMPD_masked_taskloop;
constexpr auto OMPD_masked_taskloop_simd = llvm::omp::Directive::OMPD_masked_taskloop_simd;
constexpr auto OMPD_master = llvm::omp::Directive::OMPD_master;
constexpr auto OMPD_master_taskloop = llvm::omp::Directive::OMPD_master_taskloop;
constexpr auto OMPD_master_taskloop_simd = llvm::omp::Directive::OMPD_master_taskloop_simd;
constexpr auto OMPD_metadirective = llvm::omp::Directive::OMPD_metadirective;
constexpr auto OMPD_nothing = llvm::omp::Directive::OMPD_nothing;
constexpr auto OMPD_ordered = llvm::omp::Directive::OMPD_ordered;
constexpr auto OMPD_parallel = llvm::omp::Directive::OMPD_parallel;
constexpr auto OMPD_parallel_do = llvm::omp::Directive::OMPD_parallel_do;
constexpr auto OMPD_parallel_do_simd = llvm::omp::Directive::OMPD_parallel_do_simd;
constexpr auto OMPD_parallel_for = llvm::omp::Directive::OMPD_parallel_for;
constexpr auto OMPD_parallel_for_simd = llvm::omp::Directive::OMPD_parallel_for_simd;
constexpr auto OMPD_parallel_masked = llvm::omp::Directive::OMPD_parallel_masked;
constexpr auto OMPD_parallel_masked_taskloop = llvm::omp::Directive::OMPD_parallel_masked_taskloop;
constexpr auto OMPD_parallel_masked_taskloop_simd = llvm::omp::Directive::OMPD_parallel_masked_taskloop_simd;
constexpr auto OMPD_parallel_master = llvm::omp::Directive::OMPD_parallel_master;
constexpr auto OMPD_parallel_master_taskloop = llvm::omp::Directive::OMPD_parallel_master_taskloop;
constexpr auto OMPD_parallel_master_taskloop_simd = llvm::omp::Directive::OMPD_parallel_master_taskloop_simd;
constexpr auto OMPD_parallel_sections = llvm::omp::Directive::OMPD_parallel_sections;
constexpr auto OMPD_parallel_workshare = llvm::omp::Directive::OMPD_parallel_workshare;
constexpr auto OMPD_requires = llvm::omp::Directive::OMPD_requires;
constexpr auto OMPD_scan = llvm::omp::Directive::OMPD_scan;
constexpr auto OMPD_section = llvm::omp::Directive::OMPD_section;
constexpr auto OMPD_sections = llvm::omp::Directive::OMPD_sections;
constexpr auto OMPD_simd = llvm::omp::Directive::OMPD_simd;
constexpr auto OMPD_single = llvm::omp::Directive::OMPD_single;
constexpr auto OMPD_target = llvm::omp::Directive::OMPD_target;
constexpr auto OMPD_target_data = llvm::omp::Directive::OMPD_target_data;
constexpr auto OMPD_target_enter_data = llvm::omp::Directive::OMPD_target_enter_data;
constexpr auto OMPD_target_exit_data = llvm::omp::Directive::OMPD_target_exit_data;
constexpr auto OMPD_target_parallel = llvm::omp::Directive::OMPD_target_parallel;
constexpr auto OMPD_target_parallel_do = llvm::omp::Directive::OMPD_target_parallel_do;
constexpr auto OMPD_target_parallel_do_simd = llvm::omp::Directive::OMPD_target_parallel_do_simd;
constexpr auto OMPD_target_parallel_for = llvm::omp::Directive::OMPD_target_parallel_for;
constexpr auto OMPD_target_parallel_for_simd = llvm::omp::Directive::OMPD_target_parallel_for_simd;
constexpr auto OMPD_target_simd = llvm::omp::Directive::OMPD_target_simd;
constexpr auto OMPD_target_teams = llvm::omp::Directive::OMPD_target_teams;
constexpr auto OMPD_target_teams_distribute = llvm::omp::Directive::OMPD_target_teams_distribute;
constexpr auto OMPD_target_teams_distribute_parallel_do = llvm::omp::Directive::OMPD_target_teams_distribute_parallel_do;
constexpr auto OMPD_target_teams_distribute_parallel_do_simd = llvm::omp::Directive::OMPD_target_teams_distribute_parallel_do_simd;
constexpr auto OMPD_target_teams_distribute_parallel_for = llvm::omp::Directive::OMPD_target_teams_distribute_parallel_for;
constexpr auto OMPD_target_teams_distribute_parallel_for_simd = llvm::omp::Directive::OMPD_target_teams_distribute_parallel_for_simd;
constexpr auto OMPD_target_teams_distribute_simd = llvm::omp::Directive::OMPD_target_teams_distribute_simd;
constexpr auto OMPD_target_update = llvm::omp::Directive::OMPD_target_update;
constexpr auto OMPD_task = llvm::omp::Directive::OMPD_task;
constexpr auto OMPD_taskgroup = llvm::omp::Directive::OMPD_taskgroup;
constexpr auto OMPD_taskloop = llvm::omp::Directive::OMPD_taskloop;
constexpr auto OMPD_taskloop_simd = llvm::omp::Directive::OMPD_taskloop_simd;
constexpr auto OMPD_taskwait = llvm::omp::Directive::OMPD_taskwait;
constexpr auto OMPD_taskyield = llvm::omp::Directive::OMPD_taskyield;
constexpr auto OMPD_teams = llvm::omp::Directive::OMPD_teams;
constexpr auto OMPD_teams_distribute = llvm::omp::Directive::OMPD_teams_distribute;
constexpr auto OMPD_teams_distribute_parallel_do = llvm::omp::Directive::OMPD_teams_distribute_parallel_do;
constexpr auto OMPD_teams_distribute_parallel_do_simd = llvm::omp::Directive::OMPD_teams_distribute_parallel_do_simd;
constexpr auto OMPD_teams_distribute_parallel_for = llvm::omp::Directive::OMPD_teams_distribute_parallel_for;
constexpr auto OMPD_teams_distribute_parallel_for_simd = llvm::omp::Directive::OMPD_teams_distribute_parallel_for_simd;
constexpr auto OMPD_teams_distribute_simd = llvm::omp::Directive::OMPD_teams_distribute_simd;
constexpr auto OMPD_threadprivate = llvm::omp::Directive::OMPD_threadprivate;
constexpr auto OMPD_tile = llvm::omp::Directive::OMPD_tile;
constexpr auto OMPD_unknown = llvm::omp::Directive::OMPD_unknown;
constexpr auto OMPD_unroll = llvm::omp::Directive::OMPD_unroll;
constexpr auto OMPD_workshare = llvm::omp::Directive::OMPD_workshare;
constexpr auto OMPD_dispatch = llvm::omp::Directive::OMPD_dispatch;
constexpr auto OMPD_interop = llvm::omp::Directive::OMPD_interop;
constexpr auto OMPD_loop = llvm::omp::Directive::OMPD_loop;
constexpr auto OMPD_masked = llvm::omp::Directive::OMPD_masked;
constexpr auto OMPD_parallel_loop = llvm::omp::Directive::OMPD_parallel_loop;
constexpr auto OMPD_scope = llvm::omp::Directive::OMPD_scope;
constexpr auto OMPD_target_parallel_loop = llvm::omp::Directive::OMPD_target_parallel_loop;
constexpr auto OMPD_target_teams_loop = llvm::omp::Directive::OMPD_target_teams_loop;
constexpr auto OMPD_teams_loop = llvm::omp::Directive::OMPD_teams_loop;

enum class Clause {
  OMPC_acq_rel,
  OMPC_acquire,
  OMPC_adjust_args,
  OMPC_affinity,
  OMPC_align,
  OMPC_aligned,
  OMPC_allocate,
  OMPC_allocator,
  OMPC_append_args,
  OMPC_at,
  OMPC_atomic_default_mem_order,
  OMPC_bind,
  OMPC_cancellation_construct_type,
  OMPC_capture,
  OMPC_collapse,
  OMPC_compare,
  OMPC_copyprivate,
  OMPC_copyin,
  OMPC_default,
  OMPC_defaultmap,
  OMPC_depend,
  OMPC_depobj,
  OMPC_destroy,
  OMPC_detach,
  OMPC_device,
  OMPC_device_type,
  OMPC_dist_schedule,
  OMPC_doacross,
  OMPC_dynamic_allocators,
  OMPC_enter,
  OMPC_exclusive,
  OMPC_fail,
  OMPC_filter,
  OMPC_final,
  OMPC_firstprivate,
  OMPC_flush,
  OMPC_from,
  OMPC_full,
  OMPC_grainsize,
  OMPC_has_device_addr,
  OMPC_hint,
  OMPC_if,
  OMPC_in_reduction,
  OMPC_inbranch,
  OMPC_inclusive,
  OMPC_indirect,
  OMPC_init,
  OMPC_is_device_ptr,
  OMPC_lastprivate,
  OMPC_linear,
  OMPC_link,
  OMPC_map,
  OMPC_match,
  OMPC_memory_order,
  OMPC_mergeable,
  OMPC_message,
  OMPC_nogroup,
  OMPC_nowait,
  OMPC_nocontext,
  OMPC_nontemporal,
  OMPC_notinbranch,
  OMPC_novariants,
  OMPC_num_tasks,
  OMPC_num_teams,
  OMPC_num_threads,
  OMPC_ompx_attribute,
  OMPC_ompx_dyn_cgroup_mem,
  OMPC_ompx_bare,
  OMPC_order,
  OMPC_ordered,
  OMPC_partial,
  OMPC_priority,
  OMPC_private,
  OMPC_proc_bind,
  OMPC_read,
  OMPC_reduction,
  OMPC_relaxed,
  OMPC_release,
  OMPC_reverse_offload,
  OMPC_safelen,
  OMPC_schedule,
  OMPC_seq_cst,
  OMPC_severity,
  OMPC_shared,
  OMPC_simd,
  OMPC_simdlen,
  OMPC_sizes,
  OMPC_task_reduction,
  OMPC_thread_limit,
  OMPC_threadprivate,
  OMPC_threads,
  OMPC_to,
  OMPC_unified_address,
  OMPC_unified_shared_memory,
  OMPC_uniform,
  OMPC_unknown,
  OMPC_untied,
  OMPC_update,
  OMPC_use,
  OMPC_use_device_addr,
  OMPC_use_device_ptr,
  OMPC_uses_allocators,
  OMPC_when,
  OMPC_write,
};

static constexpr std::size_t Clause_enumSize = 104;

constexpr auto OMPC_acq_rel = llvm::omp::Clause::OMPC_acq_rel;
constexpr auto OMPC_acquire = llvm::omp::Clause::OMPC_acquire;
constexpr auto OMPC_adjust_args = llvm::omp::Clause::OMPC_adjust_args;
constexpr auto OMPC_affinity = llvm::omp::Clause::OMPC_affinity;
constexpr auto OMPC_align = llvm::omp::Clause::OMPC_align;
constexpr auto OMPC_aligned = llvm::omp::Clause::OMPC_aligned;
constexpr auto OMPC_allocate = llvm::omp::Clause::OMPC_allocate;
constexpr auto OMPC_allocator = llvm::omp::Clause::OMPC_allocator;
constexpr auto OMPC_append_args = llvm::omp::Clause::OMPC_append_args;
constexpr auto OMPC_at = llvm::omp::Clause::OMPC_at;
constexpr auto OMPC_atomic_default_mem_order = llvm::omp::Clause::OMPC_atomic_default_mem_order;
constexpr auto OMPC_bind = llvm::omp::Clause::OMPC_bind;
constexpr auto OMPC_cancellation_construct_type = llvm::omp::Clause::OMPC_cancellation_construct_type;
constexpr auto OMPC_capture = llvm::omp::Clause::OMPC_capture;
constexpr auto OMPC_collapse = llvm::omp::Clause::OMPC_collapse;
constexpr auto OMPC_compare = llvm::omp::Clause::OMPC_compare;
constexpr auto OMPC_copyprivate = llvm::omp::Clause::OMPC_copyprivate;
constexpr auto OMPC_copyin = llvm::omp::Clause::OMPC_copyin;
constexpr auto OMPC_default = llvm::omp::Clause::OMPC_default;
constexpr auto OMPC_defaultmap = llvm::omp::Clause::OMPC_defaultmap;
constexpr auto OMPC_depend = llvm::omp::Clause::OMPC_depend;
constexpr auto OMPC_depobj = llvm::omp::Clause::OMPC_depobj;
constexpr auto OMPC_destroy = llvm::omp::Clause::OMPC_destroy;
constexpr auto OMPC_detach = llvm::omp::Clause::OMPC_detach;
constexpr auto OMPC_device = llvm::omp::Clause::OMPC_device;
constexpr auto OMPC_device_type = llvm::omp::Clause::OMPC_device_type;
constexpr auto OMPC_dist_schedule = llvm::omp::Clause::OMPC_dist_schedule;
constexpr auto OMPC_doacross = llvm::omp::Clause::OMPC_doacross;
constexpr auto OMPC_dynamic_allocators = llvm::omp::Clause::OMPC_dynamic_allocators;
constexpr auto OMPC_enter = llvm::omp::Clause::OMPC_enter;
constexpr auto OMPC_exclusive = llvm::omp::Clause::OMPC_exclusive;
constexpr auto OMPC_fail = llvm::omp::Clause::OMPC_fail;
constexpr auto OMPC_filter = llvm::omp::Clause::OMPC_filter;
constexpr auto OMPC_final = llvm::omp::Clause::OMPC_final;
constexpr auto OMPC_firstprivate = llvm::omp::Clause::OMPC_firstprivate;
constexpr auto OMPC_flush = llvm::omp::Clause::OMPC_flush;
constexpr auto OMPC_from = llvm::omp::Clause::OMPC_from;
constexpr auto OMPC_full = llvm::omp::Clause::OMPC_full;
constexpr auto OMPC_grainsize = llvm::omp::Clause::OMPC_grainsize;
constexpr auto OMPC_has_device_addr = llvm::omp::Clause::OMPC_has_device_addr;
constexpr auto OMPC_hint = llvm::omp::Clause::OMPC_hint;
constexpr auto OMPC_if = llvm::omp::Clause::OMPC_if;
constexpr auto OMPC_in_reduction = llvm::omp::Clause::OMPC_in_reduction;
constexpr auto OMPC_inbranch = llvm::omp::Clause::OMPC_inbranch;
constexpr auto OMPC_inclusive = llvm::omp::Clause::OMPC_inclusive;
constexpr auto OMPC_indirect = llvm::omp::Clause::OMPC_indirect;
constexpr auto OMPC_init = llvm::omp::Clause::OMPC_init;
constexpr auto OMPC_is_device_ptr = llvm::omp::Clause::OMPC_is_device_ptr;
constexpr auto OMPC_lastprivate = llvm::omp::Clause::OMPC_lastprivate;
constexpr auto OMPC_linear = llvm::omp::Clause::OMPC_linear;
constexpr auto OMPC_link = llvm::omp::Clause::OMPC_link;
constexpr auto OMPC_map = llvm::omp::Clause::OMPC_map;
constexpr auto OMPC_match = llvm::omp::Clause::OMPC_match;
constexpr auto OMPC_memory_order = llvm::omp::Clause::OMPC_memory_order;
constexpr auto OMPC_mergeable = llvm::omp::Clause::OMPC_mergeable;
constexpr auto OMPC_message = llvm::omp::Clause::OMPC_message;
constexpr auto OMPC_nogroup = llvm::omp::Clause::OMPC_nogroup;
constexpr auto OMPC_nowait = llvm::omp::Clause::OMPC_nowait;
constexpr auto OMPC_nocontext = llvm::omp::Clause::OMPC_nocontext;
constexpr auto OMPC_nontemporal = llvm::omp::Clause::OMPC_nontemporal;
constexpr auto OMPC_notinbranch = llvm::omp::Clause::OMPC_notinbranch;
constexpr auto OMPC_novariants = llvm::omp::Clause::OMPC_novariants;
constexpr auto OMPC_num_tasks = llvm::omp::Clause::OMPC_num_tasks;
constexpr auto OMPC_num_teams = llvm::omp::Clause::OMPC_num_teams;
constexpr auto OMPC_num_threads = llvm::omp::Clause::OMPC_num_threads;
constexpr auto OMPC_ompx_attribute = llvm::omp::Clause::OMPC_ompx_attribute;
constexpr auto OMPC_ompx_dyn_cgroup_mem = llvm::omp::Clause::OMPC_ompx_dyn_cgroup_mem;
constexpr auto OMPC_ompx_bare = llvm::omp::Clause::OMPC_ompx_bare;
constexpr auto OMPC_order = llvm::omp::Clause::OMPC_order;
constexpr auto OMPC_ordered = llvm::omp::Clause::OMPC_ordered;
constexpr auto OMPC_partial = llvm::omp::Clause::OMPC_partial;
constexpr auto OMPC_priority = llvm::omp::Clause::OMPC_priority;
constexpr auto OMPC_private = llvm::omp::Clause::OMPC_private;
constexpr auto OMPC_proc_bind = llvm::omp::Clause::OMPC_proc_bind;
constexpr auto OMPC_read = llvm::omp::Clause::OMPC_read;
constexpr auto OMPC_reduction = llvm::omp::Clause::OMPC_reduction;
constexpr auto OMPC_relaxed = llvm::omp::Clause::OMPC_relaxed;
constexpr auto OMPC_release = llvm::omp::Clause::OMPC_release;
constexpr auto OMPC_reverse_offload = llvm::omp::Clause::OMPC_reverse_offload;
constexpr auto OMPC_safelen = llvm::omp::Clause::OMPC_safelen;
constexpr auto OMPC_schedule = llvm::omp::Clause::OMPC_schedule;
constexpr auto OMPC_seq_cst = llvm::omp::Clause::OMPC_seq_cst;
constexpr auto OMPC_severity = llvm::omp::Clause::OMPC_severity;
constexpr auto OMPC_shared = llvm::omp::Clause::OMPC_shared;
constexpr auto OMPC_simd = llvm::omp::Clause::OMPC_simd;
constexpr auto OMPC_simdlen = llvm::omp::Clause::OMPC_simdlen;
constexpr auto OMPC_sizes = llvm::omp::Clause::OMPC_sizes;
constexpr auto OMPC_task_reduction = llvm::omp::Clause::OMPC_task_reduction;
constexpr auto OMPC_thread_limit = llvm::omp::Clause::OMPC_thread_limit;
constexpr auto OMPC_threadprivate = llvm::omp::Clause::OMPC_threadprivate;
constexpr auto OMPC_threads = llvm::omp::Clause::OMPC_threads;
constexpr auto OMPC_to = llvm::omp::Clause::OMPC_to;
constexpr auto OMPC_unified_address = llvm::omp::Clause::OMPC_unified_address;
constexpr auto OMPC_unified_shared_memory = llvm::omp::Clause::OMPC_unified_shared_memory;
constexpr auto OMPC_uniform = llvm::omp::Clause::OMPC_uniform;
constexpr auto OMPC_unknown = llvm::omp::Clause::OMPC_unknown;
constexpr auto OMPC_untied = llvm::omp::Clause::OMPC_untied;
constexpr auto OMPC_update = llvm::omp::Clause::OMPC_update;
constexpr auto OMPC_use = llvm::omp::Clause::OMPC_use;
constexpr auto OMPC_use_device_addr = llvm::omp::Clause::OMPC_use_device_addr;
constexpr auto OMPC_use_device_ptr = llvm::omp::Clause::OMPC_use_device_ptr;
constexpr auto OMPC_uses_allocators = llvm::omp::Clause::OMPC_uses_allocators;
constexpr auto OMPC_when = llvm::omp::Clause::OMPC_when;
constexpr auto OMPC_write = llvm::omp::Clause::OMPC_write;

enum class CancellationConstructType {
  OMP_CANCELLATION_CONSTRUCT_Parallel=1,
  OMP_CANCELLATION_CONSTRUCT_Loop=2,
  OMP_CANCELLATION_CONSTRUCT_Sections=3,
  OMP_CANCELLATION_CONSTRUCT_Taskgroup=4,
  OMP_CANCELLATION_CONSTRUCT_None=5,
};

constexpr auto OMP_CANCELLATION_CONSTRUCT_Parallel = llvm::omp::CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Parallel;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Loop = llvm::omp::CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Loop;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Sections = llvm::omp::CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Sections;
constexpr auto OMP_CANCELLATION_CONSTRUCT_Taskgroup = llvm::omp::CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_Taskgroup;
constexpr auto OMP_CANCELLATION_CONSTRUCT_None = llvm::omp::CancellationConstructType::OMP_CANCELLATION_CONSTRUCT_None;

enum class GrainsizeType {
  OMP_GRAINSIZE_Strict=1,
  OMP_GRAINSIZE_Unknown=2,
};

constexpr auto OMP_GRAINSIZE_Strict = llvm::omp::GrainsizeType::OMP_GRAINSIZE_Strict;
constexpr auto OMP_GRAINSIZE_Unknown = llvm::omp::GrainsizeType::OMP_GRAINSIZE_Unknown;

enum class MemoryOrderKind {
  OMP_MEMORY_ORDER_SeqCst=1,
  OMP_MEMORY_ORDER_AcqRel=2,
  OMP_MEMORY_ORDER_Acquire=3,
  OMP_MEMORY_ORDER_Release=4,
  OMP_MEMORY_ORDER_Relaxed=5,
  OMP_MEMORY_ORDER_Default=6,
};

constexpr auto OMP_MEMORY_ORDER_SeqCst = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_SeqCst;
constexpr auto OMP_MEMORY_ORDER_AcqRel = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_AcqRel;
constexpr auto OMP_MEMORY_ORDER_Acquire = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_Acquire;
constexpr auto OMP_MEMORY_ORDER_Release = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_Release;
constexpr auto OMP_MEMORY_ORDER_Relaxed = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_Relaxed;
constexpr auto OMP_MEMORY_ORDER_Default = llvm::omp::MemoryOrderKind::OMP_MEMORY_ORDER_Default;

enum class NumTasksType {
  OMP_NUMTASKS_Strict=1,
  OMP_NUMTASKS_Unknown=2,
};

constexpr auto OMP_NUMTASKS_Strict = llvm::omp::NumTasksType::OMP_NUMTASKS_Strict;
constexpr auto OMP_NUMTASKS_Unknown = llvm::omp::NumTasksType::OMP_NUMTASKS_Unknown;

enum class OrderKind {
  OMP_ORDER_unknown=2,
  OMP_ORDER_concurrent=1,
};

constexpr auto OMP_ORDER_unknown = llvm::omp::OrderKind::OMP_ORDER_unknown;
constexpr auto OMP_ORDER_concurrent = llvm::omp::OrderKind::OMP_ORDER_concurrent;

enum class ProcBindKind {
  OMP_PROC_BIND_primary=5,
  OMP_PROC_BIND_master=2,
  OMP_PROC_BIND_close=3,
  OMP_PROC_BIND_spread=4,
  OMP_PROC_BIND_default=6,
  OMP_PROC_BIND_unknown=7,
};

constexpr auto OMP_PROC_BIND_primary = llvm::omp::ProcBindKind::OMP_PROC_BIND_primary;
constexpr auto OMP_PROC_BIND_master = llvm::omp::ProcBindKind::OMP_PROC_BIND_master;
constexpr auto OMP_PROC_BIND_close = llvm::omp::ProcBindKind::OMP_PROC_BIND_close;
constexpr auto OMP_PROC_BIND_spread = llvm::omp::ProcBindKind::OMP_PROC_BIND_spread;
constexpr auto OMP_PROC_BIND_default = llvm::omp::ProcBindKind::OMP_PROC_BIND_default;
constexpr auto OMP_PROC_BIND_unknown = llvm::omp::ProcBindKind::OMP_PROC_BIND_unknown;

enum class ScheduleKind {
  OMP_SCHEDULE_Static=2,
  OMP_SCHEDULE_Dynamic=3,
  OMP_SCHEDULE_Guided=4,
  OMP_SCHEDULE_Auto=5,
  OMP_SCHEDULE_Runtime=6,
  OMP_SCHEDULE_Default=7,
};

constexpr auto OMP_SCHEDULE_Static = llvm::omp::ScheduleKind::OMP_SCHEDULE_Static;
constexpr auto OMP_SCHEDULE_Dynamic = llvm::omp::ScheduleKind::OMP_SCHEDULE_Dynamic;
constexpr auto OMP_SCHEDULE_Guided = llvm::omp::ScheduleKind::OMP_SCHEDULE_Guided;
constexpr auto OMP_SCHEDULE_Auto = llvm::omp::ScheduleKind::OMP_SCHEDULE_Auto;
constexpr auto OMP_SCHEDULE_Runtime = llvm::omp::ScheduleKind::OMP_SCHEDULE_Runtime;
constexpr auto OMP_SCHEDULE_Default = llvm::omp::ScheduleKind::OMP_SCHEDULE_Default;


Directive getOpenMPDirectiveKind(llvm::StringRef Str);

llvm::StringRef getOpenMPDirectiveName(Directive D);

Clause getOpenMPClauseKind(llvm::StringRef Str);

llvm::StringRef getOpenMPClauseName(Clause C);


bool isAllowedClauseForDirective(Directive D, Clause C, unsigned Version);

CancellationConstructType getCancellationConstructType(StringRef);
llvm::StringRef getOpenMPCancellationConstructTypeName(CancellationConstructType);
GrainsizeType getGrainsizeType(StringRef);
llvm::StringRef getOpenMPGrainsizeTypeName(GrainsizeType);
MemoryOrderKind getMemoryOrderKind(StringRef);
llvm::StringRef getOpenMPMemoryOrderKindName(MemoryOrderKind);
NumTasksType getNumTasksType(StringRef);
llvm::StringRef getOpenMPNumTasksTypeName(NumTasksType);
OrderKind getOrderKind(StringRef);
llvm::StringRef getOpenMPOrderKindName(OrderKind);
ProcBindKind getProcBindKind(StringRef);
llvm::StringRef getOpenMPProcBindKindName(ProcBindKind);
ScheduleKind getScheduleKind(StringRef);
llvm::StringRef getOpenMPScheduleKindName(ScheduleKind);

}
}
# 21 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2

namespace llvm {
namespace omp {
using ::llvm::BitmaskEnumDetail::operator~; using ::llvm::BitmaskEnumDetail::operator|; using ::llvm::BitmaskEnumDetail::operator&; using ::llvm::BitmaskEnumDetail::operator^; using ::llvm::BitmaskEnumDetail::operator|=; using ::llvm::BitmaskEnumDetail::operator&=; using ::llvm::BitmaskEnumDetail::operator^=; using ::llvm::BitmaskEnumDetail::any;


enum class InternalControlVar {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 157 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
ICV_nthreads,
ICV_active_levels,
ICV_cancel,
ICV_proc_bind,
ICV___last,
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 157 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto ICV_nthreads = omp::InternalControlVar::ICV_nthreads;
constexpr auto ICV_active_levels = omp::InternalControlVar::ICV_active_levels;
constexpr auto ICV_cancel = omp::InternalControlVar::ICV_cancel;
constexpr auto ICV_proc_bind = omp::InternalControlVar::ICV_proc_bind;
constexpr auto ICV___last = omp::InternalControlVar::ICV___last;
# 35 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2

enum class ICVInitValue {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 142 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
ICV_ZERO,
ICV_FALSE,
ICV_IMPLEMENTATION_DEFINED,
ICV_LAST,
# 39 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 142 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto ICV_ZERO = omp::ICVInitValue::ICV_ZERO;
constexpr auto ICV_FALSE = omp::ICVInitValue::ICV_FALSE;
constexpr auto ICV_IMPLEMENTATION_DEFINED = omp::ICVInitValue::ICV_IMPLEMENTATION_DEFINED;
constexpr auto ICV_LAST = omp::ICVInitValue::ICV_LAST;
# 44 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2


enum class RuntimeFunction {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 206 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMPRTL___kmpc_barrier,
OMPRTL___kmpc_cancel,
OMPRTL___kmpc_cancel_barrier,
OMPRTL___kmpc_error,
OMPRTL___kmpc_flush,
OMPRTL___kmpc_global_thread_num,
OMPRTL___kmpc_get_hardware_thread_id_in_block,
OMPRTL___kmpc_fork_call,
OMPRTL___kmpc_fork_call_if,

OMPRTL___kmpc_omp_taskwait,
OMPRTL___kmpc_omp_taskyield,
OMPRTL___kmpc_push_num_threads,

OMPRTL___kmpc_push_proc_bind,
OMPRTL___kmpc_omp_reg_task_with_affinity,



OMPRTL___kmpc_get_hardware_num_blocks,
OMPRTL___kmpc_get_hardware_num_threads_in_block,
OMPRTL___kmpc_get_warp_size,

OMPRTL_omp_get_thread_num,
OMPRTL_omp_get_num_threads,
OMPRTL_omp_get_max_threads,
OMPRTL_omp_in_parallel,
OMPRTL_omp_get_dynamic,
OMPRTL_omp_get_cancellation,
OMPRTL_omp_get_nested,
OMPRTL_omp_get_schedule,
OMPRTL_omp_get_thread_limit,
OMPRTL_omp_get_supported_active_levels,
OMPRTL_omp_get_max_active_levels,
OMPRTL_omp_get_level,
OMPRTL_omp_get_ancestor_thread_num,
OMPRTL_omp_get_team_size,
OMPRTL_omp_get_active_level,
OMPRTL_omp_in_final,
OMPRTL_omp_get_proc_bind,
OMPRTL_omp_get_num_places,
OMPRTL_omp_get_num_procs,
OMPRTL_omp_get_place_proc_ids,
OMPRTL_omp_get_place_num,
OMPRTL_omp_get_partition_num_places,
OMPRTL_omp_get_partition_place_nums,
OMPRTL_omp_get_wtime,

OMPRTL_omp_set_num_threads,
OMPRTL_omp_set_dynamic,
OMPRTL_omp_set_nested,
OMPRTL_omp_set_schedule,
OMPRTL_omp_set_max_active_levels,

OMPRTL___kmpc_master,
OMPRTL___kmpc_end_master,
OMPRTL___kmpc_masked,
OMPRTL___kmpc_end_masked,
OMPRTL___kmpc_critical,
OMPRTL___kmpc_critical_with_hint,

OMPRTL___kmpc_end_critical,


OMPRTL___kmpc_begin,
OMPRTL___kmpc_end,

OMPRTL___kmpc_reduce,

OMPRTL___kmpc_reduce_nowait,

OMPRTL___kmpc_end_reduce,
OMPRTL___kmpc_end_reduce_nowait,


OMPRTL___kmpc_ordered,
OMPRTL___kmpc_end_ordered,

OMPRTL___kmpc_for_static_init_4,

OMPRTL___kmpc_for_static_init_4u,

OMPRTL___kmpc_for_static_init_8,

OMPRTL___kmpc_for_static_init_8u,

OMPRTL___kmpc_for_static_fini,
OMPRTL___kmpc_distribute_static_init_4,

OMPRTL___kmpc_distribute_static_init_4u,

OMPRTL___kmpc_distribute_static_init_8,

OMPRTL___kmpc_distribute_static_init_8u,

OMPRTL___kmpc_distribute_static_fini,
OMPRTL___kmpc_dist_dispatch_init_4,

OMPRTL___kmpc_dist_dispatch_init_4u,

OMPRTL___kmpc_dist_dispatch_init_8,

OMPRTL___kmpc_dist_dispatch_init_8u,

OMPRTL___kmpc_dispatch_init_4,

OMPRTL___kmpc_dispatch_init_4u,

OMPRTL___kmpc_dispatch_init_8,

OMPRTL___kmpc_dispatch_init_8u,

OMPRTL___kmpc_dispatch_next_4,

OMPRTL___kmpc_dispatch_next_4u,

OMPRTL___kmpc_dispatch_next_8,

OMPRTL___kmpc_dispatch_next_8u,

OMPRTL___kmpc_dispatch_fini_4,
OMPRTL___kmpc_dispatch_fini_4u,
OMPRTL___kmpc_dispatch_fini_8,
OMPRTL___kmpc_dispatch_fini_8u,
OMPRTL___kmpc_team_static_init_4,

OMPRTL___kmpc_team_static_init_4u,

OMPRTL___kmpc_team_static_init_8,

OMPRTL___kmpc_team_static_init_8u,

OMPRTL___kmpc_dist_for_static_init_4,

OMPRTL___kmpc_dist_for_static_init_4u,

OMPRTL___kmpc_dist_for_static_init_8,

OMPRTL___kmpc_dist_for_static_init_8u,


OMPRTL___kmpc_single,
OMPRTL___kmpc_end_single,

OMPRTL___kmpc_omp_task_alloc,

OMPRTL___kmpc_omp_task,

OMPRTL___kmpc_end_taskgroup,
OMPRTL___kmpc_taskgroup,
OMPRTL___kmpc_omp_task_begin_if0,

OMPRTL___kmpc_omp_task_complete_if0,

OMPRTL___kmpc_omp_task_with_deps,



OMPRTL___kmpc_taskloop,


OMPRTL___kmpc_omp_target_task_alloc,

OMPRTL___kmpc_taskred_modifier_init,

OMPRTL___kmpc_taskred_init,

OMPRTL___kmpc_task_reduction_modifier_fini,

OMPRTL___kmpc_task_reduction_get_th_data,

OMPRTL___kmpc_task_reduction_init,
OMPRTL___kmpc_task_reduction_modifier_init,

OMPRTL___kmpc_proxy_task_completed_ooo,

OMPRTL___kmpc_omp_wait_deps,

OMPRTL___kmpc_omp_taskwait_deps_51,

OMPRTL___kmpc_cancellationpoint,

OMPRTL___kmpc_fork_teams,
OMPRTL___kmpc_push_num_teams,
OMPRTL___kmpc_push_num_teams_51,
OMPRTL___kmpc_set_thread_limit,

OMPRTL___kmpc_copyprivate,

OMPRTL___kmpc_threadprivate_cached,

OMPRTL___kmpc_threadprivate_register,


OMPRTL___kmpc_doacross_init,

OMPRTL___kmpc_doacross_post,
OMPRTL___kmpc_doacross_wait,
OMPRTL___kmpc_doacross_fini,

OMPRTL___kmpc_alloc,
OMPRTL___kmpc_aligned_alloc,

OMPRTL___kmpc_free,

OMPRTL___tgt_interop_init,

OMPRTL___tgt_interop_destroy,

OMPRTL___tgt_interop_use,


OMPRTL___kmpc_init_allocator,


OMPRTL___kmpc_destroy_allocator,


OMPRTL___kmpc_push_target_tripcount_mapper,
OMPRTL___tgt_target_mapper,

OMPRTL___tgt_target_nowait_mapper,


OMPRTL___tgt_target_teams_mapper,

OMPRTL___tgt_target_teams_nowait_mapper,


OMPRTL___tgt_target_kernel,

OMPRTL___tgt_target_kernel_nowait,

OMPRTL___tgt_register_requires,
OMPRTL___tgt_target_data_begin_mapper,

OMPRTL___tgt_target_data_begin_nowait_mapper,

OMPRTL___tgt_target_data_begin_mapper_issue,

OMPRTL___tgt_target_data_begin_mapper_wait,
OMPRTL___tgt_target_data_end_mapper,

OMPRTL___tgt_target_data_end_nowait_mapper,

OMPRTL___tgt_target_data_update_mapper,

OMPRTL___tgt_target_data_update_nowait_mapper,

OMPRTL___tgt_mapper_num_components,
OMPRTL___tgt_push_mapper_component,

OMPRTL___kmpc_task_allow_completion_event,



OMPRTL___kmpc_target_init,
OMPRTL___kmpc_target_deinit,
OMPRTL___kmpc_kernel_prepare_parallel,
OMPRTL___kmpc_parallel_51,

OMPRTL___kmpc_for_static_loop_4,
OMPRTL___kmpc_for_static_loop_4u,
OMPRTL___kmpc_for_static_loop_8,
OMPRTL___kmpc_for_static_loop_8u,
OMPRTL___kmpc_distribute_static_loop_4,
OMPRTL___kmpc_distribute_static_loop_4u,
OMPRTL___kmpc_distribute_static_loop_8,
OMPRTL___kmpc_distribute_static_loop_8u,
OMPRTL___kmpc_distribute_for_static_loop_4,
OMPRTL___kmpc_distribute_for_static_loop_4u,
OMPRTL___kmpc_distribute_for_static_loop_8,
OMPRTL___kmpc_distribute_for_static_loop_8u,
OMPRTL___kmpc_kernel_parallel,
OMPRTL___kmpc_kernel_end_parallel,
OMPRTL___kmpc_serialized_parallel,
OMPRTL___kmpc_end_serialized_parallel,
OMPRTL___kmpc_shuffle_int32,
OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2,

OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2,


OMPRTL___kmpc_reduction_get_fixed_buffer,

OMPRTL___kmpc_shuffle_int64,

OMPRTL___kmpc_alloc_shared,
OMPRTL___kmpc_free_shared,
OMPRTL___kmpc_begin_sharing_variables,
OMPRTL___kmpc_end_sharing_variables,
OMPRTL___kmpc_get_shared_variables,
OMPRTL___kmpc_parallel_level,
OMPRTL___kmpc_is_spmd_exec_mode,
OMPRTL___kmpc_barrier_simple_spmd,
OMPRTL___kmpc_barrier_simple_generic,

OMPRTL___kmpc_warp_active_thread_mask,
OMPRTL___kmpc_syncwarp,

OMPRTL___last,
# 49 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 206 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMPRTL___kmpc_barrier = omp::RuntimeFunction::OMPRTL___kmpc_barrier;
constexpr auto OMPRTL___kmpc_cancel = omp::RuntimeFunction::OMPRTL___kmpc_cancel;
constexpr auto OMPRTL___kmpc_cancel_barrier = omp::RuntimeFunction::OMPRTL___kmpc_cancel_barrier;
constexpr auto OMPRTL___kmpc_error = omp::RuntimeFunction::OMPRTL___kmpc_error;
constexpr auto OMPRTL___kmpc_flush = omp::RuntimeFunction::OMPRTL___kmpc_flush;
constexpr auto OMPRTL___kmpc_global_thread_num = omp::RuntimeFunction::OMPRTL___kmpc_global_thread_num;
constexpr auto OMPRTL___kmpc_get_hardware_thread_id_in_block = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_thread_id_in_block;
constexpr auto OMPRTL___kmpc_fork_call = omp::RuntimeFunction::OMPRTL___kmpc_fork_call;
constexpr auto OMPRTL___kmpc_fork_call_if = omp::RuntimeFunction::OMPRTL___kmpc_fork_call_if;

constexpr auto OMPRTL___kmpc_omp_taskwait = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskwait;
constexpr auto OMPRTL___kmpc_omp_taskyield = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskyield;
constexpr auto OMPRTL___kmpc_push_num_threads = omp::RuntimeFunction::OMPRTL___kmpc_push_num_threads;

constexpr auto OMPRTL___kmpc_push_proc_bind = omp::RuntimeFunction::OMPRTL___kmpc_push_proc_bind;
constexpr auto OMPRTL___kmpc_omp_reg_task_with_affinity = omp::RuntimeFunction::OMPRTL___kmpc_omp_reg_task_with_affinity;



constexpr auto OMPRTL___kmpc_get_hardware_num_blocks = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_num_blocks;
constexpr auto OMPRTL___kmpc_get_hardware_num_threads_in_block = omp::RuntimeFunction::OMPRTL___kmpc_get_hardware_num_threads_in_block;
constexpr auto OMPRTL___kmpc_get_warp_size = omp::RuntimeFunction::OMPRTL___kmpc_get_warp_size;

constexpr auto OMPRTL_omp_get_thread_num = omp::RuntimeFunction::OMPRTL_omp_get_thread_num;
constexpr auto OMPRTL_omp_get_num_threads = omp::RuntimeFunction::OMPRTL_omp_get_num_threads;
constexpr auto OMPRTL_omp_get_max_threads = omp::RuntimeFunction::OMPRTL_omp_get_max_threads;
constexpr auto OMPRTL_omp_in_parallel = omp::RuntimeFunction::OMPRTL_omp_in_parallel;
constexpr auto OMPRTL_omp_get_dynamic = omp::RuntimeFunction::OMPRTL_omp_get_dynamic;
constexpr auto OMPRTL_omp_get_cancellation = omp::RuntimeFunction::OMPRTL_omp_get_cancellation;
constexpr auto OMPRTL_omp_get_nested = omp::RuntimeFunction::OMPRTL_omp_get_nested;
constexpr auto OMPRTL_omp_get_schedule = omp::RuntimeFunction::OMPRTL_omp_get_schedule;
constexpr auto OMPRTL_omp_get_thread_limit = omp::RuntimeFunction::OMPRTL_omp_get_thread_limit;
constexpr auto OMPRTL_omp_get_supported_active_levels = omp::RuntimeFunction::OMPRTL_omp_get_supported_active_levels;
constexpr auto OMPRTL_omp_get_max_active_levels = omp::RuntimeFunction::OMPRTL_omp_get_max_active_levels;
constexpr auto OMPRTL_omp_get_level = omp::RuntimeFunction::OMPRTL_omp_get_level;
constexpr auto OMPRTL_omp_get_ancestor_thread_num = omp::RuntimeFunction::OMPRTL_omp_get_ancestor_thread_num;
constexpr auto OMPRTL_omp_get_team_size = omp::RuntimeFunction::OMPRTL_omp_get_team_size;
constexpr auto OMPRTL_omp_get_active_level = omp::RuntimeFunction::OMPRTL_omp_get_active_level;
constexpr auto OMPRTL_omp_in_final = omp::RuntimeFunction::OMPRTL_omp_in_final;
constexpr auto OMPRTL_omp_get_proc_bind = omp::RuntimeFunction::OMPRTL_omp_get_proc_bind;
constexpr auto OMPRTL_omp_get_num_places = omp::RuntimeFunction::OMPRTL_omp_get_num_places;
constexpr auto OMPRTL_omp_get_num_procs = omp::RuntimeFunction::OMPRTL_omp_get_num_procs;
constexpr auto OMPRTL_omp_get_place_proc_ids = omp::RuntimeFunction::OMPRTL_omp_get_place_proc_ids;
constexpr auto OMPRTL_omp_get_place_num = omp::RuntimeFunction::OMPRTL_omp_get_place_num;
constexpr auto OMPRTL_omp_get_partition_num_places = omp::RuntimeFunction::OMPRTL_omp_get_partition_num_places;
constexpr auto OMPRTL_omp_get_partition_place_nums = omp::RuntimeFunction::OMPRTL_omp_get_partition_place_nums;
constexpr auto OMPRTL_omp_get_wtime = omp::RuntimeFunction::OMPRTL_omp_get_wtime;

constexpr auto OMPRTL_omp_set_num_threads = omp::RuntimeFunction::OMPRTL_omp_set_num_threads;
constexpr auto OMPRTL_omp_set_dynamic = omp::RuntimeFunction::OMPRTL_omp_set_dynamic;
constexpr auto OMPRTL_omp_set_nested = omp::RuntimeFunction::OMPRTL_omp_set_nested;
constexpr auto OMPRTL_omp_set_schedule = omp::RuntimeFunction::OMPRTL_omp_set_schedule;
constexpr auto OMPRTL_omp_set_max_active_levels = omp::RuntimeFunction::OMPRTL_omp_set_max_active_levels;

constexpr auto OMPRTL___kmpc_master = omp::RuntimeFunction::OMPRTL___kmpc_master;
constexpr auto OMPRTL___kmpc_end_master = omp::RuntimeFunction::OMPRTL___kmpc_end_master;
constexpr auto OMPRTL___kmpc_masked = omp::RuntimeFunction::OMPRTL___kmpc_masked;
constexpr auto OMPRTL___kmpc_end_masked = omp::RuntimeFunction::OMPRTL___kmpc_end_masked;
constexpr auto OMPRTL___kmpc_critical = omp::RuntimeFunction::OMPRTL___kmpc_critical;
constexpr auto OMPRTL___kmpc_critical_with_hint = omp::RuntimeFunction::OMPRTL___kmpc_critical_with_hint;

constexpr auto OMPRTL___kmpc_end_critical = omp::RuntimeFunction::OMPRTL___kmpc_end_critical;


constexpr auto OMPRTL___kmpc_begin = omp::RuntimeFunction::OMPRTL___kmpc_begin;
constexpr auto OMPRTL___kmpc_end = omp::RuntimeFunction::OMPRTL___kmpc_end;

constexpr auto OMPRTL___kmpc_reduce = omp::RuntimeFunction::OMPRTL___kmpc_reduce;

constexpr auto OMPRTL___kmpc_reduce_nowait = omp::RuntimeFunction::OMPRTL___kmpc_reduce_nowait;

constexpr auto OMPRTL___kmpc_end_reduce = omp::RuntimeFunction::OMPRTL___kmpc_end_reduce;
constexpr auto OMPRTL___kmpc_end_reduce_nowait = omp::RuntimeFunction::OMPRTL___kmpc_end_reduce_nowait;


constexpr auto OMPRTL___kmpc_ordered = omp::RuntimeFunction::OMPRTL___kmpc_ordered;
constexpr auto OMPRTL___kmpc_end_ordered = omp::RuntimeFunction::OMPRTL___kmpc_end_ordered;

constexpr auto OMPRTL___kmpc_for_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_4;

constexpr auto OMPRTL___kmpc_for_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_4u;

constexpr auto OMPRTL___kmpc_for_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_8;

constexpr auto OMPRTL___kmpc_for_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_init_8u;

constexpr auto OMPRTL___kmpc_for_static_fini = omp::RuntimeFunction::OMPRTL___kmpc_for_static_fini;
constexpr auto OMPRTL___kmpc_distribute_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_4;

constexpr auto OMPRTL___kmpc_distribute_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_4u;

constexpr auto OMPRTL___kmpc_distribute_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_8;

constexpr auto OMPRTL___kmpc_distribute_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_init_8u;

constexpr auto OMPRTL___kmpc_distribute_static_fini = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_fini;
constexpr auto OMPRTL___kmpc_dist_dispatch_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_4;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_4u;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_8;

constexpr auto OMPRTL___kmpc_dist_dispatch_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dist_dispatch_init_8u;

constexpr auto OMPRTL___kmpc_dispatch_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_4;

constexpr auto OMPRTL___kmpc_dispatch_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_4u;

constexpr auto OMPRTL___kmpc_dispatch_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_8;

constexpr auto OMPRTL___kmpc_dispatch_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_init_8u;

constexpr auto OMPRTL___kmpc_dispatch_next_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_4;

constexpr auto OMPRTL___kmpc_dispatch_next_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_4u;

constexpr auto OMPRTL___kmpc_dispatch_next_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_8;

constexpr auto OMPRTL___kmpc_dispatch_next_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_next_8u;

constexpr auto OMPRTL___kmpc_dispatch_fini_4 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_4;
constexpr auto OMPRTL___kmpc_dispatch_fini_4u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_4u;
constexpr auto OMPRTL___kmpc_dispatch_fini_8 = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_8;
constexpr auto OMPRTL___kmpc_dispatch_fini_8u = omp::RuntimeFunction::OMPRTL___kmpc_dispatch_fini_8u;
constexpr auto OMPRTL___kmpc_team_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_4;

constexpr auto OMPRTL___kmpc_team_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_4u;

constexpr auto OMPRTL___kmpc_team_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_8;

constexpr auto OMPRTL___kmpc_team_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_team_static_init_8u;

constexpr auto OMPRTL___kmpc_dist_for_static_init_4 = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_4;

constexpr auto OMPRTL___kmpc_dist_for_static_init_4u = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_4u;

constexpr auto OMPRTL___kmpc_dist_for_static_init_8 = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_8;

constexpr auto OMPRTL___kmpc_dist_for_static_init_8u = omp::RuntimeFunction::OMPRTL___kmpc_dist_for_static_init_8u;


constexpr auto OMPRTL___kmpc_single = omp::RuntimeFunction::OMPRTL___kmpc_single;
constexpr auto OMPRTL___kmpc_end_single = omp::RuntimeFunction::OMPRTL___kmpc_end_single;

constexpr auto OMPRTL___kmpc_omp_task_alloc = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_alloc;

constexpr auto OMPRTL___kmpc_omp_task = omp::RuntimeFunction::OMPRTL___kmpc_omp_task;

constexpr auto OMPRTL___kmpc_end_taskgroup = omp::RuntimeFunction::OMPRTL___kmpc_end_taskgroup;
constexpr auto OMPRTL___kmpc_taskgroup = omp::RuntimeFunction::OMPRTL___kmpc_taskgroup;
constexpr auto OMPRTL___kmpc_omp_task_begin_if0 = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_begin_if0;

constexpr auto OMPRTL___kmpc_omp_task_complete_if0 = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_complete_if0;

constexpr auto OMPRTL___kmpc_omp_task_with_deps = omp::RuntimeFunction::OMPRTL___kmpc_omp_task_with_deps;



constexpr auto OMPRTL___kmpc_taskloop = omp::RuntimeFunction::OMPRTL___kmpc_taskloop;


constexpr auto OMPRTL___kmpc_omp_target_task_alloc = omp::RuntimeFunction::OMPRTL___kmpc_omp_target_task_alloc;

constexpr auto OMPRTL___kmpc_taskred_modifier_init = omp::RuntimeFunction::OMPRTL___kmpc_taskred_modifier_init;

constexpr auto OMPRTL___kmpc_taskred_init = omp::RuntimeFunction::OMPRTL___kmpc_taskred_init;

constexpr auto OMPRTL___kmpc_task_reduction_modifier_fini = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_modifier_fini;

constexpr auto OMPRTL___kmpc_task_reduction_get_th_data = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_get_th_data;

constexpr auto OMPRTL___kmpc_task_reduction_init = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_init;
constexpr auto OMPRTL___kmpc_task_reduction_modifier_init = omp::RuntimeFunction::OMPRTL___kmpc_task_reduction_modifier_init;

constexpr auto OMPRTL___kmpc_proxy_task_completed_ooo = omp::RuntimeFunction::OMPRTL___kmpc_proxy_task_completed_ooo;

constexpr auto OMPRTL___kmpc_omp_wait_deps = omp::RuntimeFunction::OMPRTL___kmpc_omp_wait_deps;

constexpr auto OMPRTL___kmpc_omp_taskwait_deps_51 = omp::RuntimeFunction::OMPRTL___kmpc_omp_taskwait_deps_51;

constexpr auto OMPRTL___kmpc_cancellationpoint = omp::RuntimeFunction::OMPRTL___kmpc_cancellationpoint;

constexpr auto OMPRTL___kmpc_fork_teams = omp::RuntimeFunction::OMPRTL___kmpc_fork_teams;
constexpr auto OMPRTL___kmpc_push_num_teams = omp::RuntimeFunction::OMPRTL___kmpc_push_num_teams;
constexpr auto OMPRTL___kmpc_push_num_teams_51 = omp::RuntimeFunction::OMPRTL___kmpc_push_num_teams_51;
constexpr auto OMPRTL___kmpc_set_thread_limit = omp::RuntimeFunction::OMPRTL___kmpc_set_thread_limit;

constexpr auto OMPRTL___kmpc_copyprivate = omp::RuntimeFunction::OMPRTL___kmpc_copyprivate;

constexpr auto OMPRTL___kmpc_threadprivate_cached = omp::RuntimeFunction::OMPRTL___kmpc_threadprivate_cached;

constexpr auto OMPRTL___kmpc_threadprivate_register = omp::RuntimeFunction::OMPRTL___kmpc_threadprivate_register;


constexpr auto OMPRTL___kmpc_doacross_init = omp::RuntimeFunction::OMPRTL___kmpc_doacross_init;

constexpr auto OMPRTL___kmpc_doacross_post = omp::RuntimeFunction::OMPRTL___kmpc_doacross_post;
constexpr auto OMPRTL___kmpc_doacross_wait = omp::RuntimeFunction::OMPRTL___kmpc_doacross_wait;
constexpr auto OMPRTL___kmpc_doacross_fini = omp::RuntimeFunction::OMPRTL___kmpc_doacross_fini;

constexpr auto OMPRTL___kmpc_alloc = omp::RuntimeFunction::OMPRTL___kmpc_alloc;
constexpr auto OMPRTL___kmpc_aligned_alloc = omp::RuntimeFunction::OMPRTL___kmpc_aligned_alloc;

constexpr auto OMPRTL___kmpc_free = omp::RuntimeFunction::OMPRTL___kmpc_free;

constexpr auto OMPRTL___tgt_interop_init = omp::RuntimeFunction::OMPRTL___tgt_interop_init;

constexpr auto OMPRTL___tgt_interop_destroy = omp::RuntimeFunction::OMPRTL___tgt_interop_destroy;

constexpr auto OMPRTL___tgt_interop_use = omp::RuntimeFunction::OMPRTL___tgt_interop_use;


constexpr auto OMPRTL___kmpc_init_allocator = omp::RuntimeFunction::OMPRTL___kmpc_init_allocator;


constexpr auto OMPRTL___kmpc_destroy_allocator = omp::RuntimeFunction::OMPRTL___kmpc_destroy_allocator;


constexpr auto OMPRTL___kmpc_push_target_tripcount_mapper = omp::RuntimeFunction::OMPRTL___kmpc_push_target_tripcount_mapper;
constexpr auto OMPRTL___tgt_target_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_mapper;

constexpr auto OMPRTL___tgt_target_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_nowait_mapper;


constexpr auto OMPRTL___tgt_target_teams_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_teams_mapper;

constexpr auto OMPRTL___tgt_target_teams_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_teams_nowait_mapper;


constexpr auto OMPRTL___tgt_target_kernel = omp::RuntimeFunction::OMPRTL___tgt_target_kernel;

constexpr auto OMPRTL___tgt_target_kernel_nowait = omp::RuntimeFunction::OMPRTL___tgt_target_kernel_nowait;

constexpr auto OMPRTL___tgt_register_requires = omp::RuntimeFunction::OMPRTL___tgt_register_requires;
constexpr auto OMPRTL___tgt_target_data_begin_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper;

constexpr auto OMPRTL___tgt_target_data_begin_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_nowait_mapper;

constexpr auto OMPRTL___tgt_target_data_begin_mapper_issue = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper_issue;

constexpr auto OMPRTL___tgt_target_data_begin_mapper_wait = omp::RuntimeFunction::OMPRTL___tgt_target_data_begin_mapper_wait;
constexpr auto OMPRTL___tgt_target_data_end_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_end_mapper;

constexpr auto OMPRTL___tgt_target_data_end_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_end_nowait_mapper;

constexpr auto OMPRTL___tgt_target_data_update_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_update_mapper;

constexpr auto OMPRTL___tgt_target_data_update_nowait_mapper = omp::RuntimeFunction::OMPRTL___tgt_target_data_update_nowait_mapper;

constexpr auto OMPRTL___tgt_mapper_num_components = omp::RuntimeFunction::OMPRTL___tgt_mapper_num_components;
constexpr auto OMPRTL___tgt_push_mapper_component = omp::RuntimeFunction::OMPRTL___tgt_push_mapper_component;

constexpr auto OMPRTL___kmpc_task_allow_completion_event = omp::RuntimeFunction::OMPRTL___kmpc_task_allow_completion_event;



constexpr auto OMPRTL___kmpc_target_init = omp::RuntimeFunction::OMPRTL___kmpc_target_init;
constexpr auto OMPRTL___kmpc_target_deinit = omp::RuntimeFunction::OMPRTL___kmpc_target_deinit;
constexpr auto OMPRTL___kmpc_kernel_prepare_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_prepare_parallel;
constexpr auto OMPRTL___kmpc_parallel_51 = omp::RuntimeFunction::OMPRTL___kmpc_parallel_51;

constexpr auto OMPRTL___kmpc_for_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_4;
constexpr auto OMPRTL___kmpc_for_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_4u;
constexpr auto OMPRTL___kmpc_for_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_8;
constexpr auto OMPRTL___kmpc_for_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_for_static_loop_8u;
constexpr auto OMPRTL___kmpc_distribute_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_4;
constexpr auto OMPRTL___kmpc_distribute_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_4u;
constexpr auto OMPRTL___kmpc_distribute_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_8;
constexpr auto OMPRTL___kmpc_distribute_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_static_loop_8u;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_4 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_4;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_4u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_4u;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_8 = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_8;
constexpr auto OMPRTL___kmpc_distribute_for_static_loop_8u = omp::RuntimeFunction::OMPRTL___kmpc_distribute_for_static_loop_8u;
constexpr auto OMPRTL___kmpc_kernel_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_parallel;
constexpr auto OMPRTL___kmpc_kernel_end_parallel = omp::RuntimeFunction::OMPRTL___kmpc_kernel_end_parallel;
constexpr auto OMPRTL___kmpc_serialized_parallel = omp::RuntimeFunction::OMPRTL___kmpc_serialized_parallel;
constexpr auto OMPRTL___kmpc_end_serialized_parallel = omp::RuntimeFunction::OMPRTL___kmpc_end_serialized_parallel;
constexpr auto OMPRTL___kmpc_shuffle_int32 = omp::RuntimeFunction::OMPRTL___kmpc_shuffle_int32;
constexpr auto OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2 = omp::RuntimeFunction::OMPRTL___kmpc_nvptx_parallel_reduce_nowait_v2;

constexpr auto OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2 = omp::RuntimeFunction::OMPRTL___kmpc_nvptx_teams_reduce_nowait_v2;


constexpr auto OMPRTL___kmpc_reduction_get_fixed_buffer = omp::RuntimeFunction::OMPRTL___kmpc_reduction_get_fixed_buffer;

constexpr auto OMPRTL___kmpc_shuffle_int64 = omp::RuntimeFunction::OMPRTL___kmpc_shuffle_int64;

constexpr auto OMPRTL___kmpc_alloc_shared = omp::RuntimeFunction::OMPRTL___kmpc_alloc_shared;
constexpr auto OMPRTL___kmpc_free_shared = omp::RuntimeFunction::OMPRTL___kmpc_free_shared;
constexpr auto OMPRTL___kmpc_begin_sharing_variables = omp::RuntimeFunction::OMPRTL___kmpc_begin_sharing_variables;
constexpr auto OMPRTL___kmpc_end_sharing_variables = omp::RuntimeFunction::OMPRTL___kmpc_end_sharing_variables;
constexpr auto OMPRTL___kmpc_get_shared_variables = omp::RuntimeFunction::OMPRTL___kmpc_get_shared_variables;
constexpr auto OMPRTL___kmpc_parallel_level = omp::RuntimeFunction::OMPRTL___kmpc_parallel_level;
constexpr auto OMPRTL___kmpc_is_spmd_exec_mode = omp::RuntimeFunction::OMPRTL___kmpc_is_spmd_exec_mode;
constexpr auto OMPRTL___kmpc_barrier_simple_spmd = omp::RuntimeFunction::OMPRTL___kmpc_barrier_simple_spmd;
constexpr auto OMPRTL___kmpc_barrier_simple_generic = omp::RuntimeFunction::OMPRTL___kmpc_barrier_simple_generic;

constexpr auto OMPRTL___kmpc_warp_active_thread_mask = omp::RuntimeFunction::OMPRTL___kmpc_warp_active_thread_mask;
constexpr auto OMPRTL___kmpc_syncwarp = omp::RuntimeFunction::OMPRTL___kmpc_syncwarp;

constexpr auto OMPRTL___last = omp::RuntimeFunction::OMPRTL___last;
# 53 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2


enum class DefaultKind {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1152 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMP_DEFAULT_none,
OMP_DEFAULT_shared,
OMP_DEFAULT_private,
OMP_DEFAULT_firstprivate,
OMP_DEFAULT_unknown,
# 58 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
};



# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1152 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMP_DEFAULT_none = omp::DefaultKind::OMP_DEFAULT_none;
constexpr auto OMP_DEFAULT_shared = omp::DefaultKind::OMP_DEFAULT_shared;
constexpr auto OMP_DEFAULT_private = omp::DefaultKind::OMP_DEFAULT_private;
constexpr auto OMP_DEFAULT_firstprivate = omp::DefaultKind::OMP_DEFAULT_firstprivate;
constexpr auto OMP_DEFAULT_unknown = omp::DefaultKind::OMP_DEFAULT_unknown;
# 63 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2



enum class IdentFlag {

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1106 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
OMP_IDENT_FLAG_KMPC = 0x02,
OMP_IDENT_FLAG_ATOMIC_REDUCE = 0x10,
OMP_IDENT_FLAG_BARRIER_EXPL = 0x20,
OMP_IDENT_FLAG_BARRIER_IMPL = 0x0040,
OMP_IDENT_FLAG_BARRIER_IMPL_MASK = 0x01C0,
OMP_IDENT_FLAG_BARRIER_IMPL_FOR = 0x0040,
OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS = 0x00C0,
OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE = 0x0140,
OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE = 0x01C0,
# 69 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
 LLVM_BITMASK_LARGEST_ENUMERATOR = 0x7FFFFFFF
};


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def" 1
# 1106 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPKinds.def"
constexpr auto OMP_IDENT_FLAG_KMPC = omp::IdentFlag::OMP_IDENT_FLAG_KMPC;
constexpr auto OMP_IDENT_FLAG_ATOMIC_REDUCE = omp::IdentFlag::OMP_IDENT_FLAG_ATOMIC_REDUCE;
constexpr auto OMP_IDENT_FLAG_BARRIER_EXPL = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_EXPL;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_MASK = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_MASK;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_FOR = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_FOR;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_SECTIONS;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_SINGLE;
constexpr auto OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE = omp::IdentFlag::OMP_IDENT_FLAG_BARRIER_IMPL_WORKSHARE;
# 74 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2






enum class OMPScheduleType {

  None = 0,


  BaseStaticChunked = 1,
  BaseStatic = 2,
  BaseDynamicChunked = 3,
  BaseGuidedChunked = 4,
  BaseRuntime = 5,
  BaseAuto = 6,
  BaseTrapezoidal = 7,
  BaseGreedy = 8,
  BaseBalanced = 9,
  BaseGuidedIterativeChunked = 10,
  BaseGuidedAnalyticalChunked = 11,
  BaseSteal = 12,


  BaseStaticBalancedChunked = 13,
  BaseGuidedSimd = 14,
  BaseRuntimeSimd = 15,


  BaseDistributeChunked = 27,
  BaseDistribute = 28,


  ModifierUnordered = (1 << 5),
  ModifierOrdered = (1 << 6),
  ModifierNomerge = (1 << 7),
  ModifierMonotonic = (1 << 29),
  ModifierNonmonotonic = (1 << 30),


  OrderingMask = ModifierUnordered | ModifierOrdered | ModifierNomerge,
  MonotonicityMask = ModifierMonotonic | ModifierNonmonotonic,
  ModifierMask = OrderingMask | MonotonicityMask,


  UnorderedStaticChunked = BaseStaticChunked | ModifierUnordered,
  UnorderedStatic = BaseStatic | ModifierUnordered,
  UnorderedDynamicChunked = BaseDynamicChunked | ModifierUnordered,
  UnorderedGuidedChunked = BaseGuidedChunked | ModifierUnordered,
  UnorderedRuntime = BaseRuntime | ModifierUnordered,
  UnorderedAuto = BaseAuto | ModifierUnordered,
  UnorderedTrapezoidal = BaseTrapezoidal | ModifierUnordered,
  UnorderedGreedy = BaseGreedy | ModifierUnordered,
  UnorderedBalanced = BaseBalanced | ModifierUnordered,
  UnorderedGuidedIterativeChunked =
      BaseGuidedIterativeChunked | ModifierUnordered,
  UnorderedGuidedAnalyticalChunked =
      BaseGuidedAnalyticalChunked | ModifierUnordered,
  UnorderedSteal = BaseSteal | ModifierUnordered,

  UnorderedStaticBalancedChunked =
      BaseStaticBalancedChunked | ModifierUnordered,
  UnorderedGuidedSimd = BaseGuidedSimd | ModifierUnordered,
  UnorderedRuntimeSimd = BaseRuntimeSimd | ModifierUnordered,

  OrderedStaticChunked = BaseStaticChunked | ModifierOrdered,
  OrderedStatic = BaseStatic | ModifierOrdered,
  OrderedDynamicChunked = BaseDynamicChunked | ModifierOrdered,
  OrderedGuidedChunked = BaseGuidedChunked | ModifierOrdered,
  OrderedRuntime = BaseRuntime | ModifierOrdered,
  OrderedAuto = BaseAuto | ModifierOrdered,
  OrderdTrapezoidal = BaseTrapezoidal | ModifierOrdered,

  OrderedDistributeChunked = BaseDistributeChunked | ModifierOrdered,
  OrderedDistribute = BaseDistribute | ModifierOrdered,

  NomergeUnorderedStaticChunked =
      BaseStaticChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedStatic =
      BaseStatic | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedDynamicChunked =
      BaseDynamicChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedChunked =
      BaseGuidedChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedRuntime =
      BaseRuntime | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedAuto = BaseAuto | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedTrapezoidal =
      BaseTrapezoidal | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGreedy =
      BaseGreedy | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedBalanced =
      BaseBalanced | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedIterativeChunked =
      BaseGuidedIterativeChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedGuidedAnalyticalChunked =
      BaseGuidedAnalyticalChunked | ModifierUnordered | ModifierNomerge,
  NomergeUnorderedSteal =
      BaseSteal | ModifierUnordered | ModifierNomerge,

  NomergeOrderedStaticChunked =
      BaseStaticChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedStatic = BaseStatic | ModifierOrdered | ModifierNomerge,
  NomergeOrderedDynamicChunked =
      BaseDynamicChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedGuidedChunked =
      BaseGuidedChunked | ModifierOrdered | ModifierNomerge,
  NomergeOrderedRuntime =
      BaseRuntime | ModifierOrdered | ModifierNomerge,
  NomergeOrderedAuto = BaseAuto | ModifierOrdered | ModifierNomerge,
  NomergeOrderedTrapezoidal =
      BaseTrapezoidal | ModifierOrdered | ModifierNomerge,

  LLVM_BITMASK_LARGEST_ENUMERATOR = ModifierMask
};



enum class OpenMPOffloadMappingFlags : uint64_t {

  OMP_MAP_NONE = 0x0,

  OMP_MAP_TO = 0x01,

  OMP_MAP_FROM = 0x02,


  OMP_MAP_ALWAYS = 0x04,


  OMP_MAP_DELETE = 0x08,


  OMP_MAP_PTR_AND_OBJ = 0x10,


  OMP_MAP_TARGET_PARAM = 0x20,



  OMP_MAP_RETURN_PARAM = 0x40,


  OMP_MAP_PRIVATE = 0x80,

  OMP_MAP_LITERAL = 0x100,

  OMP_MAP_IMPLICIT = 0x200,


  OMP_MAP_CLOSE = 0x400,


  OMP_MAP_PRESENT = 0x1000,







  OMP_MAP_OMPX_HOLD = 0x2000,



  OMP_MAP_NON_CONTIG = 0x100000000000,


  OMP_MAP_MEMBER_OF = 0xffff000000000000,
  LLVM_BITMASK_LARGEST_ENUMERATOR = OMP_MAP_MEMBER_OF
};

enum OpenMPOffloadingReservedDeviceIDs {


  OMP_DEVICEID_UNDEF = -1
};

enum class AddressSpace : unsigned {
  Generic = 0,
  Global = 1,
  Shared = 3,
  Constant = 4,
  Local = 5,
};


enum class OMPInteropType { Unknown, Target, TargetSync };


enum class OMPAtomicCompareOp : unsigned { EQ, MIN, MAX };


enum class RTLDependInfoFields { BaseAddr, Len, Flags };


enum class RTLDependenceKindTy {
  DepUnknown = 0x0,
  DepIn = 0x01,
  DepInOut = 0x3,
  DepMutexInOutSet = 0x4,
  DepInOutSet = 0x8,
  DepOmpAllMem = 0x80,
};


enum class WorksharingLoopType {

  ForStaticLoop,

  DistributeStaticLoop,

  DistributeForStaticLoop
};

}

}

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPDeviceConstants.h" 1
# 18 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPDeviceConstants.h"
namespace llvm {
namespace omp {

enum OMPTgtExecModeFlags : unsigned char {
  OMP_TGT_EXEC_MODE_GENERIC = 1 << 0,
  OMP_TGT_EXEC_MODE_SPMD = 1 << 1,
  OMP_TGT_EXEC_MODE_GENERIC_SPMD =
      OMP_TGT_EXEC_MODE_GENERIC | OMP_TGT_EXEC_MODE_SPMD
};

}
}
# 295 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMPConstants.h" 2
# 30 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2


# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 1 3
# 974 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 1 3
# 20 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 1 3 4
# 44 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/stdlib.h" 1 3 4
# 45 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 2 3 4
# 81 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/assert.h" 3 4
extern "C" {
void __assert_rtn(const char *, const char *, int, const char *) __attribute__((__noreturn__)) __attribute__((__cold__)) __attribute__((__disable_tail_calls__));



}
# 21 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 2 3
# 24 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/cassert" 3
# 975 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/memory" 2 3
# 33 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2



# 1 "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/c++/v1/type_traits" 1 3
# 37 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
# 50 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
namespace class_trait_ns_EmptyTrait { template <typename A> std::true_type test(typename A::EmptyTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::EmptyTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool EmptyTrait{class_trait_ns_EmptyTrait::trait_value<A>()};
namespace class_trait_ns_WrapperTrait { template <typename A> std::true_type test(typename A::WrapperTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::WrapperTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool WrapperTrait{class_trait_ns_WrapperTrait::trait_value<A>()};
namespace class_trait_ns_UnionTrait { template <typename A> std::true_type test(typename A::UnionTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::UnionTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool UnionTrait{class_trait_ns_UnionTrait::trait_value<A>()};
namespace class_trait_ns_TupleTrait { template <typename A> std::true_type test(typename A::TupleTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::TupleTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool TupleTrait{class_trait_ns_TupleTrait::trait_value<A>()};
namespace class_trait_ns_ConstraintTrait { template <typename A> std::true_type test(typename A::ConstraintTrait *); template <typename A> std::false_type test(...); template <typename A> constexpr bool has_trait{decltype(test<A>(nullptr))::value}; template <typename A> constexpr bool trait_value() { if constexpr (has_trait<A>) { using U = typename A::ConstraintTrait; return U::value; } else { return false; } } } template <typename A> constexpr bool ConstraintTrait{class_trait_ns_ConstraintTrait::trait_value<A>()};




namespace Fortran::semantics {
class Symbol;
class DeclTypeSpec;
class DerivedTypeSpec;
}



namespace Fortran::evaluate {
struct GenericExprWrapper;
struct GenericAssignmentWrapper;
class ProcedureRef;
}
# 128 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
namespace Fortran::parser {


struct Verbatim {

  constexpr Verbatim() {}
  Verbatim(Verbatim &&) = default; Verbatim &operator=(Verbatim &&) = default; Verbatim(const Verbatim &) = delete; Verbatim &operator=(const Verbatim &) = delete;
  using EmptyTrait = std::true_type;
  CharBlock source;
};

template <typename A> struct Scalar {
  using ConstraintTrait = std::true_type;
  Scalar(Scalar &&that) = default;
  Scalar(A &&that) : thing(std::move(that)) {}
  Scalar &operator=(Scalar &&) = default;
  A thing;
};

template <typename A> struct Constant {
  using ConstraintTrait = std::true_type;
  Constant(Constant &&that) = default;
  Constant(A &&that) : thing(std::move(that)) {}
  Constant &operator=(Constant &&) = default;
  A thing;
};

template <typename A> struct Integer {
  using ConstraintTrait = std::true_type;
  Integer(Integer &&that) = default;
  Integer(A &&that) : thing(std::move(that)) {}
  Integer &operator=(Integer &&) = default;
  A thing;
};

template <typename A> struct Logical {
  using ConstraintTrait = std::true_type;
  Logical(Logical &&that) = default;
  Logical(A &&that) : thing(std::move(that)) {}
  Logical &operator=(Logical &&) = default;
  A thing;
};

template <typename A> struct DefaultChar {
  using ConstraintTrait = std::true_type;
  DefaultChar(DefaultChar &&that) = default;
  DefaultChar(A &&that) : thing(std::move(that)) {}
  DefaultChar &operator=(DefaultChar &&) = default;
  A thing;
};

using LogicalExpr = Logical<common::Indirection<Expr>>;
using DefaultCharExpr = DefaultChar<common::Indirection<Expr>>;
using IntExpr = Integer<common::Indirection<Expr>>;
using ConstantExpr = Constant<common::Indirection<Expr>>;
using IntConstantExpr = Integer<ConstantExpr>;
using ScalarLogicalExpr = Scalar<LogicalExpr>;
using ScalarIntExpr = Scalar<IntExpr>;
using ScalarIntConstantExpr = Scalar<IntConstantExpr>;
using ScalarDefaultCharExpr = Scalar<DefaultCharExpr>;


using ScalarDefaultCharConstantExpr = Scalar<DefaultChar<ConstantExpr>>;


using Label = common::Label;



template <typename A> struct UnlabeledStatement {
  explicit UnlabeledStatement(A &&s) : statement(std::move(s)) {}
  CharBlock source;
  A statement;
};
template <typename A> struct Statement : public UnlabeledStatement<A> {
  Statement(std::optional<long> &&lab, A &&s)
      : UnlabeledStatement<A>{std::move(s)}, label(std::move(lab)) {}
  std::optional<Label> label;
};


struct ErrorRecovery { ErrorRecovery() {} ErrorRecovery(const ErrorRecovery &) {} ErrorRecovery(ErrorRecovery &&) {} ErrorRecovery &operator=(const ErrorRecovery &) { return *this; }; ErrorRecovery &operator=(ErrorRecovery &&) { return *this; }; using EmptyTrait = std::true_type; };
# 368 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct OtherSpecificationStmt {
  template <typename A, typename = common::NoLvalue<A>> OtherSpecificationStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OtherSpecificationStmt(OtherSpecificationStmt &&) = default; OtherSpecificationStmt &operator=(OtherSpecificationStmt &&) = default; OtherSpecificationStmt(const OtherSpecificationStmt &) = delete; OtherSpecificationStmt &operator=(const OtherSpecificationStmt &) = delete; OtherSpecificationStmt() = delete;
  std::variant<common::Indirection<AccessStmt>,
      common::Indirection<AllocatableStmt>,
      common::Indirection<AsynchronousStmt>, common::Indirection<BindStmt>,
      common::Indirection<CodimensionStmt>, common::Indirection<ContiguousStmt>,
      common::Indirection<DimensionStmt>, common::Indirection<ExternalStmt>,
      common::Indirection<IntentStmt>, common::Indirection<IntrinsicStmt>,
      common::Indirection<NamelistStmt>, common::Indirection<OptionalStmt>,
      common::Indirection<PointerStmt>, common::Indirection<ProtectedStmt>,
      common::Indirection<SaveStmt>, common::Indirection<TargetStmt>,
      common::Indirection<ValueStmt>, common::Indirection<VolatileStmt>,
      common::Indirection<CommonStmt>, common::Indirection<EquivalenceStmt>,
      common::Indirection<BasedPointerStmt>,
      common::Indirection<CUDAAttributesStmt>>
      u;
};





struct SpecificationConstruct {
  template <typename A, typename = common::NoLvalue<A>> SpecificationConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; SpecificationConstruct(SpecificationConstruct &&) = default; SpecificationConstruct &operator=(SpecificationConstruct &&) = default; SpecificationConstruct(const SpecificationConstruct &) = delete; SpecificationConstruct &operator=(const SpecificationConstruct &) = delete; SpecificationConstruct() = delete;
  std::variant<common::Indirection<DerivedTypeDef>,
      common::Indirection<EnumDef>, Statement<common::Indirection<GenericStmt>>,
      common::Indirection<InterfaceBlock>,
      Statement<common::Indirection<ParameterStmt>>,
      Statement<common::Indirection<OldParameterStmt>>,
      Statement<common::Indirection<ProcedureDeclarationStmt>>,
      Statement<OtherSpecificationStmt>,
      Statement<common::Indirection<TypeDeclarationStmt>>,
      common::Indirection<StructureDef>,
      common::Indirection<OpenACCDeclarativeConstruct>,
      common::Indirection<OpenMPDeclarativeConstruct>,
      common::Indirection<CompilerDirective>>
      u;
};



struct ImplicitPartStmt {
  template <typename A, typename = common::NoLvalue<A>> ImplicitPartStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImplicitPartStmt(ImplicitPartStmt &&) = default; ImplicitPartStmt &operator=(ImplicitPartStmt &&) = default; ImplicitPartStmt(const ImplicitPartStmt &) = delete; ImplicitPartStmt &operator=(const ImplicitPartStmt &) = delete; ImplicitPartStmt() = delete;
  std::variant<Statement<common::Indirection<ImplicitStmt>>,
      Statement<common::Indirection<ParameterStmt>>,
      Statement<common::Indirection<OldParameterStmt>>,
      Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCDeclarativeConstruct>>
      u;
};


struct ImplicitPart { ImplicitPart(ImplicitPart &&) = default; ImplicitPart &operator=(ImplicitPart &&) = default; ImplicitPart(const ImplicitPart &) = delete; ImplicitPart &operator=(const ImplicitPart &) = delete; ImplicitPart() = delete; ImplicitPart(std::list<ImplicitPartStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ImplicitPartStmt> v; };




struct DeclarationConstruct {
  template <typename A, typename = common::NoLvalue<A>> DeclarationConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DeclarationConstruct(DeclarationConstruct &&) = default; DeclarationConstruct &operator=(DeclarationConstruct &&) = default; DeclarationConstruct(const DeclarationConstruct &) = delete; DeclarationConstruct &operator=(const DeclarationConstruct &) = delete; DeclarationConstruct() = delete;
  std::variant<SpecificationConstruct, Statement<common::Indirection<DataStmt>>,
      Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      Statement<common::Indirection<StmtFunctionStmt>>, ErrorRecovery>
      u;
};






struct SpecificationPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SpecificationPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SpecificationPart(SpecificationPart &&) = default; SpecificationPart &operator=(SpecificationPart &&) = default; SpecificationPart(const SpecificationPart &) = delete; SpecificationPart &operator=(const SpecificationPart &) = delete; SpecificationPart() = delete;
  std::tuple<std::list<OpenACCDeclarativeConstruct>,
      std::list<OpenMPDeclarativeConstruct>,
      std::list<common::Indirection<CompilerDirective>>,
      std::list<Statement<common::Indirection<UseStmt>>>,
      std::list<Statement<common::Indirection<ImportStmt>>>, ImplicitPart,
      std::list<DeclarationConstruct>>
      t;
};


struct InternalSubprogram {
  template <typename A, typename = common::NoLvalue<A>> InternalSubprogram(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InternalSubprogram(InternalSubprogram &&) = default; InternalSubprogram &operator=(InternalSubprogram &&) = default; InternalSubprogram(const InternalSubprogram &) = delete; InternalSubprogram &operator=(const InternalSubprogram &) = delete; InternalSubprogram() = delete;
  std::variant<common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>>
      u;
};


struct ContainsStmt { ContainsStmt() {} ContainsStmt(const ContainsStmt &) {} ContainsStmt(ContainsStmt &&) {} ContainsStmt &operator=(const ContainsStmt &) { return *this; }; ContainsStmt &operator=(ContainsStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct InternalSubprogramPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InternalSubprogramPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InternalSubprogramPart(InternalSubprogramPart &&) = default; InternalSubprogramPart &operator=(InternalSubprogramPart &&) = default; InternalSubprogramPart(const InternalSubprogramPart &) = delete; InternalSubprogramPart &operator=(const InternalSubprogramPart &) = delete; InternalSubprogramPart() = delete;
  std::tuple<Statement<ContainsStmt>, std::list<InternalSubprogram>> t;
};


struct ContinueStmt { ContinueStmt() {} ContinueStmt(const ContinueStmt &) {} ContinueStmt(ContinueStmt &&) {} ContinueStmt &operator=(const ContinueStmt &) { return *this; }; ContinueStmt &operator=(ContinueStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct FailImageStmt { FailImageStmt() {} FailImageStmt(const FailImageStmt &) {} FailImageStmt(FailImageStmt &&) {} FailImageStmt &operator=(const FailImageStmt &) { return *this; }; FailImageStmt &operator=(FailImageStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
# 485 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct ActionStmt {
  template <typename A, typename = common::NoLvalue<A>> ActionStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ActionStmt(ActionStmt &&) = default; ActionStmt &operator=(ActionStmt &&) = default; ActionStmt(const ActionStmt &) = delete; ActionStmt &operator=(const ActionStmt &) = delete; ActionStmt() = delete;
  std::variant<common::Indirection<AllocateStmt>,
      common::Indirection<AssignmentStmt>, common::Indirection<BackspaceStmt>,
      common::Indirection<CallStmt>, common::Indirection<CloseStmt>,
      ContinueStmt, common::Indirection<CycleStmt>,
      common::Indirection<DeallocateStmt>, common::Indirection<EndfileStmt>,
      common::Indirection<EventPostStmt>, common::Indirection<EventWaitStmt>,
      common::Indirection<ExitStmt>, FailImageStmt,
      common::Indirection<FlushStmt>, common::Indirection<FormTeamStmt>,
      common::Indirection<GotoStmt>, common::Indirection<IfStmt>,
      common::Indirection<InquireStmt>, common::Indirection<LockStmt>,
      common::Indirection<NullifyStmt>, common::Indirection<OpenStmt>,
      common::Indirection<PointerAssignmentStmt>,
      common::Indirection<PrintStmt>, common::Indirection<ReadStmt>,
      common::Indirection<ReturnStmt>, common::Indirection<RewindStmt>,
      common::Indirection<StopStmt>, common::Indirection<SyncAllStmt>,
      common::Indirection<SyncImagesStmt>, common::Indirection<SyncMemoryStmt>,
      common::Indirection<SyncTeamStmt>, common::Indirection<UnlockStmt>,
      common::Indirection<WaitStmt>, common::Indirection<WhereStmt>,
      common::Indirection<WriteStmt>, common::Indirection<ComputedGotoStmt>,
      common::Indirection<ForallStmt>, common::Indirection<ArithmeticIfStmt>,
      common::Indirection<AssignStmt>, common::Indirection<AssignedGotoStmt>,
      common::Indirection<PauseStmt>>
      u;
};







struct ExecutableConstruct {
  template <typename A, typename = common::NoLvalue<A>> ExecutableConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ExecutableConstruct(ExecutableConstruct &&) = default; ExecutableConstruct &operator=(ExecutableConstruct &&) = default; ExecutableConstruct(const ExecutableConstruct &) = delete; ExecutableConstruct &operator=(const ExecutableConstruct &) = delete; ExecutableConstruct() = delete;
  std::variant<Statement<ActionStmt>, common::Indirection<AssociateConstruct>,
      common::Indirection<BlockConstruct>, common::Indirection<CaseConstruct>,
      common::Indirection<ChangeTeamConstruct>,
      common::Indirection<CriticalConstruct>,
      Statement<common::Indirection<LabelDoStmt>>,
      Statement<common::Indirection<EndDoStmt>>,
      common::Indirection<DoConstruct>, common::Indirection<IfConstruct>,
      common::Indirection<SelectRankConstruct>,
      common::Indirection<SelectTypeConstruct>,
      common::Indirection<WhereConstruct>, common::Indirection<ForallConstruct>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCConstruct>,
      common::Indirection<AccEndCombinedDirective>,
      common::Indirection<OpenMPConstruct>,
      common::Indirection<OmpEndLoopDirective>,
      common::Indirection<CUFKernelDoConstruct>>
      u;
};




struct ExecutionPartConstruct {
  template <typename A, typename = common::NoLvalue<A>> ExecutionPartConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ExecutionPartConstruct(ExecutionPartConstruct &&) = default; ExecutionPartConstruct &operator=(ExecutionPartConstruct &&) = default; ExecutionPartConstruct(const ExecutionPartConstruct &) = delete; ExecutionPartConstruct &operator=(const ExecutionPartConstruct &) = delete; ExecutionPartConstruct() = delete;
  std::variant<ExecutableConstruct, Statement<common::Indirection<FormatStmt>>,
      Statement<common::Indirection<EntryStmt>>,
      Statement<common::Indirection<DataStmt>>,
      Statement<common::Indirection<NamelistStmt>>, ErrorRecovery>
      u;
};


struct ExecutionPart { ExecutionPart(ExecutionPart &&) = default; ExecutionPart &operator=(ExecutionPart &&) = default; ExecutionPart(const ExecutionPart &) = delete; ExecutionPart &operator=(const ExecutionPart &) = delete; ExecutionPart() = delete; ExecutionPart(std::list<ExecutionPartConstruct> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ExecutionPartConstruct> v; };




struct ProgramUnit {
  template <typename A, typename = common::NoLvalue<A>> ProgramUnit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProgramUnit(ProgramUnit &&) = default; ProgramUnit &operator=(ProgramUnit &&) = default; ProgramUnit(const ProgramUnit &) = delete; ProgramUnit &operator=(const ProgramUnit &) = delete; ProgramUnit() = delete;
  std::variant<common::Indirection<MainProgram>,
      common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>, common::Indirection<Module>,
      common::Indirection<Submodule>, common::Indirection<BlockData>,
      common::Indirection<CompilerDirective>,
      common::Indirection<OpenACCRoutineConstruct>>
      u;
};



struct Program { Program(Program &&) = default; Program &operator=(Program &&) = default; Program(const Program &) = delete; Program &operator=(const Program &) = delete; Program() = delete; Program(std::list<ProgramUnit> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ProgramUnit> v; };


struct Name {
  std::string ToString() const { return source.ToString(); }
  CharBlock source;
  mutable semantics::Symbol *symbol{nullptr};
};


struct Keyword { Keyword(Keyword &&) = default; Keyword &operator=(Keyword &&) = default; Keyword(const Keyword &) = delete; Keyword &operator=(const Keyword &) = delete; Keyword() = delete; Keyword(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct NamedConstant { NamedConstant(NamedConstant &&) = default; NamedConstant &operator=(NamedConstant &&) = default; NamedConstant(const NamedConstant &) = delete; NamedConstant &operator=(const NamedConstant &) = delete; NamedConstant() = delete; NamedConstant(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };






struct DefinedOpName { DefinedOpName(DefinedOpName &&) = default; DefinedOpName &operator=(DefinedOpName &&) = default; DefinedOpName(const DefinedOpName &) = delete; DefinedOpName &operator=(const DefinedOpName &) = delete; DefinedOpName() = delete; DefinedOpName(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };







struct DefinedOperator {
  template <typename A, typename = common::NoLvalue<A>> DefinedOperator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DefinedOperator(DefinedOperator &&) = default; DefinedOperator &operator=(DefinedOperator &&) = default; DefinedOperator(const DefinedOperator &) = delete; DefinedOperator &operator=(const DefinedOperator &) = delete; DefinedOperator() = delete;
  enum class IntrinsicOperator { Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV }; [[maybe_unused]] static constexpr std::size_t IntrinsicOperator_enumSize{ ::Fortran::common::CountEnumNames("Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV")}; [[maybe_unused]] static inline std::string_view EnumToString(IntrinsicOperator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<IntrinsicOperator_enumSize>("Power, Multiply, Divide, Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, NOT, AND, OR, EQV, NEQV")}; return names[static_cast<std::size_t>(e)]; }

  std::variant<DefinedOpName, IntrinsicOperator> u;
};


using ObjectName = Name;




struct ImportStmt {
  ImportStmt(ImportStmt &&) = default; ImportStmt &operator=(ImportStmt &&) = default; ImportStmt(const ImportStmt &) = delete; ImportStmt &operator=(const ImportStmt &) = delete; ImportStmt() = delete;
  ImportStmt(common::ImportKind &&k) : kind{k} {}
  ImportStmt(std::list<Name> &&n) : names(std::move(n)) {}
  ImportStmt(common::ImportKind &&, std::list<Name> &&);
  common::ImportKind kind{common::ImportKind::Default};
  std::list<Name> names;
};





struct NamelistStmt {
  struct Group {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Group(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Group(Group &&) = default; Group &operator=(Group &&) = default; Group(const Group &) = delete; Group &operator=(const Group &) = delete; Group() = delete;
    std::tuple<Name, std::list<Name>> t;
  };
  NamelistStmt(NamelistStmt &&) = default; NamelistStmt &operator=(NamelistStmt &&) = default; NamelistStmt(const NamelistStmt &) = delete; NamelistStmt &operator=(const NamelistStmt &) = delete; NamelistStmt() = delete; NamelistStmt(std::list<Group> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Group> v;
};


struct Star { Star() {} Star(const Star &) {} Star(Star &&) {} Star &operator=(const Star &) { return *this; }; Star &operator=(Star &&) { return *this; }; using EmptyTrait = std::true_type; };

struct TypeParamValue {
  template <typename A, typename = common::NoLvalue<A>> TypeParamValue(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeParamValue(TypeParamValue &&) = default; TypeParamValue &operator=(TypeParamValue &&) = default; TypeParamValue(const TypeParamValue &) = delete; TypeParamValue &operator=(const TypeParamValue &) = delete; TypeParamValue() = delete;
  struct Deferred { Deferred() {} Deferred(const Deferred &) {} Deferred(Deferred &&) {} Deferred &operator=(const Deferred &) { return *this; }; Deferred &operator=(Deferred &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<ScalarIntExpr, Star, Deferred> u;
};




struct KindSelector {
  template <typename A, typename = common::NoLvalue<A>> KindSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; KindSelector(KindSelector &&) = default; KindSelector &operator=(KindSelector &&) = default; KindSelector(const KindSelector &) = delete; KindSelector &operator=(const KindSelector &) = delete; KindSelector() = delete;
  struct StarSize { StarSize(StarSize &&) = default; StarSize &operator=(StarSize &&) = default; StarSize(const StarSize &) = delete; StarSize &operator=(const StarSize &) = delete; StarSize() = delete; StarSize(std::uint64_t &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::uint64_t v; };
  std::variant<ScalarIntConstantExpr, StarSize> u;
};


struct IntegerTypeSpec { IntegerTypeSpec(IntegerTypeSpec &&) = default; IntegerTypeSpec &operator=(IntegerTypeSpec &&) = default; IntegerTypeSpec(const IntegerTypeSpec &) = delete; IntegerTypeSpec &operator=(const IntegerTypeSpec &) = delete; IntegerTypeSpec() = delete; IntegerTypeSpec(std::optional<KindSelector> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<KindSelector> v; };


struct CharLength {
  template <typename A, typename = common::NoLvalue<A>> CharLength(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CharLength(CharLength &&) = default; CharLength &operator=(CharLength &&) = default; CharLength(const CharLength &) = delete; CharLength &operator=(const CharLength &) = delete; CharLength() = delete;
  std::variant<TypeParamValue, std::uint64_t> u;
};


struct LengthSelector {
  template <typename A, typename = common::NoLvalue<A>> LengthSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LengthSelector(LengthSelector &&) = default; LengthSelector &operator=(LengthSelector &&) = default; LengthSelector(const LengthSelector &) = delete; LengthSelector &operator=(const LengthSelector &) = delete; LengthSelector() = delete;
  std::variant<TypeParamValue, CharLength> u;
};






struct CharSelector {
  template <typename A, typename = common::NoLvalue<A>> CharSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CharSelector(CharSelector &&) = default; CharSelector &operator=(CharSelector &&) = default; CharSelector(const CharSelector &) = delete; CharSelector &operator=(const CharSelector &) = delete; CharSelector() = delete;
  struct LengthAndKind {
    LengthAndKind(LengthAndKind &&) = default; LengthAndKind &operator=(LengthAndKind &&) = default; LengthAndKind(const LengthAndKind &) = delete; LengthAndKind &operator=(const LengthAndKind &) = delete; LengthAndKind() = delete;
    LengthAndKind(std::optional<TypeParamValue> &&l, ScalarIntConstantExpr &&k)
        : length(std::move(l)), kind(std::move(k)) {}
    std::optional<TypeParamValue> length;
    ScalarIntConstantExpr kind;
  };
  CharSelector(TypeParamValue &&l, ScalarIntConstantExpr &&k)
      : u{LengthAndKind{std::make_optional(std::move(l)), std::move(k)}} {}
  CharSelector(ScalarIntConstantExpr &&k, std::optional<TypeParamValue> &&l)
      : u{LengthAndKind{std::move(l), std::move(k)}} {}
  std::variant<LengthSelector, LengthAndKind> u;
};






struct IntrinsicTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> IntrinsicTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IntrinsicTypeSpec(IntrinsicTypeSpec &&) = default; IntrinsicTypeSpec &operator=(IntrinsicTypeSpec &&) = default; IntrinsicTypeSpec(const IntrinsicTypeSpec &) = delete; IntrinsicTypeSpec &operator=(const IntrinsicTypeSpec &) = delete; IntrinsicTypeSpec() = delete;
  struct Real {
    Real(Real &&) = default; Real &operator=(Real &&) = default; Real(const Real &) = delete; Real &operator=(const Real &) = delete; Real() = delete;
    Real(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct DoublePrecision { DoublePrecision() {} DoublePrecision(const DoublePrecision &) {} DoublePrecision(DoublePrecision &&) {} DoublePrecision &operator=(const DoublePrecision &) { return *this; }; DoublePrecision &operator=(DoublePrecision &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Complex {
    Complex(Complex &&) = default; Complex &operator=(Complex &&) = default; Complex(const Complex &) = delete; Complex &operator=(const Complex &) = delete; Complex() = delete;
    Complex(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct Character {
    Character(Character &&) = default; Character &operator=(Character &&) = default; Character(const Character &) = delete; Character &operator=(const Character &) = delete; Character() = delete;
    Character(std::optional<CharSelector> &&s) : selector{std::move(s)} {}
    std::optional<CharSelector> selector;
  };
  struct Logical {
    Logical(Logical &&) = default; Logical &operator=(Logical &&) = default; Logical(const Logical &) = delete; Logical &operator=(const Logical &) = delete; Logical() = delete;
    Logical(std::optional<KindSelector> &&k) : kind{std::move(k)} {}
    std::optional<KindSelector> kind;
  };
  struct DoubleComplex { DoubleComplex() {} DoubleComplex(const DoubleComplex &) {} DoubleComplex(DoubleComplex &&) {} DoubleComplex &operator=(const DoubleComplex &) { return *this; }; DoubleComplex &operator=(DoubleComplex &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<IntegerTypeSpec, Real, DoublePrecision, Complex, Character,
      Logical, DoubleComplex>
      u;
};


struct UnsignedTypeSpec { UnsignedTypeSpec(UnsignedTypeSpec &&) = default; UnsignedTypeSpec &operator=(UnsignedTypeSpec &&) = default; UnsignedTypeSpec(const UnsignedTypeSpec &) = delete; UnsignedTypeSpec &operator=(const UnsignedTypeSpec &) = delete; UnsignedTypeSpec() = delete; UnsignedTypeSpec(std::optional<KindSelector> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<KindSelector> v; };
struct VectorElementType {
  template <typename A, typename = common::NoLvalue<A>> VectorElementType(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; VectorElementType(VectorElementType &&) = default; VectorElementType &operator=(VectorElementType &&) = default; VectorElementType(const VectorElementType &) = delete; VectorElementType &operator=(const VectorElementType &) = delete; VectorElementType() = delete;
  std::variant<IntegerTypeSpec, IntrinsicTypeSpec::Real, UnsignedTypeSpec> u;
};
struct IntrinsicVectorTypeSpec { IntrinsicVectorTypeSpec(IntrinsicVectorTypeSpec &&) = default; IntrinsicVectorTypeSpec &operator=(IntrinsicVectorTypeSpec &&) = default; IntrinsicVectorTypeSpec(const IntrinsicVectorTypeSpec &) = delete; IntrinsicVectorTypeSpec &operator=(const IntrinsicVectorTypeSpec &) = delete; IntrinsicVectorTypeSpec() = delete; IntrinsicVectorTypeSpec(VectorElementType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; VectorElementType v; };
struct VectorTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> VectorTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; VectorTypeSpec(VectorTypeSpec &&) = default; VectorTypeSpec &operator=(VectorTypeSpec &&) = default; VectorTypeSpec(const VectorTypeSpec &) = delete; VectorTypeSpec &operator=(const VectorTypeSpec &) = delete; VectorTypeSpec() = delete;
  struct PairVectorTypeSpec { PairVectorTypeSpec() {} PairVectorTypeSpec(const PairVectorTypeSpec &) {} PairVectorTypeSpec(PairVectorTypeSpec &&) {} PairVectorTypeSpec &operator=(const PairVectorTypeSpec &) { return *this; }; PairVectorTypeSpec &operator=(PairVectorTypeSpec &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct QuadVectorTypeSpec { QuadVectorTypeSpec() {} QuadVectorTypeSpec(const QuadVectorTypeSpec &) {} QuadVectorTypeSpec(QuadVectorTypeSpec &&) {} QuadVectorTypeSpec &operator=(const QuadVectorTypeSpec &) { return *this; }; QuadVectorTypeSpec &operator=(QuadVectorTypeSpec &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<IntrinsicVectorTypeSpec, PairVectorTypeSpec, QuadVectorTypeSpec>
      u;
};


struct TypeParamSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamSpec(TypeParamSpec &&) = default; TypeParamSpec &operator=(TypeParamSpec &&) = default; TypeParamSpec(const TypeParamSpec &) = delete; TypeParamSpec &operator=(const TypeParamSpec &) = delete; TypeParamSpec() = delete;
  std::tuple<std::optional<Keyword>, TypeParamValue> t;
};


struct DerivedTypeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeSpec(DerivedTypeSpec &&) = default; DerivedTypeSpec &operator=(DerivedTypeSpec &&) = default; DerivedTypeSpec(const DerivedTypeSpec &) = delete; DerivedTypeSpec &operator=(const DerivedTypeSpec &) = delete; DerivedTypeSpec() = delete;
  mutable const semantics::DerivedTypeSpec *derivedTypeSpec{nullptr};
  std::tuple<Name, std::list<TypeParamSpec>> t;
};


struct TypeSpec {
  template <typename A, typename = common::NoLvalue<A>> TypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeSpec(TypeSpec &&) = default; TypeSpec &operator=(TypeSpec &&) = default; TypeSpec(const TypeSpec &) = delete; TypeSpec &operator=(const TypeSpec &) = delete; TypeSpec() = delete;
  mutable const semantics::DeclTypeSpec *declTypeSpec{nullptr};
  std::variant<IntrinsicTypeSpec, DerivedTypeSpec> u;
};






struct DeclarationTypeSpec {
  template <typename A, typename = common::NoLvalue<A>> DeclarationTypeSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DeclarationTypeSpec(DeclarationTypeSpec &&) = default; DeclarationTypeSpec &operator=(DeclarationTypeSpec &&) = default; DeclarationTypeSpec(const DeclarationTypeSpec &) = delete; DeclarationTypeSpec &operator=(const DeclarationTypeSpec &) = delete; DeclarationTypeSpec() = delete;
  struct Type {
    Type(Type &&) = default; Type &operator=(Type &&) = default; Type(const Type &) = delete; Type &operator=(const Type &) = delete; Type() = delete;
    Type(DerivedTypeSpec &&dt) : derived(std::move(dt)) {}
    DerivedTypeSpec derived;
  };
  struct Class {
    Class(Class &&) = default; Class &operator=(Class &&) = default; Class(const Class &) = delete; Class &operator=(const Class &) = delete; Class() = delete;
    Class(DerivedTypeSpec &&dt) : derived(std::move(dt)) {}
    DerivedTypeSpec derived;
  };
  struct ClassStar { ClassStar() {} ClassStar(const ClassStar &) {} ClassStar(ClassStar &&) {} ClassStar &operator=(const ClassStar &) { return *this; }; ClassStar &operator=(ClassStar &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct TypeStar { TypeStar() {} TypeStar(const TypeStar &) {} TypeStar(TypeStar &&) {} TypeStar &operator=(const TypeStar &) { return *this; }; TypeStar &operator=(TypeStar &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Record { Record(Record &&) = default; Record &operator=(Record &&) = default; Record(const Record &) = delete; Record &operator=(const Record &) = delete; Record() = delete; Record(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };
  std::variant<IntrinsicTypeSpec, Type, Class, ClassStar, TypeStar, Record,
      VectorTypeSpec>
      u;
};


struct KindParam {
  template <typename A, typename = common::NoLvalue<A>> KindParam(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; KindParam(KindParam &&) = default; KindParam &operator=(KindParam &&) = default; KindParam(const KindParam &) = delete; KindParam &operator=(const KindParam &) = delete; KindParam() = delete;
  std::variant<std::uint64_t, Scalar<Integer<Constant<Name>>>> u;
};


struct SignedIntLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedIntLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedIntLiteralConstant(SignedIntLiteralConstant &&) = default; SignedIntLiteralConstant &operator=(SignedIntLiteralConstant &&) = default; SignedIntLiteralConstant(const SignedIntLiteralConstant &) = delete; SignedIntLiteralConstant &operator=(const SignedIntLiteralConstant &) = delete; SignedIntLiteralConstant() = delete;
  CharBlock source;
  std::tuple<CharBlock, std::optional<KindParam>> t;
};


struct IntLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IntLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntLiteralConstant(IntLiteralConstant &&) = default; IntLiteralConstant &operator=(IntLiteralConstant &&) = default; IntLiteralConstant(const IntLiteralConstant &) = delete; IntLiteralConstant &operator=(const IntLiteralConstant &) = delete; IntLiteralConstant() = delete;
  std::tuple<CharBlock, std::optional<KindParam>> t;
};


enum class Sign { Positive, Negative };






struct RealLiteralConstant {
  RealLiteralConstant(RealLiteralConstant &&) = default; RealLiteralConstant &operator=(RealLiteralConstant &&) = default; RealLiteralConstant(const RealLiteralConstant &) = delete; RealLiteralConstant &operator=(const RealLiteralConstant &) = delete; RealLiteralConstant() = delete;
  struct Real {
    Real(Real &&) = default; Real &operator=(Real &&) = default; Real(const Real &) = delete; Real &operator=(const Real &) = delete;
    Real() {}
    CharBlock source;
  };
  RealLiteralConstant(Real &&r, std::optional<KindParam> &&k)
      : real{std::move(r)}, kind{std::move(k)} {}
  Real real;
  std::optional<KindParam> kind;
};


struct SignedRealLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedRealLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedRealLiteralConstant(SignedRealLiteralConstant &&) = default; SignedRealLiteralConstant &operator=(SignedRealLiteralConstant &&) = default; SignedRealLiteralConstant(const SignedRealLiteralConstant &) = delete; SignedRealLiteralConstant &operator=(const SignedRealLiteralConstant &) = delete; SignedRealLiteralConstant() = delete;
  std::tuple<std::optional<Sign>, RealLiteralConstant> t;
};







struct ComplexPart {
  template <typename A, typename = common::NoLvalue<A>> ComplexPart(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComplexPart(ComplexPart &&) = default; ComplexPart &operator=(ComplexPart &&) = default; ComplexPart(const ComplexPart &) = delete; ComplexPart &operator=(const ComplexPart &) = delete; ComplexPart() = delete;
  std::variant<SignedIntLiteralConstant, SignedRealLiteralConstant,
      NamedConstant>
      u;
};


struct ComplexLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComplexLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComplexLiteralConstant(ComplexLiteralConstant &&) = default; ComplexLiteralConstant &operator=(ComplexLiteralConstant &&) = default; ComplexLiteralConstant(const ComplexLiteralConstant &) = delete; ComplexLiteralConstant &operator=(const ComplexLiteralConstant &) = delete; ComplexLiteralConstant() = delete;
  std::tuple<ComplexPart, ComplexPart> t;
};


struct SignedComplexLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SignedComplexLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SignedComplexLiteralConstant(SignedComplexLiteralConstant &&) = default; SignedComplexLiteralConstant &operator=(SignedComplexLiteralConstant &&) = default; SignedComplexLiteralConstant(const SignedComplexLiteralConstant &) = delete; SignedComplexLiteralConstant &operator=(const SignedComplexLiteralConstant &) = delete; SignedComplexLiteralConstant() = delete;
  std::tuple<Sign, ComplexLiteralConstant> t;
};




struct CharLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CharLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharLiteralConstant(CharLiteralConstant &&) = default; CharLiteralConstant &operator=(CharLiteralConstant &&) = default; CharLiteralConstant(const CharLiteralConstant &) = delete; CharLiteralConstant &operator=(const CharLiteralConstant &) = delete; CharLiteralConstant() = delete;
  std::tuple<std::optional<KindParam>, std::string> t;
  std::string GetString() const { return std::get<std::string>(t); }
};


struct HollerithLiteralConstant {
  HollerithLiteralConstant(HollerithLiteralConstant &&) = default; HollerithLiteralConstant &operator=(HollerithLiteralConstant &&) = default; HollerithLiteralConstant(const HollerithLiteralConstant &) = delete; HollerithLiteralConstant &operator=(const HollerithLiteralConstant &) = delete; HollerithLiteralConstant() = delete; HollerithLiteralConstant(std::string &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::string v;
  std::string GetString() const { return v; }
};



struct LogicalLiteralConstant {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LogicalLiteralConstant(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LogicalLiteralConstant(LogicalLiteralConstant &&) = default; LogicalLiteralConstant &operator=(LogicalLiteralConstant &&) = default; LogicalLiteralConstant(const LogicalLiteralConstant &) = delete; LogicalLiteralConstant &operator=(const LogicalLiteralConstant &) = delete; LogicalLiteralConstant() = delete;
  std::tuple<bool, std::optional<KindParam>> t;
};
# 880 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct BOZLiteralConstant { BOZLiteralConstant(BOZLiteralConstant &&) = default; BOZLiteralConstant &operator=(BOZLiteralConstant &&) = default; BOZLiteralConstant(const BOZLiteralConstant &) = delete; BOZLiteralConstant &operator=(const BOZLiteralConstant &) = delete; BOZLiteralConstant() = delete; BOZLiteralConstant(std::string &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::string v; };





struct LiteralConstant {
  template <typename A, typename = common::NoLvalue<A>> LiteralConstant(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LiteralConstant(LiteralConstant &&) = default; LiteralConstant &operator=(LiteralConstant &&) = default; LiteralConstant(const LiteralConstant &) = delete; LiteralConstant &operator=(const LiteralConstant &) = delete; LiteralConstant() = delete;
  std::variant<HollerithLiteralConstant, IntLiteralConstant,
      RealLiteralConstant, ComplexLiteralConstant, BOZLiteralConstant,
      CharLiteralConstant, LogicalLiteralConstant>
      u;
};


struct AccessSpec {
  enum class Kind { Public, Private }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Public, Private")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Public, Private")}; return names[static_cast<std::size_t>(e)]; }
  AccessSpec(AccessSpec &&) = default; AccessSpec &operator=(AccessSpec &&) = default; AccessSpec(const AccessSpec &) = delete; AccessSpec &operator=(const AccessSpec &) = delete; AccessSpec() = delete; AccessSpec(Kind &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Kind v;
};



struct Abstract { Abstract() {} Abstract(const Abstract &) {} Abstract(Abstract &&) {} Abstract &operator=(const Abstract &) { return *this; }; Abstract &operator=(Abstract &&) { return *this; }; using EmptyTrait = std::true_type; };
struct TypeAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> TypeAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeAttrSpec(TypeAttrSpec &&) = default; TypeAttrSpec &operator=(TypeAttrSpec &&) = default; TypeAttrSpec(const TypeAttrSpec &) = delete; TypeAttrSpec &operator=(const TypeAttrSpec &) = delete; TypeAttrSpec() = delete;
  struct BindC { BindC() {} BindC(const BindC &) {} BindC(BindC &&) {} BindC &operator=(const BindC &) { return *this; }; BindC &operator=(BindC &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Extends { Extends(Extends &&) = default; Extends &operator=(Extends &&) = default; Extends(const Extends &) = delete; Extends &operator=(const Extends &) = delete; Extends() = delete; Extends(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };
  std::variant<Abstract, AccessSpec, BindC, Extends> u;
};



struct DerivedTypeStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeStmt(DerivedTypeStmt &&) = default; DerivedTypeStmt &operator=(DerivedTypeStmt &&) = default; DerivedTypeStmt(const DerivedTypeStmt &) = delete; DerivedTypeStmt &operator=(const DerivedTypeStmt &) = delete; DerivedTypeStmt() = delete;
  std::tuple<std::list<TypeAttrSpec>, Name, std::list<Name>> t;
};


struct SequenceStmt { SequenceStmt() {} SequenceStmt(const SequenceStmt &) {} SequenceStmt(SequenceStmt &&) {} SequenceStmt &operator=(const SequenceStmt &) { return *this; }; SequenceStmt &operator=(SequenceStmt &&) { return *this; }; using EmptyTrait = std::true_type; };



struct PrivateStmt { PrivateStmt() {} PrivateStmt(const PrivateStmt &) {} PrivateStmt(PrivateStmt &&) {} PrivateStmt &operator=(const PrivateStmt &) { return *this; }; PrivateStmt &operator=(PrivateStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct PrivateOrSequence {
  template <typename A, typename = common::NoLvalue<A>> PrivateOrSequence(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PrivateOrSequence(PrivateOrSequence &&) = default; PrivateOrSequence &operator=(PrivateOrSequence &&) = default; PrivateOrSequence(const PrivateOrSequence &) = delete; PrivateOrSequence &operator=(const PrivateOrSequence &) = delete; PrivateOrSequence() = delete;
  std::variant<PrivateStmt, SequenceStmt> u;
};


struct TypeParamDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamDecl(TypeParamDecl &&) = default; TypeParamDecl &operator=(TypeParamDecl &&) = default; TypeParamDecl(const TypeParamDecl &) = delete; TypeParamDecl &operator=(const TypeParamDecl &) = delete; TypeParamDecl() = delete;
  std::tuple<Name, std::optional<ScalarIntConstantExpr>> t;
};




struct TypeParamDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeParamDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeParamDefStmt(TypeParamDefStmt &&) = default; TypeParamDefStmt &operator=(TypeParamDefStmt &&) = default; TypeParamDefStmt(const TypeParamDefStmt &) = delete; TypeParamDefStmt &operator=(const TypeParamDefStmt &) = delete; TypeParamDefStmt() = delete;
  std::tuple<IntegerTypeSpec, common::TypeParamAttr, std::list<TypeParamDecl>>
      t;
};


struct SpecificationExpr { SpecificationExpr(SpecificationExpr &&) = default; SpecificationExpr &operator=(SpecificationExpr &&) = default; SpecificationExpr(const SpecificationExpr &) = delete; SpecificationExpr &operator=(const SpecificationExpr &) = delete; SpecificationExpr() = delete; SpecificationExpr(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };




struct ExplicitShapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ExplicitShapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ExplicitShapeSpec(ExplicitShapeSpec &&) = default; ExplicitShapeSpec &operator=(ExplicitShapeSpec &&) = default; ExplicitShapeSpec(const ExplicitShapeSpec &) = delete; ExplicitShapeSpec &operator=(const ExplicitShapeSpec &) = delete; ExplicitShapeSpec() = delete;
  std::tuple<std::optional<SpecificationExpr>, SpecificationExpr> t;
};



struct DeferredCoshapeSpecList { DeferredCoshapeSpecList(DeferredCoshapeSpecList &&) = default; DeferredCoshapeSpecList &operator=(DeferredCoshapeSpecList &&) = default; DeferredCoshapeSpecList(const DeferredCoshapeSpecList &) = delete; DeferredCoshapeSpecList &operator=(const DeferredCoshapeSpecList &) = delete; DeferredCoshapeSpecList() = delete; DeferredCoshapeSpecList(int &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; int v; };





struct ExplicitCoshapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ExplicitCoshapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ExplicitCoshapeSpec(ExplicitCoshapeSpec &&) = default; ExplicitCoshapeSpec &operator=(ExplicitCoshapeSpec &&) = default; ExplicitCoshapeSpec(const ExplicitCoshapeSpec &) = delete; ExplicitCoshapeSpec &operator=(const ExplicitCoshapeSpec &) = delete; ExplicitCoshapeSpec() = delete;
  std::tuple<std::list<ExplicitShapeSpec>, std::optional<SpecificationExpr>> t;
};


struct CoarraySpec {
  template <typename A, typename = common::NoLvalue<A>> CoarraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CoarraySpec(CoarraySpec &&) = default; CoarraySpec &operator=(CoarraySpec &&) = default; CoarraySpec(const CoarraySpec &) = delete; CoarraySpec &operator=(const CoarraySpec &) = delete; CoarraySpec() = delete;
  std::variant<DeferredCoshapeSpecList, ExplicitCoshapeSpec> u;
};



struct DeferredShapeSpecList { DeferredShapeSpecList(DeferredShapeSpecList &&) = default; DeferredShapeSpecList &operator=(DeferredShapeSpecList &&) = default; DeferredShapeSpecList(const DeferredShapeSpecList &) = delete; DeferredShapeSpecList &operator=(const DeferredShapeSpecList &) = delete; DeferredShapeSpecList() = delete; DeferredShapeSpecList(int &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; int v; };



struct ComponentArraySpec {
  template <typename A, typename = common::NoLvalue<A>> ComponentArraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentArraySpec(ComponentArraySpec &&) = default; ComponentArraySpec &operator=(ComponentArraySpec &&) = default; ComponentArraySpec(const ComponentArraySpec &) = delete; ComponentArraySpec &operator=(const ComponentArraySpec &) = delete; ComponentArraySpec() = delete;
  std::variant<std::list<ExplicitShapeSpec>, DeferredShapeSpecList> u;
};






struct Allocatable { Allocatable() {} Allocatable(const Allocatable &) {} Allocatable(Allocatable &&) {} Allocatable &operator=(const Allocatable &) { return *this; }; Allocatable &operator=(Allocatable &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Pointer { Pointer() {} Pointer(const Pointer &) {} Pointer(Pointer &&) {} Pointer &operator=(const Pointer &) { return *this; }; Pointer &operator=(Pointer &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Contiguous { Contiguous() {} Contiguous(const Contiguous &) {} Contiguous(Contiguous &&) {} Contiguous &operator=(const Contiguous &) { return *this; }; Contiguous &operator=(Contiguous &&) { return *this; }; using EmptyTrait = std::true_type; };
struct ComponentAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ComponentAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentAttrSpec(ComponentAttrSpec &&) = default; ComponentAttrSpec &operator=(ComponentAttrSpec &&) = default; ComponentAttrSpec(const ComponentAttrSpec &) = delete; ComponentAttrSpec &operator=(const ComponentAttrSpec &) = delete; ComponentAttrSpec() = delete;
  std::variant<AccessSpec, Allocatable, CoarraySpec, Contiguous,
      ComponentArraySpec, Pointer, common::CUDADataAttr, ErrorRecovery>
      u;
};


struct NullInit { NullInit(NullInit &&) = default; NullInit &operator=(NullInit &&) = default; NullInit(const NullInit &) = delete; NullInit &operator=(const NullInit &) = delete; NullInit() = delete; NullInit(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };


using InitialDataTarget = common::Indirection<Designator>;






struct Initialization {
  template <typename A, typename = common::NoLvalue<A>> Initialization(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Initialization(Initialization &&) = default; Initialization &operator=(Initialization &&) = default; Initialization(const Initialization &) = delete; Initialization &operator=(const Initialization &) = delete; Initialization() = delete;
  std::variant<ConstantExpr, NullInit, InitialDataTarget,
      std::list<common::Indirection<DataStmtValue>>>
      u;
};





struct ComponentDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComponentDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComponentDecl(ComponentDecl &&) = default; ComponentDecl &operator=(ComponentDecl &&) = default; ComponentDecl(const ComponentDecl &) = delete; ComponentDecl &operator=(const ComponentDecl &) = delete; ComponentDecl() = delete;
  std::tuple<Name, std::optional<ComponentArraySpec>,
      std::optional<CoarraySpec>, std::optional<CharLength>,
      std::optional<Initialization>>
      t;
};



struct FillDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FillDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FillDecl(FillDecl &&) = default; FillDecl &operator=(FillDecl &&) = default; FillDecl(const FillDecl &) = delete; FillDecl &operator=(const FillDecl &) = delete; FillDecl() = delete;
  std::tuple<Name, std::optional<ComponentArraySpec>, std::optional<CharLength>>
      t;
};

struct ComponentOrFill {
  template <typename A, typename = common::NoLvalue<A>> ComponentOrFill(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentOrFill(ComponentOrFill &&) = default; ComponentOrFill &operator=(ComponentOrFill &&) = default; ComponentOrFill(const ComponentOrFill &) = delete; ComponentOrFill &operator=(const ComponentOrFill &) = delete; ComponentOrFill() = delete;
  std::variant<ComponentDecl, FillDecl> u;
};




struct DataComponentDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataComponentDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataComponentDefStmt(DataComponentDefStmt &&) = default; DataComponentDefStmt &operator=(DataComponentDefStmt &&) = default; DataComponentDefStmt(const DataComponentDefStmt &) = delete; DataComponentDefStmt &operator=(const DataComponentDefStmt &) = delete; DataComponentDefStmt() = delete;
  std::tuple<DeclarationTypeSpec, std::list<ComponentAttrSpec>,
      std::list<ComponentOrFill>>
      t;
};



struct NoPass { NoPass() {} NoPass(const NoPass &) {} NoPass(NoPass &&) {} NoPass &operator=(const NoPass &) { return *this; }; NoPass &operator=(NoPass &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Pass { Pass(Pass &&) = default; Pass &operator=(Pass &&) = default; Pass(const Pass &) = delete; Pass &operator=(const Pass &) = delete; Pass() = delete; Pass(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
struct ProcComponentAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ProcComponentAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcComponentAttrSpec(ProcComponentAttrSpec &&) = default; ProcComponentAttrSpec &operator=(ProcComponentAttrSpec &&) = default; ProcComponentAttrSpec(const ProcComponentAttrSpec &) = delete; ProcComponentAttrSpec &operator=(const ProcComponentAttrSpec &) = delete; ProcComponentAttrSpec() = delete;
  std::variant<AccessSpec, NoPass, Pass, Pointer> u;
};



struct ProcPointerInit {
  template <typename A, typename = common::NoLvalue<A>> ProcPointerInit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcPointerInit(ProcPointerInit &&) = default; ProcPointerInit &operator=(ProcPointerInit &&) = default; ProcPointerInit(const ProcPointerInit &) = delete; ProcPointerInit &operator=(const ProcPointerInit &) = delete; ProcPointerInit() = delete;
  std::variant<NullInit, Name> u;
};



struct ProcInterface {
  template <typename A, typename = common::NoLvalue<A>> ProcInterface(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcInterface(ProcInterface &&) = default; ProcInterface &operator=(ProcInterface &&) = default; ProcInterface(const ProcInterface &) = delete; ProcInterface &operator=(const ProcInterface &) = delete; ProcInterface() = delete;
  std::variant<Name, DeclarationTypeSpec> u;
};


struct ProcDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcDecl(ProcDecl &&) = default; ProcDecl &operator=(ProcDecl &&) = default; ProcDecl(const ProcDecl &) = delete; ProcDecl &operator=(const ProcDecl &) = delete; ProcDecl() = delete;
  std::tuple<Name, std::optional<ProcPointerInit>> t;
};




struct ProcComponentDefStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcComponentDefStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcComponentDefStmt(ProcComponentDefStmt &&) = default; ProcComponentDefStmt &operator=(ProcComponentDefStmt &&) = default; ProcComponentDefStmt(const ProcComponentDefStmt &) = delete; ProcComponentDefStmt &operator=(const ProcComponentDefStmt &) = delete; ProcComponentDefStmt() = delete;
  std::tuple<std::optional<ProcInterface>, std::list<ProcComponentAttrSpec>,
      std::list<ProcDecl>>
      t;
};


struct ComponentDefStmt {
  template <typename A, typename = common::NoLvalue<A>> ComponentDefStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ComponentDefStmt(ComponentDefStmt &&) = default; ComponentDefStmt &operator=(ComponentDefStmt &&) = default; ComponentDefStmt(const ComponentDefStmt &) = delete; ComponentDefStmt &operator=(const ComponentDefStmt &) = delete; ComponentDefStmt() = delete;
  std::variant<DataComponentDefStmt, ProcComponentDefStmt, ErrorRecovery

      >
      u;
};



struct BindAttr {
  template <typename A, typename = common::NoLvalue<A>> BindAttr(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; BindAttr(BindAttr &&) = default; BindAttr &operator=(BindAttr &&) = default; BindAttr(const BindAttr &) = delete; BindAttr &operator=(const BindAttr &) = delete; BindAttr() = delete;
  struct Deferred { Deferred() {} Deferred(const Deferred &) {} Deferred(Deferred &&) {} Deferred &operator=(const Deferred &) { return *this; }; Deferred &operator=(Deferred &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Non_Overridable { Non_Overridable() {} Non_Overridable(const Non_Overridable &) {} Non_Overridable(Non_Overridable &&) {} Non_Overridable &operator=(const Non_Overridable &) { return *this; }; Non_Overridable &operator=(Non_Overridable &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<AccessSpec, Deferred, Non_Overridable, NoPass, Pass> u;
};


struct TypeBoundProcDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundProcDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundProcDecl(TypeBoundProcDecl &&) = default; TypeBoundProcDecl &operator=(TypeBoundProcDecl &&) = default; TypeBoundProcDecl(const TypeBoundProcDecl &) = delete; TypeBoundProcDecl &operator=(const TypeBoundProcDecl &) = delete; TypeBoundProcDecl() = delete;
  std::tuple<Name, std::optional<Name>> t;
};






struct TypeBoundProcedureStmt {
  template <typename A, typename = common::NoLvalue<A>> TypeBoundProcedureStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeBoundProcedureStmt(TypeBoundProcedureStmt &&) = default; TypeBoundProcedureStmt &operator=(TypeBoundProcedureStmt &&) = default; TypeBoundProcedureStmt(const TypeBoundProcedureStmt &) = delete; TypeBoundProcedureStmt &operator=(const TypeBoundProcedureStmt &) = delete; TypeBoundProcedureStmt() = delete;
  struct WithoutInterface {
    WithoutInterface(WithoutInterface &&) = default; WithoutInterface &operator=(WithoutInterface &&) = default; WithoutInterface(const WithoutInterface &) = delete; WithoutInterface &operator=(const WithoutInterface &) = delete; WithoutInterface() = delete;
    WithoutInterface(
        std::list<BindAttr> &&as, std::list<TypeBoundProcDecl> &&ds)
        : attributes(std::move(as)), declarations(std::move(ds)) {}
    std::list<BindAttr> attributes;
    std::list<TypeBoundProcDecl> declarations;
  };
  struct WithInterface {
    WithInterface(WithInterface &&) = default; WithInterface &operator=(WithInterface &&) = default; WithInterface(const WithInterface &) = delete; WithInterface &operator=(const WithInterface &) = delete; WithInterface() = delete;
    WithInterface(Name &&n, std::list<BindAttr> &&as, std::list<Name> &&bs)
        : interfaceName(std::move(n)), attributes(std::move(as)),
          bindingNames(std::move(bs)) {}
    Name interfaceName;
    std::list<BindAttr> attributes;
    std::list<Name> bindingNames;
  };
  std::variant<WithoutInterface, WithInterface> u;
};



struct TypeBoundGenericStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundGenericStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundGenericStmt(TypeBoundGenericStmt &&) = default; TypeBoundGenericStmt &operator=(TypeBoundGenericStmt &&) = default; TypeBoundGenericStmt(const TypeBoundGenericStmt &) = delete; TypeBoundGenericStmt &operator=(const TypeBoundGenericStmt &) = delete; TypeBoundGenericStmt() = delete;
  std::tuple<std::optional<AccessSpec>, common::Indirection<GenericSpec>,
      std::list<Name>>
      t;
};


struct FinalProcedureStmt { FinalProcedureStmt(FinalProcedureStmt &&) = default; FinalProcedureStmt &operator=(FinalProcedureStmt &&) = default; FinalProcedureStmt(const FinalProcedureStmt &) = delete; FinalProcedureStmt &operator=(const FinalProcedureStmt &) = delete; FinalProcedureStmt() = delete; FinalProcedureStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };




struct TypeBoundProcBinding {
  template <typename A, typename = common::NoLvalue<A>> TypeBoundProcBinding(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; TypeBoundProcBinding(TypeBoundProcBinding &&) = default; TypeBoundProcBinding &operator=(TypeBoundProcBinding &&) = default; TypeBoundProcBinding(const TypeBoundProcBinding &) = delete; TypeBoundProcBinding &operator=(const TypeBoundProcBinding &) = delete; TypeBoundProcBinding() = delete;
  std::variant<TypeBoundProcedureStmt, TypeBoundGenericStmt, FinalProcedureStmt,
      ErrorRecovery>
      u;
};



struct TypeBoundProcedurePart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeBoundProcedurePart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeBoundProcedurePart(TypeBoundProcedurePart &&) = default; TypeBoundProcedurePart &operator=(TypeBoundProcedurePart &&) = default; TypeBoundProcedurePart(const TypeBoundProcedurePart &) = delete; TypeBoundProcedurePart &operator=(const TypeBoundProcedurePart &) = delete; TypeBoundProcedurePart() = delete;
  std::tuple<Statement<ContainsStmt>, std::optional<Statement<PrivateStmt>>,
      std::list<Statement<TypeBoundProcBinding>>>
      t;
};


struct EndTypeStmt { EndTypeStmt(EndTypeStmt &&) = default; EndTypeStmt &operator=(EndTypeStmt &&) = default; EndTypeStmt(const EndTypeStmt &) = delete; EndTypeStmt &operator=(const EndTypeStmt &) = delete; EndTypeStmt() = delete; EndTypeStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };





struct DerivedTypeDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DerivedTypeDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DerivedTypeDef(DerivedTypeDef &&) = default; DerivedTypeDef &operator=(DerivedTypeDef &&) = default; DerivedTypeDef(const DerivedTypeDef &) = delete; DerivedTypeDef &operator=(const DerivedTypeDef &) = delete; DerivedTypeDef() = delete;
  std::tuple<Statement<DerivedTypeStmt>, std::list<Statement<TypeParamDefStmt>>,
      std::list<Statement<PrivateOrSequence>>,
      std::list<Statement<ComponentDefStmt>>,
      std::optional<TypeBoundProcedurePart>, Statement<EndTypeStmt>>
      t;
};




struct ComponentDataSource { ComponentDataSource(ComponentDataSource &&) = default; ComponentDataSource &operator=(ComponentDataSource &&) = default; ComponentDataSource(const ComponentDataSource &) = delete; ComponentDataSource &operator=(const ComponentDataSource &) = delete; ComponentDataSource() = delete; ComponentDataSource(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };


struct ComponentSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComponentSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComponentSpec(ComponentSpec &&) = default; ComponentSpec &operator=(ComponentSpec &&) = default; ComponentSpec(const ComponentSpec &) = delete; ComponentSpec &operator=(const ComponentSpec &) = delete; ComponentSpec() = delete;
  std::tuple<std::optional<Keyword>, ComponentDataSource> t;
};


struct StructureConstructor {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureConstructor(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureConstructor(StructureConstructor &&) = default; StructureConstructor &operator=(StructureConstructor &&) = default; StructureConstructor(const StructureConstructor &) = delete; StructureConstructor &operator=(const StructureConstructor &) = delete; StructureConstructor() = delete;
  std::tuple<DerivedTypeSpec, std::list<ComponentSpec>> t;
};


struct EnumDefStmt { EnumDefStmt() {} EnumDefStmt(const EnumDefStmt &) {} EnumDefStmt(EnumDefStmt &&) {} EnumDefStmt &operator=(const EnumDefStmt &) { return *this; }; EnumDefStmt &operator=(EnumDefStmt &&) { return *this; }; using EmptyTrait = std::true_type; };


struct Enumerator {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Enumerator(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Enumerator(Enumerator &&) = default; Enumerator &operator=(Enumerator &&) = default; Enumerator(const Enumerator &) = delete; Enumerator &operator=(const Enumerator &) = delete; Enumerator() = delete;
  std::tuple<NamedConstant, std::optional<ScalarIntConstantExpr>> t;
};


struct EnumeratorDefStmt { EnumeratorDefStmt(EnumeratorDefStmt &&) = default; EnumeratorDefStmt &operator=(EnumeratorDefStmt &&) = default; EnumeratorDefStmt(const EnumeratorDefStmt &) = delete; EnumeratorDefStmt &operator=(const EnumeratorDefStmt &) = delete; EnumeratorDefStmt() = delete; EnumeratorDefStmt(std::list<Enumerator> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Enumerator> v; };


struct EndEnumStmt { EndEnumStmt() {} EndEnumStmt(const EndEnumStmt &) {} EndEnumStmt(EndEnumStmt &&) {} EndEnumStmt &operator=(const EndEnumStmt &) { return *this; }; EndEnumStmt &operator=(EndEnumStmt &&) { return *this; }; using EmptyTrait = std::true_type; };




struct EnumDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EnumDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EnumDef(EnumDef &&) = default; EnumDef &operator=(EnumDef &&) = default; EnumDef(const EnumDef &) = delete; EnumDef &operator=(const EnumDef &) = delete; EnumDef() = delete;
  std::tuple<Statement<EnumDefStmt>, std::list<Statement<EnumeratorDefStmt>>,
      Statement<EndEnumStmt>>
      t;
};


struct AcValue {
  struct Triplet {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Triplet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Triplet(Triplet &&) = default; Triplet &operator=(Triplet &&) = default; Triplet(const Triplet &) = delete; Triplet &operator=(const Triplet &) = delete; Triplet() = delete;
    std::tuple<ScalarIntExpr, ScalarIntExpr, std::optional<ScalarIntExpr>> t;
  };
  template <typename A, typename = common::NoLvalue<A>> AcValue(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AcValue(AcValue &&) = default; AcValue &operator=(AcValue &&) = default; AcValue(const AcValue &) = delete; AcValue &operator=(const AcValue &) = delete; AcValue() = delete;
  std::variant<Triplet, common::Indirection<Expr>,
      common::Indirection<AcImpliedDo>>
      u;
};


struct AcSpec {
  AcSpec(AcSpec &&) = default; AcSpec &operator=(AcSpec &&) = default; AcSpec(const AcSpec &) = delete; AcSpec &operator=(const AcSpec &) = delete; AcSpec() = delete;
  AcSpec(std::optional<TypeSpec> &&ts, std::list<AcValue> &&xs)
      : type(std::move(ts)), values(std::move(xs)) {}
  explicit AcSpec(TypeSpec &&ts) : type{std::move(ts)} {}
  std::optional<TypeSpec> type;
  std::list<AcValue> values;
};


struct ArrayConstructor { ArrayConstructor(ArrayConstructor &&) = default; ArrayConstructor &operator=(ArrayConstructor &&) = default; ArrayConstructor(const ArrayConstructor &) = delete; ArrayConstructor &operator=(const ArrayConstructor &) = delete; ArrayConstructor() = delete; ArrayConstructor(AcSpec &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AcSpec v; };


using DoVariable = Scalar<Integer<Name>>;

template <typename VAR, typename BOUND> struct LoopBounds {
  LoopBounds(LoopBounds &&that) = default;
  LoopBounds(
      VAR &&name, BOUND &&lower, BOUND &&upper, std::optional<BOUND> &&step)
      : name{std::move(name)}, lower{std::move(lower)}, upper{std::move(upper)},
        step{std::move(step)} {}
  LoopBounds &operator=(LoopBounds &&) = default;
  VAR name;
  BOUND lower, upper;
  std::optional<BOUND> step;
};

using ScalarName = Scalar<Name>;
using ScalarExpr = Scalar<common::Indirection<Expr>>;





struct AcImpliedDoControl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AcImpliedDoControl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AcImpliedDoControl(AcImpliedDoControl &&) = default; AcImpliedDoControl &operator=(AcImpliedDoControl &&) = default; AcImpliedDoControl(const AcImpliedDoControl &) = delete; AcImpliedDoControl &operator=(const AcImpliedDoControl &) = delete; AcImpliedDoControl() = delete;
  using Bounds = LoopBounds<DoVariable, ScalarIntExpr>;
  std::tuple<std::optional<IntegerTypeSpec>, Bounds> t;
};


struct AcImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AcImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AcImpliedDo(AcImpliedDo &&) = default; AcImpliedDo &operator=(AcImpliedDo &&) = default; AcImpliedDo(const AcImpliedDo &) = delete; AcImpliedDo &operator=(const AcImpliedDo &) = delete; AcImpliedDo() = delete;
  std::tuple<std::list<AcValue>, AcImpliedDoControl> t;
};




struct LanguageBindingSpec { LanguageBindingSpec(LanguageBindingSpec &&) = default; LanguageBindingSpec &operator=(LanguageBindingSpec &&) = default; LanguageBindingSpec(const LanguageBindingSpec &) = delete; LanguageBindingSpec &operator=(const LanguageBindingSpec &) = delete; LanguageBindingSpec() = delete; LanguageBindingSpec(std::optional<ScalarDefaultCharConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarDefaultCharConstantExpr> v; };



struct NamedConstantDef {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NamedConstantDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NamedConstantDef(NamedConstantDef &&) = default; NamedConstantDef &operator=(NamedConstantDef &&) = default; NamedConstantDef(const NamedConstantDef &) = delete; NamedConstantDef &operator=(const NamedConstantDef &) = delete; NamedConstantDef() = delete;
  std::tuple<NamedConstant, ConstantExpr> t;
};


struct ParameterStmt { ParameterStmt(ParameterStmt &&) = default; ParameterStmt &operator=(ParameterStmt &&) = default; ParameterStmt(const ParameterStmt &) = delete; ParameterStmt &operator=(const ParameterStmt &) = delete; ParameterStmt() = delete; ParameterStmt(std::list<NamedConstantDef> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<NamedConstantDef> v; };


struct AssumedShapeSpec { AssumedShapeSpec(AssumedShapeSpec &&) = default; AssumedShapeSpec &operator=(AssumedShapeSpec &&) = default; AssumedShapeSpec(const AssumedShapeSpec &) = delete; AssumedShapeSpec &operator=(const AssumedShapeSpec &) = delete; AssumedShapeSpec() = delete; AssumedShapeSpec(std::optional<SpecificationExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<SpecificationExpr> v; };


struct AssumedImpliedSpec { AssumedImpliedSpec(AssumedImpliedSpec &&) = default; AssumedImpliedSpec &operator=(AssumedImpliedSpec &&) = default; AssumedImpliedSpec(const AssumedImpliedSpec &) = delete; AssumedImpliedSpec &operator=(const AssumedImpliedSpec &) = delete; AssumedImpliedSpec() = delete; AssumedImpliedSpec(std::optional<SpecificationExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<SpecificationExpr> v; };


struct AssumedSizeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssumedSizeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssumedSizeSpec(AssumedSizeSpec &&) = default; AssumedSizeSpec &operator=(AssumedSizeSpec &&) = default; AssumedSizeSpec(const AssumedSizeSpec &) = delete; AssumedSizeSpec &operator=(const AssumedSizeSpec &) = delete; AssumedSizeSpec() = delete;
  std::tuple<std::list<ExplicitShapeSpec>, AssumedImpliedSpec> t;
};





struct ImpliedShapeSpec { ImpliedShapeSpec(ImpliedShapeSpec &&) = default; ImpliedShapeSpec &operator=(ImpliedShapeSpec &&) = default; ImpliedShapeSpec(const ImpliedShapeSpec &) = delete; ImpliedShapeSpec &operator=(const ImpliedShapeSpec &) = delete; ImpliedShapeSpec() = delete; ImpliedShapeSpec(std::list<AssumedImpliedSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AssumedImpliedSpec> v; };


struct AssumedRankSpec { AssumedRankSpec() {} AssumedRankSpec(const AssumedRankSpec &) {} AssumedRankSpec(AssumedRankSpec &&) {} AssumedRankSpec &operator=(const AssumedRankSpec &) { return *this; }; AssumedRankSpec &operator=(AssumedRankSpec &&) { return *this; }; using EmptyTrait = std::true_type; };





struct ArraySpec {
  template <typename A, typename = common::NoLvalue<A>> ArraySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ArraySpec(ArraySpec &&) = default; ArraySpec &operator=(ArraySpec &&) = default; ArraySpec(const ArraySpec &) = delete; ArraySpec &operator=(const ArraySpec &) = delete; ArraySpec() = delete;
  std::variant<std::list<ExplicitShapeSpec>, std::list<AssumedShapeSpec>,
      DeferredShapeSpecList, AssumedSizeSpec, ImpliedShapeSpec, AssumedRankSpec>
      u;
};


struct IntentSpec {
  enum class Intent { In, Out, InOut }; [[maybe_unused]] static constexpr std::size_t Intent_enumSize{ ::Fortran::common::CountEnumNames("In, Out, InOut")}; [[maybe_unused]] static inline std::string_view EnumToString(Intent e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Intent_enumSize>("In, Out, InOut")}; return names[static_cast<std::size_t>(e)]; }
  IntentSpec(IntentSpec &&) = default; IntentSpec &operator=(IntentSpec &&) = default; IntentSpec(const IntentSpec &) = delete; IntentSpec &operator=(const IntentSpec &) = delete; IntentSpec() = delete; IntentSpec(Intent &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Intent v;
};
# 1352 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct Asynchronous { Asynchronous() {} Asynchronous(const Asynchronous &) {} Asynchronous(Asynchronous &&) {} Asynchronous &operator=(const Asynchronous &) { return *this; }; Asynchronous &operator=(Asynchronous &&) { return *this; }; using EmptyTrait = std::true_type; };
struct External { External() {} External(const External &) {} External(External &&) {} External &operator=(const External &) { return *this; }; External &operator=(External &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Intrinsic { Intrinsic() {} Intrinsic(const Intrinsic &) {} Intrinsic(Intrinsic &&) {} Intrinsic &operator=(const Intrinsic &) { return *this; }; Intrinsic &operator=(Intrinsic &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Optional { Optional() {} Optional(const Optional &) {} Optional(Optional &&) {} Optional &operator=(const Optional &) { return *this; }; Optional &operator=(Optional &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Parameter { Parameter() {} Parameter(const Parameter &) {} Parameter(Parameter &&) {} Parameter &operator=(const Parameter &) { return *this; }; Parameter &operator=(Parameter &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Protected { Protected() {} Protected(const Protected &) {} Protected(Protected &&) {} Protected &operator=(const Protected &) { return *this; }; Protected &operator=(Protected &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Save { Save() {} Save(const Save &) {} Save(Save &&) {} Save &operator=(const Save &) { return *this; }; Save &operator=(Save &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Target { Target() {} Target(const Target &) {} Target(Target &&) {} Target &operator=(const Target &) { return *this; }; Target &operator=(Target &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Value { Value() {} Value(const Value &) {} Value(Value &&) {} Value &operator=(const Value &) { return *this; }; Value &operator=(Value &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Volatile { Volatile() {} Volatile(const Volatile &) {} Volatile(Volatile &&) {} Volatile &operator=(const Volatile &) { return *this; }; Volatile &operator=(Volatile &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AttrSpec {
  template <typename A, typename = common::NoLvalue<A>> AttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AttrSpec(AttrSpec &&) = default; AttrSpec &operator=(AttrSpec &&) = default; AttrSpec(const AttrSpec &) = delete; AttrSpec &operator=(const AttrSpec &) = delete; AttrSpec() = delete;
  std::variant<AccessSpec, Allocatable, Asynchronous, CoarraySpec, Contiguous,
      ArraySpec, External, IntentSpec, Intrinsic, LanguageBindingSpec, Optional,
      Parameter, Pointer, Protected, Save, Target, Value, Volatile,
      common::CUDADataAttr>
      u;
};





struct EntityDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EntityDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EntityDecl(EntityDecl &&) = default; EntityDecl &operator=(EntityDecl &&) = default; EntityDecl(const EntityDecl &) = delete; EntityDecl &operator=(const EntityDecl &) = delete; EntityDecl() = delete;
  std::tuple<ObjectName, std::optional<ArraySpec>, std::optional<CoarraySpec>,
      std::optional<CharLength>, std::optional<Initialization>>
      t;
};



struct TypeDeclarationStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeDeclarationStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeDeclarationStmt(TypeDeclarationStmt &&) = default; TypeDeclarationStmt &operator=(TypeDeclarationStmt &&) = default; TypeDeclarationStmt(const TypeDeclarationStmt &) = delete; TypeDeclarationStmt &operator=(const TypeDeclarationStmt &) = delete; TypeDeclarationStmt() = delete;
  std::tuple<DeclarationTypeSpec, std::list<AttrSpec>, std::list<EntityDecl>> t;
};



struct AccessId { AccessId(AccessId &&) = default; AccessId &operator=(AccessId &&) = default; AccessId(const AccessId &) = delete; AccessId &operator=(const AccessId &) = delete; AccessId() = delete; AccessId(common::Indirection<GenericSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<GenericSpec> v; };


struct AccessStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccessStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccessStmt(AccessStmt &&) = default; AccessStmt &operator=(AccessStmt &&) = default; AccessStmt(const AccessStmt &) = delete; AccessStmt &operator=(const AccessStmt &) = delete; AccessStmt() = delete;
  std::tuple<AccessSpec, std::list<AccessId>> t;
};





struct ObjectDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ObjectDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ObjectDecl(ObjectDecl &&) = default; ObjectDecl &operator=(ObjectDecl &&) = default; ObjectDecl(const ObjectDecl &) = delete; ObjectDecl &operator=(const ObjectDecl &) = delete; ObjectDecl() = delete;
  std::tuple<ObjectName, std::optional<ArraySpec>, std::optional<CoarraySpec>>
      t;
};


struct AllocatableStmt { AllocatableStmt(AllocatableStmt &&) = default; AllocatableStmt &operator=(AllocatableStmt &&) = default; AllocatableStmt(const AllocatableStmt &) = delete; AllocatableStmt &operator=(const AllocatableStmt &) = delete; AllocatableStmt() = delete; AllocatableStmt(std::list<ObjectDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectDecl> v; };


struct AsynchronousStmt { AsynchronousStmt(AsynchronousStmt &&) = default; AsynchronousStmt &operator=(AsynchronousStmt &&) = default; AsynchronousStmt(const AsynchronousStmt &) = delete; AsynchronousStmt &operator=(const AsynchronousStmt &) = delete; AsynchronousStmt() = delete; AsynchronousStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };


struct BindEntity {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BindEntity(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BindEntity(BindEntity &&) = default; BindEntity &operator=(BindEntity &&) = default; BindEntity(const BindEntity &) = delete; BindEntity &operator=(const BindEntity &) = delete; BindEntity() = delete;
  enum class Kind { Object, Common }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Object, Common")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Object, Common")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<Kind, Name> t;
};


struct BindStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BindStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BindStmt(BindStmt &&) = default; BindStmt &operator=(BindStmt &&) = default; BindStmt(const BindStmt &) = delete; BindStmt &operator=(const BindStmt &) = delete; BindStmt() = delete;
  std::tuple<LanguageBindingSpec, std::list<BindEntity>> t;
};


struct CodimensionDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CodimensionDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CodimensionDecl(CodimensionDecl &&) = default; CodimensionDecl &operator=(CodimensionDecl &&) = default; CodimensionDecl(const CodimensionDecl &) = delete; CodimensionDecl &operator=(const CodimensionDecl &) = delete; CodimensionDecl() = delete;
  std::tuple<Name, CoarraySpec> t;
};


struct CodimensionStmt { CodimensionStmt(CodimensionStmt &&) = default; CodimensionStmt &operator=(CodimensionStmt &&) = default; CodimensionStmt(const CodimensionStmt &) = delete; CodimensionStmt &operator=(const CodimensionStmt &) = delete; CodimensionStmt() = delete; CodimensionStmt(std::list<CodimensionDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<CodimensionDecl> v; };


struct ContiguousStmt { ContiguousStmt(ContiguousStmt &&) = default; ContiguousStmt &operator=(ContiguousStmt &&) = default; ContiguousStmt(const ContiguousStmt &) = delete; ContiguousStmt &operator=(const ContiguousStmt &) = delete; ContiguousStmt() = delete; ContiguousStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };



using ConstantSubobject = Constant<common::Indirection<Designator>>;


using TypedExpr = common::ForwardOwningPointer<evaluate::GenericExprWrapper>;
# 1454 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct DataStmtConstant {
  template <typename A, typename = common::NoLvalue<A>> DataStmtConstant(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtConstant(DataStmtConstant &&) = default; DataStmtConstant &operator=(DataStmtConstant &&) = default; DataStmtConstant(const DataStmtConstant &) = delete; DataStmtConstant &operator=(const DataStmtConstant &) = delete; DataStmtConstant() = delete;
  CharBlock source;
  mutable TypedExpr typedExpr;
  std::variant<LiteralConstant, SignedIntLiteralConstant,
      SignedRealLiteralConstant, SignedComplexLiteralConstant, NullInit,
      common::Indirection<Designator>, StructureConstructor>
      u;
};





struct DataStmtRepeat {
  template <typename A, typename = common::NoLvalue<A>> DataStmtRepeat(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtRepeat(DataStmtRepeat &&) = default; DataStmtRepeat &operator=(DataStmtRepeat &&) = default; DataStmtRepeat(const DataStmtRepeat &) = delete; DataStmtRepeat &operator=(const DataStmtRepeat &) = delete; DataStmtRepeat() = delete;
  std::variant<IntLiteralConstant, Scalar<Integer<ConstantSubobject>>> u;
};


struct DataStmtValue {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataStmtValue(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataStmtValue(DataStmtValue &&) = default; DataStmtValue &operator=(DataStmtValue &&) = default; DataStmtValue(const DataStmtValue &) = delete; DataStmtValue &operator=(const DataStmtValue &) = delete; DataStmtValue() = delete;
  mutable std::int64_t repetitions{1};
  std::tuple<std::optional<DataStmtRepeat>, DataStmtConstant> t;
};



struct DataIDoObject {
  template <typename A, typename = common::NoLvalue<A>> DataIDoObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataIDoObject(DataIDoObject &&) = default; DataIDoObject &operator=(DataIDoObject &&) = default; DataIDoObject(const DataIDoObject &) = delete; DataIDoObject &operator=(const DataIDoObject &) = delete; DataIDoObject() = delete;
  std::variant<Scalar<common::Indirection<Designator>>,
      common::Indirection<DataImpliedDo>>
      u;
};






struct DataImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataImpliedDo(DataImpliedDo &&) = default; DataImpliedDo &operator=(DataImpliedDo &&) = default; DataImpliedDo(const DataImpliedDo &) = delete; DataImpliedDo &operator=(const DataImpliedDo &) = delete; DataImpliedDo() = delete;
  using Bounds = LoopBounds<DoVariable, ScalarIntConstantExpr>;
  std::tuple<std::list<DataIDoObject>, std::optional<IntegerTypeSpec>, Bounds>
      t;
};


struct DataStmtObject {
  template <typename A, typename = common::NoLvalue<A>> DataStmtObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataStmtObject(DataStmtObject &&) = default; DataStmtObject &operator=(DataStmtObject &&) = default; DataStmtObject(const DataStmtObject &) = delete; DataStmtObject &operator=(const DataStmtObject &) = delete; DataStmtObject() = delete;
  std::variant<common::Indirection<Variable>, DataImpliedDo> u;
};


struct DataStmtSet {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DataStmtSet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DataStmtSet(DataStmtSet &&) = default; DataStmtSet &operator=(DataStmtSet &&) = default; DataStmtSet(const DataStmtSet &) = delete; DataStmtSet &operator=(const DataStmtSet &) = delete; DataStmtSet() = delete;
  std::tuple<std::list<DataStmtObject>, std::list<DataStmtValue>> t;
};


struct DataStmt { DataStmt(DataStmt &&) = default; DataStmt &operator=(DataStmt &&) = default; DataStmt(const DataStmt &) = delete; DataStmt &operator=(const DataStmt &) = delete; DataStmt() = delete; DataStmt(std::list<DataStmtSet> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<DataStmtSet> v; };




struct DimensionStmt {
  struct Declaration {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Declaration(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Declaration(Declaration &&) = default; Declaration &operator=(Declaration &&) = default; Declaration(const Declaration &) = delete; Declaration &operator=(const Declaration &) = delete; Declaration() = delete;
    std::tuple<Name, ArraySpec> t;
  };
  DimensionStmt(DimensionStmt &&) = default; DimensionStmt &operator=(DimensionStmt &&) = default; DimensionStmt(const DimensionStmt &) = delete; DimensionStmt &operator=(const DimensionStmt &) = delete; DimensionStmt() = delete; DimensionStmt(std::list<Declaration> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Declaration> v;
};


struct IntentStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IntentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntentStmt(IntentStmt &&) = default; IntentStmt &operator=(IntentStmt &&) = default; IntentStmt(const IntentStmt &) = delete; IntentStmt &operator=(const IntentStmt &) = delete; IntentStmt() = delete;
  std::tuple<IntentSpec, std::list<Name>> t;
};


struct OptionalStmt { OptionalStmt(OptionalStmt &&) = default; OptionalStmt &operator=(OptionalStmt &&) = default; OptionalStmt(const OptionalStmt &) = delete; OptionalStmt &operator=(const OptionalStmt &) = delete; OptionalStmt() = delete; OptionalStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct PointerDecl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PointerDecl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PointerDecl(PointerDecl &&) = default; PointerDecl &operator=(PointerDecl &&) = default; PointerDecl(const PointerDecl &) = delete; PointerDecl &operator=(const PointerDecl &) = delete; PointerDecl() = delete;
  std::tuple<Name, std::optional<DeferredShapeSpecList>> t;
};


struct PointerStmt { PointerStmt(PointerStmt &&) = default; PointerStmt &operator=(PointerStmt &&) = default; PointerStmt(const PointerStmt &) = delete; PointerStmt &operator=(const PointerStmt &) = delete; PointerStmt() = delete; PointerStmt(std::list<PointerDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PointerDecl> v; };


struct ProtectedStmt { ProtectedStmt(ProtectedStmt &&) = default; ProtectedStmt &operator=(ProtectedStmt &&) = default; ProtectedStmt(const ProtectedStmt &) = delete; ProtectedStmt &operator=(const ProtectedStmt &) = delete; ProtectedStmt() = delete; ProtectedStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct SavedEntity {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SavedEntity(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SavedEntity(SavedEntity &&) = default; SavedEntity &operator=(SavedEntity &&) = default; SavedEntity(const SavedEntity &) = delete; SavedEntity &operator=(const SavedEntity &) = delete; SavedEntity() = delete;
  enum class Kind { Entity, Common }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Entity, Common")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Entity, Common")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<Kind, Name> t;
};


struct SaveStmt { SaveStmt(SaveStmt &&) = default; SaveStmt &operator=(SaveStmt &&) = default; SaveStmt(const SaveStmt &) = delete; SaveStmt &operator=(const SaveStmt &) = delete; SaveStmt() = delete; SaveStmt(std::list<SavedEntity> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<SavedEntity> v; };


struct TargetStmt { TargetStmt(TargetStmt &&) = default; TargetStmt &operator=(TargetStmt &&) = default; TargetStmt(const TargetStmt &) = delete; TargetStmt &operator=(const TargetStmt &) = delete; TargetStmt() = delete; TargetStmt(std::list<ObjectDecl> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectDecl> v; };


struct ValueStmt { ValueStmt(ValueStmt &&) = default; ValueStmt &operator=(ValueStmt &&) = default; ValueStmt(const ValueStmt &) = delete; ValueStmt &operator=(const ValueStmt &) = delete; ValueStmt() = delete; ValueStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };


struct VolatileStmt { VolatileStmt(VolatileStmt &&) = default; VolatileStmt &operator=(VolatileStmt &&) = default; VolatileStmt(const VolatileStmt &) = delete; VolatileStmt &operator=(const VolatileStmt &) = delete; VolatileStmt() = delete; VolatileStmt(std::list<ObjectName> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ObjectName> v; };


struct LetterSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LetterSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LetterSpec(LetterSpec &&) = default; LetterSpec &operator=(LetterSpec &&) = default; LetterSpec(const LetterSpec &) = delete; LetterSpec &operator=(const LetterSpec &) = delete; LetterSpec() = delete;
  std::tuple<Location, std::optional<Location>> t;
};


struct ImplicitSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ImplicitSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ImplicitSpec(ImplicitSpec &&) = default; ImplicitSpec &operator=(ImplicitSpec &&) = default; ImplicitSpec(const ImplicitSpec &) = delete; ImplicitSpec &operator=(const ImplicitSpec &) = delete; ImplicitSpec() = delete;
  std::tuple<DeclarationTypeSpec, std::list<LetterSpec>> t;
};





struct ImplicitStmt {
  template <typename A, typename = common::NoLvalue<A>> ImplicitStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImplicitStmt(ImplicitStmt &&) = default; ImplicitStmt &operator=(ImplicitStmt &&) = default; ImplicitStmt(const ImplicitStmt &) = delete; ImplicitStmt &operator=(const ImplicitStmt &) = delete; ImplicitStmt() = delete;
  enum class ImplicitNoneNameSpec { External, Type }; [[maybe_unused]] static constexpr std::size_t ImplicitNoneNameSpec_enumSize{ ::Fortran::common::CountEnumNames("External, Type")}; [[maybe_unused]] static inline std::string_view EnumToString(ImplicitNoneNameSpec e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImplicitNoneNameSpec_enumSize>("External, Type")}; return names[static_cast<std::size_t>(e)]; }
  std::variant<std::list<ImplicitSpec>, std::list<ImplicitNoneNameSpec>> u;
};


struct CommonBlockObject {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CommonBlockObject(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CommonBlockObject(CommonBlockObject &&) = default; CommonBlockObject &operator=(CommonBlockObject &&) = default; CommonBlockObject(const CommonBlockObject &) = delete; CommonBlockObject &operator=(const CommonBlockObject &) = delete; CommonBlockObject() = delete;
  std::tuple<Name, std::optional<ArraySpec>> t;
};




struct CommonStmt {
  struct Block {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Block(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Block(Block &&) = default; Block &operator=(Block &&) = default; Block(const Block &) = delete; Block &operator=(const Block &) = delete; Block() = delete;
    std::tuple<std::optional<Name>, std::list<CommonBlockObject>> t;
  };
  CommonStmt(CommonStmt &&) = default; CommonStmt &operator=(CommonStmt &&) = default; CommonStmt(const CommonStmt &) = delete; CommonStmt &operator=(const CommonStmt &) = delete; CommonStmt() = delete;
  CommonStmt(std::optional<Name> &&, std::list<CommonBlockObject> &&,
      std::list<Block> &&);
  std::list<Block> blocks;
};


struct EquivalenceObject { EquivalenceObject(EquivalenceObject &&) = default; EquivalenceObject &operator=(EquivalenceObject &&) = default; EquivalenceObject(const EquivalenceObject &) = delete; EquivalenceObject &operator=(const EquivalenceObject &) = delete; EquivalenceObject() = delete; EquivalenceObject(common::Indirection<Designator> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Designator> v; };



struct EquivalenceStmt { EquivalenceStmt(EquivalenceStmt &&) = default; EquivalenceStmt &operator=(EquivalenceStmt &&) = default; EquivalenceStmt(const EquivalenceStmt &) = delete; EquivalenceStmt &operator=(const EquivalenceStmt &) = delete; EquivalenceStmt() = delete; EquivalenceStmt(std::list<std::list<EquivalenceObject>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<std::list<EquivalenceObject>> v; };


struct SubstringRange {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubstringRange(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubstringRange(SubstringRange &&) = default; SubstringRange &operator=(SubstringRange &&) = default; SubstringRange(const SubstringRange &) = delete; SubstringRange &operator=(const SubstringRange &) = delete; SubstringRange() = delete;
  std::tuple<std::optional<ScalarIntExpr>, std::optional<ScalarIntExpr>> t;
};


using Subscript = ScalarIntExpr;


struct SubscriptTriplet {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubscriptTriplet(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubscriptTriplet(SubscriptTriplet &&) = default; SubscriptTriplet &operator=(SubscriptTriplet &&) = default; SubscriptTriplet(const SubscriptTriplet &) = delete; SubscriptTriplet &operator=(const SubscriptTriplet &) = delete; SubscriptTriplet() = delete;
  std::tuple<std::optional<Subscript>, std::optional<Subscript>,
      std::optional<Subscript>>
      t;
};



struct SectionSubscript {
  template <typename A, typename = common::NoLvalue<A>> SectionSubscript(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; SectionSubscript(SectionSubscript &&) = default; SectionSubscript &operator=(SectionSubscript &&) = default; SectionSubscript(const SectionSubscript &) = delete; SectionSubscript &operator=(const SectionSubscript &) = delete; SectionSubscript() = delete;
  std::variant<IntExpr, SubscriptTriplet> u;
};


using Cosubscript = ScalarIntExpr;


struct TeamValue { TeamValue(TeamValue &&) = default; TeamValue &operator=(TeamValue &&) = default; TeamValue(const TeamValue &) = delete; TeamValue &operator=(const TeamValue &) = delete; TeamValue() = delete; TeamValue(Scalar<common::Indirection<Expr>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<common::Indirection<Expr>> v; };




struct ImageSelectorSpec {
  struct Stat { Stat(Stat &&) = default; Stat &operator=(Stat &&) = default; Stat(const Stat &) = delete; Stat &operator=(const Stat &) = delete; Stat() = delete; Stat(Scalar<Integer<common::Indirection<Variable>>> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<Integer<common::Indirection<Variable>>> v; };
  struct Team_Number { Team_Number(Team_Number &&) = default; Team_Number &operator=(Team_Number &&) = default; Team_Number(const Team_Number &) = delete; Team_Number &operator=(const Team_Number &) = delete; Team_Number() = delete; Team_Number(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  template <typename A, typename = common::NoLvalue<A>> ImageSelectorSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImageSelectorSpec(ImageSelectorSpec &&) = default; ImageSelectorSpec &operator=(ImageSelectorSpec &&) = default; ImageSelectorSpec(const ImageSelectorSpec &) = delete; ImageSelectorSpec &operator=(const ImageSelectorSpec &) = delete; ImageSelectorSpec() = delete;
  std::variant<Stat, TeamValue, Team_Number> u;
};



struct ImageSelector {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ImageSelector(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ImageSelector(ImageSelector &&) = default; ImageSelector &operator=(ImageSelector &&) = default; ImageSelector(const ImageSelector &) = delete; ImageSelector &operator=(const ImageSelector &) = delete; ImageSelector() = delete;
  std::tuple<std::list<Cosubscript>, std::list<ImageSelectorSpec>> t;
};


struct Expr {
  template <typename A, typename = common::NoLvalue<A>> Expr(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Expr(Expr &&) = default; Expr &operator=(Expr &&) = default; Expr(const Expr &) = delete; Expr &operator=(const Expr &) = delete; Expr() = delete;

  struct IntrinsicUnary { IntrinsicUnary(IntrinsicUnary &&) = default; IntrinsicUnary &operator=(IntrinsicUnary &&) = default; IntrinsicUnary(const IntrinsicUnary &) = delete; IntrinsicUnary &operator=(const IntrinsicUnary &) = delete; IntrinsicUnary() = delete; IntrinsicUnary(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Parentheses : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct UnaryPlus : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct Negate : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };
  struct NOT : public IntrinsicUnary {
    using IntrinsicUnary::IntrinsicUnary;
  };

  struct PercentLoc { PercentLoc(PercentLoc &&) = default; PercentLoc &operator=(PercentLoc &&) = default; PercentLoc(const PercentLoc &) = delete; PercentLoc &operator=(const PercentLoc &) = delete; PercentLoc() = delete; PercentLoc(common::Indirection<Variable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Variable> v; };

  struct DefinedUnary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedUnary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedUnary(DefinedUnary &&) = default; DefinedUnary &operator=(DefinedUnary &&) = default; DefinedUnary(const DefinedUnary &) = delete; DefinedUnary &operator=(const DefinedUnary &) = delete; DefinedUnary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>> t;
  };

  struct IntrinsicBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntrinsicBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntrinsicBinary(IntrinsicBinary &&) = default; IntrinsicBinary &operator=(IntrinsicBinary &&) = default; IntrinsicBinary(const IntrinsicBinary &) = delete; IntrinsicBinary &operator=(const IntrinsicBinary &) = delete; IntrinsicBinary() = delete;
    std::tuple<common::Indirection<Expr>, common::Indirection<Expr>> t;
  };
  struct Power : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Multiply : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Divide : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Add : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Subtract : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct Concat : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct LE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQ : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GE : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct GT : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct AND : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct OR : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct EQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };
  struct NEQV : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };


  struct ComplexConstructor : public IntrinsicBinary {
    using IntrinsicBinary::IntrinsicBinary;
  };

  struct DefinedBinary {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> DefinedBinary(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DefinedBinary(DefinedBinary &&) = default; DefinedBinary &operator=(DefinedBinary &&) = default; DefinedBinary(const DefinedBinary &) = delete; DefinedBinary &operator=(const DefinedBinary &) = delete; DefinedBinary() = delete;
    std::tuple<DefinedOpName, common::Indirection<Expr>,
        common::Indirection<Expr>>
        t;
  };

  explicit Expr(Designator &&);
  explicit Expr(FunctionReference &&);

  mutable TypedExpr typedExpr;

  CharBlock source;

  std::variant<common::Indirection<CharLiteralConstantSubstring>,
      LiteralConstant, common::Indirection<Designator>, ArrayConstructor,
      StructureConstructor, common::Indirection<FunctionReference>, Parentheses,
      UnaryPlus, Negate, NOT, PercentLoc, DefinedUnary, Power, Multiply, Divide,
      Add, Subtract, Concat, LT, LE, EQ, NE, GE, GT, AND, OR, EQV, NEQV,
      DefinedBinary, ComplexConstructor, common::Indirection<SubstringInquiry>>
      u;
};


struct PartRef {
  PartRef(PartRef &&) = default; PartRef &operator=(PartRef &&) = default; PartRef(const PartRef &) = delete; PartRef &operator=(const PartRef &) = delete; PartRef() = delete;
  PartRef(Name &&n, std::list<SectionSubscript> &&ss,
      std::optional<ImageSelector> &&is)
      : name{std::move(n)},
        subscripts(std::move(ss)), imageSelector{std::move(is)} {}
  Name name;
  std::list<SectionSubscript> subscripts;
  std::optional<ImageSelector> imageSelector;
};


struct DataRef {
  template <typename A, typename = common::NoLvalue<A>> DataRef(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DataRef(DataRef &&) = default; DataRef &operator=(DataRef &&) = default; DataRef(const DataRef &) = delete; DataRef &operator=(const DataRef &) = delete; DataRef() = delete;
  explicit DataRef(std::list<PartRef> &&);
  std::variant<Name, common::Indirection<StructureComponent>,
      common::Indirection<ArrayElement>,
      common::Indirection<CoindexedNamedObject>>
      u;
};
# 1801 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct Substring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Substring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Substring(Substring &&) = default; Substring &operator=(Substring &&) = default; Substring(const Substring &) = delete; Substring &operator=(const Substring &) = delete; Substring() = delete;
  std::tuple<DataRef, SubstringRange> t;
};

struct CharLiteralConstantSubstring {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CharLiteralConstantSubstring(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharLiteralConstantSubstring(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring &operator=(CharLiteralConstantSubstring &&) = default; CharLiteralConstantSubstring(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring &operator=(const CharLiteralConstantSubstring &) = delete; CharLiteralConstantSubstring() = delete;
  std::tuple<CharLiteralConstant, SubstringRange> t;
};





struct SubstringInquiry {
  CharBlock source;
  SubstringInquiry(SubstringInquiry &&) = default; SubstringInquiry &operator=(SubstringInquiry &&) = default; SubstringInquiry(const SubstringInquiry &) = delete; SubstringInquiry &operator=(const SubstringInquiry &) = delete; SubstringInquiry() = delete; SubstringInquiry(Substring &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Substring v;
};




struct Designator {
  template <typename A, typename = common::NoLvalue<A>> Designator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Designator(Designator &&) = default; Designator &operator=(Designator &&) = default; Designator(const Designator &) = delete; Designator &operator=(const Designator &) = delete; Designator() = delete;
  bool EndsInBareName() const;
  CharBlock source;
  std::variant<DataRef, Substring> u;
};


struct Variable {
  template <typename A, typename = common::NoLvalue<A>> Variable(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Variable(Variable &&) = default; Variable &operator=(Variable &&) = default; Variable(const Variable &) = delete; Variable &operator=(const Variable &) = delete; Variable() = delete;
  mutable TypedExpr typedExpr;
  CharBlock GetSource() const;
  std::variant<common::Indirection<Designator>,
      common::Indirection<FunctionReference>>
      u;
};



using ScalarLogicalVariable = Scalar<Logical<Variable>>;



using ScalarDefaultCharVariable = Scalar<DefaultChar<Variable>>;



using ScalarIntVariable = Scalar<Integer<Variable>>;


struct StructureComponent {
  StructureComponent(StructureComponent &&) = default; StructureComponent &operator=(StructureComponent &&) = default; StructureComponent(const StructureComponent &) = delete; StructureComponent &operator=(const StructureComponent &) = delete; StructureComponent() = delete;
  StructureComponent(DataRef &&dr, Name &&n)
      : base{std::move(dr)}, component(std::move(n)) {}
  DataRef base;
  Name component;
};



struct ProcComponentRef {
  ProcComponentRef(ProcComponentRef &&) = default; ProcComponentRef &operator=(ProcComponentRef &&) = default; ProcComponentRef(const ProcComponentRef &) = delete; ProcComponentRef &operator=(const ProcComponentRef &) = delete; ProcComponentRef() = delete; ProcComponentRef(Scalar<StructureComponent> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<StructureComponent> v;
};


struct CoindexedNamedObject {
  CoindexedNamedObject(CoindexedNamedObject &&) = default; CoindexedNamedObject &operator=(CoindexedNamedObject &&) = default; CoindexedNamedObject(const CoindexedNamedObject &) = delete; CoindexedNamedObject &operator=(const CoindexedNamedObject &) = delete; CoindexedNamedObject() = delete;
  CoindexedNamedObject(DataRef &&dr, ImageSelector &&is)
      : base{std::move(dr)}, imageSelector{std::move(is)} {}
  DataRef base;
  ImageSelector imageSelector;
};


struct ArrayElement {
  ArrayElement(ArrayElement &&) = default; ArrayElement &operator=(ArrayElement &&) = default; ArrayElement(const ArrayElement &) = delete; ArrayElement &operator=(const ArrayElement &) = delete; ArrayElement() = delete;
  ArrayElement(DataRef &&dr, std::list<SectionSubscript> &&ss)
      : base{std::move(dr)}, subscripts(std::move(ss)) {}
  Substring ConvertToSubstring();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
  DataRef base;
  std::list<SectionSubscript> subscripts;
};


struct AllocateObject {
  template <typename A, typename = common::NoLvalue<A>> AllocateObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocateObject(AllocateObject &&) = default; AllocateObject &operator=(AllocateObject &&) = default; AllocateObject(const AllocateObject &) = delete; AllocateObject &operator=(const AllocateObject &) = delete; AllocateObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};



using BoundExpr = ScalarIntExpr;



struct AllocateShapeSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateShapeSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateShapeSpec(AllocateShapeSpec &&) = default; AllocateShapeSpec &operator=(AllocateShapeSpec &&) = default; AllocateShapeSpec(const AllocateShapeSpec &) = delete; AllocateShapeSpec &operator=(const AllocateShapeSpec &) = delete; AllocateShapeSpec() = delete;
  std::tuple<std::optional<BoundExpr>, BoundExpr> t;
};

using AllocateCoshapeSpec = AllocateShapeSpec;



struct AllocateCoarraySpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateCoarraySpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateCoarraySpec(AllocateCoarraySpec &&) = default; AllocateCoarraySpec &operator=(AllocateCoarraySpec &&) = default; AllocateCoarraySpec(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec &operator=(const AllocateCoarraySpec &) = delete; AllocateCoarraySpec() = delete;
  std::tuple<std::list<AllocateCoshapeSpec>, std::optional<BoundExpr>> t;
};




struct Allocation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Allocation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Allocation(Allocation &&) = default; Allocation &operator=(Allocation &&) = default; Allocation(const Allocation &) = delete; Allocation &operator=(const Allocation &) = delete; Allocation() = delete;
  std::tuple<AllocateObject, std::list<AllocateShapeSpec>,
      std::optional<AllocateCoarraySpec>>
      t;
};


struct StatVariable { StatVariable(StatVariable &&) = default; StatVariable &operator=(StatVariable &&) = default; StatVariable(const StatVariable &) = delete; StatVariable &operator=(const StatVariable &) = delete; StatVariable() = delete; StatVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };



struct MsgVariable { MsgVariable(MsgVariable &&) = default; MsgVariable &operator=(MsgVariable &&) = default; MsgVariable(const MsgVariable &) = delete; MsgVariable &operator=(const MsgVariable &) = delete; MsgVariable() = delete; MsgVariable(ScalarDefaultCharVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharVariable v; };



struct StatOrErrmsg {
  template <typename A, typename = common::NoLvalue<A>> StatOrErrmsg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StatOrErrmsg(StatOrErrmsg &&) = default; StatOrErrmsg &operator=(StatOrErrmsg &&) = default; StatOrErrmsg(const StatOrErrmsg &) = delete; StatOrErrmsg &operator=(const StatOrErrmsg &) = delete; StatOrErrmsg() = delete;
  std::variant<StatVariable, MsgVariable> u;
};







struct AllocOpt {
  template <typename A, typename = common::NoLvalue<A>> AllocOpt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocOpt(AllocOpt &&) = default; AllocOpt &operator=(AllocOpt &&) = default; AllocOpt(const AllocOpt &) = delete; AllocOpt &operator=(const AllocOpt &) = delete; AllocOpt() = delete;
  struct Mold { Mold(Mold &&) = default; Mold &operator=(Mold &&) = default; Mold(const Mold &) = delete; Mold &operator=(const Mold &) = delete; Mold() = delete; Mold(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Source { Source(Source &&) = default; Source &operator=(Source &&) = default; Source(const Source &) = delete; Source &operator=(const Source &) = delete; Source() = delete; Source(common::Indirection<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<Expr> v; };
  struct Stream { Stream(Stream &&) = default; Stream &operator=(Stream &&) = default; Stream(const Stream &) = delete; Stream &operator=(const Stream &) = delete; Stream() = delete; Stream(common::Indirection<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarIntExpr> v; };
  struct Pinned { Pinned(Pinned &&) = default; Pinned &operator=(Pinned &&) = default; Pinned(const Pinned &) = delete; Pinned &operator=(const Pinned &) = delete; Pinned() = delete; Pinned(common::Indirection<ScalarLogicalVariable> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::Indirection<ScalarLogicalVariable> v; };
  std::variant<Mold, Source, StatOrErrmsg, Stream, Pinned> u;
};



struct AllocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AllocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AllocateStmt(AllocateStmt &&) = default; AllocateStmt &operator=(AllocateStmt &&) = default; AllocateStmt(const AllocateStmt &) = delete; AllocateStmt &operator=(const AllocateStmt &) = delete; AllocateStmt() = delete;
  std::tuple<std::optional<TypeSpec>, std::list<Allocation>,
      std::list<AllocOpt>>
      t;
};



struct PointerObject {
  template <typename A, typename = common::NoLvalue<A>> PointerObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PointerObject(PointerObject &&) = default; PointerObject &operator=(PointerObject &&) = default; PointerObject(const PointerObject &) = delete; PointerObject &operator=(const PointerObject &) = delete; PointerObject() = delete;
  mutable TypedExpr typedExpr;
  std::variant<Name, StructureComponent> u;
};


struct NullifyStmt { NullifyStmt(NullifyStmt &&) = default; NullifyStmt &operator=(NullifyStmt &&) = default; NullifyStmt(const NullifyStmt &) = delete; NullifyStmt &operator=(const NullifyStmt &) = delete; NullifyStmt() = delete; NullifyStmt(std::list<PointerObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PointerObject> v; };



struct DeallocateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DeallocateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DeallocateStmt(DeallocateStmt &&) = default; DeallocateStmt &operator=(DeallocateStmt &&) = default; DeallocateStmt(const DeallocateStmt &) = delete; DeallocateStmt &operator=(const DeallocateStmt &) = delete; DeallocateStmt() = delete;
  std::tuple<std::list<AllocateObject>, std::list<StatOrErrmsg>> t;
};


struct AssignmentStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignmentStmt(AssignmentStmt &&) = default; AssignmentStmt &operator=(AssignmentStmt &&) = default; AssignmentStmt(const AssignmentStmt &) = delete; AssignmentStmt &operator=(const AssignmentStmt &) = delete; AssignmentStmt() = delete;
  using TypedAssignment =
      common::ForwardOwningPointer<evaluate::GenericAssignmentWrapper>;
  mutable TypedAssignment typedAssignment;
  std::tuple<Variable, Expr> t;
};


struct BoundsSpec { BoundsSpec(BoundsSpec &&) = default; BoundsSpec &operator=(BoundsSpec &&) = default; BoundsSpec(const BoundsSpec &) = delete; BoundsSpec &operator=(const BoundsSpec &) = delete; BoundsSpec() = delete; BoundsSpec(BoundExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; BoundExpr v; };


struct BoundsRemapping {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BoundsRemapping(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BoundsRemapping(BoundsRemapping &&) = default; BoundsRemapping &operator=(BoundsRemapping &&) = default; BoundsRemapping(const BoundsRemapping &) = delete; BoundsRemapping &operator=(const BoundsRemapping &) = delete; BoundsRemapping() = delete;
  std::tuple<BoundExpr, BoundExpr> t;
};
# 2006 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct PointerAssignmentStmt {
  struct Bounds {
    template <typename A, typename = common::NoLvalue<A>> Bounds(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Bounds(Bounds &&) = default; Bounds &operator=(Bounds &&) = default; Bounds(const Bounds &) = delete; Bounds &operator=(const Bounds &) = delete; Bounds() = delete;
    std::variant<std::list<BoundsRemapping>, std::list<BoundsSpec>> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PointerAssignmentStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PointerAssignmentStmt(PointerAssignmentStmt &&) = default; PointerAssignmentStmt &operator=(PointerAssignmentStmt &&) = default; PointerAssignmentStmt(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt &operator=(const PointerAssignmentStmt &) = delete; PointerAssignmentStmt() = delete;
  mutable AssignmentStmt::TypedAssignment typedAssignment;
  std::tuple<DataRef, Bounds, Expr> t;
};




struct WhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereStmt(WhereStmt &&) = default; WhereStmt &operator=(WhereStmt &&) = default; WhereStmt(const WhereStmt &) = delete; WhereStmt &operator=(const WhereStmt &) = delete; WhereStmt() = delete;
  std::tuple<LogicalExpr, AssignmentStmt> t;
};


struct WhereConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstructStmt(WhereConstructStmt &&) = default; WhereConstructStmt &operator=(WhereConstructStmt &&) = default; WhereConstructStmt(const WhereConstructStmt &) = delete; WhereConstructStmt &operator=(const WhereConstructStmt &) = delete; WhereConstructStmt() = delete;
  std::tuple<std::optional<Name>, LogicalExpr> t;
};



struct WhereBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> WhereBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WhereBodyConstruct(WhereBodyConstruct &&) = default; WhereBodyConstruct &operator=(WhereBodyConstruct &&) = default; WhereBodyConstruct(const WhereBodyConstruct &) = delete; WhereBodyConstruct &operator=(const WhereBodyConstruct &) = delete; WhereBodyConstruct() = delete;
  std::variant<Statement<AssignmentStmt>, Statement<WhereStmt>,
      common::Indirection<WhereConstruct>>
      u;
};



struct MaskedElsewhereStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhereStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhereStmt(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt &operator=(MaskedElsewhereStmt &&) = default; MaskedElsewhereStmt(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt &operator=(const MaskedElsewhereStmt &) = delete; MaskedElsewhereStmt() = delete;
  std::tuple<LogicalExpr, std::optional<Name>> t;
};


struct ElsewhereStmt { ElsewhereStmt(ElsewhereStmt &&) = default; ElsewhereStmt &operator=(ElsewhereStmt &&) = default; ElsewhereStmt(const ElsewhereStmt &) = delete; ElsewhereStmt &operator=(const ElsewhereStmt &) = delete; ElsewhereStmt() = delete; ElsewhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndWhereStmt { EndWhereStmt(EndWhereStmt &&) = default; EndWhereStmt &operator=(EndWhereStmt &&) = default; EndWhereStmt(const EndWhereStmt &) = delete; EndWhereStmt &operator=(const EndWhereStmt &) = delete; EndWhereStmt() = delete; EndWhereStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };





struct WhereConstruct {
  struct MaskedElsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> MaskedElsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MaskedElsewhere(MaskedElsewhere &&) = default; MaskedElsewhere &operator=(MaskedElsewhere &&) = default; MaskedElsewhere(const MaskedElsewhere &) = delete; MaskedElsewhere &operator=(const MaskedElsewhere &) = delete; MaskedElsewhere() = delete;
    std::tuple<Statement<MaskedElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  struct Elsewhere {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Elsewhere(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Elsewhere(Elsewhere &&) = default; Elsewhere &operator=(Elsewhere &&) = default; Elsewhere(const Elsewhere &) = delete; Elsewhere &operator=(const Elsewhere &) = delete; Elsewhere() = delete;
    std::tuple<Statement<ElsewhereStmt>, std::list<WhereBodyConstruct>> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> WhereConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; WhereConstruct(WhereConstruct &&) = default; WhereConstruct &operator=(WhereConstruct &&) = default; WhereConstruct(const WhereConstruct &) = delete; WhereConstruct &operator=(const WhereConstruct &) = delete; WhereConstruct() = delete;
  std::tuple<Statement<WhereConstructStmt>, std::list<WhereBodyConstruct>,
      std::list<MaskedElsewhere>, std::optional<Elsewhere>,
      Statement<EndWhereStmt>>
      t;
};



struct ForallConstructStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstructStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstructStmt(ForallConstructStmt &&) = default; ForallConstructStmt &operator=(ForallConstructStmt &&) = default; ForallConstructStmt(const ForallConstructStmt &) = delete; ForallConstructStmt &operator=(const ForallConstructStmt &) = delete; ForallConstructStmt() = delete;
  std::tuple<std::optional<Name>, common::Indirection<ConcurrentHeader>> t;
};


struct ForallAssignmentStmt {
  template <typename A, typename = common::NoLvalue<A>> ForallAssignmentStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallAssignmentStmt(ForallAssignmentStmt &&) = default; ForallAssignmentStmt &operator=(ForallAssignmentStmt &&) = default; ForallAssignmentStmt(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt &operator=(const ForallAssignmentStmt &) = delete; ForallAssignmentStmt() = delete;
  std::variant<AssignmentStmt, PointerAssignmentStmt> u;
};


struct ForallStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallStmt(ForallStmt &&) = default; ForallStmt &operator=(ForallStmt &&) = default; ForallStmt(const ForallStmt &) = delete; ForallStmt &operator=(const ForallStmt &) = delete; ForallStmt() = delete;
  std::tuple<common::Indirection<ConcurrentHeader>,
      UnlabeledStatement<ForallAssignmentStmt>>
      t;
};




struct ForallBodyConstruct {
  template <typename A, typename = common::NoLvalue<A>> ForallBodyConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ForallBodyConstruct(ForallBodyConstruct &&) = default; ForallBodyConstruct &operator=(ForallBodyConstruct &&) = default; ForallBodyConstruct(const ForallBodyConstruct &) = delete; ForallBodyConstruct &operator=(const ForallBodyConstruct &) = delete; ForallBodyConstruct() = delete;
  std::variant<Statement<ForallAssignmentStmt>, Statement<WhereStmt>,
      WhereConstruct, common::Indirection<ForallConstruct>,
      Statement<ForallStmt>>
      u;
};


struct EndForallStmt { EndForallStmt(EndForallStmt &&) = default; EndForallStmt &operator=(EndForallStmt &&) = default; EndForallStmt(const EndForallStmt &) = delete; EndForallStmt &operator=(const EndForallStmt &) = delete; EndForallStmt() = delete; EndForallStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct ForallConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ForallConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ForallConstruct(ForallConstruct &&) = default; ForallConstruct &operator=(ForallConstruct &&) = default; ForallConstruct(const ForallConstruct &) = delete; ForallConstruct &operator=(const ForallConstruct &) = delete; ForallConstruct() = delete;
  std::tuple<Statement<ForallConstructStmt>, std::list<ForallBodyConstruct>,
      Statement<EndForallStmt>>
      t;
};


using Block = std::list<ExecutionPartConstruct>;


struct Selector {
  template <typename A, typename = common::NoLvalue<A>> Selector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Selector(Selector &&) = default; Selector &operator=(Selector &&) = default; Selector(const Selector &) = delete; Selector &operator=(const Selector &) = delete; Selector() = delete;
  std::variant<Expr, Variable> u;
};


struct Association {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Association(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Association(Association &&) = default; Association &operator=(Association &&) = default; Association(const Association &) = delete; Association &operator=(const Association &) = delete; Association() = delete;
  std::tuple<Name, Selector> t;
};



struct AssociateStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateStmt(AssociateStmt &&) = default; AssociateStmt &operator=(AssociateStmt &&) = default; AssociateStmt(const AssociateStmt &) = delete; AssociateStmt &operator=(const AssociateStmt &) = delete; AssociateStmt() = delete;
  std::tuple<std::optional<Name>, std::list<Association>> t;
};


struct EndAssociateStmt { EndAssociateStmt(EndAssociateStmt &&) = default; EndAssociateStmt &operator=(EndAssociateStmt &&) = default; EndAssociateStmt(const EndAssociateStmt &) = delete; EndAssociateStmt &operator=(const EndAssociateStmt &) = delete; EndAssociateStmt() = delete; EndAssociateStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct AssociateConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssociateConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssociateConstruct(AssociateConstruct &&) = default; AssociateConstruct &operator=(AssociateConstruct &&) = default; AssociateConstruct(const AssociateConstruct &) = delete; AssociateConstruct &operator=(const AssociateConstruct &) = delete; AssociateConstruct() = delete;
  std::tuple<Statement<AssociateStmt>, Block, Statement<EndAssociateStmt>> t;
};


struct BlockStmt { BlockStmt(BlockStmt &&) = default; BlockStmt &operator=(BlockStmt &&) = default; BlockStmt(const BlockStmt &) = delete; BlockStmt &operator=(const BlockStmt &) = delete; BlockStmt() = delete; BlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockStmt { EndBlockStmt(EndBlockStmt &&) = default; EndBlockStmt &operator=(EndBlockStmt &&) = default; EndBlockStmt(const EndBlockStmt &) = delete; EndBlockStmt &operator=(const EndBlockStmt &) = delete; EndBlockStmt() = delete; EndBlockStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2160 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct BlockSpecificationPart { BlockSpecificationPart(BlockSpecificationPart &&) = default; BlockSpecificationPart &operator=(BlockSpecificationPart &&) = default; BlockSpecificationPart(const BlockSpecificationPart &) = delete; BlockSpecificationPart &operator=(const BlockSpecificationPart &) = delete; BlockSpecificationPart() = delete; BlockSpecificationPart(SpecificationPart &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; SpecificationPart v; };



struct BlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockConstruct(BlockConstruct &&) = default; BlockConstruct &operator=(BlockConstruct &&) = default; BlockConstruct(const BlockConstruct &) = delete; BlockConstruct &operator=(const BlockConstruct &) = delete; BlockConstruct() = delete;
  std::tuple<Statement<BlockStmt>, BlockSpecificationPart, Block,
      Statement<EndBlockStmt>>
      t;
};


struct CoarrayAssociation {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CoarrayAssociation(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CoarrayAssociation(CoarrayAssociation &&) = default; CoarrayAssociation &operator=(CoarrayAssociation &&) = default; CoarrayAssociation(const CoarrayAssociation &) = delete; CoarrayAssociation &operator=(const CoarrayAssociation &) = delete; CoarrayAssociation() = delete;
  std::tuple<CodimensionDecl, Selector> t;
};




struct ChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamStmt(ChangeTeamStmt &&) = default; ChangeTeamStmt &operator=(ChangeTeamStmt &&) = default; ChangeTeamStmt(const ChangeTeamStmt &) = delete; ChangeTeamStmt &operator=(const ChangeTeamStmt &) = delete; ChangeTeamStmt() = delete;
  std::tuple<std::optional<Name>, TeamValue, std::list<CoarrayAssociation>,
      std::list<StatOrErrmsg>>
      t;
};



struct EndChangeTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EndChangeTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EndChangeTeamStmt(EndChangeTeamStmt &&) = default; EndChangeTeamStmt &operator=(EndChangeTeamStmt &&) = default; EndChangeTeamStmt(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt &operator=(const EndChangeTeamStmt &) = delete; EndChangeTeamStmt() = delete;
  std::tuple<std::list<StatOrErrmsg>, std::optional<Name>> t;
};


struct ChangeTeamConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ChangeTeamConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ChangeTeamConstruct(ChangeTeamConstruct &&) = default; ChangeTeamConstruct &operator=(ChangeTeamConstruct &&) = default; ChangeTeamConstruct(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct &operator=(const ChangeTeamConstruct &) = delete; ChangeTeamConstruct() = delete;
  std::tuple<Statement<ChangeTeamStmt>, Block, Statement<EndChangeTeamStmt>> t;
};



struct CriticalStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalStmt(CriticalStmt &&) = default; CriticalStmt &operator=(CriticalStmt &&) = default; CriticalStmt(const CriticalStmt &) = delete; CriticalStmt &operator=(const CriticalStmt &) = delete; CriticalStmt() = delete;
  std::tuple<std::optional<Name>, std::list<StatOrErrmsg>> t;
};


struct EndCriticalStmt { EndCriticalStmt(EndCriticalStmt &&) = default; EndCriticalStmt &operator=(EndCriticalStmt &&) = default; EndCriticalStmt(const EndCriticalStmt &) = delete; EndCriticalStmt &operator=(const EndCriticalStmt &) = delete; EndCriticalStmt() = delete; EndCriticalStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct CriticalConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CriticalConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CriticalConstruct(CriticalConstruct &&) = default; CriticalConstruct &operator=(CriticalConstruct &&) = default; CriticalConstruct(const CriticalConstruct &) = delete; CriticalConstruct &operator=(const CriticalConstruct &) = delete; CriticalConstruct() = delete;
  std::tuple<Statement<CriticalStmt>, Block, Statement<EndCriticalStmt>> t;
};





struct ConcurrentControl {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentControl(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentControl(ConcurrentControl &&) = default; ConcurrentControl &operator=(ConcurrentControl &&) = default; ConcurrentControl(const ConcurrentControl &) = delete; ConcurrentControl &operator=(const ConcurrentControl &) = delete; ConcurrentControl() = delete;
  std::tuple<Name, ScalarIntExpr, ScalarIntExpr, std::optional<ScalarIntExpr>>
      t;
};




struct ConcurrentHeader {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ConcurrentHeader(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ConcurrentHeader(ConcurrentHeader &&) = default; ConcurrentHeader &operator=(ConcurrentHeader &&) = default; ConcurrentHeader(const ConcurrentHeader &) = delete; ConcurrentHeader &operator=(const ConcurrentHeader &) = delete; ConcurrentHeader() = delete;
  std::tuple<std::optional<IntegerTypeSpec>, std::list<ConcurrentControl>,
      std::optional<ScalarLogicalExpr>>
      t;
};




struct LocalitySpec {
  template <typename A, typename = common::NoLvalue<A>> LocalitySpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LocalitySpec(LocalitySpec &&) = default; LocalitySpec &operator=(LocalitySpec &&) = default; LocalitySpec(const LocalitySpec &) = delete; LocalitySpec &operator=(const LocalitySpec &) = delete; LocalitySpec() = delete;
  struct Local { Local(Local &&) = default; Local &operator=(Local &&) = default; Local(const Local &) = delete; Local &operator=(const Local &) = delete; Local() = delete; Local(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct LocalInit { LocalInit(LocalInit &&) = default; LocalInit &operator=(LocalInit &&) = default; LocalInit(const LocalInit &) = delete; LocalInit &operator=(const LocalInit &) = delete; LocalInit() = delete; LocalInit(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
  struct DefaultNone { DefaultNone() {} DefaultNone(const DefaultNone &) {} DefaultNone(DefaultNone &&) {} DefaultNone &operator=(const DefaultNone &) { return *this; }; DefaultNone &operator=(DefaultNone &&) { return *this; }; using EmptyTrait = std::true_type; };
  std::variant<Local, LocalInit, Shared, DefaultNone> u;
};







struct LoopControl {
  template <typename A, typename = common::NoLvalue<A>> LoopControl(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LoopControl(LoopControl &&) = default; LoopControl &operator=(LoopControl &&) = default; LoopControl(const LoopControl &) = delete; LoopControl &operator=(const LoopControl &) = delete; LoopControl() = delete;
  struct Concurrent {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Concurrent(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Concurrent(Concurrent &&) = default; Concurrent &operator=(Concurrent &&) = default; Concurrent(const Concurrent &) = delete; Concurrent &operator=(const Concurrent &) = delete; Concurrent() = delete;
    std::tuple<ConcurrentHeader, std::list<LocalitySpec>> t;
  };
  using Bounds = LoopBounds<ScalarName, ScalarExpr>;
  std::variant<Bounds, ScalarLogicalExpr, Concurrent> u;
};



struct LabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LabelDoStmt(LabelDoStmt &&) = default; LabelDoStmt &operator=(LabelDoStmt &&) = default; LabelDoStmt(const LabelDoStmt &) = delete; LabelDoStmt &operator=(const LabelDoStmt &) = delete; LabelDoStmt() = delete;
  std::tuple<Label, std::optional<LoopControl>> t;
};


struct NonLabelDoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> NonLabelDoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NonLabelDoStmt(NonLabelDoStmt &&) = default; NonLabelDoStmt &operator=(NonLabelDoStmt &&) = default; NonLabelDoStmt(const NonLabelDoStmt &) = delete; NonLabelDoStmt &operator=(const NonLabelDoStmt &) = delete; NonLabelDoStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Label>,
      std::optional<LoopControl>>
      t;
};


struct EndDoStmt { EndDoStmt(EndDoStmt &&) = default; EndDoStmt &operator=(EndDoStmt &&) = default; EndDoStmt(const EndDoStmt &) = delete; EndDoStmt &operator=(const EndDoStmt &) = delete; EndDoStmt() = delete; EndDoStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };
# 2289 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct DoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> DoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; DoConstruct(DoConstruct &&) = default; DoConstruct &operator=(DoConstruct &&) = default; DoConstruct(const DoConstruct &) = delete; DoConstruct &operator=(const DoConstruct &) = delete; DoConstruct() = delete;
  const std::optional<LoopControl> &GetLoopControl() const;
  bool IsDoNormal() const;
  bool IsDoWhile() const;
  bool IsDoConcurrent() const;
  std::tuple<Statement<NonLabelDoStmt>, Block, Statement<EndDoStmt>> t;
};


struct CycleStmt { CycleStmt(CycleStmt &&) = default; CycleStmt &operator=(CycleStmt &&) = default; CycleStmt(const CycleStmt &) = delete; CycleStmt &operator=(const CycleStmt &) = delete; CycleStmt() = delete; CycleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct IfThenStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfThenStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfThenStmt(IfThenStmt &&) = default; IfThenStmt &operator=(IfThenStmt &&) = default; IfThenStmt(const IfThenStmt &) = delete; IfThenStmt &operator=(const IfThenStmt &) = delete; IfThenStmt() = delete;
  std::tuple<std::optional<Name>, ScalarLogicalExpr> t;
};



struct ElseIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfStmt(ElseIfStmt &&) = default; ElseIfStmt &operator=(ElseIfStmt &&) = default; ElseIfStmt(const ElseIfStmt &) = delete; ElseIfStmt &operator=(const ElseIfStmt &) = delete; ElseIfStmt() = delete;
  std::tuple<ScalarLogicalExpr, std::optional<Name>> t;
};


struct ElseStmt { ElseStmt(ElseStmt &&) = default; ElseStmt &operator=(ElseStmt &&) = default; ElseStmt(const ElseStmt &) = delete; ElseStmt &operator=(const ElseStmt &) = delete; ElseStmt() = delete; ElseStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndIfStmt { EndIfStmt(EndIfStmt &&) = default; EndIfStmt &operator=(EndIfStmt &&) = default; EndIfStmt(const EndIfStmt &) = delete; EndIfStmt &operator=(const EndIfStmt &) = delete; EndIfStmt() = delete; EndIfStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct IfConstruct {
  struct ElseIfBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseIfBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseIfBlock(ElseIfBlock &&) = default; ElseIfBlock &operator=(ElseIfBlock &&) = default; ElseIfBlock(const ElseIfBlock &) = delete; ElseIfBlock &operator=(const ElseIfBlock &) = delete; ElseIfBlock() = delete;
    std::tuple<Statement<ElseIfStmt>, Block> t;
  };
  struct ElseBlock {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> ElseBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ElseBlock(ElseBlock &&) = default; ElseBlock &operator=(ElseBlock &&) = default; ElseBlock(const ElseBlock &) = delete; ElseBlock &operator=(const ElseBlock &) = delete; ElseBlock() = delete;
    std::tuple<Statement<ElseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfConstruct(IfConstruct &&) = default; IfConstruct &operator=(IfConstruct &&) = default; IfConstruct(const IfConstruct &) = delete; IfConstruct &operator=(const IfConstruct &) = delete; IfConstruct() = delete;
  std::tuple<Statement<IfThenStmt>, Block, std::list<ElseIfBlock>,
      std::optional<ElseBlock>, Statement<EndIfStmt>>
      t;
};


struct IfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> IfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IfStmt(IfStmt &&) = default; IfStmt &operator=(IfStmt &&) = default; IfStmt(const IfStmt &) = delete; IfStmt &operator=(const IfStmt &) = delete; IfStmt() = delete;
  std::tuple<ScalarLogicalExpr, UnlabeledStatement<ActionStmt>> t;
};



struct SelectCaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectCaseStmt(SelectCaseStmt &&) = default; SelectCaseStmt &operator=(SelectCaseStmt &&) = default; SelectCaseStmt(const SelectCaseStmt &) = delete; SelectCaseStmt &operator=(const SelectCaseStmt &) = delete; SelectCaseStmt() = delete;
  std::tuple<std::optional<Name>, Scalar<Expr>> t;
};


using CaseValue = Scalar<ConstantExpr>;



struct CaseValueRange {
  template <typename A, typename = common::NoLvalue<A>> CaseValueRange(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseValueRange(CaseValueRange &&) = default; CaseValueRange &operator=(CaseValueRange &&) = default; CaseValueRange(const CaseValueRange &) = delete; CaseValueRange &operator=(const CaseValueRange &) = delete; CaseValueRange() = delete;
  struct Range {
    Range(Range &&) = default; Range &operator=(Range &&) = default; Range(const Range &) = delete; Range &operator=(const Range &) = delete; Range() = delete;
    Range(std::optional<CaseValue> &&l, std::optional<CaseValue> &&u)
        : lower{std::move(l)}, upper{std::move(u)} {}
    std::optional<CaseValue> lower, upper;
  };
  std::variant<CaseValue, Range> u;
};


struct Default { Default() {} Default(const Default &) {} Default(Default &&) {} Default &operator=(const Default &) { return *this; }; Default &operator=(Default &&) { return *this; }; using EmptyTrait = std::true_type; };

struct CaseSelector {
  template <typename A, typename = common::NoLvalue<A>> CaseSelector(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CaseSelector(CaseSelector &&) = default; CaseSelector &operator=(CaseSelector &&) = default; CaseSelector(const CaseSelector &) = delete; CaseSelector &operator=(const CaseSelector &) = delete; CaseSelector() = delete;
  std::variant<std::list<CaseValueRange>, Default> u;
};


struct CaseStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseStmt(CaseStmt &&) = default; CaseStmt &operator=(CaseStmt &&) = default; CaseStmt(const CaseStmt &) = delete; CaseStmt &operator=(const CaseStmt &) = delete; CaseStmt() = delete;
  std::tuple<CaseSelector, std::optional<Name>> t;
};




struct EndSelectStmt { EndSelectStmt(EndSelectStmt &&) = default; EndSelectStmt &operator=(EndSelectStmt &&) = default; EndSelectStmt(const EndSelectStmt &) = delete; EndSelectStmt &operator=(const EndSelectStmt &) = delete; EndSelectStmt() = delete; EndSelectStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };



struct CaseConstruct {
  struct Case {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Case(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Case(Case &&) = default; Case &operator=(Case &&) = default; Case(const Case &) = delete; Case &operator=(const Case &) = delete; Case() = delete;
    std::tuple<Statement<CaseStmt>, Block> t;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CaseConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CaseConstruct(CaseConstruct &&) = default; CaseConstruct &operator=(CaseConstruct &&) = default; CaseConstruct(const CaseConstruct &) = delete; CaseConstruct &operator=(const CaseConstruct &) = delete; CaseConstruct() = delete;
  std::tuple<Statement<SelectCaseStmt>, std::list<Case>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectRankStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankStmt(SelectRankStmt &&) = default; SelectRankStmt &operator=(SelectRankStmt &&) = default; SelectRankStmt(const SelectRankStmt &) = delete; SelectRankStmt &operator=(const SelectRankStmt &) = delete; SelectRankStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct SelectRankCaseStmt {
  struct Rank {
    template <typename A, typename = common::NoLvalue<A>> Rank(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rank(Rank &&) = default; Rank &operator=(Rank &&) = default; Rank(const Rank &) = delete; Rank &operator=(const Rank &) = delete; Rank() = delete;
    std::variant<ScalarIntConstantExpr, Star, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankCaseStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankCaseStmt(SelectRankCaseStmt &&) = default; SelectRankCaseStmt &operator=(SelectRankCaseStmt &&) = default; SelectRankCaseStmt(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt &operator=(const SelectRankCaseStmt &) = delete; SelectRankCaseStmt() = delete;
  std::tuple<Rank, std::optional<Name>> t;
};




struct SelectRankConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectRankConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectRankConstruct(SelectRankConstruct &&) = default; SelectRankConstruct &operator=(SelectRankConstruct &&) = default; SelectRankConstruct(const SelectRankConstruct &) = delete; SelectRankConstruct &operator=(const SelectRankConstruct &) = delete; SelectRankConstruct() = delete;
  struct RankCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> RankCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; RankCase(RankCase &&) = default; RankCase &operator=(RankCase &&) = default; RankCase(const RankCase &) = delete; RankCase &operator=(const RankCase &) = delete; RankCase() = delete;
    std::tuple<Statement<SelectRankCaseStmt>, Block> t;
  };
  std::tuple<Statement<SelectRankStmt>, std::list<RankCase>,
      Statement<EndSelectStmt>>
      t;
};




struct SelectTypeStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeStmt(SelectTypeStmt &&) = default; SelectTypeStmt &operator=(SelectTypeStmt &&) = default; SelectTypeStmt(const SelectTypeStmt &) = delete; SelectTypeStmt &operator=(const SelectTypeStmt &) = delete; SelectTypeStmt() = delete;
  std::tuple<std::optional<Name>, std::optional<Name>, Selector> t;
};





struct TypeGuardStmt {
  struct Guard {
    template <typename A, typename = common::NoLvalue<A>> Guard(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Guard(Guard &&) = default; Guard &operator=(Guard &&) = default; Guard(const Guard &) = delete; Guard &operator=(const Guard &) = delete; Guard() = delete;
    std::variant<TypeSpec, DerivedTypeSpec, Default> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeGuardStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeGuardStmt(TypeGuardStmt &&) = default; TypeGuardStmt &operator=(TypeGuardStmt &&) = default; TypeGuardStmt(const TypeGuardStmt &) = delete; TypeGuardStmt &operator=(const TypeGuardStmt &) = delete; TypeGuardStmt() = delete;
  std::tuple<Guard, std::optional<Name>> t;
};



struct SelectTypeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SelectTypeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SelectTypeConstruct(SelectTypeConstruct &&) = default; SelectTypeConstruct &operator=(SelectTypeConstruct &&) = default; SelectTypeConstruct(const SelectTypeConstruct &) = delete; SelectTypeConstruct &operator=(const SelectTypeConstruct &) = delete; SelectTypeConstruct() = delete;
  struct TypeCase {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> TypeCase(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; TypeCase(TypeCase &&) = default; TypeCase &operator=(TypeCase &&) = default; TypeCase(const TypeCase &) = delete; TypeCase &operator=(const TypeCase &) = delete; TypeCase() = delete;
    std::tuple<Statement<TypeGuardStmt>, Block> t;
  };
  std::tuple<Statement<SelectTypeStmt>, std::list<TypeCase>,
      Statement<EndSelectStmt>>
      t;
};


struct ExitStmt { ExitStmt(ExitStmt &&) = default; ExitStmt &operator=(ExitStmt &&) = default; ExitStmt(const ExitStmt &) = delete; ExitStmt &operator=(const ExitStmt &) = delete; ExitStmt() = delete; ExitStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct GotoStmt { GotoStmt(GotoStmt &&) = default; GotoStmt &operator=(GotoStmt &&) = default; GotoStmt(const GotoStmt &) = delete; GotoStmt &operator=(const GotoStmt &) = delete; GotoStmt() = delete; GotoStmt(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };


struct ComputedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ComputedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComputedGotoStmt(ComputedGotoStmt &&) = default; ComputedGotoStmt &operator=(ComputedGotoStmt &&) = default; ComputedGotoStmt(const ComputedGotoStmt &) = delete; ComputedGotoStmt &operator=(const ComputedGotoStmt &) = delete; ComputedGotoStmt() = delete;
  std::tuple<std::list<Label>, ScalarIntExpr> t;
};





struct StopCode { StopCode(StopCode &&) = default; StopCode &operator=(StopCode &&) = default; StopCode(const StopCode &) = delete; StopCode &operator=(const StopCode &) = delete; StopCode() = delete; StopCode(Scalar<Expr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Scalar<Expr> v; };




struct StopStmt {
  enum class Kind { Stop, ErrorStop }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Stop, ErrorStop")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Stop, ErrorStop")}; return names[static_cast<std::size_t>(e)]; }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StopStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StopStmt(StopStmt &&) = default; StopStmt &operator=(StopStmt &&) = default; StopStmt(const StopStmt &) = delete; StopStmt &operator=(const StopStmt &) = delete; StopStmt() = delete;
  std::tuple<Kind, std::optional<StopCode>, std::optional<ScalarLogicalExpr>> t;
};


struct SyncAllStmt { SyncAllStmt(SyncAllStmt &&) = default; SyncAllStmt &operator=(SyncAllStmt &&) = default; SyncAllStmt(const SyncAllStmt &) = delete; SyncAllStmt &operator=(const SyncAllStmt &) = delete; SyncAllStmt() = delete; SyncAllStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };



struct SyncImagesStmt {
  struct ImageSet {
    template <typename A, typename = common::NoLvalue<A>> ImageSet(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ImageSet(ImageSet &&) = default; ImageSet &operator=(ImageSet &&) = default; ImageSet(const ImageSet &) = delete; ImageSet &operator=(const ImageSet &) = delete; ImageSet() = delete;
    std::variant<IntExpr, Star> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncImagesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncImagesStmt(SyncImagesStmt &&) = default; SyncImagesStmt &operator=(SyncImagesStmt &&) = default; SyncImagesStmt(const SyncImagesStmt &) = delete; SyncImagesStmt &operator=(const SyncImagesStmt &) = delete; SyncImagesStmt() = delete;
  std::tuple<ImageSet, std::list<StatOrErrmsg>> t;
};


struct SyncMemoryStmt { SyncMemoryStmt(SyncMemoryStmt &&) = default; SyncMemoryStmt &operator=(SyncMemoryStmt &&) = default; SyncMemoryStmt(const SyncMemoryStmt &) = delete; SyncMemoryStmt &operator=(const SyncMemoryStmt &) = delete; SyncMemoryStmt() = delete; SyncMemoryStmt(std::list<StatOrErrmsg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<StatOrErrmsg> v; };


struct SyncTeamStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SyncTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SyncTeamStmt(SyncTeamStmt &&) = default; SyncTeamStmt &operator=(SyncTeamStmt &&) = default; SyncTeamStmt(const SyncTeamStmt &) = delete; SyncTeamStmt &operator=(const SyncTeamStmt &) = delete; SyncTeamStmt() = delete;
  std::tuple<TeamValue, std::list<StatOrErrmsg>> t;
};


using EventVariable = Scalar<Variable>;


struct EventPostStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventPostStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventPostStmt(EventPostStmt &&) = default; EventPostStmt &operator=(EventPostStmt &&) = default; EventPostStmt(const EventPostStmt &) = delete; EventPostStmt &operator=(const EventPostStmt &) = delete; EventPostStmt() = delete;
  std::tuple<EventVariable, std::list<StatOrErrmsg>> t;
};





struct EventWaitStmt {
  struct EventWaitSpec {
    template <typename A, typename = common::NoLvalue<A>> EventWaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; EventWaitSpec(EventWaitSpec &&) = default; EventWaitSpec &operator=(EventWaitSpec &&) = default; EventWaitSpec(const EventWaitSpec &) = delete; EventWaitSpec &operator=(const EventWaitSpec &) = delete; EventWaitSpec() = delete;
    std::variant<ScalarIntExpr, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EventWaitStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EventWaitStmt(EventWaitStmt &&) = default; EventWaitStmt &operator=(EventWaitStmt &&) = default; EventWaitStmt(const EventWaitStmt &) = delete; EventWaitStmt &operator=(const EventWaitStmt &) = delete; EventWaitStmt() = delete;
  std::tuple<EventVariable, std::list<EventWaitSpec>> t;
};


using TeamVariable = Scalar<Variable>;





struct FormTeamStmt {
  struct FormTeamSpec {
    template <typename A, typename = common::NoLvalue<A>> FormTeamSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; FormTeamSpec(FormTeamSpec &&) = default; FormTeamSpec &operator=(FormTeamSpec &&) = default; FormTeamSpec(const FormTeamSpec &) = delete; FormTeamSpec &operator=(const FormTeamSpec &) = delete; FormTeamSpec() = delete;
    std::variant<ScalarIntExpr, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FormTeamStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FormTeamStmt(FormTeamStmt &&) = default; FormTeamStmt &operator=(FormTeamStmt &&) = default; FormTeamStmt(const FormTeamStmt &) = delete; FormTeamStmt &operator=(const FormTeamStmt &) = delete; FormTeamStmt() = delete;
  std::tuple<ScalarIntExpr, TeamVariable, std::list<FormTeamSpec>> t;
};


using LockVariable = Scalar<Variable>;



struct LockStmt {
  struct LockStat {
    template <typename A, typename = common::NoLvalue<A>> LockStat(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; LockStat(LockStat &&) = default; LockStat &operator=(LockStat &&) = default; LockStat(const LockStat &) = delete; LockStat &operator=(const LockStat &) = delete; LockStat() = delete;
    std::variant<Scalar<Logical<Variable>>, StatOrErrmsg> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> LockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LockStmt(LockStmt &&) = default; LockStmt &operator=(LockStmt &&) = default; LockStmt(const LockStmt &) = delete; LockStmt &operator=(const LockStmt &) = delete; LockStmt() = delete;
  std::tuple<LockVariable, std::list<LockStat>> t;
};


struct UnlockStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> UnlockStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; UnlockStmt(UnlockStmt &&) = default; UnlockStmt &operator=(UnlockStmt &&) = default; UnlockStmt(const UnlockStmt &) = delete; UnlockStmt &operator=(const UnlockStmt &) = delete; UnlockStmt() = delete;
  std::tuple<LockVariable, std::list<StatOrErrmsg>> t;
};


struct FileUnitNumber { FileUnitNumber(FileUnitNumber &&) = default; FileUnitNumber &operator=(FileUnitNumber &&) = default; FileUnitNumber(const FileUnitNumber &) = delete; FileUnitNumber &operator=(const FileUnitNumber &) = delete; FileUnitNumber() = delete; FileUnitNumber(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
# 2586 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct IoUnit {
  template <typename A, typename = common::NoLvalue<A>> IoUnit(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoUnit(IoUnit &&) = default; IoUnit &operator=(IoUnit &&) = default; IoUnit(const IoUnit &) = delete; IoUnit &operator=(const IoUnit &) = delete; IoUnit() = delete;
  std::variant<Variable, FileUnitNumber, Star> u;
};


using FileNameExpr = ScalarDefaultCharExpr;
# 2611 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct StatusExpr { StatusExpr(StatusExpr &&) = default; StatusExpr &operator=(StatusExpr &&) = default; StatusExpr(const StatusExpr &) = delete; StatusExpr &operator=(const StatusExpr &) = delete; StatusExpr() = delete; StatusExpr(ScalarDefaultCharExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharExpr v; };
struct ErrLabel { ErrLabel(ErrLabel &&) = default; ErrLabel &operator=(ErrLabel &&) = default; ErrLabel(const ErrLabel &) = delete; ErrLabel &operator=(const ErrLabel &) = delete; ErrLabel() = delete; ErrLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };

struct ConnectSpec {
  template <typename A, typename = common::NoLvalue<A>> ConnectSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ConnectSpec(ConnectSpec &&) = default; ConnectSpec &operator=(ConnectSpec &&) = default; ConnectSpec(const ConnectSpec &) = delete; ConnectSpec &operator=(const ConnectSpec &) = delete; ConnectSpec() = delete;
  struct CharExpr {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Encoding, Form, Pad, Position, Round, Sign, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; }


    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Recl { Recl(Recl &&) = default; Recl &operator=(Recl &&) = default; Recl(const Recl &) = delete; Recl &operator=(const Recl &) = delete; Recl() = delete; Recl(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Newunit { Newunit(Newunit &&) = default; Newunit &operator=(Newunit &&) = default; Newunit(const Newunit &) = delete; Newunit &operator=(const Newunit &) = delete; Newunit() = delete; Newunit(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<FileUnitNumber, FileNameExpr, CharExpr, MsgVariable,
      StatVariable, Recl, Newunit, ErrLabel, StatusExpr>
      u;
};


struct OpenStmt { OpenStmt(OpenStmt &&) = default; OpenStmt &operator=(OpenStmt &&) = default; OpenStmt(const OpenStmt &) = delete; OpenStmt &operator=(const OpenStmt &) = delete; OpenStmt() = delete; OpenStmt(std::list<ConnectSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ConnectSpec> v; };






struct CloseStmt {
  struct CloseSpec {
    template <typename A, typename = common::NoLvalue<A>> CloseSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CloseSpec(CloseSpec &&) = default; CloseSpec &operator=(CloseSpec &&) = default; CloseSpec(const CloseSpec &) = delete; CloseSpec &operator=(const CloseSpec &) = delete; CloseSpec() = delete;
    std::variant<FileUnitNumber, StatVariable, MsgVariable, ErrLabel,
        StatusExpr>
        u;
  };
  CloseStmt(CloseStmt &&) = default; CloseStmt &operator=(CloseStmt &&) = default; CloseStmt(const CloseStmt &) = delete; CloseStmt &operator=(const CloseStmt &) = delete; CloseStmt() = delete; CloseStmt(std::list<CloseSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<CloseSpec> v;
};



struct Format {
  template <typename A, typename = common::NoLvalue<A>> Format(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Format(Format &&) = default; Format &operator=(Format &&) = default; Format(const Format &) = delete; Format &operator=(const Format &) = delete; Format() = delete;
  std::variant<Expr, Label, Star> u;
};


struct IdVariable { IdVariable(IdVariable &&) = default; IdVariable &operator=(IdVariable &&) = default; IdVariable(const IdVariable &) = delete; IdVariable &operator=(const IdVariable &) = delete; IdVariable() = delete; IdVariable(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
# 2670 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct EndLabel { EndLabel(EndLabel &&) = default; EndLabel &operator=(EndLabel &&) = default; EndLabel(const EndLabel &) = delete; EndLabel &operator=(const EndLabel &) = delete; EndLabel() = delete; EndLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct EorLabel { EorLabel(EorLabel &&) = default; EorLabel &operator=(EorLabel &&) = default; EorLabel(const EorLabel &) = delete; EorLabel &operator=(const EorLabel &) = delete; EorLabel() = delete; EorLabel(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };
struct IoControlSpec {
  template <typename A, typename = common::NoLvalue<A>> IoControlSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; IoControlSpec(IoControlSpec &&) = default; IoControlSpec &operator=(IoControlSpec &&) = default; IoControlSpec(const IoControlSpec &) = delete; IoControlSpec &operator=(const IoControlSpec &) = delete; IoControlSpec() = delete;
  struct CharExpr {
    enum class Kind { Advance, Blank, Decimal, Delim, Pad, Round, Sign }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Advance, Blank, Decimal, Delim, Pad, Round, Sign")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharExpr(CharExpr &&) = default; CharExpr &operator=(CharExpr &&) = default; CharExpr(const CharExpr &) = delete; CharExpr &operator=(const CharExpr &) = delete; CharExpr() = delete;
    std::tuple<Kind, ScalarDefaultCharExpr> t;
  };
  struct Asynchronous { Asynchronous(Asynchronous &&) = default; Asynchronous &operator=(Asynchronous &&) = default; Asynchronous(const Asynchronous &) = delete; Asynchronous &operator=(const Asynchronous &) = delete; Asynchronous() = delete; Asynchronous(ScalarDefaultCharConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarDefaultCharConstantExpr v; };
  struct Pos { Pos(Pos &&) = default; Pos &operator=(Pos &&) = default; Pos(const Pos &) = delete; Pos &operator=(const Pos &) = delete; Pos() = delete; Pos(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Rec { Rec(Rec &&) = default; Rec &operator=(Rec &&) = default; Rec(const Rec &) = delete; Rec &operator=(const Rec &) = delete; Rec() = delete; Rec(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Size { Size(Size &&) = default; Size &operator=(Size &&) = default; Size(const Size &) = delete; Size &operator=(const Size &) = delete; Size() = delete; Size(ScalarIntVariable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntVariable v; };
  std::variant<IoUnit, Format, Name, CharExpr, Asynchronous, EndLabel, EorLabel,
      ErrLabel, IdVariable, MsgVariable, StatVariable, Pos, Rec, Size>
      u;
};


struct InputItem {
  template <typename A, typename = common::NoLvalue<A>> InputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InputItem(InputItem &&) = default; InputItem &operator=(InputItem &&) = default; InputItem(const InputItem &) = delete; InputItem &operator=(const InputItem &) = delete; InputItem() = delete;
  std::variant<Variable, common::Indirection<InputImpliedDo>> u;
};




struct ReadStmt {
  ReadStmt(ReadStmt &&) = default; ReadStmt &operator=(ReadStmt &&) = default; ReadStmt(const ReadStmt &) = delete; ReadStmt &operator=(const ReadStmt &) = delete; ReadStmt() = delete;
  ReadStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<InputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;


  std::list<IoControlSpec> controls;
  std::list<InputItem> items;
};


struct OutputItem {
  template <typename A, typename = common::NoLvalue<A>> OutputItem(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OutputItem(OutputItem &&) = default; OutputItem &operator=(OutputItem &&) = default; OutputItem(const OutputItem &) = delete; OutputItem &operator=(const OutputItem &) = delete; OutputItem() = delete;
  std::variant<Expr, common::Indirection<OutputImpliedDo>> u;
};


struct WriteStmt {
  WriteStmt(WriteStmt &&) = default; WriteStmt &operator=(WriteStmt &&) = default; WriteStmt(const WriteStmt &) = delete; WriteStmt &operator=(const WriteStmt &) = delete; WriteStmt() = delete;
  WriteStmt(std::optional<IoUnit> &&i, std::optional<Format> &&f,
      std::list<IoControlSpec> &&cs, std::list<OutputItem> &&its)
      : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
        items(std::move(its)) {}
  std::optional<IoUnit> iounit;

  std::optional<Format> format;

  std::list<IoControlSpec> controls;
  std::list<OutputItem> items;
};


struct PrintStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> PrintStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; PrintStmt(PrintStmt &&) = default; PrintStmt &operator=(PrintStmt &&) = default; PrintStmt(const PrintStmt &) = delete; PrintStmt &operator=(const PrintStmt &) = delete; PrintStmt() = delete;
  std::tuple<Format, std::list<OutputItem>> t;
};



using IoImpliedDoControl = LoopBounds<DoVariable, ScalarIntExpr>;



struct InputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InputImpliedDo(InputImpliedDo &&) = default; InputImpliedDo &operator=(InputImpliedDo &&) = default; InputImpliedDo(const InputImpliedDo &) = delete; InputImpliedDo &operator=(const InputImpliedDo &) = delete; InputImpliedDo() = delete;
  std::tuple<std::list<InputItem>, IoImpliedDoControl> t;
};

struct OutputImpliedDo {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OutputImpliedDo(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OutputImpliedDo(OutputImpliedDo &&) = default; OutputImpliedDo &operator=(OutputImpliedDo &&) = default; OutputImpliedDo(const OutputImpliedDo &) = delete; OutputImpliedDo &operator=(const OutputImpliedDo &) = delete; OutputImpliedDo() = delete;
  std::tuple<std::list<OutputItem>, IoImpliedDoControl> t;
};





struct IdExpr { IdExpr(IdExpr &&) = default; IdExpr &operator=(IdExpr &&) = default; IdExpr(const IdExpr &) = delete; IdExpr &operator=(const IdExpr &) = delete; IdExpr() = delete; IdExpr(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct WaitSpec {
  template <typename A, typename = common::NoLvalue<A>> WaitSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; WaitSpec(WaitSpec &&) = default; WaitSpec &operator=(WaitSpec &&) = default; WaitSpec(const WaitSpec &) = delete; WaitSpec &operator=(const WaitSpec &) = delete; WaitSpec() = delete;
  std::variant<FileUnitNumber, EndLabel, EorLabel, ErrLabel, IdExpr,
      MsgVariable, StatVariable>
      u;
};


struct WaitStmt { WaitStmt(WaitStmt &&) = default; WaitStmt &operator=(WaitStmt &&) = default; WaitStmt(const WaitStmt &) = delete; WaitStmt &operator=(const WaitStmt &) = delete; WaitStmt() = delete; WaitStmt(std::list<WaitSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<WaitSpec> v; };







struct PositionOrFlushSpec {
  template <typename A, typename = common::NoLvalue<A>> PositionOrFlushSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PositionOrFlushSpec(PositionOrFlushSpec &&) = default; PositionOrFlushSpec &operator=(PositionOrFlushSpec &&) = default; PositionOrFlushSpec(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec &operator=(const PositionOrFlushSpec &) = delete; PositionOrFlushSpec() = delete;
  std::variant<FileUnitNumber, MsgVariable, StatVariable, ErrLabel> u;
};



struct BackspaceStmt { BackspaceStmt(BackspaceStmt &&) = default; BackspaceStmt &operator=(BackspaceStmt &&) = default; BackspaceStmt(const BackspaceStmt &) = delete; BackspaceStmt &operator=(const BackspaceStmt &) = delete; BackspaceStmt() = delete; BackspaceStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };



struct EndfileStmt { EndfileStmt(EndfileStmt &&) = default; EndfileStmt &operator=(EndfileStmt &&) = default; EndfileStmt(const EndfileStmt &) = delete; EndfileStmt &operator=(const EndfileStmt &) = delete; EndfileStmt() = delete; EndfileStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct RewindStmt { RewindStmt(RewindStmt &&) = default; RewindStmt &operator=(RewindStmt &&) = default; RewindStmt(const RewindStmt &) = delete; RewindStmt &operator=(const RewindStmt &) = delete; RewindStmt() = delete; RewindStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };


struct FlushStmt { FlushStmt(FlushStmt &&) = default; FlushStmt &operator=(FlushStmt &&) = default; FlushStmt(const FlushStmt &) = delete; FlushStmt &operator=(const FlushStmt &) = delete; FlushStmt() = delete; FlushStmt(std::list<PositionOrFlushSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<PositionOrFlushSpec> v; };
# 2830 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h"
struct InquireSpec {
  template <typename A, typename = common::NoLvalue<A>> InquireSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireSpec(InquireSpec &&) = default; InquireSpec &operator=(InquireSpec &&) = default; InquireSpec(const InquireSpec &) = delete; InquireSpec &operator=(const InquireSpec &) = delete; InquireSpec() = delete;
  struct CharVar {
    enum class Kind { Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Access, Action, Asynchronous, Blank, Decimal, Delim, Direct, Encoding, Form, Formatted, Iomsg, Name, Pad, Position, Read, Readwrite, Round, Sequential, Sign, Stream, Status, Unformatted, Write, Carriagecontrol, Convert, Dispose")}; return names[static_cast<std::size_t>(e)]; }



    template <typename... Ts, typename = common::NoLvalue<Ts...>> CharVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CharVar(CharVar &&) = default; CharVar &operator=(CharVar &&) = default; CharVar(const CharVar &) = delete; CharVar &operator=(const CharVar &) = delete; CharVar() = delete;
    std::tuple<Kind, ScalarDefaultCharVariable> t;
  };
  struct IntVar {
    enum class Kind { Iostat, Nextrec, Number, Pos, Recl, Size }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Iostat, Nextrec, Number, Pos, Recl, Size")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Iostat, Nextrec, Number, Pos, Recl, Size")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IntVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IntVar(IntVar &&) = default; IntVar &operator=(IntVar &&) = default; IntVar(const IntVar &) = delete; IntVar &operator=(const IntVar &) = delete; IntVar() = delete;
    std::tuple<Kind, ScalarIntVariable> t;
  };
  struct LogVar {
    enum class Kind { Exist, Named, Opened, Pending }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Exist, Named, Opened, Pending")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Exist, Named, Opened, Pending")}; return names[static_cast<std::size_t>(e)]; }
    template <typename... Ts, typename = common::NoLvalue<Ts...>> LogVar(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; LogVar(LogVar &&) = default; LogVar &operator=(LogVar &&) = default; LogVar(const LogVar &) = delete; LogVar &operator=(const LogVar &) = delete; LogVar() = delete;
    std::tuple<Kind, Scalar<Logical<Variable>>> t;
  };
  std::variant<FileUnitNumber, FileNameExpr, CharVar, IntVar, LogVar, IdExpr,
      ErrLabel>
      u;
};




struct InquireStmt {
  template <typename A, typename = common::NoLvalue<A>> InquireStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InquireStmt(InquireStmt &&) = default; InquireStmt &operator=(InquireStmt &&) = default; InquireStmt(const InquireStmt &) = delete; InquireStmt &operator=(const InquireStmt &) = delete; InquireStmt() = delete;
  struct Iolength {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Iolength(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Iolength(Iolength &&) = default; Iolength &operator=(Iolength &&) = default; Iolength(const Iolength &) = delete; Iolength &operator=(const Iolength &) = delete; Iolength() = delete;
    std::tuple<ScalarIntVariable, std::list<OutputItem>> t;
  };
  std::variant<std::list<InquireSpec>, Iolength> u;
};


struct FormatStmt { FormatStmt(FormatStmt &&) = default; FormatStmt &operator=(FormatStmt &&) = default; FormatStmt(const FormatStmt &) = delete; FormatStmt &operator=(const FormatStmt &) = delete; FormatStmt() = delete; FormatStmt(format::FormatSpecification &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; format::FormatSpecification v; };


struct ProgramStmt { ProgramStmt(ProgramStmt &&) = default; ProgramStmt &operator=(ProgramStmt &&) = default; ProgramStmt(const ProgramStmt &) = delete; ProgramStmt &operator=(const ProgramStmt &) = delete; ProgramStmt() = delete; ProgramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndProgramStmt { EndProgramStmt(EndProgramStmt &&) = default; EndProgramStmt &operator=(EndProgramStmt &&) = default; EndProgramStmt(const EndProgramStmt &) = delete; EndProgramStmt &operator=(const EndProgramStmt &) = delete; EndProgramStmt() = delete; EndProgramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct MainProgram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> MainProgram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; MainProgram(MainProgram &&) = default; MainProgram &operator=(MainProgram &&) = default; MainProgram(const MainProgram &) = delete; MainProgram &operator=(const MainProgram &) = delete; MainProgram() = delete;
  std::tuple<std::optional<Statement<ProgramStmt>>, SpecificationPart,
      ExecutionPart, std::optional<InternalSubprogramPart>,
      Statement<EndProgramStmt>>
      t;
};


struct ModuleStmt { ModuleStmt(ModuleStmt &&) = default; ModuleStmt &operator=(ModuleStmt &&) = default; ModuleStmt(const ModuleStmt &) = delete; ModuleStmt &operator=(const ModuleStmt &) = delete; ModuleStmt() = delete; ModuleStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };




struct ModuleSubprogram {
  template <typename A, typename = common::NoLvalue<A>> ModuleSubprogram(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ModuleSubprogram(ModuleSubprogram &&) = default; ModuleSubprogram &operator=(ModuleSubprogram &&) = default; ModuleSubprogram(const ModuleSubprogram &) = delete; ModuleSubprogram &operator=(const ModuleSubprogram &) = delete; ModuleSubprogram() = delete;
  std::variant<common::Indirection<FunctionSubprogram>,
      common::Indirection<SubroutineSubprogram>,
      common::Indirection<SeparateModuleSubprogram>>
      u;
};


struct ModuleSubprogramPart {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ModuleSubprogramPart(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ModuleSubprogramPart(ModuleSubprogramPart &&) = default; ModuleSubprogramPart &operator=(ModuleSubprogramPart &&) = default; ModuleSubprogramPart(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart &operator=(const ModuleSubprogramPart &) = delete; ModuleSubprogramPart() = delete;
  std::tuple<Statement<ContainsStmt>, std::list<ModuleSubprogram>> t;
};


struct EndModuleStmt { EndModuleStmt(EndModuleStmt &&) = default; EndModuleStmt &operator=(EndModuleStmt &&) = default; EndModuleStmt(const EndModuleStmt &) = delete; EndModuleStmt &operator=(const EndModuleStmt &) = delete; EndModuleStmt() = delete; EndModuleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Module {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Module(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Module(Module &&) = default; Module &operator=(Module &&) = default; Module(const Module &) = delete; Module &operator=(const Module &) = delete; Module() = delete;
  std::tuple<Statement<ModuleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndModuleStmt>>
      t;
};





struct Rename {
  template <typename A, typename = common::NoLvalue<A>> Rename(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Rename(Rename &&) = default; Rename &operator=(Rename &&) = default; Rename(const Rename &) = delete; Rename &operator=(const Rename &) = delete; Rename() = delete;
  struct Names {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Names(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Names(Names &&) = default; Names &operator=(Names &&) = default; Names(const Names &) = delete; Names &operator=(const Names &) = delete; Names() = delete;
    std::tuple<Name, Name> t;
  };
  struct Operators {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Operators(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Operators(Operators &&) = default; Operators &operator=(Operators &&) = default; Operators(const Operators &) = delete; Operators &operator=(const Operators &) = delete; Operators() = delete;
    std::tuple<DefinedOpName, DefinedOpName> t;
  };
  std::variant<Names, Operators> u;
};


struct ParentIdentifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ParentIdentifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ParentIdentifier(ParentIdentifier &&) = default; ParentIdentifier &operator=(ParentIdentifier &&) = default; ParentIdentifier(const ParentIdentifier &) = delete; ParentIdentifier &operator=(const ParentIdentifier &) = delete; ParentIdentifier() = delete;
  std::tuple<Name, std::optional<Name>> t;
};


struct SubmoduleStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubmoduleStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubmoduleStmt(SubmoduleStmt &&) = default; SubmoduleStmt &operator=(SubmoduleStmt &&) = default; SubmoduleStmt(const SubmoduleStmt &) = delete; SubmoduleStmt &operator=(const SubmoduleStmt &) = delete; SubmoduleStmt() = delete;
  std::tuple<ParentIdentifier, Name> t;
};


struct EndSubmoduleStmt { EndSubmoduleStmt(EndSubmoduleStmt &&) = default; EndSubmoduleStmt &operator=(EndSubmoduleStmt &&) = default; EndSubmoduleStmt(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt &operator=(const EndSubmoduleStmt &) = delete; EndSubmoduleStmt() = delete; EndSubmoduleStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct Submodule {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Submodule(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Submodule(Submodule &&) = default; Submodule &operator=(Submodule &&) = default; Submodule(const Submodule &) = delete; Submodule &operator=(const Submodule &) = delete; Submodule() = delete;
  std::tuple<Statement<SubmoduleStmt>, SpecificationPart,
      std::optional<ModuleSubprogramPart>, Statement<EndSubmoduleStmt>>
      t;
};


struct BlockDataStmt { BlockDataStmt(BlockDataStmt &&) = default; BlockDataStmt &operator=(BlockDataStmt &&) = default; BlockDataStmt(const BlockDataStmt &) = delete; BlockDataStmt &operator=(const BlockDataStmt &) = delete; BlockDataStmt() = delete; BlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct EndBlockDataStmt { EndBlockDataStmt(EndBlockDataStmt &&) = default; EndBlockDataStmt &operator=(EndBlockDataStmt &&) = default; EndBlockDataStmt(const EndBlockDataStmt &) = delete; EndBlockDataStmt &operator=(const EndBlockDataStmt &) = delete; EndBlockDataStmt() = delete; EndBlockDataStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct BlockData {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BlockData(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BlockData(BlockData &&) = default; BlockData &operator=(BlockData &&) = default; BlockData(const BlockData &) = delete; BlockData &operator=(const BlockData &) = delete; BlockData() = delete;
  std::tuple<Statement<BlockDataStmt>, SpecificationPart,
      Statement<EndBlockDataStmt>>
      t;
};







struct GenericSpec {
  template <typename A, typename = common::NoLvalue<A>> GenericSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; GenericSpec(GenericSpec &&) = default; GenericSpec &operator=(GenericSpec &&) = default; GenericSpec(const GenericSpec &) = delete; GenericSpec &operator=(const GenericSpec &) = delete; GenericSpec() = delete;
  struct Assignment { Assignment() {} Assignment(const Assignment &) {} Assignment(Assignment &&) {} Assignment &operator=(const Assignment &) { return *this; }; Assignment &operator=(Assignment &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadFormatted { ReadFormatted() {} ReadFormatted(const ReadFormatted &) {} ReadFormatted(ReadFormatted &&) {} ReadFormatted &operator=(const ReadFormatted &) { return *this; }; ReadFormatted &operator=(ReadFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct ReadUnformatted { ReadUnformatted() {} ReadUnformatted(const ReadUnformatted &) {} ReadUnformatted(ReadUnformatted &&) {} ReadUnformatted &operator=(const ReadUnformatted &) { return *this; }; ReadUnformatted &operator=(ReadUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteFormatted { WriteFormatted() {} WriteFormatted(const WriteFormatted &) {} WriteFormatted(WriteFormatted &&) {} WriteFormatted &operator=(const WriteFormatted &) { return *this; }; WriteFormatted &operator=(WriteFormatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct WriteUnformatted { WriteUnformatted() {} WriteUnformatted(const WriteUnformatted &) {} WriteUnformatted(WriteUnformatted &&) {} WriteUnformatted &operator=(const WriteUnformatted &) { return *this; }; WriteUnformatted &operator=(WriteUnformatted &&) { return *this; }; using EmptyTrait = std::true_type; };
  CharBlock source;
  std::variant<Name, DefinedOperator, Assignment, ReadFormatted,
      ReadUnformatted, WriteFormatted, WriteUnformatted>
      u;
};



struct GenericStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> GenericStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; GenericStmt(GenericStmt &&) = default; GenericStmt &operator=(GenericStmt &&) = default; GenericStmt(const GenericStmt &) = delete; GenericStmt &operator=(const GenericStmt &) = delete; GenericStmt() = delete;
  std::tuple<std::optional<AccessSpec>, GenericSpec, std::list<Name>> t;
};


struct InterfaceStmt {
  template <typename A, typename = common::NoLvalue<A>> InterfaceStmt(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceStmt(InterfaceStmt &&) = default; InterfaceStmt &operator=(InterfaceStmt &&) = default; InterfaceStmt(const InterfaceStmt &) = delete; InterfaceStmt &operator=(const InterfaceStmt &) = delete; InterfaceStmt() = delete;

  InterfaceStmt(Abstract x) : u{x} {}

  std::variant<std::optional<GenericSpec>, Abstract> u;
};



struct Only {
  template <typename A, typename = common::NoLvalue<A>> Only(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; Only(Only &&) = default; Only &operator=(Only &&) = default; Only(const Only &) = delete; Only &operator=(const Only &) = delete; Only() = delete;
  std::variant<common::Indirection<GenericSpec>, Name, Rename> u;
};





struct UseStmt {
  UseStmt(UseStmt &&) = default; UseStmt &operator=(UseStmt &&) = default; UseStmt(const UseStmt &) = delete; UseStmt &operator=(const UseStmt &) = delete; UseStmt() = delete;
  enum class ModuleNature { Intrinsic, Non_Intrinsic }; [[maybe_unused]] static constexpr std::size_t ModuleNature_enumSize{ ::Fortran::common::CountEnumNames("Intrinsic, Non_Intrinsic")}; [[maybe_unused]] static inline std::string_view EnumToString(ModuleNature e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ModuleNature_enumSize>("Intrinsic, Non_Intrinsic")}; return names[static_cast<std::size_t>(e)]; }
  template <typename A>
  UseStmt(std::optional<ModuleNature> &&nat, Name &&n, std::list<A> &&x)
      : nature(std::move(nat)), moduleName(std::move(n)), u(std::move(x)) {}
  std::optional<ModuleNature> nature;
  Name moduleName;
  std::variant<std::list<Rename>, std::list<Only>> u;
};




struct ProcAttrSpec {
  template <typename A, typename = common::NoLvalue<A>> ProcAttrSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcAttrSpec(ProcAttrSpec &&) = default; ProcAttrSpec &operator=(ProcAttrSpec &&) = default; ProcAttrSpec(const ProcAttrSpec &) = delete; ProcAttrSpec &operator=(const ProcAttrSpec &) = delete; ProcAttrSpec() = delete;
  std::variant<AccessSpec, LanguageBindingSpec, IntentSpec, Optional, Pointer,
      Protected, Save>
      u;
};




struct ProcedureDeclarationStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureDeclarationStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureDeclarationStmt(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt &operator=(ProcedureDeclarationStmt &&) = default; ProcedureDeclarationStmt(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt &operator=(const ProcedureDeclarationStmt &) = delete; ProcedureDeclarationStmt() = delete;
  std::tuple<std::optional<ProcInterface>, std::list<ProcAttrSpec>,
      std::list<ProcDecl>>
      t;
};






struct PrefixSpec {
  template <typename A, typename = common::NoLvalue<A>> PrefixSpec(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; PrefixSpec(PrefixSpec &&) = default; PrefixSpec &operator=(PrefixSpec &&) = default; PrefixSpec(const PrefixSpec &) = delete; PrefixSpec &operator=(const PrefixSpec &) = delete; PrefixSpec() = delete;
  struct Elemental { Elemental() {} Elemental(const Elemental &) {} Elemental(Elemental &&) {} Elemental &operator=(const Elemental &) { return *this; }; Elemental &operator=(Elemental &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Impure { Impure() {} Impure(const Impure &) {} Impure(Impure &&) {} Impure &operator=(const Impure &) { return *this; }; Impure &operator=(Impure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Module { Module() {} Module(const Module &) {} Module(Module &&) {} Module &operator=(const Module &) { return *this; }; Module &operator=(Module &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Non_Recursive { Non_Recursive() {} Non_Recursive(const Non_Recursive &) {} Non_Recursive(Non_Recursive &&) {} Non_Recursive &operator=(const Non_Recursive &) { return *this; }; Non_Recursive &operator=(Non_Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Pure { Pure() {} Pure(const Pure &) {} Pure(Pure &&) {} Pure &operator=(const Pure &) { return *this; }; Pure &operator=(Pure &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Recursive { Recursive() {} Recursive(const Recursive &) {} Recursive(Recursive &&) {} Recursive &operator=(const Recursive &) { return *this; }; Recursive &operator=(Recursive &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Attributes { Attributes(Attributes &&) = default; Attributes &operator=(Attributes &&) = default; Attributes(const Attributes &) = delete; Attributes &operator=(const Attributes &) = delete; Attributes() = delete; Attributes(std::list<common::CUDASubprogramAttrs> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<common::CUDASubprogramAttrs> v; };
  struct Launch_Bounds { Launch_Bounds(Launch_Bounds &&) = default; Launch_Bounds &operator=(Launch_Bounds &&) = default; Launch_Bounds(const Launch_Bounds &) = delete; Launch_Bounds &operator=(const Launch_Bounds &) = delete; Launch_Bounds() = delete; Launch_Bounds(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  struct Cluster_Dims { Cluster_Dims(Cluster_Dims &&) = default; Cluster_Dims &operator=(Cluster_Dims &&) = default; Cluster_Dims(const Cluster_Dims &) = delete; Cluster_Dims &operator=(const Cluster_Dims &) = delete; Cluster_Dims() = delete; Cluster_Dims(std::list<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntConstantExpr> v; };
  std::variant<DeclarationTypeSpec, Elemental, Impure, Module, Non_Recursive,
      Pure, Recursive, Attributes, Launch_Bounds, Cluster_Dims>
      u;
};




struct Suffix {
  Suffix(Suffix &&) = default; Suffix &operator=(Suffix &&) = default; Suffix(const Suffix &) = delete; Suffix &operator=(const Suffix &) = delete; Suffix() = delete;
  Suffix(LanguageBindingSpec &&lbs, std::optional<Name> &&rn)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  Suffix(Name &&rn, std::optional<LanguageBindingSpec> &&lbs)
      : binding(std::move(lbs)), resultName(std::move(rn)) {}
  std::optional<LanguageBindingSpec> binding;
  std::optional<Name> resultName;
};





struct FunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionStmt(FunctionStmt &&) = default; FunctionStmt &operator=(FunctionStmt &&) = default; FunctionStmt(const FunctionStmt &) = delete; FunctionStmt &operator=(const FunctionStmt &) = delete; FunctionStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<Name>,
      std::optional<Suffix>>
      t;
};


struct EndFunctionStmt { EndFunctionStmt(EndFunctionStmt &&) = default; EndFunctionStmt &operator=(EndFunctionStmt &&) = default; EndFunctionStmt(const EndFunctionStmt &) = delete; EndFunctionStmt &operator=(const EndFunctionStmt &) = delete; EndFunctionStmt() = delete; EndFunctionStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };


struct DummyArg {
  template <typename A, typename = common::NoLvalue<A>> DummyArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; DummyArg(DummyArg &&) = default; DummyArg &operator=(DummyArg &&) = default; DummyArg(const DummyArg &) = delete; DummyArg &operator=(const DummyArg &) = delete; DummyArg() = delete;
  std::variant<Name, Star> u;
};




struct SubroutineStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineStmt(SubroutineStmt &&) = default; SubroutineStmt &operator=(SubroutineStmt &&) = default; SubroutineStmt(const SubroutineStmt &) = delete; SubroutineStmt &operator=(const SubroutineStmt &) = delete; SubroutineStmt() = delete;
  std::tuple<std::list<PrefixSpec>, Name, std::list<DummyArg>,
      std::optional<LanguageBindingSpec>>
      t;
};


struct EndSubroutineStmt { EndSubroutineStmt(EndSubroutineStmt &&) = default; EndSubroutineStmt &operator=(EndSubroutineStmt &&) = default; EndSubroutineStmt(const EndSubroutineStmt &) = delete; EndSubroutineStmt &operator=(const EndSubroutineStmt &) = delete; EndSubroutineStmt() = delete; EndSubroutineStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type;
  std::optional<Name> v;
};

struct InterfaceBody {
  template <typename A, typename = common::NoLvalue<A>> InterfaceBody(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceBody(InterfaceBody &&) = default; InterfaceBody &operator=(InterfaceBody &&) = default; InterfaceBody(const InterfaceBody &) = delete; InterfaceBody &operator=(const InterfaceBody &) = delete; InterfaceBody() = delete;
  struct Function {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Function(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Function(Function &&) = default; Function &operator=(Function &&) = default; Function(const Function &) = delete; Function &operator=(const Function &) = delete; Function() = delete;
    std::tuple<Statement<FunctionStmt>, common::Indirection<SpecificationPart>,
        Statement<EndFunctionStmt>>
        t;
  };
  struct Subroutine {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Subroutine(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Subroutine(Subroutine &&) = default; Subroutine &operator=(Subroutine &&) = default; Subroutine(const Subroutine &) = delete; Subroutine &operator=(const Subroutine &) = delete; Subroutine() = delete;
    std::tuple<Statement<SubroutineStmt>,
        common::Indirection<SpecificationPart>, Statement<EndSubroutineStmt>>
        t;
  };
  std::variant<Function, Subroutine> u;
};


struct ProcedureStmt {
  enum class Kind { ModuleProcedure, Procedure }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("ModuleProcedure, Procedure")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("ModuleProcedure, Procedure")}; return names[static_cast<std::size_t>(e)]; }
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ProcedureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ProcedureStmt(ProcedureStmt &&) = default; ProcedureStmt &operator=(ProcedureStmt &&) = default; ProcedureStmt(const ProcedureStmt &) = delete; ProcedureStmt &operator=(const ProcedureStmt &) = delete; ProcedureStmt() = delete;
  std::tuple<Kind, std::list<Name>> t;
};


struct InterfaceSpecification {
  template <typename A, typename = common::NoLvalue<A>> InterfaceSpecification(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; InterfaceSpecification(InterfaceSpecification &&) = default; InterfaceSpecification &operator=(InterfaceSpecification &&) = default; InterfaceSpecification(const InterfaceSpecification &) = delete; InterfaceSpecification &operator=(const InterfaceSpecification &) = delete; InterfaceSpecification() = delete;
  std::variant<InterfaceBody, Statement<ProcedureStmt>> u;
};


struct EndInterfaceStmt { EndInterfaceStmt(EndInterfaceStmt &&) = default; EndInterfaceStmt &operator=(EndInterfaceStmt &&) = default; EndInterfaceStmt(const EndInterfaceStmt &) = delete; EndInterfaceStmt &operator=(const EndInterfaceStmt &) = delete; EndInterfaceStmt() = delete; EndInterfaceStmt(std::optional<GenericSpec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<GenericSpec> v; };



struct InterfaceBlock {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> InterfaceBlock(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InterfaceBlock(InterfaceBlock &&) = default; InterfaceBlock &operator=(InterfaceBlock &&) = default; InterfaceBlock(const InterfaceBlock &) = delete; InterfaceBlock &operator=(const InterfaceBlock &) = delete; InterfaceBlock() = delete;
  std::tuple<Statement<InterfaceStmt>, std::list<InterfaceSpecification>,
      Statement<EndInterfaceStmt>>
      t;
};


struct ExternalStmt { ExternalStmt(ExternalStmt &&) = default; ExternalStmt &operator=(ExternalStmt &&) = default; ExternalStmt(const ExternalStmt &) = delete; ExternalStmt &operator=(const ExternalStmt &) = delete; ExternalStmt() = delete; ExternalStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };


struct IntrinsicStmt { IntrinsicStmt(IntrinsicStmt &&) = default; IntrinsicStmt &operator=(IntrinsicStmt &&) = default; IntrinsicStmt(const IntrinsicStmt &) = delete; IntrinsicStmt &operator=(const IntrinsicStmt &) = delete; IntrinsicStmt() = delete; IntrinsicStmt(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };



struct ProcedureDesignator {
  template <typename A, typename = common::NoLvalue<A>> ProcedureDesignator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ProcedureDesignator(ProcedureDesignator &&) = default; ProcedureDesignator &operator=(ProcedureDesignator &&) = default; ProcedureDesignator(const ProcedureDesignator &) = delete; ProcedureDesignator &operator=(const ProcedureDesignator &) = delete; ProcedureDesignator() = delete;
  std::variant<Name, ProcComponentRef> u;
};


struct AltReturnSpec { AltReturnSpec(AltReturnSpec &&) = default; AltReturnSpec &operator=(AltReturnSpec &&) = default; AltReturnSpec(const AltReturnSpec &) = delete; AltReturnSpec &operator=(const AltReturnSpec &) = delete; AltReturnSpec() = delete; AltReturnSpec(Label &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Label v; };




struct ActualArg {
  struct PercentRef { PercentRef(PercentRef &&) = default; PercentRef &operator=(PercentRef &&) = default; PercentRef(const PercentRef &) = delete; PercentRef &operator=(const PercentRef &) = delete; PercentRef() = delete; PercentRef(Variable &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Variable v; };
  struct PercentVal { PercentVal(PercentVal &&) = default; PercentVal &operator=(PercentVal &&) = default; PercentVal(const PercentVal &) = delete; PercentVal &operator=(const PercentVal &) = delete; PercentVal() = delete; PercentVal(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };
  template <typename A, typename = common::NoLvalue<A>> ActualArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; ActualArg(ActualArg &&) = default; ActualArg &operator=(ActualArg &&) = default; ActualArg(const ActualArg &) = delete; ActualArg &operator=(const ActualArg &) = delete; ActualArg() = delete;
  ActualArg(Expr &&x) : u{common::Indirection<Expr>(std::move(x))} {}
  std::variant<common::Indirection<Expr>, AltReturnSpec, PercentRef, PercentVal>
      u;
};


struct ActualArgSpec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ActualArgSpec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ActualArgSpec(ActualArgSpec &&) = default; ActualArgSpec &operator=(ActualArgSpec &&) = default; ActualArgSpec(const ActualArgSpec &) = delete; ActualArgSpec &operator=(const ActualArgSpec &) = delete; ActualArgSpec() = delete;
  std::tuple<std::optional<Keyword>, ActualArg> t;
};



struct Call {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Call(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Call(Call &&) = default; Call &operator=(Call &&) = default; Call(const Call &) = delete; Call &operator=(const Call &) = delete; Call() = delete;
  std::tuple<ProcedureDesignator, std::list<ActualArgSpec>> t;
};

struct FunctionReference {
  FunctionReference(FunctionReference &&) = default; FunctionReference &operator=(FunctionReference &&) = default; FunctionReference(const FunctionReference &) = delete; FunctionReference &operator=(const FunctionReference &) = delete; FunctionReference() = delete; FunctionReference(Call &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Call v;
  CharBlock source;
  Designator ConvertToArrayElementRef();
  StructureConstructor ConvertToStructureConstructor(
      const semantics::DerivedTypeSpec &);
};

struct CallStmt {
  CallStmt(CallStmt &&) = default;
  CallStmt &operator=(CallStmt &&) = default;
  CallStmt(const CallStmt &) = delete;
  CallStmt &operator=(const CallStmt &) = delete;
  CallStmt() = delete;

  struct Chevrons {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Chevrons(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Chevrons(Chevrons &&) = default; Chevrons &operator=(Chevrons &&) = default; Chevrons(const Chevrons &) = delete; Chevrons &operator=(const Chevrons &) = delete; Chevrons() = delete;
    std::tuple<ScalarExpr,
               ScalarExpr,
               std::optional<ScalarIntExpr>,
               std::optional<ScalarIntExpr>>
        t;
  };

  explicit CallStmt(ProcedureDesignator &&pd, std::optional<Chevrons> &&ch,
      std::list<ActualArgSpec> &&args)
      : call{std::move(pd), std::move(args)}, chevrons{std::move(ch)} {}
  Call call;
  std::optional<Chevrons> chevrons;
  CharBlock source;
  mutable common::ForwardOwningPointer<evaluate::ProcedureRef>
      typedCall;
};




struct FunctionSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> FunctionSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; FunctionSubprogram(FunctionSubprogram &&) = default; FunctionSubprogram &operator=(FunctionSubprogram &&) = default; FunctionSubprogram(const FunctionSubprogram &) = delete; FunctionSubprogram &operator=(const FunctionSubprogram &) = delete; FunctionSubprogram() = delete;
  std::tuple<Statement<FunctionStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndFunctionStmt>>
      t;
};




struct SubroutineSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SubroutineSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SubroutineSubprogram(SubroutineSubprogram &&) = default; SubroutineSubprogram &operator=(SubroutineSubprogram &&) = default; SubroutineSubprogram(const SubroutineSubprogram &) = delete; SubroutineSubprogram &operator=(const SubroutineSubprogram &) = delete; SubroutineSubprogram() = delete;
  std::tuple<Statement<SubroutineStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndSubroutineStmt>>
      t;
};


struct MpSubprogramStmt { MpSubprogramStmt(MpSubprogramStmt &&) = default; MpSubprogramStmt &operator=(MpSubprogramStmt &&) = default; MpSubprogramStmt(const MpSubprogramStmt &) = delete; MpSubprogramStmt &operator=(const MpSubprogramStmt &) = delete; MpSubprogramStmt() = delete; MpSubprogramStmt(Name &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Name v; };


struct EndMpSubprogramStmt { EndMpSubprogramStmt(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt &operator=(EndMpSubprogramStmt &&) = default; EndMpSubprogramStmt(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt &operator=(const EndMpSubprogramStmt &) = delete; EndMpSubprogramStmt() = delete; EndMpSubprogramStmt(std::optional<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<Name> v; };




struct SeparateModuleSubprogram {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> SeparateModuleSubprogram(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; SeparateModuleSubprogram(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram &operator=(SeparateModuleSubprogram &&) = default; SeparateModuleSubprogram(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram &operator=(const SeparateModuleSubprogram &) = delete; SeparateModuleSubprogram() = delete;
  std::tuple<Statement<MpSubprogramStmt>, SpecificationPart, ExecutionPart,
      std::optional<InternalSubprogramPart>, Statement<EndMpSubprogramStmt>>
      t;
};


struct EntryStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> EntryStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; EntryStmt(EntryStmt &&) = default; EntryStmt &operator=(EntryStmt &&) = default; EntryStmt(const EntryStmt &) = delete; EntryStmt &operator=(const EntryStmt &) = delete; EntryStmt() = delete;
  std::tuple<Name, std::list<DummyArg>, std::optional<Suffix>> t;
};


struct ReturnStmt { ReturnStmt(ReturnStmt &&) = default; ReturnStmt &operator=(ReturnStmt &&) = default; ReturnStmt(const ReturnStmt &) = delete; ReturnStmt &operator=(const ReturnStmt &) = delete; ReturnStmt() = delete; ReturnStmt(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };



struct StmtFunctionStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StmtFunctionStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StmtFunctionStmt(StmtFunctionStmt &&) = default; StmtFunctionStmt &operator=(StmtFunctionStmt &&) = default; StmtFunctionStmt(const StmtFunctionStmt &) = delete; StmtFunctionStmt &operator=(const StmtFunctionStmt &) = delete; StmtFunctionStmt() = delete;
  std::tuple<Name, std::list<Name>, Scalar<Expr>> t;
  Statement<ActionStmt> ConvertToAssignment();
};





struct CompilerDirective {
  template <typename A, typename = common::NoLvalue<A>> CompilerDirective(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; CompilerDirective(CompilerDirective &&) = default; CompilerDirective &operator=(CompilerDirective &&) = default; CompilerDirective(const CompilerDirective &) = delete; CompilerDirective &operator=(const CompilerDirective &) = delete; CompilerDirective() = delete;
  struct IgnoreTKR {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> IgnoreTKR(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; IgnoreTKR(IgnoreTKR &&) = default; IgnoreTKR &operator=(IgnoreTKR &&) = default; IgnoreTKR(const IgnoreTKR &) = delete; IgnoreTKR &operator=(const IgnoreTKR &) = delete; IgnoreTKR() = delete;
    std::tuple<std::optional<std::list<const char *>>, Name> t;
  };
  struct LoopCount {
    LoopCount(LoopCount &&) = default; LoopCount &operator=(LoopCount &&) = default; LoopCount(const LoopCount &) = delete; LoopCount &operator=(const LoopCount &) = delete; LoopCount() = delete; LoopCount(std::list<std::uint64_t> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<std::uint64_t> v;
  };
  struct NameValue {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> NameValue(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; NameValue(NameValue &&) = default; NameValue &operator=(NameValue &&) = default; NameValue(const NameValue &) = delete; NameValue &operator=(const NameValue &) = delete; NameValue() = delete;
    std::tuple<Name, std::optional<std::uint64_t>> t;
  };
  CharBlock source;
  std::variant<std::list<IgnoreTKR>, LoopCount, std::list<NameValue>> u;
};


struct CUDAAttributesStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUDAAttributesStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUDAAttributesStmt(CUDAAttributesStmt &&) = default; CUDAAttributesStmt &operator=(CUDAAttributesStmt &&) = default; CUDAAttributesStmt(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt &operator=(const CUDAAttributesStmt &) = delete; CUDAAttributesStmt() = delete;
  std::tuple<common::CUDADataAttr, std::list<Name>> t;
};


struct BasedPointer {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> BasedPointer(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; BasedPointer(BasedPointer &&) = default; BasedPointer &operator=(BasedPointer &&) = default; BasedPointer(const BasedPointer &) = delete; BasedPointer &operator=(const BasedPointer &) = delete; BasedPointer() = delete;
  std::tuple<ObjectName, ObjectName, std::optional<ArraySpec>> t;
};
struct BasedPointerStmt { BasedPointerStmt(BasedPointerStmt &&) = default; BasedPointerStmt &operator=(BasedPointerStmt &&) = default; BasedPointerStmt(const BasedPointerStmt &) = delete; BasedPointerStmt &operator=(const BasedPointerStmt &) = delete; BasedPointerStmt() = delete; BasedPointerStmt(std::list<BasedPointer> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<BasedPointer> v; };

struct Union;
struct StructureDef;

struct StructureField {
  template <typename A, typename = common::NoLvalue<A>> StructureField(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; StructureField(StructureField &&) = default; StructureField &operator=(StructureField &&) = default; StructureField(const StructureField &) = delete; StructureField &operator=(const StructureField &) = delete; StructureField() = delete;
  std::variant<Statement<DataComponentDefStmt>,
      common::Indirection<StructureDef>, common::Indirection<Union>>
      u;
};

struct Map {
  struct MapStmt { MapStmt() {} MapStmt(const MapStmt &) {} MapStmt(MapStmt &&) {} MapStmt &operator=(const MapStmt &) { return *this; }; MapStmt &operator=(MapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndMapStmt { EndMapStmt() {} EndMapStmt(const EndMapStmt &) {} EndMapStmt(EndMapStmt &&) {} EndMapStmt &operator=(const EndMapStmt &) { return *this; }; EndMapStmt &operator=(EndMapStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Map(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete;
  std::tuple<Statement<MapStmt>, std::list<StructureField>,
      Statement<EndMapStmt>>
      t;
};

struct Union {
  struct UnionStmt { UnionStmt() {} UnionStmt(const UnionStmt &) {} UnionStmt(UnionStmt &&) {} UnionStmt &operator=(const UnionStmt &) { return *this; }; UnionStmt &operator=(UnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct EndUnionStmt { EndUnionStmt() {} EndUnionStmt(const EndUnionStmt &) {} EndUnionStmt(EndUnionStmt &&) {} EndUnionStmt &operator=(const EndUnionStmt &) { return *this; }; EndUnionStmt &operator=(EndUnionStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> Union(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Union(Union &&) = default; Union &operator=(Union &&) = default; Union(const Union &) = delete; Union &operator=(const Union &) = delete; Union() = delete;
  std::tuple<Statement<UnionStmt>, std::list<Map>, Statement<EndUnionStmt>> t;
};

struct StructureStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureStmt(StructureStmt &&) = default; StructureStmt &operator=(StructureStmt &&) = default; StructureStmt(const StructureStmt &) = delete; StructureStmt &operator=(const StructureStmt &) = delete; StructureStmt() = delete;
  std::tuple<std::optional<Name>, std::list<EntityDecl>> t;
};

struct StructureDef {
  struct EndStructureStmt { EndStructureStmt() {} EndStructureStmt(const EndStructureStmt &) {} EndStructureStmt(EndStructureStmt &&) {} EndStructureStmt &operator=(const EndStructureStmt &) { return *this; }; EndStructureStmt &operator=(EndStructureStmt &&) { return *this; }; using EmptyTrait = std::true_type; };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> StructureDef(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; StructureDef(StructureDef &&) = default; StructureDef &operator=(StructureDef &&) = default; StructureDef(const StructureDef &) = delete; StructureDef &operator=(const StructureDef &) = delete; StructureDef() = delete;
  std::tuple<Statement<StructureStmt>, std::list<StructureField>,
      Statement<EndStructureStmt>>
      t;
};



struct OldParameterStmt { OldParameterStmt(OldParameterStmt &&) = default; OldParameterStmt &operator=(OldParameterStmt &&) = default; OldParameterStmt(const OldParameterStmt &) = delete; OldParameterStmt &operator=(const OldParameterStmt &) = delete; OldParameterStmt() = delete; OldParameterStmt(std::list<NamedConstantDef> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<NamedConstantDef> v; };


struct ArithmeticIfStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> ArithmeticIfStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ArithmeticIfStmt(ArithmeticIfStmt &&) = default; ArithmeticIfStmt &operator=(ArithmeticIfStmt &&) = default; ArithmeticIfStmt(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt &operator=(const ArithmeticIfStmt &) = delete; ArithmeticIfStmt() = delete;
  std::tuple<Expr, Label, Label, Label> t;
};

struct AssignStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignStmt(AssignStmt &&) = default; AssignStmt &operator=(AssignStmt &&) = default; AssignStmt(const AssignStmt &) = delete; AssignStmt &operator=(const AssignStmt &) = delete; AssignStmt() = delete;
  std::tuple<Label, Name> t;
};

struct AssignedGotoStmt {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AssignedGotoStmt(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AssignedGotoStmt(AssignedGotoStmt &&) = default; AssignedGotoStmt &operator=(AssignedGotoStmt &&) = default; AssignedGotoStmt(const AssignedGotoStmt &) = delete; AssignedGotoStmt &operator=(const AssignedGotoStmt &) = delete; AssignedGotoStmt() = delete;
  std::tuple<Name, std::list<Label>> t;
};

struct PauseStmt { PauseStmt(PauseStmt &&) = default; PauseStmt &operator=(PauseStmt &&) = default; PauseStmt(const PauseStmt &) = delete; PauseStmt &operator=(const PauseStmt &) = delete; PauseStmt() = delete; PauseStmt(std::optional<StopCode> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<StopCode> v; };




struct OmpProcBindClause {
  enum class Type { Close, Master, Spread, Primary }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Close, Master, Spread, Primary")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Close, Master, Spread, Primary")}; return names[static_cast<std::size_t>(e)]; }
  OmpProcBindClause(OmpProcBindClause &&) = default; OmpProcBindClause &operator=(OmpProcBindClause &&) = default; OmpProcBindClause(const OmpProcBindClause &) = delete; OmpProcBindClause &operator=(const OmpProcBindClause &) = delete; OmpProcBindClause() = delete; OmpProcBindClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};


struct OmpDefaultClause {
  enum class Type { Private, Firstprivate, Shared, None }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Private, Firstprivate, Shared, None")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Private, Firstprivate, Shared, None")}; return names[static_cast<std::size_t>(e)]; }
  OmpDefaultClause(OmpDefaultClause &&) = default; OmpDefaultClause &operator=(OmpDefaultClause &&) = default; OmpDefaultClause(const OmpDefaultClause &) = delete; OmpDefaultClause &operator=(const OmpDefaultClause &) = delete; OmpDefaultClause() = delete; OmpDefaultClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};





struct OmpObject {
  template <typename A, typename = common::NoLvalue<A>> OmpObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpObject(OmpObject &&) = default; OmpObject &operator=(OmpObject &&) = default; OmpObject(const OmpObject &) = delete; OmpObject &operator=(const OmpObject &) = delete; OmpObject() = delete;
  std::variant<Designator, Name> u;
};

struct OmpObjectList { OmpObjectList(OmpObjectList &&) = default; OmpObjectList &operator=(OmpObjectList &&) = default; OmpObjectList(const OmpObjectList &) = delete; OmpObjectList &operator=(const OmpObjectList &) = delete; OmpObjectList() = delete; OmpObjectList(std::list<OmpObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpObject> v; };


struct OmpMapType {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapType(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapType(OmpMapType &&) = default; OmpMapType &operator=(OmpMapType &&) = default; OmpMapType(const OmpMapType &) = delete; OmpMapType &operator=(const OmpMapType &) = delete; OmpMapType() = delete;
  struct Always { Always() {} Always(const Always &) {} Always(Always &&) {} Always &operator=(const Always &) { return *this; }; Always &operator=(Always &&) { return *this; }; using EmptyTrait = std::true_type; };
  enum class Type { To, From, Tofrom, Alloc, Release, Delete }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("To, From, Tofrom, Alloc, Release, Delete")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("To, From, Tofrom, Alloc, Release, Delete")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<Always>, Type> t;
};


struct OmpMapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpMapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpMapClause(OmpMapClause &&) = default; OmpMapClause &operator=(OmpMapClause &&) = default; OmpMapClause(const OmpMapClause &) = delete; OmpMapClause &operator=(const OmpMapClause &) = delete; OmpMapClause() = delete;
  std::tuple<std::optional<OmpMapType>, OmpObjectList> t;
};


struct OmpDefaultmapClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDefaultmapClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDefaultmapClause(OmpDefaultmapClause &&) = default; OmpDefaultmapClause &operator=(OmpDefaultmapClause &&) = default; OmpDefaultmapClause(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause &operator=(const OmpDefaultmapClause &) = delete; OmpDefaultmapClause() = delete;
  enum class ImplicitBehavior { Alloc, To, From, Tofrom, Firstprivate, None, Default }; [[maybe_unused]] static constexpr std::size_t ImplicitBehavior_enumSize{ ::Fortran::common::CountEnumNames("Alloc, To, From, Tofrom, Firstprivate, None, Default")}; [[maybe_unused]] static inline std::string_view EnumToString(ImplicitBehavior e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ImplicitBehavior_enumSize>("Alloc, To, From, Tofrom, Firstprivate, None, Default")}; return names[static_cast<std::size_t>(e)]; }

  enum class VariableCategory { Scalar, Aggregate, Allocatable, Pointer }; [[maybe_unused]] static constexpr std::size_t VariableCategory_enumSize{ ::Fortran::common::CountEnumNames("Scalar, Aggregate, Allocatable, Pointer")}; [[maybe_unused]] static inline std::string_view EnumToString(VariableCategory e) { static const constexpr auto names{ ::Fortran::common::EnumNames<VariableCategory_enumSize>("Scalar, Aggregate, Allocatable, Pointer")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<ImplicitBehavior, std::optional<VariableCategory>> t;
};


struct OmpScheduleModifierType {
  enum class ModType { Monotonic, Nonmonotonic, Simd }; [[maybe_unused]] static constexpr std::size_t ModType_enumSize{ ::Fortran::common::CountEnumNames("Monotonic, Nonmonotonic, Simd")}; [[maybe_unused]] static inline std::string_view EnumToString(ModType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ModType_enumSize>("Monotonic, Nonmonotonic, Simd")}; return names[static_cast<std::size_t>(e)]; }
  OmpScheduleModifierType(OmpScheduleModifierType &&) = default; OmpScheduleModifierType &operator=(OmpScheduleModifierType &&) = default; OmpScheduleModifierType(const OmpScheduleModifierType &) = delete; OmpScheduleModifierType &operator=(const OmpScheduleModifierType &) = delete; OmpScheduleModifierType() = delete; OmpScheduleModifierType(ModType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ModType v;
};

struct OmpScheduleModifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpScheduleModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpScheduleModifier(OmpScheduleModifier &&) = default; OmpScheduleModifier &operator=(OmpScheduleModifier &&) = default; OmpScheduleModifier(const OmpScheduleModifier &) = delete; OmpScheduleModifier &operator=(const OmpScheduleModifier &) = delete; OmpScheduleModifier() = delete;
  struct Modifier1 { Modifier1(Modifier1 &&) = default; Modifier1 &operator=(Modifier1 &&) = default; Modifier1(const Modifier1 &) = delete; Modifier1 &operator=(const Modifier1 &) = delete; Modifier1() = delete; Modifier1(OmpScheduleModifierType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleModifierType v; };
  struct Modifier2 { Modifier2(Modifier2 &&) = default; Modifier2 &operator=(Modifier2 &&) = default; Modifier2(const Modifier2 &) = delete; Modifier2 &operator=(const Modifier2 &) = delete; Modifier2() = delete; Modifier2(OmpScheduleModifierType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleModifierType v; };
  std::tuple<Modifier1, std::optional<Modifier2>> t;
};



struct OmpScheduleClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpScheduleClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpScheduleClause(OmpScheduleClause &&) = default; OmpScheduleClause &operator=(OmpScheduleClause &&) = default; OmpScheduleClause(const OmpScheduleClause &) = delete; OmpScheduleClause &operator=(const OmpScheduleClause &) = delete; OmpScheduleClause() = delete;
  enum class ScheduleType { Static, Dynamic, Guided, Auto, Runtime }; [[maybe_unused]] static constexpr std::size_t ScheduleType_enumSize{ ::Fortran::common::CountEnumNames("Static, Dynamic, Guided, Auto, Runtime")}; [[maybe_unused]] static inline std::string_view EnumToString(ScheduleType e) { static const constexpr auto names{ ::Fortran::common::EnumNames<ScheduleType_enumSize>("Static, Dynamic, Guided, Auto, Runtime")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<OmpScheduleModifier>, ScheduleType,
      std::optional<ScalarIntExpr>>
      t;
};


struct OmpDeviceClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDeviceClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDeviceClause(OmpDeviceClause &&) = default; OmpDeviceClause &operator=(OmpDeviceClause &&) = default; OmpDeviceClause(const OmpDeviceClause &) = delete; OmpDeviceClause &operator=(const OmpDeviceClause &) = delete; OmpDeviceClause() = delete;
  enum class DeviceModifier { Ancestor, Device_Num }; [[maybe_unused]] static constexpr std::size_t DeviceModifier_enumSize{ ::Fortran::common::CountEnumNames("Ancestor, Device_Num")}; [[maybe_unused]] static inline std::string_view EnumToString(DeviceModifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DeviceModifier_enumSize>("Ancestor, Device_Num")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<DeviceModifier>, ScalarIntExpr> t;
};


struct OmpDeviceTypeClause {
  enum class Type { Any, Host, Nohost }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Any, Host, Nohost")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Any, Host, Nohost")}; return names[static_cast<std::size_t>(e)]; }
  OmpDeviceTypeClause(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause &operator=(OmpDeviceTypeClause &&) = default; OmpDeviceTypeClause(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause &operator=(const OmpDeviceTypeClause &) = delete; OmpDeviceTypeClause() = delete; OmpDeviceTypeClause(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};


struct OmpIfClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpIfClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpIfClause(OmpIfClause &&) = default; OmpIfClause &operator=(OmpIfClause &&) = default; OmpIfClause(const OmpIfClause &) = delete; OmpIfClause &operator=(const OmpIfClause &) = delete; OmpIfClause() = delete;
  enum class DirectiveNameModifier { Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams }; [[maybe_unused]] static constexpr std::size_t DirectiveNameModifier_enumSize{ ::Fortran::common::CountEnumNames("Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams")}; [[maybe_unused]] static inline std::string_view EnumToString(DirectiveNameModifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<DirectiveNameModifier_enumSize>("Parallel, Simd, Target, TargetData, TargetEnterData, TargetExitData, TargetUpdate, Task, Taskloop, Teams")}; return names[static_cast<std::size_t>(e)]; }

  std::tuple<std::optional<DirectiveNameModifier>, ScalarLogicalExpr> t;
};


struct OmpAlignedClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAlignedClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAlignedClause(OmpAlignedClause &&) = default; OmpAlignedClause &operator=(OmpAlignedClause &&) = default; OmpAlignedClause(const OmpAlignedClause &) = delete; OmpAlignedClause &operator=(const OmpAlignedClause &) = delete; OmpAlignedClause() = delete;
  CharBlock source;
  std::tuple<OmpObjectList, std::optional<ScalarIntConstantExpr>> t;
};


struct OmpOrderModifier {
  template <typename A, typename = common::NoLvalue<A>> OmpOrderModifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpOrderModifier(OmpOrderModifier &&) = default; OmpOrderModifier &operator=(OmpOrderModifier &&) = default; OmpOrderModifier(const OmpOrderModifier &) = delete; OmpOrderModifier &operator=(const OmpOrderModifier &) = delete; OmpOrderModifier() = delete;
  enum class Kind { Reproducible, Unconstrained }; [[maybe_unused]] static constexpr std::size_t Kind_enumSize{ ::Fortran::common::CountEnumNames("Reproducible, Unconstrained")}; [[maybe_unused]] static inline std::string_view EnumToString(Kind e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Kind_enumSize>("Reproducible, Unconstrained")}; return names[static_cast<std::size_t>(e)]; }
  std::variant<Kind> u;
};

struct OmpOrderClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpOrderClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpOrderClause(OmpOrderClause &&) = default; OmpOrderClause &operator=(OmpOrderClause &&) = default; OmpOrderClause(const OmpOrderClause &) = delete; OmpOrderClause &operator=(const OmpOrderClause &) = delete; OmpOrderClause() = delete;
  enum class Type { Concurrent }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Concurrent")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Concurrent")}; return names[static_cast<std::size_t>(e)]; }
  std::tuple<std::optional<OmpOrderModifier>, Type> t;
};


struct OmpLinearModifier {
  enum class Type { Ref, Val, Uval }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Ref, Val, Uval")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Ref, Val, Uval")}; return names[static_cast<std::size_t>(e)]; }
  OmpLinearModifier(OmpLinearModifier &&) = default; OmpLinearModifier &operator=(OmpLinearModifier &&) = default; OmpLinearModifier(const OmpLinearModifier &) = delete; OmpLinearModifier &operator=(const OmpLinearModifier &) = delete; OmpLinearModifier() = delete; OmpLinearModifier(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};



struct OmpLinearClause {
  template <typename A, typename = common::NoLvalue<A>> OmpLinearClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpLinearClause(OmpLinearClause &&) = default; OmpLinearClause &operator=(OmpLinearClause &&) = default; OmpLinearClause(const OmpLinearClause &) = delete; OmpLinearClause &operator=(const OmpLinearClause &) = delete; OmpLinearClause() = delete;
  struct WithModifier {
    WithModifier(WithModifier &&) = default; WithModifier &operator=(WithModifier &&) = default; WithModifier(const WithModifier &) = delete; WithModifier &operator=(const WithModifier &) = delete; WithModifier() = delete;
    WithModifier(OmpLinearModifier &&m, std::list<Name> &&n,
        std::optional<ScalarIntConstantExpr> &&s)
        : modifier(std::move(m)), names(std::move(n)), step(std::move(s)) {}
    OmpLinearModifier modifier;
    std::list<Name> names;
    std::optional<ScalarIntConstantExpr> step;
  };
  struct WithoutModifier {
    WithoutModifier(WithoutModifier &&) = default; WithoutModifier &operator=(WithoutModifier &&) = default; WithoutModifier(const WithoutModifier &) = delete; WithoutModifier &operator=(const WithoutModifier &) = delete; WithoutModifier() = delete;
    WithoutModifier(
        std::list<Name> &&n, std::optional<ScalarIntConstantExpr> &&s)
        : names(std::move(n)), step(std::move(s)) {}
    std::list<Name> names;
    std::optional<ScalarIntConstantExpr> step;
  };
  std::variant<WithModifier, WithoutModifier> u;
};



struct OmpReductionOperator {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionOperator(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionOperator(OmpReductionOperator &&) = default; OmpReductionOperator &operator=(OmpReductionOperator &&) = default; OmpReductionOperator(const OmpReductionOperator &) = delete; OmpReductionOperator &operator=(const OmpReductionOperator &) = delete; OmpReductionOperator() = delete;
  std::variant<DefinedOperator, ProcedureDesignator> u;
};



struct OmpReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpReductionClause(OmpReductionClause &&) = default; OmpReductionClause &operator=(OmpReductionClause &&) = default; OmpReductionClause(const OmpReductionClause &) = delete; OmpReductionClause &operator=(const OmpReductionClause &) = delete; OmpReductionClause() = delete;
  std::tuple<OmpReductionOperator, OmpObjectList> t;
};



struct OmpInReductionClause {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpInReductionClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpInReductionClause(OmpInReductionClause &&) = default; OmpInReductionClause &operator=(OmpInReductionClause &&) = default; OmpInReductionClause(const OmpInReductionClause &) = delete; OmpInReductionClause &operator=(const OmpInReductionClause &) = delete; OmpInReductionClause() = delete;
  std::tuple<OmpReductionOperator, OmpObjectList> t;
};






struct OmpAllocateClause {
  struct AllocateModifier {
    struct Allocator { Allocator(Allocator &&) = default; Allocator &operator=(Allocator &&) = default; Allocator(const Allocator &) = delete; Allocator &operator=(const Allocator &) = delete; Allocator() = delete; Allocator(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
    struct Align { Align(Align &&) = default; Align &operator=(Align &&) = default; Align(const Align &) = delete; Align &operator=(const Align &) = delete; Align() = delete; Align(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
    struct ComplexModifier {
      template <typename... Ts, typename = common::NoLvalue<Ts...>> ComplexModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; ComplexModifier(ComplexModifier &&) = default; ComplexModifier &operator=(ComplexModifier &&) = default; ComplexModifier(const ComplexModifier &) = delete; ComplexModifier &operator=(const ComplexModifier &) = delete; ComplexModifier() = delete;
      std::tuple<Allocator, Align> t;
    };
    template <typename A, typename = common::NoLvalue<A>> AllocateModifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AllocateModifier(AllocateModifier &&) = default; AllocateModifier &operator=(AllocateModifier &&) = default; AllocateModifier(const AllocateModifier &) = delete; AllocateModifier &operator=(const AllocateModifier &) = delete; AllocateModifier() = delete;
    std::variant<Allocator, ComplexModifier, Align> u;
  };
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAllocateClause(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAllocateClause(OmpAllocateClause &&) = default; OmpAllocateClause &operator=(OmpAllocateClause &&) = default; OmpAllocateClause(const OmpAllocateClause &) = delete; OmpAllocateClause &operator=(const OmpAllocateClause &) = delete; OmpAllocateClause() = delete;
  std::tuple<std::optional<AllocateModifier>, OmpObjectList> t;
};


struct OmpDependSinkVecLength {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDependSinkVecLength(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDependSinkVecLength(OmpDependSinkVecLength &&) = default; OmpDependSinkVecLength &operator=(OmpDependSinkVecLength &&) = default; OmpDependSinkVecLength(const OmpDependSinkVecLength &) = delete; OmpDependSinkVecLength &operator=(const OmpDependSinkVecLength &) = delete; OmpDependSinkVecLength() = delete;
  std::tuple<DefinedOperator, ScalarIntConstantExpr> t;
};


struct OmpDependSinkVec {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpDependSinkVec(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpDependSinkVec(OmpDependSinkVec &&) = default; OmpDependSinkVec &operator=(OmpDependSinkVec &&) = default; OmpDependSinkVec(const OmpDependSinkVec &) = delete; OmpDependSinkVec &operator=(const OmpDependSinkVec &) = delete; OmpDependSinkVec() = delete;
  std::tuple<Name, std::optional<OmpDependSinkVecLength>> t;
};


struct OmpDependenceType {
  enum class Type { In, Out, Inout, Source, Sink }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("In, Out, Inout, Source, Sink")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("In, Out, Inout, Source, Sink")}; return names[static_cast<std::size_t>(e)]; }
  OmpDependenceType(OmpDependenceType &&) = default; OmpDependenceType &operator=(OmpDependenceType &&) = default; OmpDependenceType(const OmpDependenceType &) = delete; OmpDependenceType &operator=(const OmpDependenceType &) = delete; OmpDependenceType() = delete; OmpDependenceType(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
};



struct OmpDependClause {
  template <typename A, typename = common::NoLvalue<A>> OmpDependClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDependClause(OmpDependClause &&) = default; OmpDependClause &operator=(OmpDependClause &&) = default; OmpDependClause(const OmpDependClause &) = delete; OmpDependClause &operator=(const OmpDependClause &) = delete; OmpDependClause() = delete;
  struct Source { Source() {} Source(const Source &) {} Source(Source &&) {} Source &operator=(const Source &) { return *this; }; Source &operator=(Source &&) { return *this; }; using EmptyTrait = std::true_type; };
  struct Sink { Sink(Sink &&) = default; Sink &operator=(Sink &&) = default; Sink(const Sink &) = delete; Sink &operator=(const Sink &) = delete; Sink() = delete; Sink(std::list<OmpDependSinkVec> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpDependSinkVec> v; };
  struct InOut {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> InOut(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; InOut(InOut &&) = default; InOut &operator=(InOut &&) = default; InOut(const InOut &) = delete; InOut &operator=(const InOut &) = delete; InOut() = delete;
    std::tuple<OmpDependenceType, std::list<Designator>> t;
  };
  std::variant<Source, Sink, InOut> u;
};




struct OmpAtomicDefaultMemOrderClause {
  OmpAtomicDefaultMemOrderClause(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause &operator=(OmpAtomicDefaultMemOrderClause &&) = default; OmpAtomicDefaultMemOrderClause(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause &operator=(const OmpAtomicDefaultMemOrderClause &) = delete; OmpAtomicDefaultMemOrderClause() = delete; OmpAtomicDefaultMemOrderClause(common::OmpAtomicDefaultMemOrderType &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; common::OmpAtomicDefaultMemOrderType v;

};


struct OmpClause {
  template <typename A, typename = common::NoLvalue<A>> OmpClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpClause(OmpClause &&) = default; OmpClause &operator=(OmpClause &&) = default; OmpClause(const OmpClause &) = delete; OmpClause &operator=(const OmpClause &) = delete; OmpClause() = delete;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3624 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
struct AcqRel { AcqRel() {} AcqRel(const AcqRel &) {} AcqRel(AcqRel &&) {} AcqRel &operator=(const AcqRel &) { return *this; }; AcqRel &operator=(AcqRel &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Acquire { Acquire() {} Acquire(const Acquire &) {} Acquire(Acquire &&) {} Acquire &operator=(const Acquire &) { return *this; }; Acquire &operator=(Acquire &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AdjustArgs { AdjustArgs() {} AdjustArgs(const AdjustArgs &) {} AdjustArgs(AdjustArgs &&) {} AdjustArgs &operator=(const AdjustArgs &) { return *this; }; AdjustArgs &operator=(AdjustArgs &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Affinity { Affinity() {} Affinity(const Affinity &) {} Affinity(Affinity &&) {} Affinity &operator=(const Affinity &) { return *this; }; Affinity &operator=(Affinity &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Align { Align() {} Align(const Align &) {} Align(Align &&) {} Align &operator=(const Align &) { return *this; }; Align &operator=(Align &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Aligned { Aligned(Aligned &&) = default; Aligned &operator=(Aligned &&) = default; Aligned(const Aligned &) = delete; Aligned &operator=(const Aligned &) = delete; Aligned() = delete; Aligned(OmpAlignedClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAlignedClause v; };
struct Allocate { Allocate(Allocate &&) = default; Allocate &operator=(Allocate &&) = default; Allocate(const Allocate &) = delete; Allocate &operator=(const Allocate &) = delete; Allocate() = delete; Allocate(OmpAllocateClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAllocateClause v; };
struct Allocator { Allocator(Allocator &&) = default; Allocator &operator=(Allocator &&) = default; Allocator(const Allocator &) = delete; Allocator &operator=(const Allocator &) = delete; Allocator() = delete; Allocator(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct AppendArgs { AppendArgs() {} AppendArgs(const AppendArgs &) {} AppendArgs(AppendArgs &&) {} AppendArgs &operator=(const AppendArgs &) { return *this; }; AppendArgs &operator=(AppendArgs &&) { return *this; }; using EmptyTrait = std::true_type; };
struct At { At() {} At(const At &) {} At(At &&) {} At &operator=(const At &) { return *this; }; At &operator=(At &&) { return *this; }; using EmptyTrait = std::true_type; };
struct AtomicDefaultMemOrder { AtomicDefaultMemOrder(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder &operator=(AtomicDefaultMemOrder &&) = default; AtomicDefaultMemOrder(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder &operator=(const AtomicDefaultMemOrder &) = delete; AtomicDefaultMemOrder() = delete; AtomicDefaultMemOrder(OmpAtomicDefaultMemOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpAtomicDefaultMemOrderClause v; };
struct Bind { Bind() {} Bind(const Bind &) {} Bind(Bind &&) {} Bind &operator=(const Bind &) { return *this; }; Bind &operator=(Bind &&) { return *this; }; using EmptyTrait = std::true_type; };
struct CancellationConstructType { CancellationConstructType() {} CancellationConstructType(const CancellationConstructType &) {} CancellationConstructType(CancellationConstructType &&) {} CancellationConstructType &operator=(const CancellationConstructType &) { return *this; }; CancellationConstructType &operator=(CancellationConstructType &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Compare { Compare() {} Compare(const Compare &) {} Compare(Compare &&) {} Compare &operator=(const Compare &) { return *this; }; Compare &operator=(Compare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Copyprivate { Copyprivate(Copyprivate &&) = default; Copyprivate &operator=(Copyprivate &&) = default; Copyprivate(const Copyprivate &) = delete; Copyprivate &operator=(const Copyprivate &) = delete; Copyprivate() = delete; Copyprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(OmpDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultClause v; };
struct Defaultmap { Defaultmap(Defaultmap &&) = default; Defaultmap &operator=(Defaultmap &&) = default; Defaultmap(const Defaultmap &) = delete; Defaultmap &operator=(const Defaultmap &) = delete; Defaultmap() = delete; Defaultmap(OmpDefaultmapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDefaultmapClause v; };
struct Depend { Depend(Depend &&) = default; Depend &operator=(Depend &&) = default; Depend(const Depend &) = delete; Depend &operator=(const Depend &) = delete; Depend() = delete; Depend(OmpDependClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDependClause v; };
struct Depobj { Depobj() {} Depobj(const Depobj &) {} Depobj(Depobj &&) {} Depobj &operator=(const Depobj &) { return *this; }; Depobj &operator=(Depobj &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Destroy { Destroy() {} Destroy(const Destroy &) {} Destroy(Destroy &&) {} Destroy &operator=(const Destroy &) { return *this; }; Destroy &operator=(Destroy &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Detach { Detach() {} Detach(const Detach &) {} Detach(Detach &&) {} Detach &operator=(const Detach &) { return *this; }; Detach &operator=(Detach &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(OmpDeviceClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceClause v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(OmpDeviceTypeClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpDeviceTypeClause v; };
struct DistSchedule { DistSchedule(DistSchedule &&) = default; DistSchedule &operator=(DistSchedule &&) = default; DistSchedule(const DistSchedule &) = delete; DistSchedule &operator=(const DistSchedule &) = delete; DistSchedule() = delete; DistSchedule(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Doacross { Doacross() {} Doacross(const Doacross &) {} Doacross(Doacross &&) {} Doacross &operator=(const Doacross &) { return *this; }; Doacross &operator=(Doacross &&) { return *this; }; using EmptyTrait = std::true_type; };
struct DynamicAllocators { DynamicAllocators() {} DynamicAllocators(const DynamicAllocators &) {} DynamicAllocators(DynamicAllocators &&) {} DynamicAllocators &operator=(const DynamicAllocators &) { return *this; }; DynamicAllocators &operator=(DynamicAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Enter { Enter(Enter &&) = default; Enter &operator=(Enter &&) = default; Enter(const Enter &) = delete; Enter &operator=(const Enter &) = delete; Enter() = delete; Enter(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Exclusive { Exclusive() {} Exclusive(const Exclusive &) {} Exclusive(Exclusive &&) {} Exclusive &operator=(const Exclusive &) { return *this; }; Exclusive &operator=(Exclusive &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Fail { Fail() {} Fail(const Fail &) {} Fail(Fail &&) {} Fail &operator=(const Fail &) { return *this; }; Fail &operator=(Fail &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Filter { Filter(Filter &&) = default; Filter &operator=(Filter &&) = default; Filter(const Filter &) = delete; Filter &operator=(const Filter &) = delete; Filter() = delete; Filter(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Final { Final(Final &&) = default; Final &operator=(Final &&) = default; Final(const Final &) = delete; Final &operator=(const Final &) = delete; Final() = delete; Final(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Flush { Flush() {} Flush(const Flush &) {} Flush(Flush &&) {} Flush &operator=(const Flush &) { return *this; }; Flush &operator=(Flush &&) { return *this; }; using EmptyTrait = std::true_type; };
struct From { From(From &&) = default; From &operator=(From &&) = default; From(const From &) = delete; From &operator=(const From &) = delete; From() = delete; From(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Full { Full() {} Full(const Full &) {} Full(Full &&) {} Full &operator=(const Full &) { return *this; }; Full &operator=(Full &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Grainsize { Grainsize(Grainsize &&) = default; Grainsize &operator=(Grainsize &&) = default; Grainsize(const Grainsize &) = delete; Grainsize &operator=(const Grainsize &) = delete; Grainsize() = delete; Grainsize(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct HasDeviceAddr { HasDeviceAddr(HasDeviceAddr &&) = default; HasDeviceAddr &operator=(HasDeviceAddr &&) = default; HasDeviceAddr(const HasDeviceAddr &) = delete; HasDeviceAddr &operator=(const HasDeviceAddr &) = delete; HasDeviceAddr() = delete; HasDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Hint { Hint(Hint &&) = default; Hint &operator=(Hint &&) = default; Hint(const Hint &) = delete; Hint &operator=(const Hint &) = delete; Hint() = delete; Hint(ConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ConstantExpr v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(OmpIfClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpIfClause v; };
struct InReduction { InReduction(InReduction &&) = default; InReduction &operator=(InReduction &&) = default; InReduction(const InReduction &) = delete; InReduction &operator=(const InReduction &) = delete; InReduction() = delete; InReduction(OmpInReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpInReductionClause v; };
struct Inbranch { Inbranch() {} Inbranch(const Inbranch &) {} Inbranch(Inbranch &&) {} Inbranch &operator=(const Inbranch &) { return *this; }; Inbranch &operator=(Inbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Inclusive { Inclusive() {} Inclusive(const Inclusive &) {} Inclusive(Inclusive &&) {} Inclusive &operator=(const Inclusive &) { return *this; }; Inclusive &operator=(Inclusive &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Indirect { Indirect() {} Indirect(const Indirect &) {} Indirect(Indirect &&) {} Indirect &operator=(const Indirect &) { return *this; }; Indirect &operator=(Indirect &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Init { Init() {} Init(const Init &) {} Init(Init &&) {} Init &operator=(const Init &) { return *this; }; Init &operator=(Init &&) { return *this; }; using EmptyTrait = std::true_type; };
struct IsDevicePtr { IsDevicePtr(IsDevicePtr &&) = default; IsDevicePtr &operator=(IsDevicePtr &&) = default; IsDevicePtr(const IsDevicePtr &) = delete; IsDevicePtr &operator=(const IsDevicePtr &) = delete; IsDevicePtr() = delete; IsDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Lastprivate { Lastprivate(Lastprivate &&) = default; Lastprivate &operator=(Lastprivate &&) = default; Lastprivate(const Lastprivate &) = delete; Lastprivate &operator=(const Lastprivate &) = delete; Lastprivate() = delete; Lastprivate(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Linear { Linear(Linear &&) = default; Linear &operator=(Linear &&) = default; Linear(const Linear &) = delete; Linear &operator=(const Linear &) = delete; Linear() = delete; Linear(OmpLinearClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpLinearClause v; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Map { Map(Map &&) = default; Map &operator=(Map &&) = default; Map(const Map &) = delete; Map &operator=(const Map &) = delete; Map() = delete; Map(OmpMapClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpMapClause v; };
struct Match { Match() {} Match(const Match &) {} Match(Match &&) {} Match &operator=(const Match &) { return *this; }; Match &operator=(Match &&) { return *this; }; using EmptyTrait = std::true_type; };
struct MemoryOrder { MemoryOrder() {} MemoryOrder(const MemoryOrder &) {} MemoryOrder(MemoryOrder &&) {} MemoryOrder &operator=(const MemoryOrder &) { return *this; }; MemoryOrder &operator=(MemoryOrder &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Mergeable { Mergeable() {} Mergeable(const Mergeable &) {} Mergeable(Mergeable &&) {} Mergeable &operator=(const Mergeable &) { return *this; }; Mergeable &operator=(Mergeable &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Message { Message() {} Message(const Message &) {} Message(Message &&) {} Message &operator=(const Message &) { return *this; }; Message &operator=(Message &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nogroup { Nogroup() {} Nogroup(const Nogroup &) {} Nogroup(Nogroup &&) {} Nogroup &operator=(const Nogroup &) { return *this; }; Nogroup &operator=(Nogroup &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nowait { Nowait() {} Nowait(const Nowait &) {} Nowait(Nowait &&) {} Nowait &operator=(const Nowait &) { return *this; }; Nowait &operator=(Nowait &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Nocontext { Nocontext(Nocontext &&) = default; Nocontext &operator=(Nocontext &&) = default; Nocontext(const Nocontext &) = delete; Nocontext &operator=(const Nocontext &) = delete; Nocontext() = delete; Nocontext(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct Nontemporal { Nontemporal(Nontemporal &&) = default; Nontemporal &operator=(Nontemporal &&) = default; Nontemporal(const Nontemporal &) = delete; Nontemporal &operator=(const Nontemporal &) = delete; Nontemporal() = delete; Nontemporal(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Notinbranch { Notinbranch() {} Notinbranch(const Notinbranch &) {} Notinbranch(Notinbranch &&) {} Notinbranch &operator=(const Notinbranch &) { return *this; }; Notinbranch &operator=(Notinbranch &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Novariants { Novariants(Novariants &&) = default; Novariants &operator=(Novariants &&) = default; Novariants(const Novariants &) = delete; Novariants &operator=(const Novariants &) = delete; Novariants() = delete; Novariants(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
struct NumTasks { NumTasks(NumTasks &&) = default; NumTasks &operator=(NumTasks &&) = default; NumTasks(const NumTasks &) = delete; NumTasks &operator=(const NumTasks &) = delete; NumTasks() = delete; NumTasks(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct NumTeams { NumTeams(NumTeams &&) = default; NumTeams &operator=(NumTeams &&) = default; NumTeams(const NumTeams &) = delete; NumTeams &operator=(const NumTeams &) = delete; NumTeams() = delete; NumTeams(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct NumThreads { NumThreads(NumThreads &&) = default; NumThreads &operator=(NumThreads &&) = default; NumThreads(const NumThreads &) = delete; NumThreads &operator=(const NumThreads &) = delete; NumThreads() = delete; NumThreads(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct OmpxAttribute { OmpxAttribute() {} OmpxAttribute(const OmpxAttribute &) {} OmpxAttribute(OmpxAttribute &&) {} OmpxAttribute &operator=(const OmpxAttribute &) { return *this; }; OmpxAttribute &operator=(OmpxAttribute &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OmpxDynCgroupMem { OmpxDynCgroupMem(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem &operator=(OmpxDynCgroupMem &&) = default; OmpxDynCgroupMem(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem &operator=(const OmpxDynCgroupMem &) = delete; OmpxDynCgroupMem() = delete; OmpxDynCgroupMem(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct OmpxBare { OmpxBare() {} OmpxBare(const OmpxBare &) {} OmpxBare(OmpxBare &&) {} OmpxBare &operator=(const OmpxBare &) { return *this; }; OmpxBare &operator=(OmpxBare &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Order { Order(Order &&) = default; Order &operator=(Order &&) = default; Order(const Order &) = delete; Order &operator=(const Order &) = delete; Order() = delete; Order(OmpOrderClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpOrderClause v; };
struct Ordered { Ordered(Ordered &&) = default; Ordered &operator=(Ordered &&) = default; Ordered(const Ordered &) = delete; Ordered &operator=(const Ordered &) = delete; Ordered() = delete; Ordered(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Partial { Partial(Partial &&) = default; Partial &operator=(Partial &&) = default; Partial(const Partial &) = delete; Partial &operator=(const Partial &) = delete; Partial() = delete; Partial(std::optional<ScalarIntConstantExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntConstantExpr> v; };
struct Priority { Priority(Priority &&) = default; Priority &operator=(Priority &&) = default; Priority(const Priority &) = delete; Priority &operator=(const Priority &) = delete; Priority() = delete; Priority(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct ProcBind { ProcBind(ProcBind &&) = default; ProcBind &operator=(ProcBind &&) = default; ProcBind(const ProcBind &) = delete; ProcBind &operator=(const ProcBind &) = delete; ProcBind() = delete; ProcBind(OmpProcBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpProcBindClause v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(OmpReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpReductionClause v; };
struct Relaxed { Relaxed() {} Relaxed(const Relaxed &) {} Relaxed(Relaxed &&) {} Relaxed &operator=(const Relaxed &) { return *this; }; Relaxed &operator=(Relaxed &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Release { Release() {} Release(const Release &) {} Release(Release &&) {} Release &operator=(const Release &) { return *this; }; Release &operator=(Release &&) { return *this; }; using EmptyTrait = std::true_type; };
struct ReverseOffload { ReverseOffload() {} ReverseOffload(const ReverseOffload &) {} ReverseOffload(ReverseOffload &&) {} ReverseOffload &operator=(const ReverseOffload &) { return *this; }; ReverseOffload &operator=(ReverseOffload &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Safelen { Safelen(Safelen &&) = default; Safelen &operator=(Safelen &&) = default; Safelen(const Safelen &) = delete; Safelen &operator=(const Safelen &) = delete; Safelen() = delete; Safelen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Schedule { Schedule(Schedule &&) = default; Schedule &operator=(Schedule &&) = default; Schedule(const Schedule &) = delete; Schedule &operator=(const Schedule &) = delete; Schedule() = delete; Schedule(OmpScheduleClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpScheduleClause v; };
struct SeqCst { SeqCst() {} SeqCst(const SeqCst &) {} SeqCst(SeqCst &&) {} SeqCst &operator=(const SeqCst &) { return *this; }; SeqCst &operator=(SeqCst &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Severity { Severity() {} Severity(const Severity &) {} Severity(Severity &&) {} Severity &operator=(const Severity &) { return *this; }; Severity &operator=(Severity &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Shared { Shared(Shared &&) = default; Shared &operator=(Shared &&) = default; Shared(const Shared &) = delete; Shared &operator=(const Shared &) = delete; Shared() = delete; Shared(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct Simd { Simd() {} Simd(const Simd &) {} Simd(Simd &&) {} Simd &operator=(const Simd &) { return *this; }; Simd &operator=(Simd &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Simdlen { Simdlen(Simdlen &&) = default; Simdlen &operator=(Simdlen &&) = default; Simdlen(const Simdlen &) = delete; Simdlen &operator=(const Simdlen &) = delete; Simdlen() = delete; Simdlen(ScalarIntConstantExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntConstantExpr v; };
struct Sizes { Sizes(Sizes &&) = default; Sizes &operator=(Sizes &&) = default; Sizes(const Sizes &) = delete; Sizes &operator=(const Sizes &) = delete; Sizes() = delete; Sizes(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct TaskReduction { TaskReduction(TaskReduction &&) = default; TaskReduction &operator=(TaskReduction &&) = default; TaskReduction(const TaskReduction &) = delete; TaskReduction &operator=(const TaskReduction &) = delete; TaskReduction() = delete; TaskReduction(OmpReductionClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpReductionClause v; };
struct ThreadLimit { ThreadLimit(ThreadLimit &&) = default; ThreadLimit &operator=(ThreadLimit &&) = default; ThreadLimit(const ThreadLimit &) = delete; ThreadLimit &operator=(const ThreadLimit &) = delete; ThreadLimit() = delete; ThreadLimit(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Threadprivate { Threadprivate() {} Threadprivate(const Threadprivate &) {} Threadprivate(Threadprivate &&) {} Threadprivate &operator=(const Threadprivate &) { return *this; }; Threadprivate &operator=(Threadprivate &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Threads { Threads() {} Threads(const Threads &) {} Threads(Threads &&) {} Threads &operator=(const Threads &) { return *this; }; Threads &operator=(Threads &&) { return *this; }; using EmptyTrait = std::true_type; };
struct To { To(To &&) = default; To &operator=(To &&) = default; To(const To &) = delete; To &operator=(const To &) = delete; To() = delete; To(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UnifiedAddress { UnifiedAddress() {} UnifiedAddress(const UnifiedAddress &) {} UnifiedAddress(UnifiedAddress &&) {} UnifiedAddress &operator=(const UnifiedAddress &) { return *this; }; UnifiedAddress &operator=(UnifiedAddress &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UnifiedSharedMemory { UnifiedSharedMemory() {} UnifiedSharedMemory(const UnifiedSharedMemory &) {} UnifiedSharedMemory(UnifiedSharedMemory &&) {} UnifiedSharedMemory &operator=(const UnifiedSharedMemory &) { return *this; }; UnifiedSharedMemory &operator=(UnifiedSharedMemory &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Uniform { Uniform(Uniform &&) = default; Uniform &operator=(Uniform &&) = default; Uniform(const Uniform &) = delete; Uniform &operator=(const Uniform &) = delete; Uniform() = delete; Uniform(std::list<Name> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<Name> v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Untied { Untied() {} Untied(const Untied &) {} Untied(Untied &&) {} Untied &operator=(const Untied &) { return *this; }; Untied &operator=(Untied &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Update { Update() {} Update(const Update &) {} Update(Update &&) {} Update &operator=(const Update &) { return *this; }; Update &operator=(Update &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Use { Use() {} Use(const Use &) {} Use(Use &&) {} Use &operator=(const Use &) { return *this; }; Use &operator=(Use &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UseDeviceAddr { UseDeviceAddr(UseDeviceAddr &&) = default; UseDeviceAddr &operator=(UseDeviceAddr &&) = default; UseDeviceAddr(const UseDeviceAddr &) = delete; UseDeviceAddr &operator=(const UseDeviceAddr &) = delete; UseDeviceAddr() = delete; UseDeviceAddr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UseDevicePtr { UseDevicePtr(UseDevicePtr &&) = default; UseDevicePtr &operator=(UseDevicePtr &&) = default; UseDevicePtr(const UseDevicePtr &) = delete; UseDevicePtr &operator=(const UseDevicePtr &) = delete; UseDevicePtr() = delete; UseDevicePtr(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v; };
struct UsesAllocators { UsesAllocators() {} UsesAllocators(const UsesAllocators &) {} UsesAllocators(UsesAllocators &&) {} UsesAllocators &operator=(const UsesAllocators &) { return *this; }; UsesAllocators &operator=(UsesAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };
struct When { When() {} When(const When &) {} When(When &&) {} When &operator=(const When &) { return *this; }; When &operator=(When &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 3612 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc" 1
# 3734 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenMP/OMP.inc"
AcqRel
, Acquire
, AdjustArgs
, Affinity
, Align
, Aligned
, Allocate
, Allocator
, AppendArgs
, At
, AtomicDefaultMemOrder
, Bind
, CancellationConstructType
, Capture
, Collapse
, Compare
, Copyprivate
, Copyin
, Default
, Defaultmap
, Depend
, Depobj
, Destroy
, Detach
, Device
, DeviceType
, DistSchedule
, Doacross
, DynamicAllocators
, Enter
, Exclusive
, Fail
, Filter
, Final
, Firstprivate
, Flush
, From
, Full
, Grainsize
, HasDeviceAddr
, Hint
, If
, InReduction
, Inbranch
, Inclusive
, Indirect
, Init
, IsDevicePtr
, Lastprivate
, Linear
, Link
, Map
, Match
, MemoryOrder
, Mergeable
, Message
, Nogroup
, Nowait
, Nocontext
, Nontemporal
, Notinbranch
, Novariants
, NumTasks
, NumTeams
, NumThreads
, OmpxAttribute
, OmpxDynCgroupMem
, OmpxBare
, Order
, Ordered
, Partial
, Priority
, Private
, ProcBind
, Read
, Reduction
, Relaxed
, Release
, ReverseOffload
, Safelen
, Schedule
, SeqCst
, Severity
, Shared
, Simd
, Simdlen
, Sizes
, TaskReduction
, ThreadLimit
, Threadprivate
, Threads
, To
, UnifiedAddress
, UnifiedSharedMemory
, Uniform
, Unknown
, Untied
, Update
, Use
, UseDeviceAddr
, UseDevicePtr
, UsesAllocators
, When
, Write
# 3618 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct OmpClauseList {
  OmpClauseList(OmpClauseList &&) = default; OmpClauseList &operator=(OmpClauseList &&) = default; OmpClauseList(const OmpClauseList &) = delete; OmpClauseList &operator=(const OmpClauseList &) = delete; OmpClauseList() = delete; OmpClauseList(std::list<OmpClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpClause> v;
  CharBlock source;
};



struct OmpSectionsDirective {
  OmpSectionsDirective(OmpSectionsDirective &&) = default; OmpSectionsDirective &operator=(OmpSectionsDirective &&) = default; OmpSectionsDirective(const OmpSectionsDirective &) = delete; OmpSectionsDirective &operator=(const OmpSectionsDirective &) = delete; OmpSectionsDirective() = delete; OmpSectionsDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};

struct OmpBeginSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginSectionsDirective(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective &operator=(OmpBeginSectionsDirective &&) = default; OmpBeginSectionsDirective(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective &operator=(const OmpBeginSectionsDirective &) = delete; OmpBeginSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};
struct OmpEndSectionsDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndSectionsDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndSectionsDirective(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective &operator=(OmpEndSectionsDirective &&) = default; OmpEndSectionsDirective(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective &operator=(const OmpEndSectionsDirective &) = delete; OmpEndSectionsDirective() = delete;
  std::tuple<OmpSectionsDirective, OmpClauseList> t;
  CharBlock source;
};






struct OpenMPSectionConstruct {
  OpenMPSectionConstruct(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct &operator=(OpenMPSectionConstruct &&) = default; OpenMPSectionConstruct(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct &operator=(const OpenMPSectionConstruct &) = delete; OpenMPSectionConstruct() = delete; OpenMPSectionConstruct(Block &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Block v;
  CharBlock source;
};




struct OmpSectionBlocks { OmpSectionBlocks(OmpSectionBlocks &&) = default; OmpSectionBlocks &operator=(OmpSectionBlocks &&) = default; OmpSectionBlocks(const OmpSectionBlocks &) = delete; OmpSectionBlocks &operator=(const OmpSectionBlocks &) = delete; OmpSectionBlocks() = delete; OmpSectionBlocks(std::list<OpenMPConstruct> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OpenMPConstruct> v; };

struct OpenMPSectionsConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSectionsConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSectionsConstruct(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct &operator=(OpenMPSectionsConstruct &&) = default; OpenMPSectionsConstruct(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct &operator=(const OpenMPSectionsConstruct &) = delete; OpenMPSectionsConstruct() = delete;
  std::tuple<OmpBeginSectionsDirective, OmpSectionBlocks,
      OmpEndSectionsDirective>
      t;
};


struct OmpBlockDirective {
  OmpBlockDirective(OmpBlockDirective &&) = default; OmpBlockDirective &operator=(OmpBlockDirective &&) = default; OmpBlockDirective(const OmpBlockDirective &) = delete; OmpBlockDirective &operator=(const OmpBlockDirective &) = delete; OmpBlockDirective() = delete; OmpBlockDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};




struct OmpDeclareTargetWithList {
  OmpDeclareTargetWithList(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList &operator=(OmpDeclareTargetWithList &&) = default; OmpDeclareTargetWithList(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList &operator=(const OmpDeclareTargetWithList &) = delete; OmpDeclareTargetWithList() = delete; OmpDeclareTargetWithList(OmpObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpObjectList v;
  CharBlock source;
};

struct OmpDeclareTargetWithClause {
  OmpDeclareTargetWithClause(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause &operator=(OmpDeclareTargetWithClause &&) = default; OmpDeclareTargetWithClause(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause &operator=(const OmpDeclareTargetWithClause &) = delete; OmpDeclareTargetWithClause() = delete; OmpDeclareTargetWithClause(OmpClauseList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpClauseList v;
  CharBlock source;
};

struct OmpDeclareTargetSpecifier {
  template <typename A, typename = common::NoLvalue<A>> OmpDeclareTargetSpecifier(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpDeclareTargetSpecifier(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier &operator=(OmpDeclareTargetSpecifier &&) = default; OmpDeclareTargetSpecifier(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier &operator=(const OmpDeclareTargetSpecifier &) = delete; OmpDeclareTargetSpecifier() = delete;
  std::variant<OmpDeclareTargetWithList, OmpDeclareTargetWithClause> u;
};

struct OpenMPDeclareTargetConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareTargetConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareTargetConstruct(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct &operator=(OpenMPDeclareTargetConstruct &&) = default; OpenMPDeclareTargetConstruct(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct &operator=(const OpenMPDeclareTargetConstruct &) = delete; OpenMPDeclareTargetConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpDeclareTargetSpecifier> t;
};



struct OmpReductionCombiner {
  template <typename A, typename = common::NoLvalue<A>> OmpReductionCombiner(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpReductionCombiner(OmpReductionCombiner &&) = default; OmpReductionCombiner &operator=(OmpReductionCombiner &&) = default; OmpReductionCombiner(const OmpReductionCombiner &) = delete; OmpReductionCombiner &operator=(const OmpReductionCombiner &) = delete; OmpReductionCombiner() = delete;
  struct FunctionCombiner { FunctionCombiner(FunctionCombiner &&) = default; FunctionCombiner &operator=(FunctionCombiner &&) = default; FunctionCombiner(const FunctionCombiner &) = delete; FunctionCombiner &operator=(const FunctionCombiner &) = delete; FunctionCombiner() = delete; FunctionCombiner(Call &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Call v; };
  std::variant<AssignmentStmt, FunctionCombiner> u;
};

struct OmpReductionInitializerClause { OmpReductionInitializerClause(OmpReductionInitializerClause &&) = default; OmpReductionInitializerClause &operator=(OmpReductionInitializerClause &&) = default; OmpReductionInitializerClause(const OmpReductionInitializerClause &) = delete; OmpReductionInitializerClause &operator=(const OmpReductionInitializerClause &) = delete; OmpReductionInitializerClause() = delete; OmpReductionInitializerClause(Expr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Expr v; };

struct OpenMPDeclareReductionConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareReductionConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareReductionConstruct(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct &operator=(OpenMPDeclareReductionConstruct &&) = default; OpenMPDeclareReductionConstruct(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct &operator=(const OpenMPDeclareReductionConstruct &) = delete; OpenMPDeclareReductionConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpReductionOperator, std::list<DeclarationTypeSpec>,
      OmpReductionCombiner, std::optional<OmpReductionInitializerClause>>
      t;
};



struct OpenMPDeclareSimdConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclareSimdConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclareSimdConstruct(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct &operator=(OpenMPDeclareSimdConstruct &&) = default; OpenMPDeclareSimdConstruct(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct &operator=(const OpenMPDeclareSimdConstruct &) = delete; OpenMPDeclareSimdConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};


struct OpenMPRequiresConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPRequiresConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPRequiresConstruct(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct &operator=(OpenMPRequiresConstruct &&) = default; OpenMPRequiresConstruct(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct &operator=(const OpenMPRequiresConstruct &) = delete; OpenMPRequiresConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList> t;
};


struct OpenMPThreadprivate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPThreadprivate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPThreadprivate(OpenMPThreadprivate &&) = default; OpenMPThreadprivate &operator=(OpenMPThreadprivate &&) = default; OpenMPThreadprivate(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate &operator=(const OpenMPThreadprivate &) = delete; OpenMPThreadprivate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList> t;
};


struct OpenMPDeclarativeAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPDeclarativeAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPDeclarativeAllocate(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate &operator=(OpenMPDeclarativeAllocate &&) = default; OpenMPDeclarativeAllocate(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate &operator=(const OpenMPDeclarativeAllocate &) = delete; OpenMPDeclarativeAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpObjectList, OmpClauseList> t;
};

struct OpenMPDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPDeclarativeConstruct(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct &operator=(OpenMPDeclarativeConstruct &&) = default; OpenMPDeclarativeConstruct(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct &operator=(const OpenMPDeclarativeConstruct &) = delete; OpenMPDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPDeclarativeAllocate, OpenMPDeclareReductionConstruct,
      OpenMPDeclareSimdConstruct, OpenMPDeclareTargetConstruct,
      OpenMPThreadprivate, OpenMPRequiresConstruct>
      u;
};


struct OmpCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpCriticalDirective(OmpCriticalDirective &&) = default; OmpCriticalDirective &operator=(OmpCriticalDirective &&) = default; OmpCriticalDirective(const OmpCriticalDirective &) = delete; OmpCriticalDirective &operator=(const OmpCriticalDirective &) = delete; OmpCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, OmpClauseList> t;
};
struct OmpEndCriticalDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndCriticalDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndCriticalDirective(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective &operator=(OmpEndCriticalDirective &&) = default; OmpEndCriticalDirective(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective &operator=(const OmpEndCriticalDirective &) = delete; OmpEndCriticalDirective() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>> t;
};
struct OpenMPCriticalConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCriticalConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCriticalConstruct(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct &operator=(OpenMPCriticalConstruct &&) = default; OpenMPCriticalConstruct(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct &operator=(const OpenMPCriticalConstruct &) = delete; OpenMPCriticalConstruct() = delete;
  std::tuple<OmpCriticalDirective, Block, OmpEndCriticalDirective> t;
};





struct OpenMPExecutableAllocate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPExecutableAllocate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPExecutableAllocate(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate &operator=(OpenMPExecutableAllocate &&) = default; OpenMPExecutableAllocate(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate &operator=(const OpenMPExecutableAllocate &) = delete; OpenMPExecutableAllocate() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<OmpObjectList>, OmpClauseList,
      std::optional<std::list<OpenMPDeclarativeAllocate>>,
      Statement<AllocateStmt>>
      t;
};

struct OmpEndAllocators { OmpEndAllocators() {} OmpEndAllocators(const OmpEndAllocators &) {} OmpEndAllocators(OmpEndAllocators &&) {} OmpEndAllocators &operator=(const OmpEndAllocators &) { return *this; }; OmpEndAllocators &operator=(OmpEndAllocators &&) { return *this; }; using EmptyTrait = std::true_type; };





struct OpenMPAllocatorsConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPAllocatorsConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPAllocatorsConstruct(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct &operator=(OpenMPAllocatorsConstruct &&) = default; OpenMPAllocatorsConstruct(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct &operator=(const OpenMPAllocatorsConstruct &) = delete; OpenMPAllocatorsConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpClauseList, Statement<AllocateStmt>,
      std::optional<OmpEndAllocators>>
      t;
};







struct OmpMemoryOrderClause {
  OmpMemoryOrderClause(OmpMemoryOrderClause &&) = default; OmpMemoryOrderClause &operator=(OmpMemoryOrderClause &&) = default; OmpMemoryOrderClause(const OmpMemoryOrderClause &) = delete; OmpMemoryOrderClause &operator=(const OmpMemoryOrderClause &) = delete; OmpMemoryOrderClause() = delete; OmpMemoryOrderClause(OmpClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; OmpClause v;
  CharBlock source;
};



struct OmpAtomicClause {
  template <typename A, typename = common::NoLvalue<A>> OmpAtomicClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OmpAtomicClause(OmpAtomicClause &&) = default; OmpAtomicClause &operator=(OmpAtomicClause &&) = default; OmpAtomicClause(const OmpAtomicClause &) = delete; OmpAtomicClause &operator=(const OmpAtomicClause &) = delete; OmpAtomicClause() = delete;
  CharBlock source;
  std::variant<OmpMemoryOrderClause, OmpClause> u;
};


struct OmpAtomicClauseList {
  OmpAtomicClauseList(OmpAtomicClauseList &&) = default; OmpAtomicClauseList &operator=(OmpAtomicClauseList &&) = default; OmpAtomicClauseList(const OmpAtomicClauseList &) = delete; OmpAtomicClauseList &operator=(const OmpAtomicClauseList &) = delete; OmpAtomicClauseList() = delete; OmpAtomicClauseList(std::list<OmpAtomicClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<OmpAtomicClause> v;
  CharBlock source;
};


struct OmpEndAtomic { OmpEndAtomic() {} OmpEndAtomic(const OmpEndAtomic &) {} OmpEndAtomic(OmpEndAtomic &&) {} OmpEndAtomic &operator=(const OmpEndAtomic &) { return *this; }; OmpEndAtomic &operator=(OmpEndAtomic &&) { return *this; }; using EmptyTrait = std::true_type; };


struct OmpAtomicRead {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicRead(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicRead(OmpAtomicRead &&) = default; OmpAtomicRead &operator=(OmpAtomicRead &&) = default; OmpAtomicRead(const OmpAtomicRead &) = delete; OmpAtomicRead &operator=(const OmpAtomicRead &) = delete; OmpAtomicRead() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};


struct OmpAtomicWrite {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicWrite(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicWrite(OmpAtomicWrite &&) = default; OmpAtomicWrite &operator=(OmpAtomicWrite &&) = default; OmpAtomicWrite(const OmpAtomicWrite &) = delete; OmpAtomicWrite &operator=(const OmpAtomicWrite &) = delete; OmpAtomicWrite() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};


struct OmpAtomicUpdate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicUpdate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicUpdate(OmpAtomicUpdate &&) = default; OmpAtomicUpdate &operator=(OmpAtomicUpdate &&) = default; OmpAtomicUpdate(const OmpAtomicUpdate &) = delete; OmpAtomicUpdate &operator=(const OmpAtomicUpdate &) = delete; OmpAtomicUpdate() = delete;
  CharBlock source;
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList,
      Statement<AssignmentStmt>, std::optional<OmpEndAtomic>>
      t;
};


struct OmpAtomicCapture {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomicCapture(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomicCapture(OmpAtomicCapture &&) = default; OmpAtomicCapture &operator=(OmpAtomicCapture &&) = default; OmpAtomicCapture(const OmpAtomicCapture &) = delete; OmpAtomicCapture &operator=(const OmpAtomicCapture &) = delete; OmpAtomicCapture() = delete;
  CharBlock source;
  struct Stmt1 { Stmt1(Stmt1 &&) = default; Stmt1 &operator=(Stmt1 &&) = default; Stmt1(const Stmt1 &) = delete; Stmt1 &operator=(const Stmt1 &) = delete; Stmt1() = delete; Stmt1(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  struct Stmt2 { Stmt2(Stmt2 &&) = default; Stmt2 &operator=(Stmt2 &&) = default; Stmt2(const Stmt2 &) = delete; Stmt2 &operator=(const Stmt2 &) = delete; Stmt2() = delete; Stmt2(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  std::tuple<OmpAtomicClauseList, Verbatim, OmpAtomicClauseList, Stmt1, Stmt2,
      OmpEndAtomic>
      t;
};


struct OmpAtomic {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpAtomic(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpAtomic(OmpAtomic &&) = default; OmpAtomic &operator=(OmpAtomic &&) = default; OmpAtomic(const OmpAtomic &) = delete; OmpAtomic &operator=(const OmpAtomic &) = delete; OmpAtomic() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpAtomicClauseList, Statement<AssignmentStmt>,
      std::optional<OmpEndAtomic>>
      t;
};





struct OpenMPAtomicConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPAtomicConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPAtomicConstruct(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct &operator=(OpenMPAtomicConstruct &&) = default; OpenMPAtomicConstruct(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct &operator=(const OpenMPAtomicConstruct &) = delete; OpenMPAtomicConstruct() = delete;
  std::variant<OmpAtomicRead, OmpAtomicWrite, OmpAtomicCapture, OmpAtomicUpdate,
      OmpAtomic>
      u;
};


struct OmpLoopDirective {
  OmpLoopDirective(OmpLoopDirective &&) = default; OmpLoopDirective &operator=(OmpLoopDirective &&) = default; OmpLoopDirective(const OmpLoopDirective &) = delete; OmpLoopDirective &operator=(const OmpLoopDirective &) = delete; OmpLoopDirective() = delete; OmpLoopDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};


struct OmpCancelType {
  enum class Type { Parallel, Sections, Do, Taskgroup }; [[maybe_unused]] static constexpr std::size_t Type_enumSize{ ::Fortran::common::CountEnumNames("Parallel, Sections, Do, Taskgroup")}; [[maybe_unused]] static inline std::string_view EnumToString(Type e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Type_enumSize>("Parallel, Sections, Do, Taskgroup")}; return names[static_cast<std::size_t>(e)]; }
  OmpCancelType(OmpCancelType &&) = default; OmpCancelType &operator=(OmpCancelType &&) = default; OmpCancelType(const OmpCancelType &) = delete; OmpCancelType &operator=(const OmpCancelType &) = delete; OmpCancelType() = delete; OmpCancelType(Type &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Type v;
  CharBlock source;
};


struct OpenMPCancellationPointConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCancellationPointConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCancellationPointConstruct(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct &operator=(OpenMPCancellationPointConstruct &&) = default; OpenMPCancellationPointConstruct(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct &operator=(const OpenMPCancellationPointConstruct &) = delete; OpenMPCancellationPointConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, OmpCancelType> t;
};


struct OpenMPCancelConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPCancelConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPCancelConstruct(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct &operator=(OpenMPCancelConstruct &&) = default; OpenMPCancelConstruct(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct &operator=(const OpenMPCancelConstruct &) = delete; OpenMPCancelConstruct() = delete;
  struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(ScalarLogicalExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarLogicalExpr v; };
  CharBlock source;
  std::tuple<Verbatim, OmpCancelType, std::optional<If>> t;
};


struct OpenMPFlushConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPFlushConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPFlushConstruct(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct &operator=(OpenMPFlushConstruct &&) = default; OpenMPFlushConstruct(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct &operator=(const OpenMPFlushConstruct &) = delete; OpenMPFlushConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<std::list<OmpMemoryOrderClause>>,
      std::optional<OmpObjectList>>
      t;
};

struct OmpSimpleStandaloneDirective {
  OmpSimpleStandaloneDirective(OmpSimpleStandaloneDirective &&) = default; OmpSimpleStandaloneDirective &operator=(OmpSimpleStandaloneDirective &&) = default; OmpSimpleStandaloneDirective(const OmpSimpleStandaloneDirective &) = delete; OmpSimpleStandaloneDirective &operator=(const OmpSimpleStandaloneDirective &) = delete; OmpSimpleStandaloneDirective() = delete; OmpSimpleStandaloneDirective(llvm::omp::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::omp::Directive v;
  CharBlock source;
};

struct OpenMPSimpleStandaloneConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPSimpleStandaloneConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPSimpleStandaloneConstruct(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct &operator=(OpenMPSimpleStandaloneConstruct &&) = default; OpenMPSimpleStandaloneConstruct(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct &operator=(const OpenMPSimpleStandaloneConstruct &) = delete; OpenMPSimpleStandaloneConstruct() = delete;
  CharBlock source;
  std::tuple<OmpSimpleStandaloneDirective, OmpClauseList> t;
};

struct OpenMPStandaloneConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPStandaloneConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPStandaloneConstruct(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct &operator=(OpenMPStandaloneConstruct &&) = default; OpenMPStandaloneConstruct(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct &operator=(const OpenMPStandaloneConstruct &) = delete; OpenMPStandaloneConstruct() = delete;
  CharBlock source;
  std::variant<OpenMPSimpleStandaloneConstruct, OpenMPFlushConstruct,
      OpenMPCancelConstruct, OpenMPCancellationPointConstruct>
      u;
};

struct OmpBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginLoopDirective(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective &operator=(OmpBeginLoopDirective &&) = default; OmpBeginLoopDirective(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective &operator=(const OmpBeginLoopDirective &) = delete; OmpBeginLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndLoopDirective(OmpEndLoopDirective &&) = default; OmpEndLoopDirective &operator=(OmpEndLoopDirective &&) = default; OmpEndLoopDirective(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective &operator=(const OmpEndLoopDirective &) = delete; OmpEndLoopDirective() = delete;
  std::tuple<OmpLoopDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpBeginBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpBeginBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpBeginBlockDirective(OmpBeginBlockDirective &&) = default; OmpBeginBlockDirective &operator=(OmpBeginBlockDirective &&) = default; OmpBeginBlockDirective(const OmpBeginBlockDirective &) = delete; OmpBeginBlockDirective &operator=(const OmpBeginBlockDirective &) = delete; OmpBeginBlockDirective() = delete;
  std::tuple<OmpBlockDirective, OmpClauseList> t;
  CharBlock source;
};

struct OmpEndBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OmpEndBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OmpEndBlockDirective(OmpEndBlockDirective &&) = default; OmpEndBlockDirective &operator=(OmpEndBlockDirective &&) = default; OmpEndBlockDirective(const OmpEndBlockDirective &) = delete; OmpEndBlockDirective &operator=(const OmpEndBlockDirective &) = delete; OmpEndBlockDirective() = delete;
  std::tuple<OmpBlockDirective, OmpClauseList> t;
  CharBlock source;
};

struct OpenMPBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPBlockConstruct(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct &operator=(OpenMPBlockConstruct &&) = default; OpenMPBlockConstruct(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct &operator=(const OpenMPBlockConstruct &) = delete; OpenMPBlockConstruct() = delete;
  std::tuple<OmpBeginBlockDirective, Block, OmpEndBlockDirective> t;
};


struct OpenMPLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenMPLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenMPLoopConstruct(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct &operator=(OpenMPLoopConstruct &&) = default; OpenMPLoopConstruct(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct &operator=(const OpenMPLoopConstruct &) = delete; OpenMPLoopConstruct() = delete;
  OpenMPLoopConstruct(OmpBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<OmpBeginLoopDirective, std::optional<DoConstruct>,
      std::optional<OmpEndLoopDirective>>
      t;
};

struct OpenMPConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenMPConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenMPConstruct(OpenMPConstruct &&) = default; OpenMPConstruct &operator=(OpenMPConstruct &&) = default; OpenMPConstruct(const OpenMPConstruct &) = delete; OpenMPConstruct &operator=(const OpenMPConstruct &) = delete; OpenMPConstruct() = delete;
  std::variant<OpenMPStandaloneConstruct, OpenMPSectionsConstruct,
      OpenMPSectionConstruct, OpenMPLoopConstruct, OpenMPBlockConstruct,
      OpenMPAtomicConstruct, OpenMPDeclarativeAllocate,
      OpenMPExecutableAllocate, OpenMPAllocatorsConstruct,
      OpenMPCriticalConstruct>
      u;
};



struct AccObject {
  template <typename A, typename = common::NoLvalue<A>> AccObject(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccObject(AccObject &&) = default; AccObject &operator=(AccObject &&) = default; AccObject(const AccObject &) = delete; AccObject &operator=(const AccObject &) = delete; AccObject() = delete;
  std::variant<Designator, Name> u;
};

struct AccObjectList { AccObjectList(AccObjectList &&) = default; AccObjectList &operator=(AccObjectList &&) = default; AccObjectList(const AccObjectList &) = delete; AccObjectList &operator=(const AccObjectList &) = delete; AccObjectList() = delete; AccObjectList(std::list<AccObject> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccObject> v; };


struct AccBlockDirective {
  AccBlockDirective(AccBlockDirective &&) = default; AccBlockDirective &operator=(AccBlockDirective &&) = default; AccBlockDirective(const AccBlockDirective &) = delete; AccBlockDirective &operator=(const AccBlockDirective &) = delete; AccBlockDirective() = delete; AccBlockDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccLoopDirective {
  AccLoopDirective(AccLoopDirective &&) = default; AccLoopDirective &operator=(AccLoopDirective &&) = default; AccLoopDirective(const AccLoopDirective &) = delete; AccLoopDirective &operator=(const AccLoopDirective &) = delete; AccLoopDirective() = delete; AccLoopDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccStandaloneDirective {
  AccStandaloneDirective(AccStandaloneDirective &&) = default; AccStandaloneDirective &operator=(AccStandaloneDirective &&) = default; AccStandaloneDirective(const AccStandaloneDirective &) = delete; AccStandaloneDirective &operator=(const AccStandaloneDirective &) = delete; AccStandaloneDirective() = delete; AccStandaloneDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccCombinedDirective {
  AccCombinedDirective(AccCombinedDirective &&) = default; AccCombinedDirective &operator=(AccCombinedDirective &&) = default; AccCombinedDirective(const AccCombinedDirective &) = delete; AccCombinedDirective &operator=(const AccCombinedDirective &) = delete; AccCombinedDirective() = delete; AccCombinedDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct AccDeclarativeDirective {
  AccDeclarativeDirective(AccDeclarativeDirective &&) = default; AccDeclarativeDirective &operator=(AccDeclarativeDirective &&) = default; AccDeclarativeDirective(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective &operator=(const AccDeclarativeDirective &) = delete; AccDeclarativeDirective() = delete; AccDeclarativeDirective(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};


struct AccBindClause {
  template <typename A, typename = common::NoLvalue<A>> AccBindClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccBindClause(AccBindClause &&) = default; AccBindClause &operator=(AccBindClause &&) = default; AccBindClause(const AccBindClause &) = delete; AccBindClause &operator=(const AccBindClause &) = delete; AccBindClause() = delete;
  std::variant<Name, ScalarDefaultCharExpr> u;
  CharBlock source;
};

struct AccDefaultClause {
  AccDefaultClause(AccDefaultClause &&) = default; AccDefaultClause &operator=(AccDefaultClause &&) = default; AccDefaultClause(const AccDefaultClause &) = delete; AccDefaultClause &operator=(const AccDefaultClause &) = delete; AccDefaultClause() = delete; AccDefaultClause(llvm::acc::DefaultValue &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::DefaultValue v;
  CharBlock source;
};

struct AccDataModifier {
  enum class Modifier { ReadOnly, Zero }; [[maybe_unused]] static constexpr std::size_t Modifier_enumSize{ ::Fortran::common::CountEnumNames("ReadOnly, Zero")}; [[maybe_unused]] static inline std::string_view EnumToString(Modifier e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Modifier_enumSize>("ReadOnly, Zero")}; return names[static_cast<std::size_t>(e)]; }
  AccDataModifier(AccDataModifier &&) = default; AccDataModifier &operator=(AccDataModifier &&) = default; AccDataModifier(const AccDataModifier &) = delete; AccDataModifier &operator=(const AccDataModifier &) = delete; AccDataModifier() = delete; AccDataModifier(Modifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Modifier v;
  CharBlock source;
};

struct AccObjectListWithModifier {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithModifier(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithModifier(AccObjectListWithModifier &&) = default; AccObjectListWithModifier &operator=(AccObjectListWithModifier &&) = default; AccObjectListWithModifier(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier &operator=(const AccObjectListWithModifier &) = delete; AccObjectListWithModifier() = delete;
  std::tuple<std::optional<AccDataModifier>, AccObjectList> t;
};


struct AccReductionOperator {
  enum class Operator { Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv }; [[maybe_unused]] static constexpr std::size_t Operator_enumSize{ ::Fortran::common::CountEnumNames("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; [[maybe_unused]] static inline std::string_view EnumToString(Operator e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Operator_enumSize>("Plus, Multiply, Max, Min, Iand, Ior, Ieor, And, Or, Eqv, Neqv")}; return names[static_cast<std::size_t>(e)]; }

  AccReductionOperator(AccReductionOperator &&) = default; AccReductionOperator &operator=(AccReductionOperator &&) = default; AccReductionOperator(const AccReductionOperator &) = delete; AccReductionOperator &operator=(const AccReductionOperator &) = delete; AccReductionOperator() = delete; AccReductionOperator(Operator &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Operator v;
  CharBlock source;
};

struct AccObjectListWithReduction {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccObjectListWithReduction(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccObjectListWithReduction(AccObjectListWithReduction &&) = default; AccObjectListWithReduction &operator=(AccObjectListWithReduction &&) = default; AccObjectListWithReduction(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction &operator=(const AccObjectListWithReduction &) = delete; AccObjectListWithReduction() = delete;
  std::tuple<AccReductionOperator, AccObjectList> t;
};

struct AccWaitArgument {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccWaitArgument(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccWaitArgument(AccWaitArgument &&) = default; AccWaitArgument &operator=(AccWaitArgument &&) = default; AccWaitArgument(const AccWaitArgument &) = delete; AccWaitArgument &operator=(const AccWaitArgument &) = delete; AccWaitArgument() = delete;
  std::tuple<std::optional<ScalarIntExpr>, std::list<ScalarIntExpr>> t;
};

struct AccDeviceTypeExpr {
  enum class Device { Star, Default, Nvidia, Radeon, Host, Multicore }; [[maybe_unused]] static constexpr std::size_t Device_enumSize{ ::Fortran::common::CountEnumNames("Star, Default, Nvidia, Radeon, Host, Multicore")}; [[maybe_unused]] static inline std::string_view EnumToString(Device e) { static const constexpr auto names{ ::Fortran::common::EnumNames<Device_enumSize>("Star, Default, Nvidia, Radeon, Host, Multicore")}; return names[static_cast<std::size_t>(e)]; }
  AccDeviceTypeExpr(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr &operator=(AccDeviceTypeExpr &&) = default; AccDeviceTypeExpr(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr &operator=(const AccDeviceTypeExpr &) = delete; AccDeviceTypeExpr() = delete; AccDeviceTypeExpr(Device &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Device v;
  CharBlock source;
};

struct AccDeviceTypeExprList {
  AccDeviceTypeExprList(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList &operator=(AccDeviceTypeExprList &&) = default; AccDeviceTypeExprList(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList &operator=(const AccDeviceTypeExprList &) = delete; AccDeviceTypeExprList() = delete; AccDeviceTypeExprList(std::list<AccDeviceTypeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccDeviceTypeExpr> v;

};

struct AccTileExpr {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccTileExpr(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccTileExpr(AccTileExpr &&) = default; AccTileExpr &operator=(AccTileExpr &&) = default; AccTileExpr(const AccTileExpr &) = delete; AccTileExpr &operator=(const AccTileExpr &) = delete; AccTileExpr() = delete;
  CharBlock source;
  std::tuple<std::optional<ScalarIntConstantExpr>> t;
};

struct AccTileExprList {
  AccTileExprList(AccTileExprList &&) = default; AccTileExprList &operator=(AccTileExprList &&) = default; AccTileExprList(const AccTileExprList &) = delete; AccTileExprList &operator=(const AccTileExprList &) = delete; AccTileExprList() = delete; AccTileExprList(std::list<AccTileExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccTileExpr> v;
};

struct AccSizeExpr {
  AccSizeExpr(AccSizeExpr &&) = default; AccSizeExpr &operator=(AccSizeExpr &&) = default; AccSizeExpr(const AccSizeExpr &) = delete; AccSizeExpr &operator=(const AccSizeExpr &) = delete; AccSizeExpr() = delete; AccSizeExpr(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v;
};

struct AccSizeExprList {
  AccSizeExprList(AccSizeExprList &&) = default; AccSizeExprList &operator=(AccSizeExprList &&) = default; AccSizeExprList(const AccSizeExprList &) = delete; AccSizeExprList &operator=(const AccSizeExprList &) = delete; AccSizeExprList() = delete; AccSizeExprList(std::list<AccSizeExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccSizeExpr> v;
};

struct AccSelfClause {
  template <typename A, typename = common::NoLvalue<A>> AccSelfClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccSelfClause(AccSelfClause &&) = default; AccSelfClause &operator=(AccSelfClause &&) = default; AccSelfClause(const AccSelfClause &) = delete; AccSelfClause &operator=(const AccSelfClause &) = delete; AccSelfClause() = delete;
  std::variant<std::optional<ScalarLogicalExpr>, AccObjectList> u;
  CharBlock source;
};


struct AccGangArg {
  template <typename A, typename = common::NoLvalue<A>> AccGangArg(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccGangArg(AccGangArg &&) = default; AccGangArg &operator=(AccGangArg &&) = default; AccGangArg(const AccGangArg &) = delete; AccGangArg &operator=(const AccGangArg &) = delete; AccGangArg() = delete;
  struct Num { Num(Num &&) = default; Num &operator=(Num &&) = default; Num(const Num &) = delete; Num &operator=(const Num &) = delete; Num() = delete; Num(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Dim { Dim(Dim &&) = default; Dim &operator=(Dim &&) = default; Dim(const Dim &) = delete; Dim &operator=(const Dim &) = delete; Dim() = delete; Dim(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
  struct Static { Static(Static &&) = default; Static &operator=(Static &&) = default; Static(const Static &) = delete; Static &operator=(const Static &) = delete; Static() = delete; Static(AccSizeExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccSizeExpr v; };
  std::variant<Num, Dim, Static> u;
  CharBlock source;
};

struct AccGangArgList {
  AccGangArgList(AccGangArgList &&) = default; AccGangArgList &operator=(AccGangArgList &&) = default; AccGangArgList(const AccGangArgList &) = delete; AccGangArgList &operator=(const AccGangArgList &) = delete; AccGangArgList() = delete; AccGangArgList(std::list<AccGangArg> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccGangArg> v;
};

struct AccCollapseArg {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccCollapseArg(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccCollapseArg(AccCollapseArg &&) = default; AccCollapseArg &operator=(AccCollapseArg &&) = default; AccCollapseArg(const AccCollapseArg &) = delete; AccCollapseArg &operator=(const AccCollapseArg &) = delete; AccCollapseArg() = delete;
  std::tuple<bool, ScalarIntConstantExpr> t;
};

struct AccClause {
  template <typename A, typename = common::NoLvalue<A>> AccClause(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; AccClause(AccClause &&) = default; AccClause &operator=(AccClause &&) = default; AccClause(const AccClause &) = delete; AccClause &operator=(const AccClause &) = delete; AccClause() = delete;


# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 697 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
struct Async { Async(Async &&) = default; Async &operator=(Async &&) = default; Async(const Async &) = delete; Async &operator=(const Async &) = delete; Async() = delete; Async(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Attach { Attach(Attach &&) = default; Attach &operator=(Attach &&) = default; Attach(const Attach &) = delete; Attach &operator=(const Attach &) = delete; Attach() = delete; Attach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Auto { Auto() {} Auto(const Auto &) {} Auto(Auto &&) {} Auto &operator=(const Auto &) { return *this; }; Auto &operator=(Auto &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Bind { Bind(Bind &&) = default; Bind &operator=(Bind &&) = default; Bind(const Bind &) = delete; Bind &operator=(const Bind &) = delete; Bind() = delete; Bind(AccBindClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBindClause v; };
struct Capture { Capture() {} Capture(const Capture &) {} Capture(Capture &&) {} Capture &operator=(const Capture &) { return *this; }; Capture &operator=(Capture &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Collapse { Collapse(Collapse &&) = default; Collapse &operator=(Collapse &&) = default; Collapse(const Collapse &) = delete; Collapse &operator=(const Collapse &) = delete; Collapse() = delete; Collapse(AccCollapseArg &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCollapseArg v; };
struct Copy { Copy(Copy &&) = default; Copy &operator=(Copy &&) = default; Copy(const Copy &) = delete; Copy &operator=(const Copy &) = delete; Copy() = delete; Copy(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Copyin { Copyin(Copyin &&) = default; Copyin &operator=(Copyin &&) = default; Copyin(const Copyin &) = delete; Copyin &operator=(const Copyin &) = delete; Copyin() = delete; Copyin(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Copyout { Copyout(Copyout &&) = default; Copyout &operator=(Copyout &&) = default; Copyout(const Copyout &) = delete; Copyout &operator=(const Copyout &) = delete; Copyout() = delete; Copyout(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Create { Create(Create &&) = default; Create &operator=(Create &&) = default; Create(const Create &) = delete; Create &operator=(const Create &) = delete; Create() = delete; Create(AccObjectListWithModifier &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithModifier v; };
struct Default { Default(Default &&) = default; Default &operator=(Default &&) = default; Default(const Default &) = delete; Default &operator=(const Default &) = delete; Default() = delete; Default(AccDefaultClause &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDefaultClause v; };
struct DefaultAsync { DefaultAsync(DefaultAsync &&) = default; DefaultAsync &operator=(DefaultAsync &&) = default; DefaultAsync(const DefaultAsync &) = delete; DefaultAsync &operator=(const DefaultAsync &) = delete; DefaultAsync() = delete; DefaultAsync(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Delete { Delete(Delete &&) = default; Delete &operator=(Delete &&) = default; Delete(const Delete &) = delete; Delete &operator=(const Delete &) = delete; Delete() = delete; Delete(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Detach { Detach(Detach &&) = default; Detach &operator=(Detach &&) = default; Detach(const Detach &) = delete; Detach &operator=(const Detach &) = delete; Detach() = delete; Detach(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Device { Device(Device &&) = default; Device &operator=(Device &&) = default; Device(const Device &) = delete; Device &operator=(const Device &) = delete; Device() = delete; Device(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceNum { DeviceNum(DeviceNum &&) = default; DeviceNum &operator=(DeviceNum &&) = default; DeviceNum(const DeviceNum &) = delete; DeviceNum &operator=(const DeviceNum &) = delete; DeviceNum() = delete; DeviceNum(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Deviceptr { Deviceptr(Deviceptr &&) = default; Deviceptr &operator=(Deviceptr &&) = default; Deviceptr(const Deviceptr &) = delete; Deviceptr &operator=(const Deviceptr &) = delete; Deviceptr() = delete; Deviceptr(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceResident { DeviceResident(DeviceResident &&) = default; DeviceResident &operator=(DeviceResident &&) = default; DeviceResident(const DeviceResident &) = delete; DeviceResident &operator=(const DeviceResident &) = delete; DeviceResident() = delete; DeviceResident(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct DeviceType { DeviceType(DeviceType &&) = default; DeviceType &operator=(DeviceType &&) = default; DeviceType(const DeviceType &) = delete; DeviceType &operator=(const DeviceType &) = delete; DeviceType() = delete; DeviceType(AccDeviceTypeExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccDeviceTypeExprList v; };
struct Finalize { Finalize() {} Finalize(const Finalize &) {} Finalize(Finalize &&) {} Finalize &operator=(const Finalize &) { return *this; }; Finalize &operator=(Finalize &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Firstprivate { Firstprivate(Firstprivate &&) = default; Firstprivate &operator=(Firstprivate &&) = default; Firstprivate(const Firstprivate &) = delete; Firstprivate &operator=(const Firstprivate &) = delete; Firstprivate() = delete; Firstprivate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Gang { Gang(Gang &&) = default; Gang &operator=(Gang &&) = default; Gang(const Gang &) = delete; Gang &operator=(const Gang &) = delete; Gang() = delete; Gang(std::optional<AccGangArgList> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccGangArgList> v; };
struct Host { Host(Host &&) = default; Host &operator=(Host &&) = default; Host(const Host &) = delete; Host &operator=(const Host &) = delete; Host() = delete; Host(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct If { If(If &&) = default; If &operator=(If &&) = default; If(const If &) = delete; If &operator=(const If &) = delete; If() = delete; If(ScalarExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarExpr v; };
struct IfPresent { IfPresent() {} IfPresent(const IfPresent &) {} IfPresent(IfPresent &&) {} IfPresent &operator=(const IfPresent &) { return *this; }; IfPresent &operator=(IfPresent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Independent { Independent() {} Independent(const Independent &) {} Independent(Independent &&) {} Independent &operator=(const Independent &) { return *this; }; Independent &operator=(Independent &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Link { Link(Link &&) = default; Link &operator=(Link &&) = default; Link(const Link &) = delete; Link &operator=(const Link &) = delete; Link() = delete; Link(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct NoCreate { NoCreate(NoCreate &&) = default; NoCreate &operator=(NoCreate &&) = default; NoCreate(const NoCreate &) = delete; NoCreate &operator=(const NoCreate &) = delete; NoCreate() = delete; NoCreate(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Nohost { Nohost() {} Nohost(const Nohost &) {} Nohost(Nohost &&) {} Nohost &operator=(const Nohost &) { return *this; }; Nohost &operator=(Nohost &&) { return *this; }; using EmptyTrait = std::true_type; };
struct NumGangs { NumGangs(NumGangs &&) = default; NumGangs &operator=(NumGangs &&) = default; NumGangs(const NumGangs &) = delete; NumGangs &operator=(const NumGangs &) = delete; NumGangs() = delete; NumGangs(std::list<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<ScalarIntExpr> v; };
struct NumWorkers { NumWorkers(NumWorkers &&) = default; NumWorkers &operator=(NumWorkers &&) = default; NumWorkers(const NumWorkers &) = delete; NumWorkers &operator=(const NumWorkers &) = delete; NumWorkers() = delete; NumWorkers(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Present { Present(Present &&) = default; Present &operator=(Present &&) = default; Present(const Present &) = delete; Present &operator=(const Present &) = delete; Present() = delete; Present(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Private { Private(Private &&) = default; Private &operator=(Private &&) = default; Private(const Private &) = delete; Private &operator=(const Private &) = delete; Private() = delete; Private(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Read { Read() {} Read(const Read &) {} Read(Read &&) {} Read &operator=(const Read &) { return *this; }; Read &operator=(Read &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Reduction { Reduction(Reduction &&) = default; Reduction &operator=(Reduction &&) = default; Reduction(const Reduction &) = delete; Reduction &operator=(const Reduction &) = delete; Reduction() = delete; Reduction(AccObjectListWithReduction &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectListWithReduction v; };
struct Self { Self(Self &&) = default; Self &operator=(Self &&) = default; Self(const Self &) = delete; Self &operator=(const Self &) = delete; Self() = delete; Self(std::optional<AccSelfClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccSelfClause> v; };
struct Seq { Seq() {} Seq(const Seq &) {} Seq(Seq &&) {} Seq &operator=(const Seq &) { return *this; }; Seq &operator=(Seq &&) { return *this; }; using EmptyTrait = std::true_type; };
struct Tile { Tile(Tile &&) = default; Tile &operator=(Tile &&) = default; Tile(const Tile &) = delete; Tile &operator=(const Tile &) = delete; Tile() = delete; Tile(AccTileExprList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccTileExprList v; };
struct Unknown { Unknown() {} Unknown(const Unknown &) {} Unknown(Unknown &&) {} Unknown &operator=(const Unknown &) { return *this; }; Unknown &operator=(Unknown &&) { return *this; }; using EmptyTrait = std::true_type; };
struct UseDevice { UseDevice(UseDevice &&) = default; UseDevice &operator=(UseDevice &&) = default; UseDevice(const UseDevice &) = delete; UseDevice &operator=(const UseDevice &) = delete; UseDevice() = delete; UseDevice(AccObjectList &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccObjectList v; };
struct Vector { Vector(Vector &&) = default; Vector &operator=(Vector &&) = default; Vector(const Vector &) = delete; Vector &operator=(const Vector &) = delete; Vector() = delete; Vector(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct VectorLength { VectorLength(VectorLength &&) = default; VectorLength &operator=(VectorLength &&) = default; VectorLength(const VectorLength &) = delete; VectorLength &operator=(const VectorLength &) = delete; VectorLength() = delete; VectorLength(ScalarIntExpr &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; ScalarIntExpr v; };
struct Wait { Wait(Wait &&) = default; Wait &operator=(Wait &&) = default; Wait(const Wait &) = delete; Wait &operator=(const Wait &) = delete; Wait() = delete; Wait(std::optional<AccWaitArgument> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<AccWaitArgument> v; };
struct Worker { Worker(Worker &&) = default; Worker &operator=(Worker &&) = default; Worker(const Worker &) = delete; Worker &operator=(const Worker &) = delete; Worker() = delete; Worker(std::optional<ScalarIntExpr> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::optional<ScalarIntExpr> v; };
struct Write { Write() {} Write(const Write &) {} Write(Write &&) {} Write &operator=(const Write &) { return *this; }; Write &operator=(Write &&) { return *this; }; using EmptyTrait = std::true_type; };
# 4123 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2

  CharBlock source;

  std::variant<

# 1 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc" 1
# 748 "/Users/rasmussen17/opt/llvm/llvm-release/include/llvm/Frontend/OpenACC/ACC.inc"
Async
, Attach
, Auto
, Bind
, Capture
, Collapse
, Copy
, Copyin
, Copyout
, Create
, Default
, DefaultAsync
, Delete
, Detach
, Device
, DeviceNum
, Deviceptr
, DeviceResident
, DeviceType
, Finalize
, Firstprivate
, Gang
, Host
, If
, IfPresent
, Independent
, Link
, NoCreate
, Nohost
, NumGangs
, NumWorkers
, Present
, Private
, Read
, Reduction
, Self
, Seq
, Tile
, Unknown
, UseDevice
, Vector
, VectorLength
, Wait
, Worker
, Write
# 4129 "/Users/rasmussen17/opt/llvm/llvm-release/include/flang/Parser/parse-tree.h" 2
 >
      u;
};

struct AccClauseList {
  AccClauseList(AccClauseList &&) = default; AccClauseList &operator=(AccClauseList &&) = default; AccClauseList(const AccClauseList &) = delete; AccClauseList &operator=(const AccClauseList &) = delete; AccClauseList() = delete; AccClauseList(std::list<AccClause> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; std::list<AccClause> v;
  CharBlock source;
};

struct OpenACCRoutineConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCRoutineConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCRoutineConstruct(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct &operator=(OpenACCRoutineConstruct &&) = default; OpenACCRoutineConstruct(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct &operator=(const OpenACCRoutineConstruct &) = delete; OpenACCRoutineConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<Name>, AccClauseList> t;
};

struct OpenACCCacheConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCacheConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCacheConstruct(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct &operator=(OpenACCCacheConstruct &&) = default; OpenACCCacheConstruct(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct &operator=(const OpenACCCacheConstruct &) = delete; OpenACCCacheConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, AccObjectListWithModifier> t;
};

struct OpenACCWaitConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCWaitConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCWaitConstruct(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct &operator=(OpenACCWaitConstruct &&) = default; OpenACCWaitConstruct(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct &operator=(const OpenACCWaitConstruct &) = delete; OpenACCWaitConstruct() = delete;
  CharBlock source;
  std::tuple<Verbatim, std::optional<AccWaitArgument>, AccClauseList> t;
};

struct AccBeginLoopDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginLoopDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginLoopDirective(AccBeginLoopDirective &&) = default; AccBeginLoopDirective &operator=(AccBeginLoopDirective &&) = default; AccBeginLoopDirective(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective &operator=(const AccBeginLoopDirective &) = delete; AccBeginLoopDirective() = delete;
  std::tuple<AccLoopDirective, AccClauseList> t;
  CharBlock source;
};

struct AccBeginBlockDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginBlockDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginBlockDirective(AccBeginBlockDirective &&) = default; AccBeginBlockDirective &operator=(AccBeginBlockDirective &&) = default; AccBeginBlockDirective(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective &operator=(const AccBeginBlockDirective &) = delete; AccBeginBlockDirective() = delete;
  CharBlock source;
  std::tuple<AccBlockDirective, AccClauseList> t;
};

struct AccEndBlockDirective {
  CharBlock source;
  AccEndBlockDirective(AccEndBlockDirective &&) = default; AccEndBlockDirective &operator=(AccEndBlockDirective &&) = default; AccEndBlockDirective(const AccEndBlockDirective &) = delete; AccEndBlockDirective &operator=(const AccEndBlockDirective &) = delete; AccEndBlockDirective() = delete; AccEndBlockDirective(AccBlockDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccBlockDirective v;
};


struct AccEndAtomic { AccEndAtomic() {} AccEndAtomic(const AccEndAtomic &) {} AccEndAtomic(AccEndAtomic &&) {} AccEndAtomic &operator=(const AccEndAtomic &) { return *this; }; AccEndAtomic &operator=(AccEndAtomic &&) { return *this; }; using EmptyTrait = std::true_type; };


struct AccAtomicRead {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicRead(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicRead(AccAtomicRead &&) = default; AccAtomicRead &operator=(AccAtomicRead &&) = default; AccAtomicRead(const AccAtomicRead &) = delete; AccAtomicRead &operator=(const AccAtomicRead &) = delete; AccAtomicRead() = delete;
  std::tuple<Verbatim, Statement<AssignmentStmt>, std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicWrite {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicWrite(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicWrite(AccAtomicWrite &&) = default; AccAtomicWrite &operator=(AccAtomicWrite &&) = default; AccAtomicWrite(const AccAtomicWrite &) = delete; AccAtomicWrite &operator=(const AccAtomicWrite &) = delete; AccAtomicWrite() = delete;
  std::tuple<Verbatim, Statement<AssignmentStmt>, std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicUpdate {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicUpdate(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicUpdate(AccAtomicUpdate &&) = default; AccAtomicUpdate &operator=(AccAtomicUpdate &&) = default; AccAtomicUpdate(const AccAtomicUpdate &) = delete; AccAtomicUpdate &operator=(const AccAtomicUpdate &) = delete; AccAtomicUpdate() = delete;
  std::tuple<std::optional<Verbatim>, Statement<AssignmentStmt>,
      std::optional<AccEndAtomic>>
      t;
};


struct AccAtomicCapture {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccAtomicCapture(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccAtomicCapture(AccAtomicCapture &&) = default; AccAtomicCapture &operator=(AccAtomicCapture &&) = default; AccAtomicCapture(const AccAtomicCapture &) = delete; AccAtomicCapture &operator=(const AccAtomicCapture &) = delete; AccAtomicCapture() = delete;
  struct Stmt1 { Stmt1(Stmt1 &&) = default; Stmt1 &operator=(Stmt1 &&) = default; Stmt1(const Stmt1 &) = delete; Stmt1 &operator=(const Stmt1 &) = delete; Stmt1() = delete; Stmt1(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  struct Stmt2 { Stmt2(Stmt2 &&) = default; Stmt2 &operator=(Stmt2 &&) = default; Stmt2(const Stmt2 &) = delete; Stmt2 &operator=(const Stmt2 &) = delete; Stmt2() = delete; Stmt2(Statement<AssignmentStmt> &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; Statement<AssignmentStmt> v; };
  std::tuple<Verbatim, Stmt1, Stmt2, AccEndAtomic> t;
};

struct OpenACCAtomicConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCAtomicConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCAtomicConstruct(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct &operator=(OpenACCAtomicConstruct &&) = default; OpenACCAtomicConstruct(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct &operator=(const OpenACCAtomicConstruct &) = delete; OpenACCAtomicConstruct() = delete;
  std::variant<AccAtomicRead, AccAtomicWrite, AccAtomicCapture, AccAtomicUpdate>
      u;
  CharBlock source;
};

struct OpenACCBlockConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCBlockConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCBlockConstruct(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct &operator=(OpenACCBlockConstruct &&) = default; OpenACCBlockConstruct(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct &operator=(const OpenACCBlockConstruct &) = delete; OpenACCBlockConstruct() = delete;
  std::tuple<AccBeginBlockDirective, Block, AccEndBlockDirective> t;
};

struct OpenACCStandaloneDeclarativeConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneDeclarativeConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneDeclarativeConstruct(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct &operator=(OpenACCStandaloneDeclarativeConstruct &&) = default; OpenACCStandaloneDeclarativeConstruct(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct &operator=(const OpenACCStandaloneDeclarativeConstruct &) = delete; OpenACCStandaloneDeclarativeConstruct() = delete;
  CharBlock source;
  std::tuple<AccDeclarativeDirective, AccClauseList> t;
};

struct AccBeginCombinedDirective {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> AccBeginCombinedDirective(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; AccBeginCombinedDirective(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective &operator=(AccBeginCombinedDirective &&) = default; AccBeginCombinedDirective(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective &operator=(const AccBeginCombinedDirective &) = delete; AccBeginCombinedDirective() = delete;
  CharBlock source;
  std::tuple<AccCombinedDirective, AccClauseList> t;
};

struct AccEndCombinedDirective {
  AccEndCombinedDirective(AccEndCombinedDirective &&) = default; AccEndCombinedDirective &operator=(AccEndCombinedDirective &&) = default; AccEndCombinedDirective(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective &operator=(const AccEndCombinedDirective &) = delete; AccEndCombinedDirective() = delete; AccEndCombinedDirective(AccCombinedDirective &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; AccCombinedDirective v;
  CharBlock source;
};

struct OpenACCCombinedConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCCombinedConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCCombinedConstruct(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct &operator=(OpenACCCombinedConstruct &&) = default; OpenACCCombinedConstruct(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct &operator=(const OpenACCCombinedConstruct &) = delete; OpenACCCombinedConstruct() = delete;
  CharBlock source;
  OpenACCCombinedConstruct(AccBeginCombinedDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginCombinedDirective, std::optional<DoConstruct>,
      std::optional<AccEndCombinedDirective>>
      t;
};

struct OpenACCDeclarativeConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCDeclarativeConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCDeclarativeConstruct(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct &operator=(OpenACCDeclarativeConstruct &&) = default; OpenACCDeclarativeConstruct(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct &operator=(const OpenACCDeclarativeConstruct &) = delete; OpenACCDeclarativeConstruct() = delete;
  CharBlock source;
  std::variant<OpenACCStandaloneDeclarativeConstruct, OpenACCRoutineConstruct>
      u;
};


struct AccEndLoop { AccEndLoop() {} AccEndLoop(const AccEndLoop &) {} AccEndLoop(AccEndLoop &&) {} AccEndLoop &operator=(const AccEndLoop &) { return *this; }; AccEndLoop &operator=(AccEndLoop &&) { return *this; }; using EmptyTrait = std::true_type; };
struct OpenACCLoopConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCLoopConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCLoopConstruct(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct &operator=(OpenACCLoopConstruct &&) = default; OpenACCLoopConstruct(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct &operator=(const OpenACCLoopConstruct &) = delete; OpenACCLoopConstruct() = delete;
  OpenACCLoopConstruct(AccBeginLoopDirective &&a)
      : t({std::move(a), std::nullopt, std::nullopt}) {}
  std::tuple<AccBeginLoopDirective, std::optional<DoConstruct>,
      std::optional<AccEndLoop>>
      t;
};

struct OpenACCEndConstruct {
  OpenACCEndConstruct(OpenACCEndConstruct &&) = default; OpenACCEndConstruct &operator=(OpenACCEndConstruct &&) = default; OpenACCEndConstruct(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct &operator=(const OpenACCEndConstruct &) = delete; OpenACCEndConstruct() = delete; OpenACCEndConstruct(llvm::acc::Directive &&x) : v(std::move(x)) {} using WrapperTrait = std::true_type; llvm::acc::Directive v;
  CharBlock source;
};

struct OpenACCStandaloneConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> OpenACCStandaloneConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; OpenACCStandaloneConstruct(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct &operator=(OpenACCStandaloneConstruct &&) = default; OpenACCStandaloneConstruct(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct &operator=(const OpenACCStandaloneConstruct &) = delete; OpenACCStandaloneConstruct() = delete;
  CharBlock source;
  std::tuple<AccStandaloneDirective, AccClauseList> t;
};

struct OpenACCConstruct {
  template <typename A, typename = common::NoLvalue<A>> OpenACCConstruct(A &&x) : u(std::move(x)) {} using UnionTrait = std::true_type; OpenACCConstruct(OpenACCConstruct &&) = default; OpenACCConstruct &operator=(OpenACCConstruct &&) = default; OpenACCConstruct(const OpenACCConstruct &) = delete; OpenACCConstruct &operator=(const OpenACCConstruct &) = delete; OpenACCConstruct() = delete;
  std::variant<OpenACCBlockConstruct, OpenACCCombinedConstruct,
      OpenACCLoopConstruct, OpenACCStandaloneConstruct, OpenACCCacheConstruct,
      OpenACCWaitConstruct, OpenACCAtomicConstruct, OpenACCEndConstruct>
      u;
};







struct CUFKernelDoConstruct {
  template <typename... Ts, typename = common::NoLvalue<Ts...>> CUFKernelDoConstruct(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; CUFKernelDoConstruct(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct &operator=(CUFKernelDoConstruct &&) = default; CUFKernelDoConstruct(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct &operator=(const CUFKernelDoConstruct &) = delete; CUFKernelDoConstruct() = delete;
  struct Directive {
    template <typename... Ts, typename = common::NoLvalue<Ts...>> Directive(Ts &&...args) : t(std::move(args)...) {} using TupleTrait = std::true_type; Directive(Directive &&) = default; Directive &operator=(Directive &&) = default; Directive(const Directive &) = delete; Directive &operator=(const Directive &) = delete; Directive() = delete;
    CharBlock source;
    std::tuple<std::optional<ScalarIntConstantExpr>, std::list<ScalarIntExpr>,
        std::list<ScalarIntExpr>, std::optional<ScalarIntExpr>>
        t;
  };
  std::tuple<Directive, std::optional<DoConstruct>> t;
};

}
