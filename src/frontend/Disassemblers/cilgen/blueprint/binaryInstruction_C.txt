// This part of the ROSETTA code has been generated from a JSON description file using json2rosetta.
//   Do not modify this file directly, but the corresponding JSON file.
// --- BEGIN generated code: ----------------------------------------------------


%%forall Class%%
    /*************************************************************************************************************************
     *                                          CIL %%Class.Name%% (%%Class.Section%%)
     *************************************************************************************************************************/

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    DECLARE_LEAF_CLASS(AsmCil%%Class.Name%%);
    IS_SERIALIZABLE(AsmCil%%Class.Name%%);

#ifdef DOCUMENTATION
    /** CIL %%Class.Name%% table.
     *
     */
    class SgAsmCil%%Class.Name%%: public Sg%%Class.Baseclass%% {
    public:
#endif

%%forall Fields%%
#ifdef DOCUMENTATION
        /** Property: %%Fields.Name%%.
         *
         *  %%Fields.Doc%%
         *
         * @{ */
        %%Fields.Type%% get_%%Fields.Name%%() const;
        void set_%%Fields.Name%%(%%Fields.Type%%);
        /** @} */
#else
        AsmCil%%Class.Name%%.setDataPrototype("%%Fields.Type%%", "%%Fields.Name%%", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif
%%end_for%%
%%forall Extras%%
#ifdef DOCUMENTATION
        /** Property: %%Extras.Name%%.
         *
         *  %%Extras.Doc%%
         *
         * @{ */
        %%Extras.Type%% get_%%Extras.Name%%() const;
        void set_%%Extras.Name%%(%%Extras.Type%%);
        /** @} */
#else
        AsmCil%%Class.Name%%.setDataPrototype("%%Extras.Type%%", "%%Extras.Name%%", "%%Extras.Init%%", NO_CONSTRUCTOR_PARAMETER,
                                              BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif
%%end_for%%


        DECLARE_OTHERS(AsmCil%%Class.Name%%);
#if defined(SgAsmCil%%Class.Name%%_OTHERS) || defined(DOCUMENTATION)

    public:
        void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
            %%forall Fields%%
            s & BOOST_SERIALIZATION_NVP(p_%%Fields.Name%%);
            %%end_for%%
        }
#endif


#endif // SgAsmCil%%Class.Name%%_OTHERS

#ifdef DOCUMENTATION
    protected:
      %%forall Fields%%
      %%Fields.Type%% p_%%Fields.Name%%;
      %%end_for%%
#endif

#ifdef DOCUMENTATION
    };
#endif
%%end_for%%

    /*************************************************************************************************************************
     *                                      Root of a branch of CIL IR classes
     *************************************************************************************************************************/

    NEW_NONTERMINAL_MACRO(AsmCilMetadata,
                          AsmCilAssembly        | AsmCilAssemblyOS           | AsmCilAssemblyProcessor | AsmCilAssemblyRef |
                          AsmCilAssemblyRefOS   | AsmCilAssemblyRefProcessor | AsmCilClassLayout       | AsmCilConstant |
                          AsmCilCustomAttribute | AsmCilDeclSecurity         | AsmCilEvent             | AsmCilEventMap |
                          AsmCilExportedType    | AsmCilField                | AsmCilFieldLayout       | AsmCilFieldMarshal |
                          AsmCilFieldRVA        | AsmCilFile                 | AsmCilGenericParam      | AsmCilGenericParamConstraint |
                          AsmCilImplMap         | AsmCilInterfaceImpl        | AsmCilManifestResource  | AsmCilMemberRef |
                          AsmCilMethodDef       | AsmCilMethodImpl           | AsmCilMethodSemantics   | AsmCilMethodSpec |
                          AsmCilModule          | AsmCilModuleRef            | AsmCilNestedClass       | AsmCilParam |
                          AsmCilProperty        | AsmCilPropertyMap          | AsmCilStandAloneSig     | AsmCilTypeDef |
                          AsmCilTypeRef         | AsmCilTypeSpec,
                          "AsmCilMetadata", "AsmCilMetadataTag", false);
    AsmCilMetadata.setCppCondition("!defined(DOCUMENTATION)");
    IS_SERIALIZABLE(AsmCilMetadata);

#ifdef DOCUMENTATION
    /** Base class for CIL branch of binary analysis IR nodes. */
    class SgAsmCilMetadata : public SgAsmCilNode {
    public:
#endif

        DECLARE_OTHERS(AsmCilMetadata);
#if defined(SgAsmCilMetadata_OTHERS) || defined(DOCUMENTATION)
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
        }
#endif

#endif // SgAsmCilMetadata_OTHERS

#ifdef DOCUMENTATION
    };
#endif

////// from metadataHeap_C.txt

    DECLARE_LEAF_CLASS(AsmCilMetadataHeap);
    IS_SERIALIZABLE(AsmCilMetadataHeap);

#ifdef DOCUMENTATION
    /** CIL AsmCilMetadataHeap.
     *
     */
    class SgAsmCilMetadataHeap: public SgAsmCilDataStream {
    public:
#endif



#ifdef DOCUMENTATION
        /** Property: 4 reserved bytes
         * @{ */
        uint32_t get_ReservedAlwaysZero() const;
        void set_ReservedAlwaysZero(uint32_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint32_t", "ReservedAlwaysZero", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 1-byte constant.
         * @{ */
        uint8_t get_MajorVersion() const;
        void set_MajorVersion(uint8_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint8_t", "MajorVersion", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 1-byte constant.
         * @{ */
        uint8_t get_MinorVersion() const;
        void set_MinorVersion(uint8_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint8_t", "MinorVersion", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 1-byte constant indicating the index sizes of streams.
         * @{ */
        uint8_t get_HeapSizes() const;
        void set_HeapSizes(uint8_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint8_t", "HeapSizes", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 1-byte constant.
         * @{ */
        uint8_t get_ReservedAlwaysOne() const;
        void set_ReservedAlwaysOne(uint8_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint8_t", "ReservedAlwaysOne", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 4-byte value indicating which metadata tables are present.
         * @{ */
        uint64_t get_Valid() const;
        void set_Valid(uint64_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint64_t", "Valid", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a 4-byte value.
         * @{ */
        uint64_t get_Sorted() const;
        void set_Sorted(uint64_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint64_t", "Sorted", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: a vector indicating how many rows the present tables contain.
         * @{ */
        std::vector<uint32_t> get_NumberOfRows() const;
        void set_NumberOfRows(std::vector<uint32_t>);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<uint32_t>", "NumberOfRows", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: precomputed flags that determine whether a metadata reference is stored as 2 or 4 byte value in the file.
         * @{ */
        uint64_t get_DataSizeFlags() const;
        void set_DataSizeFlags(uint64_t);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("uint64_t", "DataSizeFlags", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif





#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssembly*>", "assembly", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssemblyProcessor*>", "assemblyProcessor", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssemblyOS*>", "assemblyOS", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssemblyRef*>", "assemblyRef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssemblyRefProcessor*>", "assemblyRefProcessor", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilAssemblyRefOS*>", "assemblyRefOS", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilClassLayout*>", "classLayout", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilConstant*>", "constant", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilCustomAttribute*>", "customAttribute", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilDeclSecurity*>", "declSecurity", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilEventMap*>", "eventMap", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilEvent*>", "event", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilExportedType*>", "exportedType", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilField*>", "field", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilFieldLayout*>", "fieldLayout", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilFieldMarshal*>", "fieldMarshal", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilFieldRVA*>", "fieldRVA", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilFile*>", "file", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilGenericParam*>", "genericParam", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilGenericParamConstraint*>", "genericParamConstraint", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilImplMap*>", "implMap", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilInterfaceImpl*>", "interfaceImpl", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilManifestResource*>", "manifestResource", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilMemberRef*>", "memberRef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilMethodDef*>", "methodDef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilMethodImpl*>", "methodImpl", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilMethodSemantics*>", "methodSemantics", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilMethodSpec*>", "methodSpec", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilModule*>", "module", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilModuleRef*>", "moduleRef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilNestedClass*>", "nestedClass", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilParam*>", "param", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilProperty*>", "property", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilPropertyMap*>", "propertyMap", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilStandAloneSig*>", "standAloneSig", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilTypeDef*>", "typeDef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilTypeRef*>", "typeRef", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<SgAsmCilTypeSpec*>", "typeSpec", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif



        DECLARE_OTHERS(AsmCilMetadataHeap);
#if defined(SgAsmCilMetadataHeap_OTHERS) || defined(DOCUMENTATION)

    public:
        /// reference kinds in the metadata tables
        enum ReferenceKind
        {
          // heaps
          e_ref_string_heap           = 1 << 0,
          e_ref_guid_heap             = 1 << 1,
          e_ref_blob_heap             = 1 << 2,
          // single-table references
          e_ref_assembly_ref          = 1 << 3,
          e_ref_type_def              = 1 << 4,
          e_ref_event                 = 1 << 5,
          e_ref_field                 = 1 << 6,
          e_ref_generic_param         = 1 << 7,
          e_ref_module_ref            = 1 << 8,
          e_ref_method_def            = 1 << 9,
          e_ref_param                 = 1 << 10,
          e_ref_property              = 1 << 11,
          // multi-table references
          e_ref_has_constant          = 1 << 12,
          e_ref_has_custom_attribute  = 1 << 13,
          e_ref_has_decl_security     = 1 << 14,
          e_ref_has_field_marshall    = 1 << 15,
          e_ref_has_semantics         = 1 << 16,
          e_ref_method_def_or_ref     = 1 << 17,
          e_ref_type_def_or_ref       = 1 << 18,
          e_ref_implementation        = 1 << 19,
          e_ref_member_forwarded      = 1 << 20,
          e_ref_member_ref_parent     = 1 << 21,
          e_ref_type_or_method_def    = 1 << 22,
          // defined, but seemingly not used from inside the metadata tables
          e_ref_custom_attribute_type = 1 << 23,
          e_ref_resolution_scope      = 1 << 24,
        };

        SgAsmCilMetadataHeap() = default;

        /** parses the metadata objects from the buffer. */
        void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;

        /** looks up the node associated with the coded index @ref refcode in the metadata tables
         *  under the assumption that @refval is of kind @ref knd
         */
        SgAsmCilMetadata* get_MetadataNode(std::uint32_t refcode, ReferenceKind knd) const;

        /** metadata-tables accessor methods
         *  @{ */

              std::vector<SgAsmCilAssembly*>& get_assembly()       { return p_assembly; }
        const std::vector<SgAsmCilAssembly*>& get_assembly() const { return p_assembly; }
              std::vector<SgAsmCilAssemblyProcessor*>& get_assemblyProcessor()       { return p_assemblyProcessor; }
        const std::vector<SgAsmCilAssemblyProcessor*>& get_assemblyProcessor() const { return p_assemblyProcessor; }
              std::vector<SgAsmCilAssemblyOS*>& get_assemblyOS()       { return p_assemblyOS; }
        const std::vector<SgAsmCilAssemblyOS*>& get_assemblyOS() const { return p_assemblyOS; }
              std::vector<SgAsmCilAssemblyRef*>& get_assemblyRef()       { return p_assemblyRef; }
        const std::vector<SgAsmCilAssemblyRef*>& get_assemblyRef() const { return p_assemblyRef; }
              std::vector<SgAsmCilAssemblyRefProcessor*>& get_assemblyRefProcessor()       { return p_assemblyRefProcessor; }
        const std::vector<SgAsmCilAssemblyRefProcessor*>& get_assemblyRefProcessor() const { return p_assemblyRefProcessor; }
              std::vector<SgAsmCilAssemblyRefOS*>& get_assemblyRefOS()       { return p_assemblyRefOS; }
        const std::vector<SgAsmCilAssemblyRefOS*>& get_assemblyRefOS() const { return p_assemblyRefOS; }
              std::vector<SgAsmCilClassLayout*>& get_classLayout()       { return p_classLayout; }
        const std::vector<SgAsmCilClassLayout*>& get_classLayout() const { return p_classLayout; }
              std::vector<SgAsmCilConstant*>& get_constant()       { return p_constant; }
        const std::vector<SgAsmCilConstant*>& get_constant() const { return p_constant; }
              std::vector<SgAsmCilCustomAttribute*>& get_customAttribute()       { return p_customAttribute; }
        const std::vector<SgAsmCilCustomAttribute*>& get_customAttribute() const { return p_customAttribute; }
              std::vector<SgAsmCilDeclSecurity*>& get_declSecurity()       { return p_declSecurity; }
        const std::vector<SgAsmCilDeclSecurity*>& get_declSecurity() const { return p_declSecurity; }
              std::vector<SgAsmCilEventMap*>& get_eventMap()       { return p_eventMap; }
        const std::vector<SgAsmCilEventMap*>& get_eventMap() const { return p_eventMap; }
              std::vector<SgAsmCilEvent*>& get_event()       { return p_event; }
        const std::vector<SgAsmCilEvent*>& get_event() const { return p_event; }
              std::vector<SgAsmCilExportedType*>& get_exportedType()       { return p_exportedType; }
        const std::vector<SgAsmCilExportedType*>& get_exportedType() const { return p_exportedType; }
              std::vector<SgAsmCilField*>& get_field()       { return p_field; }
        const std::vector<SgAsmCilField*>& get_field() const { return p_field; }
              std::vector<SgAsmCilFieldLayout*>& get_fieldLayout()       { return p_fieldLayout; }
        const std::vector<SgAsmCilFieldLayout*>& get_fieldLayout() const { return p_fieldLayout; }
              std::vector<SgAsmCilFieldMarshal*>& get_fieldMarshal()       { return p_fieldMarshal; }
        const std::vector<SgAsmCilFieldMarshal*>& get_fieldMarshal() const { return p_fieldMarshal; }
              std::vector<SgAsmCilFieldRVA*>& get_fieldRVA()       { return p_fieldRVA; }
        const std::vector<SgAsmCilFieldRVA*>& get_fieldRVA() const { return p_fieldRVA; }
              std::vector<SgAsmCilFile*>& get_file()       { return p_file; }
        const std::vector<SgAsmCilFile*>& get_file() const { return p_file; }
              std::vector<SgAsmCilGenericParam*>& get_genericParam()       { return p_genericParam; }
        const std::vector<SgAsmCilGenericParam*>& get_genericParam() const { return p_genericParam; }
              std::vector<SgAsmCilGenericParamConstraint*>& get_genericParamConstraint()       { return p_genericParamConstraint; }
        const std::vector<SgAsmCilGenericParamConstraint*>& get_genericParamConstraint() const { return p_genericParamConstraint; }
              std::vector<SgAsmCilImplMap*>& get_implMap()       { return p_implMap; }
        const std::vector<SgAsmCilImplMap*>& get_implMap() const { return p_implMap; }
              std::vector<SgAsmCilInterfaceImpl*>& get_interfaceImpl()       { return p_interfaceImpl; }
        const std::vector<SgAsmCilInterfaceImpl*>& get_interfaceImpl() const { return p_interfaceImpl; }
              std::vector<SgAsmCilManifestResource*>& get_manifestResource()       { return p_manifestResource; }
        const std::vector<SgAsmCilManifestResource*>& get_manifestResource() const { return p_manifestResource; }
              std::vector<SgAsmCilMemberRef*>& get_memberRef()       { return p_memberRef; }
        const std::vector<SgAsmCilMemberRef*>& get_memberRef() const { return p_memberRef; }
              std::vector<SgAsmCilMethodDef*>& get_methodDef()       { return p_methodDef; }
        const std::vector<SgAsmCilMethodDef*>& get_methodDef() const { return p_methodDef; }
              std::vector<SgAsmCilMethodImpl*>& get_methodImpl()       { return p_methodImpl; }
        const std::vector<SgAsmCilMethodImpl*>& get_methodImpl() const { return p_methodImpl; }
              std::vector<SgAsmCilMethodSemantics*>& get_methodSemantics()       { return p_methodSemantics; }
        const std::vector<SgAsmCilMethodSemantics*>& get_methodSemantics() const { return p_methodSemantics; }
              std::vector<SgAsmCilMethodSpec*>& get_methodSpec()       { return p_methodSpec; }
        const std::vector<SgAsmCilMethodSpec*>& get_methodSpec() const { return p_methodSpec; }
              std::vector<SgAsmCilModule*>& get_module()       { return p_module; }
        const std::vector<SgAsmCilModule*>& get_module() const { return p_module; }
              std::vector<SgAsmCilModuleRef*>& get_moduleRef()       { return p_moduleRef; }
        const std::vector<SgAsmCilModuleRef*>& get_moduleRef() const { return p_moduleRef; }
              std::vector<SgAsmCilNestedClass*>& get_nestedClass()       { return p_nestedClass; }
        const std::vector<SgAsmCilNestedClass*>& get_nestedClass() const { return p_nestedClass; }
              std::vector<SgAsmCilParam*>& get_param()       { return p_param; }
        const std::vector<SgAsmCilParam*>& get_param() const { return p_param; }
              std::vector<SgAsmCilProperty*>& get_property()       { return p_property; }
        const std::vector<SgAsmCilProperty*>& get_property() const { return p_property; }
              std::vector<SgAsmCilPropertyMap*>& get_propertyMap()       { return p_propertyMap; }
        const std::vector<SgAsmCilPropertyMap*>& get_propertyMap() const { return p_propertyMap; }
              std::vector<SgAsmCilStandAloneSig*>& get_standAloneSig()       { return p_standAloneSig; }
        const std::vector<SgAsmCilStandAloneSig*>& get_standAloneSig() const { return p_standAloneSig; }
              std::vector<SgAsmCilTypeDef*>& get_typeDef()       { return p_typeDef; }
        const std::vector<SgAsmCilTypeDef*>& get_typeDef() const { return p_typeDef; }
              std::vector<SgAsmCilTypeRef*>& get_typeRef()       { return p_typeRef; }
        const std::vector<SgAsmCilTypeRef*>& get_typeRef() const { return p_typeRef; }
              std::vector<SgAsmCilTypeSpec*>& get_typeSpec()       { return p_typeSpec; }
        const std::vector<SgAsmCilTypeSpec*>& get_typeSpec() const { return p_typeSpec; }
        /** @} */


#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);

            s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysZero);
            s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
            s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
            s & BOOST_SERIALIZATION_NVP(p_HeapSizes);
            s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysOne);
            s & BOOST_SERIALIZATION_NVP(p_Valid);
            s & BOOST_SERIALIZATION_NVP(p_Sorted);
            s & BOOST_SERIALIZATION_NVP(p_NumberOfRows);
            s & BOOST_SERIALIZATION_NVP(p_DataSizeFlags);

            s & BOOST_SERIALIZATION_NVP(p_assembly);
            s & BOOST_SERIALIZATION_NVP(p_assemblyProcessor);
            s & BOOST_SERIALIZATION_NVP(p_assemblyOS);
            s & BOOST_SERIALIZATION_NVP(p_assemblyRef);
            s & BOOST_SERIALIZATION_NVP(p_assemblyRefProcessor);
            s & BOOST_SERIALIZATION_NVP(p_assemblyRefOS);
            s & BOOST_SERIALIZATION_NVP(p_classLayout);
            s & BOOST_SERIALIZATION_NVP(p_constant);
            s & BOOST_SERIALIZATION_NVP(p_customAttribute);
            s & BOOST_SERIALIZATION_NVP(p_declSecurity);
            s & BOOST_SERIALIZATION_NVP(p_eventMap);
            s & BOOST_SERIALIZATION_NVP(p_event);
            s & BOOST_SERIALIZATION_NVP(p_exportedType);
            s & BOOST_SERIALIZATION_NVP(p_field);
            s & BOOST_SERIALIZATION_NVP(p_fieldLayout);
            s & BOOST_SERIALIZATION_NVP(p_fieldMarshal);
            s & BOOST_SERIALIZATION_NVP(p_fieldRVA);
            s & BOOST_SERIALIZATION_NVP(p_file);
            s & BOOST_SERIALIZATION_NVP(p_genericParam);
            s & BOOST_SERIALIZATION_NVP(p_genericParamConstraint);
            s & BOOST_SERIALIZATION_NVP(p_implMap);
            s & BOOST_SERIALIZATION_NVP(p_interfaceImpl);
            s & BOOST_SERIALIZATION_NVP(p_manifestResource);
            s & BOOST_SERIALIZATION_NVP(p_memberRef);
            s & BOOST_SERIALIZATION_NVP(p_methodDef);
            s & BOOST_SERIALIZATION_NVP(p_methodImpl);
            s & BOOST_SERIALIZATION_NVP(p_methodSemantics);
            s & BOOST_SERIALIZATION_NVP(p_methodSpec);
            s & BOOST_SERIALIZATION_NVP(p_module);
            s & BOOST_SERIALIZATION_NVP(p_moduleRef);
            s & BOOST_SERIALIZATION_NVP(p_nestedClass);
            s & BOOST_SERIALIZATION_NVP(p_param);
            s & BOOST_SERIALIZATION_NVP(p_property);
            s & BOOST_SERIALIZATION_NVP(p_propertyMap);
            s & BOOST_SERIALIZATION_NVP(p_standAloneSig);
            s & BOOST_SERIALIZATION_NVP(p_typeDef);
            s & BOOST_SERIALIZATION_NVP(p_typeRef);
            s & BOOST_SERIALIZATION_NVP(p_typeSpec);
        }
#endif


#endif // SgAsmCilMetadataHeap_OTHERS

#ifdef DOCUMENTATION
    protected:

      uint32_t p_ReservedAlwaysZero;
      uint8_t p_MajorVersion;
      uint8_t p_MinorVersion;
      uint8_t p_HeapSizes;
      uint8_t p_ReservedAlwaysOne;
      uint64_t p_Valid;
      uint64_t p_Sorted;
      std::vector<uint32_t> p_NumberOfRows;
      uint64_t p_DataSizeFlags;

      std::vector<SgAsmCilAssembly*> p_assembly;
      std::vector<SgAsmCilAssemblyProcessor*> p_assemblyProcessor;
      std::vector<SgAsmCilAssemblyOS*> p_assemblyOS;
      std::vector<SgAsmCilAssemblyRef*> p_assemblyRef;
      std::vector<SgAsmCilAssemblyRefProcessor*> p_assemblyRefProcessor;
      std::vector<SgAsmCilAssemblyRefOS*> p_assemblyRefOS;
      std::vector<SgAsmCilClassLayout*> p_classLayout;
      std::vector<SgAsmCilConstant*> p_constant;
      std::vector<SgAsmCilCustomAttribute*> p_customAttribute;
      std::vector<SgAsmCilDeclSecurity*> p_declSecurity;
      std::vector<SgAsmCilEventMap*> p_eventMap;
      std::vector<SgAsmCilEvent*> p_event;
      std::vector<SgAsmCilExportedType*> p_exportedType;
      std::vector<SgAsmCilField*> p_field;
      std::vector<SgAsmCilFieldLayout*> p_fieldLayout;
      std::vector<SgAsmCilFieldMarshal*> p_fieldMarshal;
      std::vector<SgAsmCilFieldRVA*> p_fieldRVA;
      std::vector<SgAsmCilFile*> p_file;
      std::vector<SgAsmCilGenericParam*> p_genericParam;
      std::vector<SgAsmCilGenericParamConstraint*> p_genericParamConstraint;
      std::vector<SgAsmCilImplMap*> p_implMap;
      std::vector<SgAsmCilInterfaceImpl*> p_interfaceImpl;
      std::vector<SgAsmCilManifestResource*> p_manifestResource;
      std::vector<SgAsmCilMemberRef*> p_memberRef;
      std::vector<SgAsmCilMethodDef*> p_methodDef;
      std::vector<SgAsmCilMethodImpl*> p_methodImpl;
      std::vector<SgAsmCilMethodSemantics*> p_methodSemantics;
      std::vector<SgAsmCilMethodSpec*> p_methodSpec;
      std::vector<SgAsmCilModule*> p_module;
      std::vector<SgAsmCilModuleRef*> p_moduleRef;
      std::vector<SgAsmCilNestedClass*> p_nestedClass;
      std::vector<SgAsmCilParam*> p_param;
      std::vector<SgAsmCilProperty*> p_property;
      std::vector<SgAsmCilPropertyMap*> p_propertyMap;
      std::vector<SgAsmCilStandAloneSig*> p_standAloneSig;
      std::vector<SgAsmCilTypeDef*> p_typeDef;
      std::vector<SgAsmCilTypeRef*> p_typeRef;
      std::vector<SgAsmCilTypeSpec*> p_typeSpec;
#endif

#ifdef DOCUMENTATION
    };
#endif

////// end from metadataHeap_C.txt




    DECLARE_LEAF_CLASS(AsmCilUint8Heap);
    IS_SERIALIZABLE(AsmCilUint8Heap);

#ifdef DOCUMENTATION
    /** Base class for CIL branch of binary analysis IR nodes. */
    class SgAsmCilUint8Heap : public SgAsmCilDataStream {
    public:
#endif

#ifdef DOCUMENTATION
#else
        AsmCilUint8Heap.setDataPrototype("std::vector<uint8_t>", "Stream", "", NO_CONSTRUCTOR_PARAMETER,
                                         NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


    DECLARE_OTHERS(AsmCilUint8Heap);

#if defined(SgAsmCilUint8Heap_OTHERS) || defined(DOCUMENTATION)
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    public:
        // using SgAsmCilDataStream::SgAsmCilDataStream;
        SgAsmCilUint8Heap() = default;

        void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;

        /** Property: Returns stream representation
         * @{ */
              std::vector<uint8_t>& get_Stream()       { return p_Stream; }
        const std::vector<uint8_t>& get_Stream() const { return p_Stream; }
        /** @} */

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);

            s & BOOST_SERIALIZATION_NVP(p_Stream);
        }
#endif

#endif // SgAsmCilUint8Heap_OTHERS

#ifdef DOCUMENTATION
    protected:
        std::vector<uint8_t> p_Stream;
#endif

#ifdef DOCUMENTATION
    };
#endif


    DECLARE_LEAF_CLASS(AsmCilUint32Heap);
    IS_SERIALIZABLE(AsmCilUint32Heap);

#ifdef DOCUMENTATION
    /** Base class for CIL branch of binary analysis IR nodes. */
    class SgAsmCilUint32Heap : public SgAsmCilDataStream {
    public:
#endif

#ifdef DOCUMENTATION
#else
        AsmCilUint32Heap.setDataPrototype("std::vector<uint32_t>", "Stream", "", NO_CONSTRUCTOR_PARAMETER,
                                          NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


    DECLARE_OTHERS(AsmCilUint32Heap);

#if defined(SgAsmCilUint32Heap_OTHERS) || defined(DOCUMENTATION)
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    public:
        // using SgAsmCilDataStream::SgAsmCilDataStream;
        SgAsmCilUint32Heap() = default;

        void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;
        /** Property: Returns stream representation
         * @{ */
              std::vector<uint32_t>& get_Stream()       { return p_Stream; }
        const std::vector<uint32_t>& get_Stream() const { return p_Stream; }
        /** @} */


    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);

            s & BOOST_SERIALIZATION_NVP(p_Stream);
        }
#endif

#endif // SgAsmCilUint32Heap_OTHERS

#ifdef DOCUMENTATION
    protected:
        std::vector<uint32_t> p_Stream;
#endif

#ifdef DOCUMENTATION
    };
#endif


    NEW_NONTERMINAL_MACRO(AsmCilDataStream,
                          AsmCilMetadataHeap | AsmCilUint8Heap | AsmCilUint32Heap,
                          "AsmCilDataStream", "AsmCilDataStreamTag", false);
    AsmCilDataStream.setCppCondition("!defined(DOCUMENTATION)");
    IS_SERIALIZABLE(AsmCilDataStream);

#ifdef DOCUMENTATION
    /** Base class for CIL branch of binary analysis IR nodes. */
    class SgAsmCilDataStream : public SgAsmCilNode {
    public:
#endif

#ifdef DOCUMENTATION
        /** Property: Start offset of the byte stream
         * @{ */
        uint32_t get_Offset() const;
        void set_Offset(uint32_t);
        /** @} */
#else
        AsmCilDataStream.setDataPrototype("uint32_t", "Offset", "", CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#ifdef DOCUMENTATION
        /** Property: Length of the byte stream
         * @{ */
        uint32_t get_Size() const;
        void set_Size(uint32_t);
        /** @} */
#else
        AsmCilDataStream.setDataPrototype("uint32_t", "Size", "", CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#ifdef DOCUMENTATION
        /** Property: Name of the byte stream
         * @{ */
        std::string get_Name() const;
        void set_Name(std::string);
        /** @} */
#else
        AsmCilDataStream.setDataPrototype("std::string", "Name", "", CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

#ifdef DOCUMENTATION
        /** Property: Name of the byte stream
         * @{ */
        uint32_t get_NamePadding() const;
        void set_NamePadding(uint32_t);
        /** @} */
#else
        AsmCilDataStream.setDataPrototype("uint32_t", "NamePadding", "", CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

    DECLARE_OTHERS(AsmCilDataStream);

#if defined(SgAsmCilDataStream_OTHERS) || defined(DOCUMENTATION)
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    public:
        /** Define constant strings for the known stream types
         *  @{
         */
        static const std::string ID_STRING_HEAP;
        static const std::string ID_BLOB_HEAP;
        static const std::string ID_US_HEAP;
        static const std::string ID_GUID_HEAP;
        static const std::string ID_METADATA_HEAP;
        /** }@ */

        SgAsmCilDataStream() = default;

        /**
         * Defines the parse function.
         * @param buf the binary buffer.
         * @param startOfMetaData the location in buf where the metadata root (CIL ECMA II.24.2.1)
         *        is located.
         * @details
         *   buf[startOfMetaData] is the location of the metadata root magic number.
         *   parse will add get_Offset to startOfMetaData to find the first byte of a
         *   stream.
         */
        virtual void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) { /* FIXME: should be abstract */ }

    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);

            s & BOOST_SERIALIZATION_NVP(p_Offset);
            s & BOOST_SERIALIZATION_NVP(p_Size);
            s & BOOST_SERIALIZATION_NVP(p_Name);
            s & BOOST_SERIALIZATION_NVP(p_NamePadding);
        }
#endif

#endif // SgAsmCilDataStream_OTHERS

#ifdef DOCUMENTATION
    protected:
        uint32_t    p_Offset;
        uint32_t    p_Size;
        std::string p_Name;
        uint32_t    p_NamePadding;
#endif

#ifdef DOCUMENTATION
    };
#endif


////// from metadataRoot_C.txt

    DECLARE_LEAF_CLASS(AsmCilMetadataRoot);
    IS_SERIALIZABLE(AsmCilMetadataRoot);

#ifdef DOCUMENTATION
    /** CIL SgAsmCilMetadataRoot.
     *
     */
    class SgAsmCilMetadataRoot: public SgAsmCilNode {
    public:
#endif



#ifdef DOCUMENTATION
        /** Property: Magic signature for physical metadata (always 0x424A5342)
         * @{ */
        uint32_t get_Signature() const;
        void set_Signature(uint32_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint32_t", "Signature", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Major version number
         * @{ */
        uint16_t get_MajorVersion() const;
        void set_MajorVersion(uint16_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint16_t", "MajorVersion", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Minor version number
         * @{ */
        uint16_t get_MinorVersion() const;
        void set_MinorVersion(uint16_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint16_t", "MinorVersion", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Reserved space
         * @{ */
        uint32_t get_Reserved0() const;
        void set_Reserved0(uint32_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint32_t", "Reserved0", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Number of bytes allocated to hold version string (including null terminator)
         * @{ */
        uint32_t get_Length() const;
        void set_Length(uint32_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint32_t", "Length", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Version string
         * @{ */
        std::string get_Version() const;
        void set_Version(std::string);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("std::string", "Version", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Padding to next 4-byte boundary
         * @{ */
        uint32_t get_VersionPadding() const;
        void set_VersionPadding(uint32_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint32_t", "VersionPadding", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Reserved space
         * @{ */
        uint16_t get_Flags() const;
        void set_Flags(uint16_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint16_t", "Flags", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif


#ifdef DOCUMENTATION
        /** Property: Reserved space
         * @{ */
        uint16_t get_NumberOfStreams() const;
        void set_NumberOfStreams(uint16_t);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("uint16_t", "NumberOfStreams", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif





#ifdef DOCUMENTATION

#else
        AsmCilMetadataRoot.setDataPrototype("std::vector<SgAsmCilDataStream*>", "Streams", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif



        DECLARE_OTHERS(AsmCilMetadataRoot);
#if defined(SgAsmCilMetadataRoot_OTHERS) || defined(DOCUMENTATION)
    private:
        /** indices to efficienty access the different heaps
         * @{ */
        mutable int8_t idxStringHeap = -1;
        mutable int8_t idxBlobHeap = -1;
        mutable int8_t idxUsHeap = -1;
        mutable int8_t idxGuidHeap = -1;
        mutable int8_t idxMetadataHeap = -1;
        /** }@ */

    public:
        /** 4-byte indicating the start of the metadata root in the .text section.
         */
        static constexpr uint32_t MAGIC_SIGNATURE = 0x424A5342;

        /** Declares the parse function as called from the Cil section header object
         *  @pre isSgAsmCliHeader(this->get_parent()) != nullptr
         */
        void parse();

        /** Declares the parse function.
         *  @param buf the binary buffer
         *  @param index the start location of the metadata root object.
         *         buf[index] is the location of the magic number.
         */
        void parse(std::vector<uint8_t>& buf, size_t index);

        /** accessor functions to return specific heaps
         * @{ */
        SgAsmCilUint8Heap*    get_StringHeap() const;
        SgAsmCilUint8Heap*    get_BlobHeap() const;
        SgAsmCilUint8Heap*    get_UsHeap() const;
        SgAsmCilUint32Heap*   get_GuidHeap() const;
        SgAsmCilMetadataHeap* get_MetadataHeap() const;
        /** }@ */


        /** Streams accessor
         * @{ */
        const std::vector<SgAsmCilDataStream*>& get_Streams() const;
        std::vector<SgAsmCilDataStream*>& get_Streams();
        /** @} */



#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);

            s & BOOST_SERIALIZATION_NVP(p_Signature);
            s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
            s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
            s & BOOST_SERIALIZATION_NVP(p_Reserved0);
            s & BOOST_SERIALIZATION_NVP(p_Length);
            s & BOOST_SERIALIZATION_NVP(p_Version);
            s & BOOST_SERIALIZATION_NVP(p_VersionPadding);
            s & BOOST_SERIALIZATION_NVP(p_Flags);
            s & BOOST_SERIALIZATION_NVP(p_NumberOfStreams);

            s & BOOST_SERIALIZATION_NVP(p_Streams);
        }
#endif


#endif // SgAsmCilMetadataRoot_OTHERS

#ifdef DOCUMENTATION
    protected:

      uint32_t p_Signature;
      uint16_t p_MajorVersion;
      uint16_t p_MinorVersion;
      uint32_t p_Reserved0;
      uint32_t p_Length;
      std::string p_Version;
      uint32_t p_VersionPadding;
      uint16_t p_Flags;
      uint16_t p_NumberOfStreams;

      std::vector<SgAsmCilDataStream*> p_Streams;
#endif

#ifdef DOCUMENTATION
    };
#endif

////// end from metadataRoot_C.txt


    NEW_NONTERMINAL_MACRO(AsmCilNode,
                          AsmCilMetadata | AsmCilDataStream | AsmCilMetadataRoot,
                          "AsmCilNode", "AsmCilNodeTag", false);
    AsmCilNode.setCppCondition("!defined(DOCUMENTATION)");
    IS_SERIALIZABLE(AsmCilNode);

#ifdef DOCUMENTATION
    /** Base class for CIL branch of binary analysis IR nodes. */
    class SgAsmCilNode: public SgAsmNode {
    public:
#endif

        DECLARE_OTHERS(AsmCilNode);
#if defined(SgAsmCilNode_OTHERS) || defined(DOCUMENTATION)
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
        }
#endif

#endif // SgAsmCilNode_OTHERS

#ifdef DOCUMENTATION
    };
#endif


// --- END generated code. ------------------------------------------------------
