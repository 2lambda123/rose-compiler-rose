////// from metadataRoot_C.txt

    DECLARE_LEAF_CLASS(AsmCilMetadataRoot);
    IS_SERIALIZABLE(AsmCilMetadataRoot);

#ifdef DOCUMENTATION
    /** CIL SgAsmCilMetadataRoot.
     *
     */
    class SgAsmCilMetadataRoot: public SgAsmCilNode {
    public:
#endif

%%forall Fields%%

#ifdef DOCUMENTATION
        /** Property: %%Fields.Doc%%
         * @{ */
        %%Fields.Type%% get_%%Fields.Name%%() const;
        void set_%%Fields.Name%%(%%Fields.Type%%);
        /** @} */
#else
        AsmCilMetadataRoot.setDataPrototype("%%Fields.Type%%", "%%Fields.Name%%", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

%%end_for%%


%%forall Streams%%

#ifdef DOCUMENTATION

#else
        AsmCilMetadataRoot.setDataPrototype("std::vector<%%Streams.Type%%*>", "%%Streams.Name%%", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

%%end_for%%


        DECLARE_OTHERS(AsmCilMetadataRoot);
#if defined(SgAsmCilMetadataRoot_OTHERS) || defined(DOCUMENTATION)
    private:
        /** indices to efficienty access the different heaps
         * @{ */
        mutable int8_t idxStringHeap = -1;
        mutable int8_t idxBlobHeap = -1;
        mutable int8_t idxUsHeap = -1;
        mutable int8_t idxGuidHeap = -1;
        mutable int8_t idxMetadataHeap = -1;
        /** }@ */

    public:
        /** 4-byte indicating the start of the metadata root in the .text section.
         */
        static constexpr uint32_t MAGIC_SIGNATURE = 0x424A5342;

        /** Declares the parse function as called from the Cil section header object
         *  @pre isSgAsmCliHeader(this->get_parent()) != nullptr
         */
        void parse();

        /** Declares the parse function.
         *  @param buf the binary buffer
         *  @param index the start location of the metadata root object.
         *         buf[index] is the location of the magic number.
         */
        void parse(std::vector<uint8_t>& buf, size_t index);

        /** accessor functions to return specific heaps
         * @{ */
        SgAsmCilUint8Heap*    get_StringHeap() const;
        SgAsmCilUint8Heap*    get_BlobHeap() const;
        SgAsmCilUint8Heap*    get_UsHeap() const;
        SgAsmCilUint32Heap*   get_GuidHeap() const;
        SgAsmCilMetadataHeap* get_MetadataHeap() const;
        /** }@ */

%%forall Streams%%
        /** %%Streams.Name%% accessor
         * @{ */
        const std::vector<%%Streams.Type%%*>& get_%%Streams.Name%%() const;
        std::vector<%%Streams.Type%%*>& get_%%Streams.Name%%();
        /** @} */
%%end_for%%



#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
            %%forall Fields%%
            s & BOOST_SERIALIZATION_NVP(p_%%Fields.Name%%);
            %%end_for%%
            %%forall Streams%%
            s & BOOST_SERIALIZATION_NVP(p_%%Streams.Name%%);
            %%end_for%%
        }
#endif


#endif // SgAsmCilMetadataRoot_OTHERS

#ifdef DOCUMENTATION
    protected:
      %%forall Fields%%
      %%Fields.Type%% p_%%Fields.Name%%;
      %%end_for%%
      %%forall Streams%%
      std::vector<%%Streams.Type%%*> p_%%Streams.Name%%;
      %%end_for%%
#endif

#ifdef DOCUMENTATION
    };
#endif

////// end from metadataRoot_C.txt

////// from metadataRoot_C.txt

namespace
{

struct ExceptionClause : std::tuple<std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t>
{
  // flags values
  static constexpr std::uint32_t TYPED   = 0x0000;
  static constexpr std::uint32_t FILTER  = 0x0001;
  static constexpr std::uint32_t FINALLY = 0x0002;
  static constexpr std::uint32_t FAULT   = 0x0003;

  using base = std::tuple<std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t, std::uint32_t>;
  using base::base;
  
  std::uint32_t flags()         const { return std::get<0>(*this); }
  std::uint32_t tryOffset()     const { return std::get<1>(*this); }
  std::uint32_t tryLength()     const { return std::get<2>(*this); }
  std::uint32_t handlerOffset() const { return std::get<3>(*this); }
  std::uint32_t handlerLength() const { return std::get<4>(*this); }
  std::uint32_t classToken()    const { ROSE_ASSERT(flags() == TYPED); return std::get<5>(*this); }
  std::uint32_t filterOffset()  const { ROSE_ASSERT(flags() == FILTER); return std::get<5>(*this); }
};

struct MethodSectionHeader : std::tuple<std::uint8_t, std::uint32_t, std::vector<ExceptionClause> >
{
  static constexpr std::uint8_t EH_TABLE    = 0x01;
  static constexpr std::uint8_t OPTIL_TABLE = 0x02;
  static constexpr std::uint8_t FAT_FORMAT  = 0x40;
  static constexpr std::uint8_t MORE_SECTS  = 0x80;
  
  using base = std::tuple<std::uint8_t, std::uint32_t, std::vector<ExceptionClause> >;
  using base::base;

  std::uint8_t  kind()         const { return std::get<0>(*this); }
  bool          ehTable()      const { return (kind() & EH_TABLE) == EH_TABLE; }
  bool          optilTable()   const { return (kind() & OPTIL_TABLE) == OPTIL_TABLE; }
  bool          small()        const { return (kind() & FAT_FORMAT) == 0; }
  bool          moreSections() const { return (kind() & MORE_SECTS) == MORE_SECTS; }
  
  std::uint32_t size()         const { return std::get<1>(*this); }
  
  const std::vector<ExceptionClause> clauses() const { return std::get<2>(*this); }  
};

std::vector<ExceptionClause>
parseSmallExceptionClauses(std::uint8_t len, rose_addr_t base_va, std::uint32_t rva, SgAsmPEFileHeader& fhdr)
{
  static constexpr int CLAUSE_LEN = 12;

  std::vector<ExceptionClause> res;
  std::size_t                  idx = 0;
  std::vector<std::uint8_t>    buf(len, 0);
  const std::size_t            nread = fhdr.get_loader_map()->readQuick(buf.data(), base_va + rva, len);
  ROSE_ASSERT(nread == len);
  const std::uint8_t           n = sz/CLAUSE_LEN;
  ROSE_ASSERT(sz%CLAUSE_LEN == 0);
  
  for (std::uint8_t i = 0; i < n; ++i)
    res.emplace_back( read16bitValue(buf.data(), idx), 
                      read16bitValue(buf.data(), idx),
                      read8bitValue(buf.data(), idx),
                      read16bitValue(buf.data(), idx),
                      read8bitValue(buf.data(), idx),
                      read32bitValue(buf.data(), idx),    
                    );
  
  return res;
}

std::vector<ExceptionClause>
parseFatExceptionClauses(std::uint32_t len, rose_addr_t base_va, std::uint32_t rva, SgAsmPEFileHeader& fhdr)
{
  static constexpr int CLAUSE_LEN = 24;
  
  std::vector<ExceptionClause> res;
  std::size_t                  idx = 0;
  std::vector<std::uint8_t>    buf(len, 0);
  const std::size_t            nread = fhdr.get_loader_map()->readQuick(buf.data(), base_va + rva, len);
  ROSE_ASSERT(nread == len);
  const std::uint32_t          n = sz/CLAUSE_LEN;
  ROSE_ASSERT(sz%CLAUSE_LEN == 0);
  
  for (std::uint8_t i = 0; i < n; ++i)
    res.emplace_back( read32bitValue(buf.data(), idx), 
                      read32bitValue(buf.data(), idx),
                      read32bitValue(buf.data(), idx),
                      read32bitValue(buf.data(), idx),
                      read32bitValue(buf.data(), idx),
                      read32bitValue(buf.data(), idx),    
                    );
  
  return res;
}

MethodSectionHeader parseSmallSectionHeader(std::uint8_t buf[2], rose_addr_t base_va, std::uint32_t rva, SgAsmPEFileHeader& fhdr)
{
  const std::uint32_t rvaofs = rva + 4; // small header + padding
  
  ROSE_ASSERT(buf[1] >= 4);
  return MethodSectionHeader{buf[0], buf[1], parseSmallExceptionClauses(buf[1]-4, base_va, rvaofs, fhdr)};
}

MethodSectionHeader parseFatSectionHeader(rose_addr_t base_va, std::uint32_t rva, SgAsmPEFileHeader& fhdr)
{
  std::uint8_t        buf[4];
  const std::size_t   nread = fhdr.get_loader_map()->readQuick(buf.data(), base_va + rva + 4, sizeof(buf));  
  ROSE_ASSERT(nread == sizeof(buf));
  
  std::size_t         idxF = 0;
  const std::uint8_t  flags = read8bitValue(buf, idxF);
  std::size_t         idxS = 0;
  const std::uint32_t sz = read32bitValue(buf, idxS) >> 8;

  const std::uint32_t rvaofs = rva + 4; // small header + padding
  
  ROSE_ASSERT(sz >= 4);
  return MethodSectionHeader{flags, sz, parseFatExceptionClauses(sz-4, base_va, rvaofs, fhdr)};
}


struct MethodHeader : std::tuple<std::uint16_t, std::uint16_t, std::uint32_t, std::uint32_t>
{
  static constexpr std::uint8_t TINY        = 0x2;
  static constexpr std::uint8_t FAT         = 0x3;
  static constexpr std::uint8_t FORMAT      = TINY | FAT;
  static constexpr std::uint8_t MORE_SECTS  = 0x8;
  static constexpr std::uint8_t INIT_LOCALS = 0x10;
  static constexpr std::uint8_t FLAGS       = MORE_SECTS | INIT_LOCALS;

  using base = std::tuple<std::uint16_t, std::uint16_t, std::uint32_t, std::uint32_t>;
  using base::base;

  std::uint16_t flags() const          { return std::get<0>(*this); }
  bool          tiny()  const          { return (flags() & FORMAT) == TINY; }
  bool          moreSections()  const  { return (flags() & MORE_SECTS) == MORE_SECTS; }
  bool          initLocals()  const    { return (flags() & INIT_LOCALS) == INIT_LOCALS; }
  std::uint8_t  headerSize() const     { return tiny() ? 1 : (flags() >> 12); }

  std::uint16_t maxStackSize() const   { return std::get<1>(*this); }
  std::uint32_t codeSize() const       { return std::get<2>(*this); }
  std::uint32_t localVarSigTok() const { return std::get<3>(*this); }
};

MethodHeader
parseFatHeader(rose_addr_t base_va, std::uint32_t rva, SgAsmPEFileHeader& fhdr)
{
  std::uint8_t         buf[12];
  const std::size_t    nread = fhdr.get_loader_map()->readQuick(&buf, base_va + rva, sizeof(buf));
  ROSE_ASSERT(nread == 12);

  const std::uint16_t  flags    = ByteOrder::le_to_host(*reinterpret_cast<uint16_t*>(buf+0));
  const std::uint16_t  maxStack = ByteOrder::le_to_host(*reinterpret_cast<uint16_t*>(buf+2));
  const std::uint16_t  codeSize = ByteOrder::le_to_host(*reinterpret_cast<uint32_t*>(buf+4));
  const std::uint16_t  localIni = ByteOrder::le_to_host(*reinterpret_cast<uint32_t*>(buf+8));
  const MethodHeader   res{ flags, maxStack, codeSize, localIni };

  ROSE_ASSERT(!res.tiny());
  ROSE_ASSERT(res.headerSize() == 3);
  return res;
}

MethodHeader
parseTinyHeader(std::uint8_t header)
{
  return { header & MethodHeader::FORMAT, 8, header >> 2, 0 };
}

SgAsmBlock*
disassemble(SgAsmCilMethodDef* m, MethodHeader mh, std::vector<std::uint8_t>& buf, Rose::BinaryAnalysis::Disassembler&& disasm)
{
  const std::size_t              sz = buf.size();
  rose_addr_t                    addr = 0;
  std::uint8_t*                  b = buf.data();
  std::vector<SgAsmInstruction*> lst;

  while (addr < sz)
  {
    SgAsmInstruction* instr = disasm.disassembleOne(b, 0, sz, addr);
    ASSERT_not_null(instr);

    lst.push_back(instr);

    addr += instr->get_size();
  }

  return sb::buildBasicBlock(lst);
}

void decodeMethods(rose_addr_t base_va, SgAsmPEFileHeader& fhdr, SgAsmCilMetadataRoot& root, SgAsmCilMetadataHeap& mdh)
{
  static constexpr std::uint8_t CIL_CODE       = 0;
  static constexpr std::uint8_t NATIVE_CODE    = 1;
  static constexpr std::uint8_t OPTIL_RESERVED = 2;
  static constexpr std::uint8_t RUNTIME_CODE   = 3;
  static constexpr std::uint8_t CODE_TYPE_MASK = CIL_CODE | NATIVE_CODE | OPTIL_RESERVED | RUNTIME_CODE;
  
  SgAsmCilUint8Heap* stringHeap = root.get_StringHeap();
  ASSERT_not_null(stringHeap);  

  // decode methods
  for (SgAsmCilMethodDef* m : mdh.get_methodDef())
  {
    ASSERT_not_null(m);

    std::size_t nameidx = m->get_Name();
    //~ std::cerr << "proc " << readUtf8String(stringHeap->get_Stream(), nameidx)
    //~           << std::endl;

    // parse header
    std::uint32_t  rva = m->get_RVA();
    std::uint8_t   mh0;
    std::size_t    nread = fhdr.get_loader_map()->readQuick(&mh0, base_va + rva, 1);
    ROSE_ASSERT(nread == 1);

    bool           isTiny = (mh0 & MethodHeader::FORMAT) == MethodHeader::TINY;
    ROSE_ASSERT((!isTiny) || (((base_va+rva)%4) == 0));
    MethodHeader   mh = isTiny ? parseTinyHeader(mh0) : parseFatHeader(base_va, rva, fhdr);

    m->set_stackSize(mh.maxStackSize());
    m->set_hasMoreSections(mh.moreSections());
    m->set_initLocals(mh.initLocals());

    // parse code
    std::uint32_t  codeRVA = rva + mh.headerSize();
    std::uint32_t  codeLen = mh.codeSize();

    std::vector<std::uint8_t> code(codeLen, 0);
    std::size_t    nreadCode = fhdr.get_loader_map()->readQuick(code.data(), base_va + codeRVA, codeLen);
    ROSE_ASSERT(nreadCode == codeLen);

    SgAsmBlock* blk = nullptr;

    switch (m->get_ImplFlags() & CODE_TYPE_MASK)
    {
      namespace rb = Rose::BinaryAnalysis;

      case CIL_CODE:
        //~ std::cerr << "  - disassembling CIL code: " << code.size() << " bytes."
        //~           << std::endl;
        blk = disassemble(m, mh, code, rb::DisassemblerCil());
        break;

      case NATIVE_CODE:
        //~ std::cerr << "  - disassembling x86 code: " << code.size() << " bytes."
        //~           << std::endl;
        blk = disassemble(m, mh, code, rb::DisassemblerX86(4 /* word size */));
        break;

      case RUNTIME_CODE:
        std::cerr << "  - runtime provided: " << code.size()
                  << std::endl;
        // looking for sample code
        ROSE_ABORT();
        break;

      default:
        ROSE_ABORT();
    }

    ASSERT_not_null(blk);
    m->set_body(blk);
    
    bool hasMoreSects = mh.moreSections();
    std::uint32_t sectRVA = ((codeRVA + codeLen + 3) / 4) * 4;
    
    while (hasMoreSects)
    {
      std::uint8_t  sectHead[2];
      std::size_t   nreadHead = fhdr.get_loader_map()->readQuick(sectHead, base_va + sectRVA, sizeof(sectHead));  
      ROSE_ASSERT(nreadHead == sizeof(sectHead));
      
      bool          isSmall = ((sectHead[0] & SECT_FAT_FORMAT) == 0)
      SectionHeader sh      = isSmall ? parseSmallSectionHeader(sectHead, base_va, sectRVA, fhdr) 
                                      : parseFatSectionHeader(base_va, sectRVA, fhdr);
    
      std::uint32_t codeLen = mh.codeSize();
    
      sectRVA += sh.size();
      hasMoreSects = ((sectHead[0] & SECT_MORE_SECTS) == SECT_MORE_SECTS);
    }
  }
}

void decodeMetadata(rose_addr_t base_va, SgAsmCilMetadataHeap* mdh, SgAsmCilMetadataRoot* root)
{
  ASSERT_not_null(mdh); ASSERT_not_null(root);

  SgAsmPEFileHeader* fhdr = SageInterface::getEnclosingNode<SgAsmPEFileHeader>(root);
  ASSERT_not_null(fhdr);
  
  decodeMethods(base_va, *fhdr, *root, *mdh);
}

}


void SgAsmCilMetadataRoot::parse()
{
  SgAsmCliHeader* clih = isSgAsmCliHeader(get_parent());
  ASSERT_not_null(clih);

  SgAsmPEFileHeader* fhdr = SageInterface::getEnclosingNode<SgAsmPEFileHeader>(this);
  ASSERT_not_null(fhdr);

  uint64_t    metaData = clih->get_metaData();
  uint8_t*    data = reinterpret_cast<uint8_t*>(&metaData);
  rose_addr_t rva = ByteOrder::le_to_host(*reinterpret_cast<uint32_t*>(data));
  size_t      size = ByteOrder::le_to_host(*reinterpret_cast<uint32_t*>(data+4));
  rose_addr_t base_va = clih->get_base_va();
  rose_addr_t rva_offset = clih->get_rva_offset(rva);

  if (TRACE_CONSTRUCTION)
  {
    std::cerr << "------------------------SgAsmCilMetadataRoot::parse-----------------------------\n";
    std::cerr << "    rva: " << rva << " size: " << size << std::endl;
    std::cerr << "    base_va: " << base_va << " rva_offset: " << rva_offset << std::endl;
  }

  /* Read the Signature via loader map. */
  // Note: probably want to allocate a larger buffer
  std::vector<uint8_t> buf(size, 0);

  size_t nread = fhdr->get_loader_map()->readQuick(buf.data(), base_va + rva, size);
  ROSE_ASSERT(nread == size);

  this->parse(buf, 0);
  decodeMetadata(base_va, get_MetadataHeap(), this);
}


void SgAsmCilMetadataRoot::parse(std::vector<uint8_t>& buf, size_t index)
{
  size_t start_of_MetadataRoot = index;

  if (TRACE_CONSTRUCTION)
    std::cerr << "Initialize the elements of the data structure" << std::endl;

  %%forall Fields%%
  p_%%Fields.Name%% = %%Fields.Init%%;
  if (TRACE_CONSTRUCTION)
    std::cerr << "%%Fields.Name%% = " << p_%%Fields.Name%% << std::endl;
  %%end_for%%

  %%forall Streams%%
  p_%%Streams.Name%% = %%Streams.Init%%;
  if (TRACE_CONSTRUCTION)
    std::cerr << "%%Streams.Name%% has " << p_%%Streams.Name%%.size() << "elements." << std::endl;
  %%end_for%%
}

%%forall Streams%%
const std::vector<%%Streams.Type%%*>&
SgAsmCilMetadataRoot::get_%%Streams.Name%%() const
{
  return p_%%Streams.Name%%;
}

std::vector<%%Streams.Type%%*>&
SgAsmCilMetadataRoot::get_%%Streams.Name%%()
{
  return p_%%Streams.Name%%;
}
%%end_for%%

namespace
{
  template <class SageAsmCilHeap>
  SageAsmCilHeap*
  getHeapInternal(const std::vector<SgAsmCilDataStream*>& streams, int8_t& idx, const std::string& streamID)
  {
    const int numHeaps = streams.size();

    if (idx < 0)
    {
      while ((++idx < numHeaps) && (streams[idx]->get_Name() != streamID));
    }

    if (idx < numHeaps)
      return dynamic_cast<SageAsmCilHeap*>(streams[idx]);

    return nullptr;
  }
}


SgAsmCilUint8Heap*
SgAsmCilMetadataRoot::get_StringHeap() const
{
  return getHeapInternal<SgAsmCilUint8Heap>(get_Streams(), idxStringHeap, SgAsmCilDataStream::ID_STRING_HEAP);
}

SgAsmCilUint8Heap*
SgAsmCilMetadataRoot::get_BlobHeap() const
{
  return getHeapInternal<SgAsmCilUint8Heap>(get_Streams(), idxBlobHeap, SgAsmCilDataStream::ID_BLOB_HEAP);
}

SgAsmCilUint8Heap*
SgAsmCilMetadataRoot::get_UsHeap() const
{
  return getHeapInternal<SgAsmCilUint8Heap>(get_Streams(), idxUsHeap, SgAsmCilDataStream::ID_US_HEAP);
}

SgAsmCilUint32Heap*
SgAsmCilMetadataRoot::get_GuidHeap() const
{
  return getHeapInternal<SgAsmCilUint32Heap>(get_Streams(), idxGuidHeap, SgAsmCilDataStream::ID_GUID_HEAP);
}

SgAsmCilMetadataHeap*
SgAsmCilMetadataRoot::get_MetadataHeap() const
{
  return getHeapInternal<SgAsmCilMetadataHeap>(get_Streams(), idxMetadataHeap, SgAsmCilDataStream::ID_METADATA_HEAP);
}

////// end from metadataRoot_C.txt
