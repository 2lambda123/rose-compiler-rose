////// from metadataHeap_C.txt

    DECLARE_LEAF_CLASS(AsmCilMetadataHeap);
    IS_SERIALIZABLE(AsmCilMetadataHeap);

#ifdef DOCUMENTATION
    /** CIL AsmCilMetadataHeap.
     *
     */
    class SgAsmCilMetadataHeap: public SgAsmCilDataStream {
    public:
#endif

%%forall Fields%%

#ifdef DOCUMENTATION
        /** Property: %%Fields.Doc%%
         * @{ */
        %%Fields.Type%% get_%%Fields.Name%%() const;
        void set_%%Fields.Name%%(%%Fields.Type%%);
        /** @} */
#else
        AsmCilMetadataHeap.setDataPrototype("%%Fields.Type%%", "%%Fields.Name%%", "", NO_CONSTRUCTOR_PARAMETER,
                                            BUILD_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

%%end_for%%


%%forall Tables%%

#ifdef DOCUMENTATION
#else
        AsmCilMetadataHeap.setDataPrototype("std::vector<%%Tables.Type%%*>", "%%Tables.Name%%", "", NO_CONSTRUCTOR_PARAMETER,
                                            NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

%%end_for%%


        DECLARE_OTHERS(AsmCilMetadataHeap);
#if defined(SgAsmCilMetadataHeap_OTHERS) || defined(DOCUMENTATION)

    public:
        /// reference kinds in the metadata tables
        enum ReferenceKind
        {
          // heaps
          e_ref_string_heap           = 1 << 0,
          e_ref_guid_heap             = 1 << 1,
          e_ref_blob_heap             = 1 << 2,
          // single-table references
          e_ref_assembly_ref          = 1 << 3,
          e_ref_type_def              = 1 << 4,
          e_ref_event                 = 1 << 5,
          e_ref_field                 = 1 << 6,
          e_ref_generic_param         = 1 << 7,
          e_ref_module_ref            = 1 << 8,
          e_ref_method_def            = 1 << 9,
          e_ref_param                 = 1 << 10,
          e_ref_property              = 1 << 11,
          // multi-table references
          e_ref_has_constant          = 1 << 12,
          e_ref_has_custom_attribute  = 1 << 13,
          e_ref_has_decl_security     = 1 << 14,
          e_ref_has_field_marshall    = 1 << 15,
          e_ref_has_semantics         = 1 << 16,
          e_ref_method_def_or_ref     = 1 << 17,
          e_ref_type_def_or_ref       = 1 << 18,
          e_ref_implementation        = 1 << 19,
          e_ref_member_forwarded      = 1 << 20,
          e_ref_member_ref_parent     = 1 << 21,
          e_ref_type_or_method_def    = 1 << 22,
          e_ref_custom_attribute_type = 1 << 23,
          e_ref_resolution_scope      = 1 << 24,
        };

        SgAsmCilMetadataHeap() = default;

        /** parses the metadata objects from the buffer. */
        void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;

        /** looks up the node associated with the coded index @ref refcode in the metadata tables
         *  under the assumption that @refval is of kind @ref knd
         */
        SgAsmCilMetadata* get_MetadataNode(std::uint32_t refcode, ReferenceKind knd) const;

        /** metadata-tables accessor methods
         *  @{ */
        %%forall Tables%%
              std::vector<%%Tables.Type%%*>& get_%%Tables.Name%%()       { return p_%%Tables.Name%%; }
        const std::vector<%%Tables.Type%%*>& get_%%Tables.Name%%() const { return p_%%Tables.Name%%; }
        %%end_for%%
        /** @} */


#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;

        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
            %%forall Fields%%
            s & BOOST_SERIALIZATION_NVP(p_%%Fields.Name%%);
            %%end_for%%
            %%forall Tables%%
            s & BOOST_SERIALIZATION_NVP(p_%%Tables.Name%%);
            %%end_for%%
        }
#endif


#endif // SgAsmCilMetadataHeap_OTHERS

#ifdef DOCUMENTATION
    protected:
      %%forall Fields%%
      %%Fields.Type%% p_%%Fields.Name%%;
      %%end_for%%
      %%forall Tables%%
      std::vector<%%Tables.Type%%*> p_%%Tables.Name%%;
      %%end_for%%
#endif

#ifdef DOCUMENTATION
    };
#endif

////// end from metadataHeap_C.txt

////// from metadataHeap_C.txt

namespace
{
/// Metadata table identifiers to support .net metadata layout within the .text section.
enum MetaDataHeapTableKinds
{
// Values of enum fields are the bit positions in the valid array of valid tables (for each table).
  e_unknown_table_kind     = 0xFF,
  e_error_table_kind       = 0xFE,
%%forall Tables%%
  e_%%Tables.Name%%        = %%Tables.Code%%,
%%end_for%%
  e_last_table_kind        = 0xFD
};

const char*
table_kind_to_string ( enum MetaDataHeapTableKinds e )
{
   const char* res = nullptr;

   switch (e)
   {
     case e_unknown_table_kind:     res = "e_unknown_table_kind"; break;
     case e_error_table_kind:       res = "e_error_table_kind"; break;
%%forall Tables%%
     case e_%%Tables.Name%%:        res = "e_%%Tables.Name%%"; break;
%%end_for%%
     case e_last_table_kind:        res = "e_last_table_kind"; break;

     default:
        {
          ROSE_ABORT();
        }
   }

  return res;
}

std::vector<int8_t>
computePositionInRowVector(uint64_t valid)
{
  constexpr int NUM_BITS = sizeof(valid) * CHAR_BIT;

  std::vector<int8_t> res;
  const int           numValidBits = Rose::BitOps::nSet(valid);
  int                 ctr = -1;

  res.reserve(NUM_BITS);
  for (int i = 0; i < NUM_BITS; ++i)
  {
    int8_t idx = (valid & 1) ? ++ctr : -1;

    valid >>= 1;
    res.push_back(idx);
  }

  //~ std::cerr << ctr << " ctr <? " << numValidBits << std::endl;
  ROSE_ASSERT(ctr < numValidBits);
  return res;
}

/// computes number of bits required to store the table identifier
///   ii.24.2.6
uint64_t
calcTableIdentifierSize(const std::vector<uint8_t>& tables)
{
  const size_t tblsz = tables.size();
  ROSE_ASSERT(tblsz > 0);

  auto hiBit = Rose::BitOps::highestSetBit(tblsz-1);

  return hiBit ? (*hiBit) + 1 : 0;
}

uint32_t
calcMaxTableSize( const std::vector<uint32_t>& numberOfRows,
                  const std::vector<int8_t>& posInRowVector,
                  const std::vector<uint8_t>& tables
                )
{
  uint32_t max = 0;

  for (uint8_t tbl : tables)
  {
    if (tbl == e_unknown_table_kind) continue;

    const int8_t posInRowVec = posInRowVector.at(tbl);
    if (posInRowVec < 0) continue;

    const uint32_t numEntries = numberOfRows.at(posInRowVec);
    if (max < numEntries) max = numEntries;
  }

  return max;
}


const std::unordered_map<std::uint64_t, std::vector<uint8_t> >
REF_TABLES = { // single table
               { SgAsmCilMetadataHeap::e_ref_assembly_ref,  { e_assembly } }
             , { SgAsmCilMetadataHeap::e_ref_type_def,      { e_typeDef } }
             , { SgAsmCilMetadataHeap::e_ref_event,         { e_event } }
             , { SgAsmCilMetadataHeap::e_ref_field,         { e_field } }
             , { SgAsmCilMetadataHeap::e_ref_generic_param, { e_genericParam } }
             , { SgAsmCilMetadataHeap::e_ref_method_def,    { e_methodDef } }
             , { SgAsmCilMetadataHeap::e_ref_module_ref,    { e_moduleRef } }
             , { SgAsmCilMetadataHeap::e_ref_param,         { e_param } }
             , { SgAsmCilMetadataHeap::e_ref_property,      { e_property } }
               // multi-table
             , { SgAsmCilMetadataHeap::e_ref_has_constant,  { e_field, e_param, e_property } }
             , { SgAsmCilMetadataHeap::e_ref_has_custom_attribute,
                     { e_methodDef, e_field, e_typeRef, e_typeDef
                     , e_param, e_interfaceImpl, e_memberRef, e_module
                     , e_unknown_table_kind // FIXME instead of: e_permission
                     , e_property, e_event, e_standAloneSig
                     , e_moduleRef, e_typeSpec, e_assembly, e_assemblyRef
                     , e_file, e_exportedType, e_manifestResource, e_genericParam
                     , e_genericParamConstraint, e_methodSpec
                     }
               }
             , { SgAsmCilMetadataHeap::e_ref_has_decl_security, { e_typeDef, e_methodDef, e_assembly } }
             , { SgAsmCilMetadataHeap::e_ref_has_field_marshall, { e_field, e_param } }
             , { SgAsmCilMetadataHeap::e_ref_has_semantics, { e_event, e_property } }
             , { SgAsmCilMetadataHeap::e_ref_method_def_or_ref, { e_methodDef, e_memberRef } }
             , { SgAsmCilMetadataHeap::e_ref_type_def_or_ref, { e_typeDef, e_typeRef, e_typeSpec } }
             , { SgAsmCilMetadataHeap::e_ref_implementation, { e_file, e_assemblyRef, e_exportedType } }
             , { SgAsmCilMetadataHeap::e_ref_member_forwarded, { e_field, e_methodDef } }
             , { SgAsmCilMetadataHeap::e_ref_member_ref_parent, { e_typeDef, e_typeRef, e_moduleRef, e_methodDef, e_typeSpec } }
             , { SgAsmCilMetadataHeap::e_ref_type_or_method_def, { e_typeDef, e_methodDef } }
               // not used inside the tables
             , { SgAsmCilMetadataHeap::e_ref_custom_attribute_type,
                     { e_unknown_table_kind, e_unknown_table_kind, e_methodDef, e_memberRef
                     , e_unknown_table_kind
                     }
               }
             , { SgAsmCilMetadataHeap::e_ref_resolution_scope, { e_module, e_moduleRef, e_assemblyRef, e_typeRef } }
             };


uint64_t
uses4byteIndex( const std::vector<uint32_t>& numberOfRows,
                const std::vector<int8_t>& posInRowVector,
                const std::vector<uint8_t>& tables,
                uint64_t flag
              )
{
  const size_t   bitsForTableIdentifier = calcTableIdentifierSize(tables);

  if (TRACE_CONSTRUCTION)
    std::cerr << "|numberOfRows, posInRowVector, tables| = "
              << numberOfRows.size() << ", "
              << posInRowVector.size() << ", "
              << tables.size()
              << "  flag = " << flag
              << "  bitsForTableIdentifier = " << bitsForTableIdentifier
              << std::endl;

  const uint32_t maxTableSize = calcMaxTableSize(numberOfRows, posInRowVector, tables);
  const uint32_t TWO_BYTE_MAX = (1 << (16-bitsForTableIdentifier))-1;

  return TWO_BYTE_MAX >= maxTableSize ? 0 : flag;
}


inline
uint64_t
uses4byteIndex(const std::vector<uint32_t>& numberOfRows, const std::vector<int8_t>& posInRowVector, uint64_t flag)
{
  return uses4byteIndex(numberOfRows, posInRowVector, REF_TABLES.at(flag), flag);
}


uint64_t
computeDataSizeFlags( uint8_t heapSizes,
                      const std::vector<int8_t>& posInRowVector,
                      const std::vector<uint32_t>& numberOfRows
                    )
{
  // the lower three flags are taken from the heapSizes field
  uint64_t            res = heapSizes;

  //   - single table references (constants are arbitrary)
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_assembly_ref);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_type_def);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_event);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_field);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_generic_param);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_method_def);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_module_ref);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_param);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_property);

  //   - multi table references (constants are arbitrary)
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_has_constant);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_has_custom_attribute);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_has_decl_security);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_has_field_marshall);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_has_semantics);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_method_def_or_ref);

  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_type_def_or_ref);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_implementation);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_member_forwarded);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_member_ref_parent);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_type_or_method_def);

  //   - not used from inside the metadata tables
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_custom_attribute_type);
  res |= uses4byteIndex(numberOfRows, posInRowVector, SgAsmCilMetadataHeap::e_ref_resolution_scope);

  return res;
}

struct AccessTuple : std::tuple<uint8_t, std::uint32_t>
{
  using base = std::tuple<uint8_t, std::uint32_t>;
  using base::base;

  std::uint8_t  table() const { return std::get<0>(*this); }
  std::uint32_t index() const { return std::get<1>(*this); }
};

AccessTuple
computeAccessPair( const std::vector<int8_t>& posInRowVector,
                   const std::vector<uint32_t>& numberOfRows,
                   std::uint32_t refcode,
                   SgAsmCilMetadataHeap::ReferenceKind knd
                 )
{
  const std::vector<uint8_t>& tables = REF_TABLES.at(knd);

  if (tables.size() == 1) return AccessTuple{ tables.front(), refcode };

  const bool                  uses4Bytes = uses4byteIndex(numberOfRows, posInRowVector, tables, knd) != 0;

  ROSE_ASSERT(uses4Bytes || (refcode < (1<<16)));

  const std::uint8_t          idxLen = uses4Bytes ? 32 : 16;
  const std::uint64_t         tableIdSize = calcTableIdentifierSize(tables);

  ROSE_ASSERT(idxLen > tableIdSize);
  const std::uint8_t          numShifts = (idxLen-tableIdSize);
  const std::uint8_t          table = refcode >> numShifts;
  const std::uint32_t         index = refcode ^ (table << numShifts);

  return AccessTuple{ table, index };
}


template <class SageAsmCilMetadata>
std::vector<SageAsmCilMetadata*>
parseMetadataTable( SgAsmCilMetadataHeap* parent,
                    std::vector<uint8_t>& buf,
                    size_t& index,
                    uint64_t sizeFlags,
                    size_t rows,
                    const char* tblName
                  )
{
  std::vector<SageAsmCilMetadata*> res;

  if (TRACE_CONSTRUCTION)
    std::cerr << "Build the e_" << tblName << " table; rows = " << rows << std::endl;

  for (size_t j=0; j < rows; ++j)
  {
    if (TRACE_CONSTRUCTION)
      std::cerr << " --- processing row j = " << j << std::endl;

    SageAsmCilMetadata* obj = parseAsmCilNode<SageAsmCilMetadata>(parent,buf,index,sizeFlags);
    res.push_back(obj);

    if (TRACE_CONSTRUCTION)
      std::cerr << "DONE: processing row j = " << j << std::endl;
  }

  if (TRACE_CONSTRUCTION)
    std::cerr << "DONE: Build the e_" << tblName << " table; rows = " << rows << std::endl;

  return res;
}

template <class T>
T traceRep(const T& el) { return el; }

template <class T>
int traceRep(const std::vector<T>& vec) { return vec.size(); }

}


void SgAsmCilMetadataHeap::parse(std::vector<uint8_t>& buf, size_t startOfMetaData)
{
  const uint32_t ofs = get_Offset();

  if (TRACE_CONSTRUCTION)
    printf ("In MetadataTable constructor: buf = 0x%" PRIxPTR ", index = %zu, offset = %" PRIu32 "\n",(uintptr_t)buf.data(),startOfMetaData,ofs);

  size_t index = startOfMetaData + ofs;

%%forall Fields%%
  p_%%Fields.Name%% = %%Fields.Init%%;

  if (TRACE_CONSTRUCTION)
    std::cerr << "%%Fields.Name%% = " << traceRep(p_%%Fields.Name%%) << std::endl;
%%end_for%%

  if (TRACE_CONSTRUCTION)
    std::cerr << "Build the tables: " << std::endl;

  for (size_t kind = 0; kind < posInRowVector.size(); ++kind)
  {
    const int    tblpos = posInRowVector[kind];
    if (tblpos < 0) continue;

    const size_t rows = p_NumberOfRows.at(tblpos);

    // Build the associated table.
    switch (kind)
    {
      %%forall Tables%%
      case e_%%Tables.Name%%:
        p_%%Tables.Name%% = parseMetadataTable<%%Tables.Type%%>(this, buf, index, get_DataSizeFlags(), rows, "%%Tables.Name%%");
        break;
      %%end_for%%
      default:
        std::cerr << "default reached:\n"
                  << "parsing not implemented for kind = " << kind << table_kind_to_string(MetaDataHeapTableKinds(kind))
                  << std::endl;
        ROSE_ABORT();
        break;
    }
  }
}

SgAsmCilMetadata*
SgAsmCilMetadataHeap::get_MetadataNode(std::uint32_t refcode, ReferenceKind knd) const
{
  SgAsmCilMetadata*   res    = nullptr;

  // FIXME: maybe cache result in static or in the object if this turns out to be slow
  std::vector<std::int8_t> posInRow = computePositionInRowVector(get_Valid());
  const AccessTuple        access = computeAccessPair(posInRow, get_NumberOfRows(), refcode, knd);
  const std::uint32_t      index  = access.index();

  switch (access.table())
  {
    %%forall Tables%%
    case e_%%Tables.Name%%:
      res = get_%%Tables.Name%%().at(index);
      break;
    %%end_for%%

    default: ;
  }

  ASSERT_not_null(res);
  return res;
}

////// end from metadataHeap_C.txt
