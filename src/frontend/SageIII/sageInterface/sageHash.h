#ifndef ROSE_sageHash_H
#define ROSE_sageHash_H
// [Robb Matzke 2024-03-12]: This was copied here from src/ROSETTA/Grammar/Node.code because it doesn't need to be generated by
// ROSETTA since it doesn't depend on any of the CxxGrammarMetaProgram inputs.

#include <boost/unordered_map.hpp>
#include <boost/unordered_set.hpp>

// DQ (11/4/2009): Trying to use the boost hash_map support
namespace rose_hash
   {
  // The condition here is not needed for GCC 4.2, but is needed (and does not completely work) for earlier versions
     using boost::unordered_map;
     using boost::unordered_multimap;
     using boost::unordered_set;
     using boost::hash;

  // DQ (4/23/2009): These should be put into this namespace so that we don't contaminate the global scope.
  // DQ (8/19/2008): This is already defined in src/frontend/SageIII/astMerge/buildMangledNameMap.h
     struct eqstr_string
        {
          bool operator()(const std::string & s1, const std::string & s2) const
             {
               return s1 == s2;
             }
        };

/*! \brief Hash name support for symbol tables within ROSE.
 */
     struct hash_integer
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const int n) const
             {
               return n;
             }
        };

     struct hash_integer_pair
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const std::pair<int,int> & p) const
             {
            // DQ (4/30/2009): This subject should be reviewed!
            // Since this is a hash function, it might not a problem if we have
            // overflow (also the values should not be so large as to be a problem).
               return p.first+p.second;
             }
        };

  // DQ (4/30/2009): This might already exist for std::pair<>
     struct eqstr_integer_pair
        {
          bool operator()(const std::pair<int,int> & p1, const std::pair<int,int> & p2) const
             {
               return (p1.first == p2.first) && (p1.second == p2.second);
             }
        };

     struct eqstr_graph_node
        {
          bool operator()(const SgGraphNode* p1, const SgGraphNode* p2) const
             {
               return p1 == p2;
             }
        };

     struct eqstr_graph_edge
        {
          bool operator()(const SgGraphNode* p1, const SgGraphNode* p2) const
             {
               return p1 == p2;
             }
        };

     struct hash_graph_node
        {
       // tps (11/17/2009) : Changed this so that it works under Windows.
       // CH (4/9/2010): Use boost::hash instead
          size_t operator()(const SgGraphNode* ptr) const
             {
               return (size_t) ptr;
             }
        };
   }


/*! \brief Hash table support for graph IR nodes within ROSE (uses strings to lookup nodes).
 */

// DQ (8/19/2008): Note that "rose_hash" is a namespace defined above.
// class rose_hash_multimap : public rose_hash::unordered_multimap<SgName, SgSymbol*, hash_Name, eqstr>
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<std::string, SgGraphNode*> rose_graph_string_node_hash_multimap_base_type;

class rose_graph_string_node_hash_multimap : public rose_graph_string_node_hash_multimap_base_type
   {
  // Need to document why we are using hash_multimap type here.  Why a hash (obvious), then why a multimap?
  // I think a multimap is used to support having no names on the nodes if they are unlabeled.  If the
  // nodes are labled then operations on the labled edges are possible using the multimap.  But is there
  // a performance trade-off for these choices?

     protected:

       // DQ (4/25/2009): We need to change this name since I think we just want the
       // associated IR node in the AST, and not any concept of parent in the graph.
          SgNode* parent;

     public:
          rose_graph_string_node_hash_multimap()
             : rose_graph_string_node_hash_multimap_base_type(), parent(nullptr)
             {}
                         // tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
          rose_graph_string_node_hash_multimap(const rose_graph_string_node_hash_multimap & rhs)
             : rose_graph_string_node_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}
       // See note (above) about name change to the associated data member for these access functions.
          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_string_node_hash_multimap()
             {
               delete_elements();

               parent = nullptr;
             }


        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_string_node_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_string_node_hash_multimap::iterator & rhm_it );

// DQ (5/1/2009): Temporary typedef to use older name for compatability.
typedef rose_graph_string_node_hash_multimap rose_graph_hash_multimap;



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using nodes).

    \internal This class is depricated and it's functionality will be produced using two other hash maps.
 */

// DQ (4/29/2009): Added to support ROSE Graph IR nodes
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<SgGraphNode*, SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node> rose_graph_node_edge_hash_multimap_base_type;
class rose_graph_node_edge_hash_multimap : public rose_graph_node_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
          SgNode * parent;

     public:
          rose_graph_node_edge_hash_multimap()
             : rose_graph_node_edge_hash_multimap_base_type()
             {}
         // tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
          rose_graph_node_edge_hash_multimap(const rose_graph_node_edge_hash_multimap& rhs)
          // DQ (4/30/2009): This fixed a problem reported by Thomas Panas relative to seg-faults when using the copy constructor (forced his code to use references).
          // : rose_hash::unordered_multimap<SgGraphNode*, SgGraphEdge*, rose_hash::hash_graph_node, rose_hash::eqstr_graph_node>((rose_graph_node_edge_hash_multimap)rhs)
             : rose_graph_node_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_node_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_node_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_node_edge_hash_multimap::iterator & rhm_it );


/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup nodes using node index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphNode*, rose_hash::hash_integer, rose_hash::eqstr_graph_node> rose_graph_integer_node_hash_map_base_type
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_map<int, SgGraphNode*, rose_hash::hash_integer> rose_graph_integer_node_hash_map_base_type;
class rose_graph_integer_node_hash_map : public rose_graph_integer_node_hash_map_base_type
   {
     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_node_hash_map()
             : rose_graph_integer_node_hash_map_base_type()
             {}
// tps (11/18/2009) : Is this constructor wrong? Should it be a pair of (int,SgGraphNode)?
          rose_graph_integer_node_hash_map(const rose_graph_integer_node_hash_map& rhs)
             : rose_graph_integer_node_hash_map_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_node_hash_map()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_node_hash_map*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_node_hash_map::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using edge index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer, rose_hash::eqstr_graph_edge> rose_graph_integer_edge_hash_map_base_type;
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer> rose_graph_integer_edge_hash_map_base_type;
class rose_graph_integer_edge_hash_map : public rose_graph_integer_edge_hash_map_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_edge_hash_map()
             : rose_graph_integer_edge_hash_map_base_type()
             {}
          rose_graph_integer_edge_hash_map(const rose_graph_integer_edge_hash_map& rhs)
             : rose_graph_integer_edge_hash_map_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_edge_hash_map()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_edge_hash_map*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_edge_hash_map::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using edge index values).
 */

// DQ (4/30/2009): Added to support more of the Graph functionality in new ROSE IR nodes
// typedef rose_hash::unordered_map<int,SgGraphEdge*, rose_hash::hash_integer, rose_hash::eqstr_graph_edge> rose_graph_integer_edge_hash_multimap_base_type;

typedef rose_hash::unordered_multimap<int,SgGraphEdge*> rose_graph_integer_edge_hash_multimap_base_type;
class rose_graph_integer_edge_hash_multimap : public rose_graph_integer_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integer_edge_hash_multimap()
             : rose_graph_integer_edge_hash_multimap_base_type()
             {}
          rose_graph_integer_edge_hash_multimap(const rose_graph_integer_edge_hash_multimap& rhs)
             : rose_graph_integer_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integer_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integer_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integer_edge_hash_multimap::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup edges using node index pairs).
 */
typedef rose_hash::unordered_multimap<std::pair<int,int>,SgGraphEdge*, rose_hash::hash_integer_pair> rose_graph_integerpair_edge_hash_multimap_base_type;
class rose_graph_integerpair_edge_hash_multimap : public rose_graph_integerpair_edge_hash_multimap_base_type
   {
  // This class is used to map nodes to edges in the highest level graph class.
  // Different graph classes derived from the SgGraph class contain additional
  // maps that contain specific types of edges.

     protected:
       // I think this is required by the AST file I/O support.
          SgNode * parent;

     public:
          rose_graph_integerpair_edge_hash_multimap()
             : rose_graph_integerpair_edge_hash_multimap_base_type()
             {}
          rose_graph_integerpair_edge_hash_multimap(const rose_graph_integerpair_edge_hash_multimap& rhs)
             : rose_graph_integerpair_edge_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_integerpair_edge_hash_multimap()
             {
               delete_elements();
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_integerpair_edge_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_integerpair_edge_hash_multimap::iterator & rhm_it );



/*! \brief Hash table support for graph IR nodes within ROSE (used to lookup nodes and edges index values from lables).
 */

// DQ (5/1/2009): This is added to support lookup of indexes based on labels (can be used for nodes or edges).
// tps (11/18/2009) : This cannot be correct since the constructor takes a string not an int.
// CH (4/9/2010): Use boost::unordered instead
typedef rose_hash::unordered_multimap<std::string, int> rose_graph_string_integer_hash_multimap_base_type;
class rose_graph_string_integer_hash_multimap : public rose_graph_string_integer_hash_multimap_base_type
   {
     protected:
       // DQ (4/25/2009): We need to change this name since I think we just want the
       // associated IR node in the AST, and not any concept of parent in the graph.
          SgNode* parent;

     public:
          rose_graph_string_integer_hash_multimap()
             : rose_graph_string_integer_hash_multimap_base_type(), parent(nullptr)
             {}
          rose_graph_string_integer_hash_multimap(const rose_graph_string_integer_hash_multimap & rhs)
             : rose_graph_string_integer_hash_multimap_base_type(rhs),parent(rhs.parent)
             {}

       // See note (above) about name change to the associated data member for these access functions.
          void set_parent(SgNode * new_parent)
             {
               parent = new_parent;
             }
          SgNode * get_parent()
             {
               return parent;
             }

          void delete_elements()
             {
             }

         ~rose_graph_string_integer_hash_multimap()
             {
               delete_elements();

               parent = nullptr;
             }

        friend class AST_FILE_IO;
        friend class SgSymbolTableStorageClass;
        friend class EasyStorage<rose_graph_string_integer_hash_multimap*>;
   };

std::ostream & operator<< ( std::ostream & os, const rose_graph_string_integer_hash_multimap::iterator & rhm_it );

#endif
