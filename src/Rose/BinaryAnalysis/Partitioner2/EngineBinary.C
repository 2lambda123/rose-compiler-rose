#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <sage3basic.h>

#include <Rose/BinaryAnalysis/BinaryLoader.h>
#include <Rose/BinaryAnalysis/Debugger/Linux.h>
#include <Rose/BinaryAnalysis/Disassembler/M68k.h>
#include <Rose/BinaryAnalysis/Disassembler/Mips.h>
#include <Rose/BinaryAnalysis/Disassembler/Powerpc.h>
#include <Rose/BinaryAnalysis/Disassembler/X86.h>
#include <Rose/BinaryAnalysis/MemoryMap.h>
#include <Rose/BinaryAnalysis/Partitioner2/BasicBlock.h>
#include <Rose/BinaryAnalysis/Partitioner2/DataBlock.h>
#include <Rose/BinaryAnalysis/Partitioner2/EngineBinary.h>
#include <Rose/BinaryAnalysis/Partitioner2/Function.h>
#include <Rose/BinaryAnalysis/Partitioner2/Modules.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesElf.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesLinux.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesM68k.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesMips.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesPe.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesPowerpc.h>
#include <Rose/BinaryAnalysis/Partitioner2/ModulesX86.h>
#include <Rose/BinaryAnalysis/Partitioner2/Partitioner.h>
#include <Rose/BinaryAnalysis/Partitioner2/Semantics.h>
#include <Rose/BinaryAnalysis/Partitioner2/Thunk.h>
#include <Rose/BinaryAnalysis/Partitioner2/Utility.h>
#include <Rose/BinaryAnalysis/SerialIo.h>
#include <Rose/BinaryAnalysis/SRecord.h>
#include <Rose/BinaryAnalysis/SymbolicExpression.h>
#include <Rose/CommandLine.h>
#include <Rose/Diagnostics.h>
#include <Rose/Progress.h>

#include <AsmUnparser_compat.h>
#include <BinaryVxcoreParser.h>
#include <boost/algorithm/string/classification.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/filesystem.hpp>
#include <boost/format.hpp>
#include <boost/regex.hpp>
#include <rose_getline.h>
#include <rose_strtoull.h>
#include <Sawyer/FileSystem.h>
#include <Sawyer/GraphAlgorithm.h>
#include <Sawyer/GraphTraversal.h>
#include <Sawyer/Stopwatch.h>

#ifdef ROSE_HAVE_YAMLCPP
#include <yaml-cpp/yaml.h>
#endif

using namespace Rose::Diagnostics;

namespace Rose {
namespace BinaryAnalysis {
namespace Partitioner2 {

EngineBinary::EngineBinary(const std::string &name)
    : Engine{name} {
}

EngineBinary::EngineBinary(const Settings &settings)
    : Engine{settings} {
    init();
}

EngineBinary::~EngineBinary() {}

EngineBinaryPtr
EngineBinary::instance() {
    return EngineBinaryPtr(new EngineBinary(Settings{}));
}

EngineBinary::EngineBinaryPtr
EngineBinary::factory() {
    return EngineBinaryPtr(new EngineBinary("EngineBinary"));
}

bool
EngineBinary::matchFactory(const std::vector<std::string> &specimen) const {
    // EngineBinary is the default, return false if the specimen contains any JVM files
    for (auto file: specimen) {
        if (CommandlineProcessing::isJavaJvmFile(file)) {
            return false;
        }
    }
    return true;
}

Engine::Ptr
EngineBinary::instanceFromFactory() {
    ASSERT_require(isFactory());
    return instance();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Utility functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void
EngineBinary::init() {
    functionMatcherThunks_ = ThunkPredicates::functionMatcherThunks();
    functionSplittingThunks_ = ThunkPredicates::allThunks();
}

void
EngineBinary::reset() {
    binaryLoader_ = BinaryLoader::Ptr();
}

// Returns true if the specified vertex has at least one E_CALL_RETURN edge
static bool
hasCallReturnEdges(const ControlFlowGraph::ConstVertexIterator &vertex) {
    for (const ControlFlowGraph::Edge &edge: vertex->outEdges()) {
        if (edge.value().type() == E_CALL_RETURN)
            return true;
    }
    return false;
}

// True if any callee may-return is positive; false if all callees are negative; indeterminate if any are indeterminate
static boost::logic::tribool
hasAnyCalleeReturn(const Partitioner::ConstPtr &partitioner, const ControlFlowGraph::ConstVertexIterator &caller) {
    ASSERT_not_null(partitioner);
    bool hasIndeterminateCallee = false;
    for (ControlFlowGraph::ConstEdgeIterator edge=caller->outEdges().begin(); edge != caller->outEdges().end(); ++edge) {
        if (edge->value().type() == E_FUNCTION_CALL) {
            bool mayReturn = false;
            if (!partitioner->basicBlockOptionalMayReturn(edge->target()).assignTo(mayReturn)) {
                hasIndeterminateCallee = true;
            } else if (mayReturn) {
                return true;
            }
        }
    }
    if (hasIndeterminateCallee)
        return boost::logic::indeterminate;
    return false;
}

// Increment the address as far as possible while avoiding overflow.
static rose_addr_t
incrementAddress(rose_addr_t va, rose_addr_t amount, rose_addr_t maxaddr) {
    if (maxaddr - va < amount)
        return maxaddr;
    return va + amount;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Top-level, do everything functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SgAsmBlock*
EngineBinary::frontend(const std::vector<std::string> &args, const std::string &purpose, const std::string &description) {
    try {
        std::vector<std::string> specimenNames = parseCommandLine(args, purpose, description).unreachedArgs();
        if (specimenNames.empty())
            throw std::runtime_error("no binary specimen specified; see --help");
        return buildAst(specimenNames);
    } catch (const std::runtime_error &e) {
        if (settings().engine.exitOnError) {
            mlog[FATAL] <<e.what() <<"\n";
            exit(1);
        } else {
            throw;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Command-line parsing
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Binary container parsing
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

bool
EngineBinary::isNonContainer(const std::string &name) {
    return (boost::starts_with(name, "map:")  ||        // map file directly into MemoryMap
            boost::starts_with(name, "data:") ||        // map data directly into MemoryMap
            boost::starts_with(name, "proc:") ||        // map process memory into MemoryMap
            boost::starts_with(name, "run:")  ||        // run a process in a debugger, then map into MemoryMap
            boost::starts_with(name, "srec:") ||        // Motorola S-Record format
            boost::ends_with(name, ".srec")   ||        // Motorola S-Record format
            boost::starts_with(name, "vxcore:") ||      // Jim Lee's format of a VxWorks core dump
            boost::starts_with(name, "meta:") ||        // Adjust meta information about the map
            isRbaFile(name));                           // ROSE Binary Analysis file
}

bool
EngineBinary::areContainersParsed() const {
    return interpretation() != nullptr;
}

SgAsmInterpretation*
EngineBinary::parseContainers(const std::vector<std::string> &fileNames) {
    try {
        interpretation(nullptr);
        memoryMap(MemoryMap::Ptr());
        checkSettings();

        // Prune away things we recognize as not being binary containers.
        std::vector<boost::filesystem::path> containerFiles;
        for (const std::string &fileName: fileNames) {
            if (boost::starts_with(fileName, "run:") && fileName.size()>4) {
                static size_t colon1 = 3;
                size_t colon2 = fileName.find(':', colon1+1);
                if (colon2 == std::string::npos) {
                    // [Robb Matzke 2017-07-24]: deprecated: use two colons for consistency with other schemas
                    containerFiles.push_back(fileName.substr(colon1+1));
                } else {
                    containerFiles.push_back(fileName.substr(colon2+1));
                }
            } else if (!isNonContainer(fileName)) {
                containerFiles.push_back(fileName);
            }
        }

        // Try to link all the .o and .a files
        bool linkerFailed = false;
        Sawyer::FileSystem::TemporaryFile linkerOutput;
        if (!settings().loader.linker.empty()) {
            std::vector<boost::filesystem::path> filesToLink, nonLinkedFiles;
            for (const boost::filesystem::path &file: containerFiles) {
                if (settings().loader.linkObjectFiles && ModulesElf::isObjectFile(file)) {
                    filesToLink.push_back(file);
                } else if (settings().loader.linkStaticArchives && ModulesElf::isStaticArchive(file)) {
                    filesToLink.push_back(file);
                } else {
                    nonLinkedFiles.push_back(file);
                }
            }
            if (!filesToLink.empty()) {
                linkerOutput.stream().close();          // will be written by linker command
                if (ModulesElf::tryLink(settings().loader.linker, linkerOutput.name().string(), filesToLink, mlog[WARN])) {
                    containerFiles = nonLinkedFiles;
                    containerFiles.push_back(linkerOutput.name().string());
                } else {
                    mlog[ERROR] <<"linking objects and/or archives failed; falling back to internal (incomplete) linker\n";
                    filesToLink.clear();
                    linkerFailed = true;
                }
            }
        }

        // If we have *.a files that couldn't be linked, extract all their members and replace the archive file with the list
        // of object files.
        Sawyer::FileSystem::TemporaryDirectory tempDir;
        if (linkerFailed) {
            std::vector<boost::filesystem::path> expandedList;
            for (const boost::filesystem::path &file: containerFiles) {
                if (ModulesElf::isStaticArchive(file)) {
                    std::vector<boost::filesystem::path> objects = ModulesElf::extractStaticArchive(tempDir.name(), file);
                    if (objects.empty())
                        mlog[WARN] <<"empty static archive \"" <<StringUtility::cEscape(file.string()) <<"\"\n";
                    for (const boost::filesystem::path &objectFile: objects)
                        expandedList.push_back(objectFile.string());
                } else {
                    expandedList.push_back(file);
                }
            }
            containerFiles = expandedList;
        }

        // Process through ROSE's frontend()
        if (!containerFiles.empty()) {
            SgProject *project = roseFrontendReplacement(containerFiles);
            ASSERT_not_null(project);                       // an exception should have been thrown

            std::vector<SgAsmInterpretation*> interps = SageInterface::querySubTree<SgAsmInterpretation>(project);
            if (interps.empty())
                throw std::runtime_error("a binary specimen container must have at least one SgAsmInterpretation");
            interpretation(interps.back());    // windows PE is always after DOS
            ASSERT_require(areContainersParsed());
        }

        ASSERT_require(!areSpecimensLoaded());
        return interpretation();
    } catch (const std::runtime_error &e) {
        if (settings().engine.exitOnError) {
            mlog[FATAL] <<e.what() <<"\n";
            exit(1);
        } else {
            throw;
        }
    }
}

// Replacement for ::frontend, which is a complete mess, in order create a project containing multiple files. Nothing
// special happens to any of the input file names--that should have already been done by this point. All the fileNames
// are expected to be names of existing container (ELF, PE, etc) files that will result in an AST (non-container files
// typically are loaded into virtual memory and have no AST since they have very little structure).
SgProject *
EngineBinary::roseFrontendReplacement(const std::vector<boost::filesystem::path> &fileNames) {
    ASSERT_forbid(fileNames.empty());

    // Create the SgAsmGenericFiles (not a type of SgFile), one per fileName, and add them to a SgAsmGenericFileList node. Each
    // SgAsmGenericFile has one or more file headers (e.g., ELF files have one, PE files have two).
    SgAsmGenericFileList *fileList = new SgAsmGenericFileList;
    for (const boost::filesystem::path &fileName: fileNames) {
        SAWYER_MESG(mlog[TRACE]) <<"parsing " <<fileName <<"\n";
        SgAsmGenericFile *file = SgAsmExecutableFileFormat::parseBinaryFormat(fileName.string().c_str());
        ASSERT_not_null(file);
#ifdef ROSE_HAVE_LIBDWARF
        readDwarf(file);
#endif
        fileList->get_files().push_back(file);
        file->set_parent(fileList);
    }
    SAWYER_MESG(mlog[DEBUG]) <<"parsed " <<StringUtility::plural(fileList->get_files().size(), "container files") <<"\n";


    // DQ (11/25/2020): Add support to set this as a binary file (there is at least one binary file processed by ROSE).
    Rose::is_binary_executable = true;

    // The SgBinaryComposite (type of SgFile) points to the list of SgAsmGenericFile nodes created above.
    // FIXME[Robb Matzke 2019-01-29]: The defaults set here should be set in the SgBinaryComposite constructor instead.
    // FIXME[Robb Matzke 2019-01-29]: A SgBinaryComposite represents many files, not just one, so some of these settings
    //                                don't make much sense.
    SgBinaryComposite *binaryComposite = new SgBinaryComposite;
    binaryComposite->initialization(); // SgFile::initialization
    binaryComposite->set_skipfinalCompileStep(true);
    binaryComposite->set_genericFileList(fileList); fileList->set_parent(binaryComposite);
    binaryComposite->set_sourceFileUsesBinaryFileExtension(true);
    binaryComposite->set_outputLanguage(SgFile::e_Binary_language);
    binaryComposite->set_inputLanguage(SgFile::e_Binary_language);
    binaryComposite->set_binary_only(true);
    binaryComposite->set_requires_C_preprocessor(false);
    //binaryComposite->set_isObjectFile(???) -- makes no sense since the composite can be multiple files of different types
    binaryComposite->set_sourceFileNameWithPath(boost::filesystem::absolute(fileNames[0]).string()); // best we can do
    binaryComposite->set_sourceFileNameWithoutPath(fileNames[0].filename().string());                // best we can do
    binaryComposite->initializeSourcePosition(fileNames[0].string());                                // best we can do
    binaryComposite->set_originalCommandLineArgumentList(std::vector<std::string>(1, fileNames[0].string())); // best we can do
    ASSERT_not_null(binaryComposite->get_file_info());

    // Create one or more SgAsmInterpretation nodes. If all the SgAsmGenericFile objects are ELF files, then there's one
    // SgAsmInterpretation that points to them all. If all the SgAsmGenericFile objects are PE files, then there's two
    // SgAsmInterpretation nodes: one for all the DOS parts of the files, and one for all the PE parts of the files.
    std::vector<std::pair<SgAsmExecutableFileFormat::ExecFamily, SgAsmInterpretation*>> interpretations;
    for (SgAsmGenericFile *file: fileList->get_files()) {
        SgAsmGenericHeaderList *headerList = file->get_headers();
        ASSERT_not_null(headerList);
        for (SgAsmGenericHeader *header: headerList->get_headers()) {
            SgAsmGenericFormat *format = header->get_exec_format();
            ASSERT_not_null(format);

            // Find or create the interpretation that holds this family of headers.
            SgAsmInterpretation *interpretation = nullptr;
            for (size_t i = 0; i < interpretations.size() && !interpretation; ++i) {
                if (interpretations[i].first == format->get_family())
                    interpretation = interpretations[i].second;
            }
            if (!interpretation) {
                interpretation = new SgAsmInterpretation;
                interpretations.push_back(std::make_pair(format->get_family(), interpretation));
            }

            // Add the header to the interpretation. This isn't an AST parent/child link, so don't set the parent ptr.
            SgAsmGenericHeaderList *interpHeaders = interpretation->get_headers();
            ASSERT_not_null(interpHeaders);
            interpHeaders->get_headers().push_back(header);
        }
    }
    SAWYER_MESG(mlog[DEBUG]) <<"created " <<StringUtility::plural(interpretations.size(), "interpretation nodes") <<"\n";

    // Put all the interpretations in a list
    SgAsmInterpretationList *interpList = new SgAsmInterpretationList;
    for (size_t i=0; i<interpretations.size(); ++i) {
        SgAsmInterpretation *interpretation = interpretations[i].second;
        interpList->get_interpretations().push_back(interpretation);
        interpretation->set_parent(interpList);
    }
    ASSERT_require(interpList->get_interpretations().size() == interpretations.size());

    // Add the interpretation list to the SgBinaryComposite node
    binaryComposite->set_interpretations(interpList);
    interpList->set_parent(binaryComposite);

    // The project
    SgProject *project = new SgProject;
    project->get_fileList().push_back(binaryComposite);
    binaryComposite->set_parent(project);

    return project;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Memory map creation (loading)
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BinaryLoader::Ptr
EngineBinary::obtainLoader(const BinaryLoader::Ptr &hint) {
    if (!binaryLoader_ && interpretation()) {
        if ((binaryLoader_ = BinaryLoader::lookup(interpretation()))) {
            binaryLoader_ = binaryLoader_->clone();
        }
    }

    if (!binaryLoader_ && hint)
        binaryLoader_ = hint;

    if (!binaryLoader_)
        throw std::runtime_error("no binary loader found and none specified");

    return binaryLoader_;
}

BinaryLoader::Ptr
EngineBinary::obtainLoader() {
    return obtainLoader(BinaryLoader::Ptr());
}

void
EngineBinary::loadContainers(const std::vector<std::string> &fileNames) {
    // Load the interpretation if it hasn't been already
    if (interpretation() && (!interpretation()->get_map() || interpretation()->get_map()->isEmpty())) {
        obtainLoader();
        binaryLoader_->load(interpretation());
    }

    // Get a map from the now-loaded interpretation, or use an empty map if the interp isn't mapped
    memoryMap(MemoryMap::instance());
    if (interpretation() && interpretation()->get_map()) {
        *memoryMap() = *interpretation()->get_map();
    }
}

void
EngineBinary::loadNonContainers(const std::vector<std::string> &fileNames) {
    MemoryMap::Ptr map = memoryMap();
    ASSERT_not_null(map);
    for (const std::string &fileName: fileNames) {
        if (boost::starts_with(fileName, "map:")) {
            std::string resource = fileName.substr(3);  // remove "map", leaving colon and rest of string
            map->insertFile(resource);
        } else if (boost::starts_with(fileName, "data:")) {
            std::string resource = fileName.substr(4);  // remove "data", leaving colon and the rest of the string
            map->insertData(resource);
        } else if (boost::starts_with(fileName, "meta:")) {
            std::string resource = fileName.substr(4);  // "remove "meta", leaving the colon and the rest of the string
            map->adjustMap(resource);
        } else if (boost::starts_with(fileName, "proc:")) {
            std::string resource = fileName.substr(4);  // remove "proc", leaving colon and the rest of the string
            map->insertProcess(resource);
        } else if (boost::starts_with(fileName, "run:")) {
            // Split resource as "run:OPTIONS:EXECUTABLE"
#ifdef ROSE_ENABLE_DEBUGGER_LINUX
            static const size_t colon1 = 3;             // index of first colon in fileName
            const size_t colon2 = fileName.find(':', colon1+1); // index of second colon in FileName
            if (std::string::npos == colon2)
                throw Rose::Exception("two colons are required in \"run\" resource \"" + StringUtility::cEscape(fileName) + "\"");
            std::string optionsStr = fileName.substr(colon1+1, colon2-(colon1+1)); // between the first two colons
            std::string exeName = fileName.substr(colon2+1);                       // after the second colon

            // Parse options
            bool doReplace = false;                                                // "replace" word was present?
            bool aslr = false;                                                     // allow address space layout randomization?
            std::vector<std::string> options;
            boost::split(options, optionsStr, boost::is_any_of(","));
            for (const std::string &option: options) {
                if (option.empty()) {
                } else if ("replace" == option) {
                    doReplace = true;
                } else if ("aslr" == option) {
                    aslr = true;
                } else if ("noaslr" == option) {
                    aslr = false;
                } else {
                    throw Rose::Exception("option \"" + StringUtility::cEscape(option) + "\" not recognized"
                                          " in resource \"" + StringUtility::cEscape(fileName) + "\"");
                }
            }

            Debugger::Linux::Specimen subordinate(exeName);
            subordinate.flags()
                .set(Debugger::Linux::Flag::CLOSE_FILES)
                .set(Debugger::Linux::Flag::REDIRECT_INPUT)
                .set(Debugger::Linux::Flag::REDIRECT_OUTPUT)
                .set(Debugger::Linux::Flag::REDIRECT_ERROR);
            subordinate.randomizedAddresses(aslr);

            for (const std::string &name: settings().loader.envEraseNames)
                subordinate.eraseEnvironmentVariable(name);
            for (const boost::regex &re: settings().loader.envErasePatterns)
                subordinate.eraseMatchingEnvironmentVariables(re);
            for (const std::string &var: settings().loader.envInsert) {
                size_t eq = var.find('=');
                if (std::string::npos == eq)
                    throw std::runtime_error("no '=' in NAME=VALUE: \"" + StringUtility::cEscape(var) + "\"");
                if (eq == 0)
                    throw std::runtime_error("empty name in NAME=VALUE: \"" + StringUtility::cEscape(var) + "\"");
                subordinate.insertEnvironmentVariable(var.substr(0, eq), var.substr(eq+1));
            }
            auto debugger = Debugger::Linux::instance(subordinate);

            // Set breakpoints for all executable addresses in the memory map created by the Linux kernel. Since we're doing
            // this before the first instruction executes, no shared libraries have been loaded yet. However, the dynamic
            // linker itself is present as are the vdso and vsyscall segments.  We don't want to set breakpoints in anything
            // that the dynamic linker might call because the whole purpose of the "run:" URL is to get an accurate memory map
            // of the process after shared libraries are loaded. We assume that the kernel has loaded the executable at the
            // lowest address.
            MemoryMap::Ptr procMap = MemoryMap::instance();
            procMap->insertProcess(*debugger->processId(), MemoryMap::Attach::NO);
            procMap->require(MemoryMap::EXECUTABLE).keep();
            if (procMap->isEmpty())
                throw std::runtime_error(exeName + " has no executable addresses");
            std::string name = procMap->segments().begin()->name(); // lowest segment is always part of the main executable
            for (const MemoryMap::Node &node: procMap->nodes()) {
                if (node.value().name() == name)        // usually just one match; names are like "proc:123(/bin/ls)"
                    debugger->setBreakPoint(node.key());
            }

            debugger->runToBreakPoint(Debugger::ThreadId::unspecified());
            if (debugger->isTerminated())
                throw std::runtime_error(exeName + " " + debugger->howTerminated() + " without reaching a breakpoint");
            if (doReplace)
                map->clear();
            map->insertProcess(*debugger->processId(), MemoryMap::Attach::NO);
            debugger->terminate();
#else
            throw std::runtime_error("\"run:\" loader schema is not available in this configuration of ROSE");
#endif
        } else if (boost::starts_with(fileName, "srec:") || boost::ends_with(fileName, ".srec")) {
            std::string resource;                       // name of file to open
            unsigned perms = MemoryMap::READABLE | MemoryMap::WRITABLE | MemoryMap::EXECUTABLE;

            if (boost::starts_with(fileName, "srec:")) {
                // Format is "srec:[=PERMS]:FILENAME" where PERMS are the letters "r", "w", and/or "x"
                std::vector<std::string> parts = StringUtility::split(":", fileName, 3);
                if (parts.size() != 3)
                    throw std::runtime_error("second ':' expected in \"srec\" URI (expected \"srec:[=PERMS]:FILENAME\")");
                resource = parts[2];

                // Permissions, like "=rw". Lack of '=...' means default permissions; nothing after '=' means no permissions
                // (e.g., "srec:=:filename").
                if (!parts[1].empty()) {
                    if ('=' != parts[1][0])
                        throw std::runtime_error("expected \"=PERMS\" in \"srec:\" URI");
                    perms = 0;
                    for (size_t i=1; i<parts[1].size(); ++i) {
                        switch (parts[1][i]) {
                            case 'r': perms |= MemoryMap::READABLE; break;
                            case 'w': perms |= MemoryMap::WRITABLE; break;
                            case 'x': perms |= MemoryMap::EXECUTABLE; break;
                            default:
                                throw std::runtime_error("invalid permission character '" +
                                                         StringUtility::cEscape(parts[1].substr(i, 1)) +
                                                         "' in \"srec:\" URI");
                                break;
                        }
                    }
                }
            } else {
                resource = fileName;
            }

            // Parse and load the S-Record file
            if (resource.size()!=strlen(resource.c_str())) {
                throw std::runtime_error("file name contains internal NUL characters: \"" +
                                         StringUtility::cEscape(resource) + "\"");
            }
            std::ifstream input(resource.c_str());
            if (!input.good()) {
                throw std::runtime_error("cannot open Motorola S-Record file: \"" +
                                         StringUtility::cEscape(resource) + "\"");
            }
            std::vector<SRecord> srecs = SRecord::parse(input);
            for (size_t i=0; i<srecs.size(); ++i) {
                if (!srecs[i].error().empty())
                    mlog[ERROR] <<resource <<":" <<(i+1) <<": S-Record: " <<srecs[i].error() <<"\n";
            }
            SRecord::load(srecs, map, true /*create*/, perms);
        } else if (boost::starts_with(fileName, "vxcore:")) {
            // format is "vxcore:[MEMORY_ATTRS]:[FILE_ATTRS]:FILE_NAME
            loadVxCore(fileName.substr(7));             // the part after "vxcore:"
        }
    }
}

void
EngineBinary::loadVxCore(const std::string &spec) {
    VxcoreParser parser;
    boost::filesystem::path fileName = parser.parseUrl(spec);
    parser.parse(fileName, memoryMap());
    if (settings().disassembler.isaName.empty())
        settings().disassembler.isaName = parser.isaName();
}

MemoryMap::Ptr
EngineBinary::loadSpecimens(const std::vector<std::string> &fileNames) {
    try {
        if (!areContainersParsed()) {
            parseContainers(fileNames);
        }
        if (!memoryMap()) {
            memoryMap(MemoryMap::instance());
        }
        loadContainers(fileNames);
        loadNonContainers(fileNames);
        adjustMemoryMap();
        memoryMap()->shrinkUnshare();
        return memoryMap();
    } catch (const std::runtime_error &e) {
        if (settings().engine.exitOnError) {
            mlog[FATAL] <<e.what() <<"\n";
            exit(1);
        } else {
            throw;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Disassembler creation
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Partitioner high-level functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Partitioner::Ptr
EngineBinary::createGenericPartitioner() {
    checkCreatePartitionerPrerequisites();
    Partitioner::Ptr partitioner = createBarePartitioner();
    partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchHotPatchPrologue::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchStandardPrologue::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchAbbreviatedPrologue::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchEnterPrologue::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesPowerpc::MatchStwuPrologue::instance());
    if (settings().partitioner.findingThunks)
        partitioner->functionPrologueMatchers().push_back(Modules::MatchThunk::instance(functionMatcherThunks()));
    partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchRetPadPush::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesM68k::MatchLink::instance());
    partitioner->functionPrologueMatchers().push_back(ModulesMips::MatchRetAddiu::instance());
    partitioner->basicBlockCallbacks().append(ModulesX86::FunctionReturnDetector::instance());
    partitioner->basicBlockCallbacks().append(ModulesM68k::SwitchSuccessors::instance());
    partitioner->basicBlockCallbacks().append(ModulesX86::SwitchSuccessors::instance());
    partitioner->basicBlockCallbacks().append(libcStartMain_ = ModulesLinux::LibcStartMain::instance());
    return partitioner;
}

Partitioner::Ptr
EngineBinary::createTunedPartitioner() {
    obtainDisassembler();

    if (disassembler().dynamicCast<Disassembler::M68k>()) {
        checkCreatePartitionerPrerequisites();
        Partitioner::Ptr partitioner = createBarePartitioner();
        partitioner->functionPrologueMatchers().push_back(ModulesM68k::MatchLink::instance());
        partitioner->basicBlockCallbacks().append(ModulesM68k::SwitchSuccessors::instance());
        partitioner->basicBlockCallbacks().append(libcStartMain_ = ModulesLinux::LibcStartMain::instance());
        return partitioner;
    }

    if (disassembler().dynamicCast<Disassembler::X86>()) {
        checkCreatePartitionerPrerequisites();
        Partitioner::Ptr partitioner = createBarePartitioner();
        partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchHotPatchPrologue::instance());
        partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchStandardPrologue::instance());
        partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchEnterPrologue::instance());
        if (settings().partitioner.findingThunks)
            partitioner->functionPrologueMatchers().push_back(Modules::MatchThunk::instance(functionMatcherThunks_));
        partitioner->functionPrologueMatchers().push_back(ModulesX86::MatchRetPadPush::instance());
        partitioner->basicBlockCallbacks().append(ModulesX86::FunctionReturnDetector::instance());
        partitioner->basicBlockCallbacks().append(ModulesX86::SwitchSuccessors::instance());
        partitioner->basicBlockCallbacks().append(ModulesLinux::SyscallSuccessors::instance(partitioner,
                                                                                            settings().partitioner.syscallHeader));
        partitioner->basicBlockCallbacks().append(libcStartMain_ = ModulesLinux::LibcStartMain::instance());
        return partitioner;
    }

    if (disassembler().dynamicCast<Disassembler::Powerpc>()) {
        checkCreatePartitionerPrerequisites();
        Partitioner::Ptr partitioner = createBarePartitioner();
        partitioner->functionPrologueMatchers().push_back(ModulesPowerpc::MatchStwuPrologue::instance());
        return partitioner;
    }

    if (disassembler().dynamicCast<Disassembler::Mips>()) {
        checkCreatePartitionerPrerequisites();
        Partitioner::Ptr partitioner = createBarePartitioner();
        partitioner->functionPrologueMatchers().push_back(ModulesMips::MatchRetAddiu::instance());
        return partitioner;
    }

    return createGenericPartitioner();
}

Partitioner::Ptr
EngineBinary::createPartitionerFromAst(SgAsmInterpretation *interp) {
    ASSERT_not_null(interp);
    interpretation(interp);
    memoryMap(MemoryMap::Ptr());
    loadSpecimens(std::vector<std::string>());
    Partitioner::Ptr partitioner = createTunedPartitioner();

    // Cache all the instructions so they're available by address in O(log N) time in the future.
    for (SgAsmInstruction *insn: SageInterface::querySubTree<SgAsmInstruction>(interp))
        partitioner->instructionProvider().insert(insn);

    // Create and attach basic blocks
    for (SgAsmNode *node: SageInterface::querySubTree<SgAsmNode>(interp)) {
        SgAsmBlock *blockAst = isSgAsmBlock(node);
        if (!blockAst || !blockAst->has_instructions())
            continue;
        BasicBlock::Ptr bblock = BasicBlock::instance(blockAst->get_address(), partitioner);
        bblock->comment(blockAst->get_comment());

        // Instructions
        const SgAsmStatementPtrList &stmts = blockAst->get_statementList();
        for (SgAsmStatementPtrList::const_iterator si=stmts.begin(); si!=stmts.end(); ++si) {
            if (SgAsmInstruction *insn = isSgAsmInstruction(*si))
                bblock->append(partitioner, insn);
        }

        // Successors
        const SgAsmIntegerValuePtrList &successors = blockAst->get_successors();
        for (SgAsmIntegerValueExpression *ival: successors)
            bblock->insertSuccessor(ival->get_absoluteValue(), ival->get_significantBits());
        if (!blockAst->get_successors_complete()) {
            size_t nbits = partitioner->instructionProvider().instructionPointerRegister().nBits();
            bblock->insertSuccessor(Semantics::SValue::instance_undefined(nbits));
        }

        partitioner->attachBasicBlock(bblock);
    }

    // Create and attach functions
    for (SgAsmFunction *funcAst: SageInterface::querySubTree<SgAsmFunction>(interp)) {
        if (0!=(funcAst->get_reason() & SgAsmFunction::FUNC_LEFTOVERS))
            continue;                                   // this isn't really a true function
        Function::Ptr function = Function::instance(funcAst->get_entry_va(), funcAst->get_name());
        function->comment(funcAst->get_comment());
        function->reasons(funcAst->get_reason());
        function->reasonComment(funcAst->get_reasonComment());

        for (SgAsmBlock *blockAst: SageInterface::querySubTree<SgAsmBlock>(funcAst)) {
            if (blockAst->has_instructions())
                function->insertBasicBlock(blockAst->get_address());
        }

        for (SgAsmStaticData *dataAst: SageInterface::querySubTree<SgAsmStaticData>(funcAst)) {
            DataBlock::Ptr dblock = DataBlock::instanceBytes(dataAst->get_address(), dataAst->get_size());
            partitioner->attachDataBlock(dblock);
            function->insertDataBlock(dblock);
        }

        partitioner->attachFunction(function);
    }

    return partitioner;
}

Partitioner::Ptr
EngineBinary::createPartitioner() {
    return createTunedPartitioner();
}

void EngineBinary::runPartitionerInit(const Partitioner::Ptr &partitioner) {
    Sawyer::Message::Stream where(mlog[WHERE]);

    SAWYER_MESG(where) <<"labeling addresses\n";
    labelAddresses(partitioner, partitioner->configuration());

    SAWYER_MESG(where) <<"marking configured basic blocks\n";
    makeConfiguredDataBlocks(partitioner, partitioner->configuration());

    SAWYER_MESG(where) <<"marking configured functions\n";
    makeConfiguredFunctions(partitioner, partitioner->configuration());

    SAWYER_MESG(where) <<"marking ELF/PE container functions\n";
    makeContainerFunctions(partitioner, interpretation());

    SAWYER_MESG(where) <<"marking interrupt functions\n";
    makeInterruptVectorFunctions(partitioner, settings().partitioner.interruptVector);

    SAWYER_MESG(where) <<"marking user-defined functions\n";
    makeUserFunctions(partitioner, settings().partitioner.functionStartingVas);
}

void
EngineBinary::runPartitionerRecursive(const Partitioner::Ptr &partitioner) {
    Sawyer::Message::Stream where(mlog[WHERE]);

    // Start discovering instructions and forming them into basic blocks and functions
    SAWYER_MESG(where) <<"discovering and populating functions\n";
    discoverFunctions(partitioner);

    // Try to attach basic blocks to functions
    SAWYER_MESG(where) <<"marking function call targets\n";
    if (settings().partitioner.findingFunctionCallFunctions) {
        SAWYER_MESG(where) <<"finding called functions\n";
        makeCalledFunctions(partitioner);
    }

    SAWYER_MESG(where) <<"discovering basic blocks for marked functions\n";
    attachBlocksToFunctions(partitioner);

    // Additional work
    if (settings().partitioner.findingDeadCode) {
        SAWYER_MESG(where) <<"attaching dead code to functions\n";
        attachDeadCodeToFunctions(partitioner);
    }
    if (settings().partitioner.findingFunctionPadding) {
        SAWYER_MESG(where) <<"attaching function padding\n";
        attachPaddingToFunctions(partitioner);
    }
    if (settings().partitioner.findingIntraFunctionCode > 0) {
        // WHERE message is emitted in the call
        attachAllSurroundedCodeToFunctions(partitioner);
    }
    if (settings().partitioner.findingIntraFunctionData) {
        SAWYER_MESG(where) <<"searching for inter-function code\n";
        attachSurroundedDataToFunctions(partitioner);
    }

    // Another pass to attach blocks to functions
    SAWYER_MESG(where) <<"discovering basic blocks for marked functions\n";
    attachBlocksToFunctions(partitioner);
}

void
EngineBinary::runPartitionerFinal(const Partitioner::Ptr &partitioner) {
    Sawyer::Message::Stream where(mlog[WHERE]);

    if (settings().partitioner.splittingThunks) {
        // Splitting thunks off the front of a basic block causes the rest of the basic block to be discarded and then
        // rediscovered. This might also create additional blocks due to the fact that opaque predicate analysis runs only on
        // single blocks at a time -- splitting the block may have broken the opaque predicate.
        SAWYER_MESG(where) <<"splitting thunks from functions\n";
        splitThunkFunctions(partitioner, functionSplittingThunks_);
        discoverBasicBlocks(partitioner);
    }

    // Perform a final pass over all functions.
    SAWYER_MESG(where) <<"discovering basic blocks for marked functions\n";
    attachBlocksToFunctions(partitioner);

    if (interpretation()) {
        SAWYER_MESG(where) <<"naming imports\n";
        ModulesPe::nameImportThunks(partitioner, interpretation());
        ModulesPowerpc::nameImportThunks(partitioner, interpretation());
    }
    if (settings().partitioner.namingConstants) {
        SAWYER_MESG(where) <<"naming constants\n";
        Modules::nameConstants(partitioner, settings().partitioner.namingConstants);
    }
    if (!settings().partitioner.namingStrings.isEmpty()) {
        SAWYER_MESG(where) <<"naming strings\n";
        Modules::nameStrings(partitioner, settings().partitioner.namingStrings);
    }
    if (settings().partitioner.namingSyscalls) {
        SAWYER_MESG(where) <<"naming system calls\n";
        ModulesLinux::nameSystemCalls(partitioner, settings().partitioner.syscallHeader);
    }
    if (settings().partitioner.demangleNames) {
        SAWYER_MESG(where) <<"demangling names\n";
        Modules::demangleFunctionNames(partitioner);
    }
    if (SgBinaryComposite *bc = SageInterface::getEnclosingNode<SgBinaryComposite>(interpretation())) {
        // [Robb Matzke 2020-02-11]: This only works if ROSE was configured with external DWARF and ELF libraries.
        SAWYER_MESG(where) <<"mapping source locations\n";
        partitioner->sourceLocations().insertFromDebug(bc);
    }
    if (libcStartMain_)
        libcStartMain_->nameMainFunction(partitioner);
}

Partitioner::Ptr
EngineBinary::partition(const std::vector<std::string> &fileNames) {
    try {
        for (const std::string &fileName: fileNames) {
            if (isRbaFile(fileName) && fileNames.size() != 1)
                throw Exception("specifying an RBA file excludes all other inputs");
        }
        if (fileNames.size() == 1 && isRbaFile(fileNames[0])) {
            return loadPartitioner(fileNames[0]);
        } else {
            if (!areSpecimensLoaded())
                loadSpecimens(fileNames);
            obtainDisassembler();
            Partitioner::Ptr partitioner = createPartitioner();
            runPartitioner(partitioner);
            return partitioner;
        }
    } catch (const std::runtime_error &e) {
        if (settings().engine.exitOnError) {
            mlog[FATAL] <<e.what() <<"\n";
            exit(1);
        } else {
            throw;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Partitioner mid-level operations
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

std::vector<Function::Ptr>
EngineBinary::makeEntryFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    if (interp) {
        for (SgAsmGenericHeader *fileHeader: interp->get_headers()->get_headers()) {
            for (const rose_rva_t &rva: fileHeader->get_entry_rvas()) {
                rose_addr_t va = rva.get_rva() + fileHeader->get_base_va();
                Function::Ptr function = Function::instance(va, "_start", SgAsmFunction::FUNC_ENTRY_POINT);
                insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
                ASSERT_require2(function->address() == va, function->printableName());
            }
        }
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeErrorHandlingFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    if (interp) {
        for (const Function::Ptr &function: ModulesElf::findErrorHandlingFunctions(interp))
            insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeImportFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    if (interp) {
        // Windows PE imports
        ModulesPe::rebaseImportAddressTables(partitioner, ModulesPe::getImportIndex(partitioner, interp));
        for (const Function::Ptr &function: ModulesPe::findImportFunctions(partitioner, interp)) {
            rose_addr_t va = function->address();
            insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
            ASSERT_always_require2(function->address() == va, function->printableName());
        }

        // ELF imports
        for (const Function::Ptr &function: ModulesElf::findPltFunctions(partitioner, interp))
            insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeExportFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    if (interp) {
        for (const Function::Ptr &function: ModulesPe::findExportFunctions(partitioner, interp))
            insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeSymbolFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    if (interp) {
        for (const Function::Ptr &function: Modules::findSymbolFunctions(partitioner, interp))
            insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeContainerFunctions(const Partitioner::Ptr &partitioner, SgAsmInterpretation *interp) {
    std::vector<Function::Ptr> retval;
    Sawyer::Message::Stream where(mlog[WHERE]);

    if (settings().partitioner.findingImportFunctions) {
        SAWYER_MESG(where) <<"making import functions\n";
        for (const Function::Ptr &function: makeImportFunctions(partitioner, interp)) {
            if (auto exists = getOrInsertUnique(retval, function, sortFunctionsByAddress))
                (*exists)->insertReasons(SgAsmFunction::FUNC_IMPORT);
        }
    }
    if (settings().partitioner.findingExportFunctions) {
        SAWYER_MESG(where) <<"making export functions\n";
        for (const Function::Ptr &function: makeExportFunctions(partitioner, interp)) {
            if (auto exists = getOrInsertUnique(retval, function, sortFunctionsByAddress))
                (*exists)->insertReasons(SgAsmFunction::FUNC_EXPORT);
        }
    }
    if (settings().partitioner.findingSymbolFunctions) {
        SAWYER_MESG(where) <<"making symbol table functions\n";
        for (const Function::Ptr &function: makeSymbolFunctions(partitioner, interp)) {
            if (auto exists = getOrInsertUnique(retval, function, sortFunctionsByAddress))
                (*exists)->insertReasons(SgAsmFunction::FUNC_SYMBOL);
        }
    }
    if (settings().partitioner.findingEntryFunctions) {
        SAWYER_MESG(where) <<"making entry point functions\n";
        for (const Function::Ptr &function: makeEntryFunctions(partitioner, interp)) {
            if (auto exists = getOrInsertUnique(retval, function, sortFunctionsByAddress))
                (*exists)->insertReasons(SgAsmFunction::FUNC_ENTRY_POINT);
        }
    }
    if (settings().partitioner.findingErrorFunctions) {
        SAWYER_MESG(where) <<"making error-handling functions\n";
        for (const Function::Ptr &function: makeErrorHandlingFunctions(partitioner, interp)) {
            if (auto exists = getOrInsertUnique(retval, function, sortFunctionsByAddress))
                (*exists)->insertReasons(SgAsmFunction::FUNC_EH_FRAME);
        }
    }
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeInterruptVectorFunctions(const Partitioner::Ptr &partitioner, const AddressInterval &interruptVector) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> functions;
    if (interruptVector.isEmpty()) {
        return functions;
    }
    Disassembler::Base::Ptr disassembler = Engine::disassembler();
    if (!disassembler) {
        disassembler = partitioner->instructionProvider().disassembler();
    }    
    if (!disassembler) {
        throw std::runtime_error("cannot decode interrupt vector without architecture information");
    } else if (disassembler.dynamicCast<Disassembler::M68k>()) {
        for (const Function::Ptr &f: ModulesM68k::findInterruptFunctions(partitioner, interruptVector.least()))
            insertUnique(functions, partitioner->attachOrMergeFunction(f), sortFunctionsByAddress);
    } else if (1 == interruptVector.size()) {
        throw std::runtime_error("cannot determine interrupt vector size for architecture");
    } else {
        size_t ptrSize = partitioner->instructionProvider().instructionPointerRegister().nBits();
        ASSERT_require2(ptrSize % 8 == 0, "instruction pointer register size is strange");
        size_t bytesPerPointer = ptrSize / 8;
        size_t nPointers = interruptVector.size() / bytesPerPointer;
        ByteOrder::Endianness byteOrder = partitioner->instructionProvider().defaultByteOrder();

        for (size_t i=0; i<nPointers; ++i) {
            rose_addr_t elmtVa = interruptVector.least() + i*bytesPerPointer;
            uint32_t functionVa;
            if (4 == partitioner->memoryMap()->at(elmtVa).limit(4).read((uint8_t*)&functionVa).size()) {
                functionVa = ByteOrder::disk_to_host(byteOrder, functionVa);
                std::string name = "interrupt_" + StringUtility::numberToString(i) + "_handler";
                Function::Ptr function = Function::instance(functionVa, name, SgAsmFunction::FUNC_EXCEPTION_HANDLER);
                if (Sawyer::Optional<Function::Ptr> found = getUnique(functions, function, sortFunctionsByAddress)) {
                    // Multiple vector entries point to the same function, so give it a rather generic name
                    found.get()->name("interrupt_vector_function");
                } else {
                    insertUnique(functions, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
                }
            }
        }
    }
    return functions;
}

std::vector<Function::Ptr>
EngineBinary::makeUserFunctions(const Partitioner::Ptr &partitioner, const std::vector<rose_addr_t> &vas) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    for (rose_addr_t va: vas) {
        Function::Ptr function = Function::instance(va, SgAsmFunction::FUNC_CMDLINE);
        insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    }
    return retval;
}

void
EngineBinary::discoverBasicBlocks(const Partitioner::Ptr &partitioner) {
    while (makeNextBasicBlock(partitioner)) /*void*/;
}

Function::Ptr
EngineBinary::makeNextDataReferencedFunction(const Partitioner::ConstPtr &partitioner, rose_addr_t &readVa /*in,out*/) {
    ASSERT_not_null(partitioner);
    const rose_addr_t wordSize = partitioner->instructionProvider().instructionPointerRegister().nBits() / 8;
    ASSERT_require2(wordSize>0 && wordSize<=8, StringUtility::numberToString(wordSize)+"-byte words not implemented yet");
    const rose_addr_t maxaddr = partitioner->memoryMap()->hull().greatest();

    while (readVa < maxaddr &&
           partitioner->memoryMap()->atOrAfter(readVa)
           .require(MemoryMap::READABLE).prohibit(MemoryMap::EXECUTABLE|MemoryMap::WRITABLE)
           .next().assignTo(readVa)) {

        // Addresses must be aligned on a word boundary
        if (rose_addr_t misaligned = readVa % wordSize) {
            readVa = incrementAddress(readVa, wordSize-misaligned, maxaddr);
            continue;
        }

        // Convert raw memory to native address
        // FIXME[Robb P. Matzke 2014-12-08]: assuming little endian
        ASSERT_require(wordSize<=8);
        uint8_t raw[8];
        if (partitioner->memoryMap()->at(readVa).limit(wordSize)
            .require(MemoryMap::READABLE).prohibit(MemoryMap::EXECUTABLE|MemoryMap::WRITABLE)
            .read(raw).size()!=wordSize) {
            readVa = incrementAddress(readVa, wordSize, maxaddr);
            continue;
        }
        rose_addr_t targetVa = 0;
        for (size_t i=0; i<wordSize; ++i)
            targetVa |= raw[i] << (8*i);

        // Sanity checks
        SgAsmInstruction *insn = partitioner->discoverInstruction(targetVa);
        if (!insn || insn->isUnknown()) {
            readVa = incrementAddress(readVa, wordSize, maxaddr);
            continue;                                   // no instruction
        }
        AddressInterval insnInterval = AddressInterval::baseSize(insn->get_address(), insn->get_size());
        if (!partitioner->instructionsOverlapping(insnInterval).empty()) {
            readVa = incrementAddress(readVa, wordSize, maxaddr);
            continue;                                   // would overlap with existing instruction
        }

        // All seems okay, so make a function there
        // FIXME[Robb P. Matzke 2014-12-08]: USERDEF is not the best, most descriptive reason, but it's what we have for now
        mlog[INFO] <<"possible code address " <<StringUtility::addrToString(targetVa)
                   <<" found at read-only address " <<StringUtility::addrToString(readVa) <<"\n";
        readVa = incrementAddress(readVa, wordSize, maxaddr);
        Function::Ptr function = Function::instance(targetVa, SgAsmFunction::FUNC_SCAN_RO_DATA);
        function->reasonComment("at ro-data address " + StringUtility::addrToString(readVa));
        return function;
    }
    readVa = maxaddr;
    return Function::Ptr();
}

Function::Ptr
EngineBinary::makeNextCodeReferencedFunction(const Partitioner::ConstPtr &partitioner) {
    ASSERT_not_null(partitioner);
    // As basic blocks are inserted into the CFG their instructions go into a set to be examined by this function. Once this
    // function examines them, it moves them to an already-examined set.
    rose_addr_t constant = 0;
    while (codeFunctionPointers() && codeFunctionPointers()->nextConstant(partitioner).assignTo(constant)) {
        rose_addr_t srcVa = codeFunctionPointers()->inProgress();
        SgAsmInstruction *srcInsn = partitioner->instructionProvider()[srcVa];
        ASSERT_not_null(srcInsn);

        SgAsmInstruction *targetInsn = partitioner->discoverInstruction(constant);
        if (!targetInsn || targetInsn->isUnknown())
            continue;                                   // no instruction

        AddressInterval insnInterval = AddressInterval::baseSize(targetInsn->get_address(), targetInsn->get_size());
        if (!partitioner->instructionsOverlapping(insnInterval).empty())
            continue;                                   // would overlap with existing instruction

        // All seems okay, so make a function there
        // FIXME[Robb P Matzke 2017-04-13]: USERDEF is not the best, most descriptive reason, but it's what we have for now
        mlog[INFO] <<"possible code address " <<StringUtility::addrToString(constant)
                   <<" found in instruction at " <<StringUtility::addrToString(srcVa) <<"\n";
        Function::Ptr function = Function::instance(constant, SgAsmFunction::FUNC_INSN_RO_DATA);

        function->reasonComment("from " + srcInsn->toString() + ", ro-data address " + StringUtility::addrToString(constant));
        return function;
    }
    return Function::Ptr();
}

std::vector<Function::Ptr>
EngineBinary::makeCalledFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    for (const Function::Ptr &function: partitioner->discoverCalledFunctions())
        insertUnique(retval, partitioner->attachOrMergeFunction(function), sortFunctionsByAddress);
    return retval;
}

std::vector<Function::Ptr>
EngineBinary::makeNextPrologueFunction(const Partitioner::Ptr &partitioner, rose_addr_t startVa) {
    return makeNextPrologueFunction(partitioner, startVa, startVa);
}

std::vector<Function::Ptr>
EngineBinary::makeNextPrologueFunction(const Partitioner::Ptr &partitioner, rose_addr_t startVa, rose_addr_t &lastSearchedVa) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> functions = partitioner->nextFunctionPrologue(startVa, lastSearchedVa /*out*/);
    for (const Function::Ptr &function: functions)
        partitioner->attachOrMergeFunction(function);
    return functions;
}

std::vector<Function::Ptr>
EngineBinary::makeFunctionFromInterFunctionCalls(const Partitioner::Ptr &partitioner, rose_addr_t &startVa /*in,out*/) {
    ASSERT_not_null(partitioner);
    static const rose_addr_t MAX_ADDR(-1);
    static const std::vector<Function::Ptr> NO_FUNCTIONS;
    static const char *me = "makeFunctionFromInterFunctionCalls: ";
    Sawyer::Message::Stream debug(mlog[DEBUG]);
    SAWYER_MESG(debug) <<me <<"(startVa = " <<StringUtility::addrToString(startVa) <<")\n";

    // Avoid creating large basic blocks since this can drastically slow down instruction semantics. Large basic blocks are a
    // real possibility here because we're likely to be interpreting data areas as code. We're not creating any permanent basic
    // blocks in this analysis, so limiting the size here has no effect on which blocks are ultimately added to the control
    // flow graph.  The smaller the limit, the more likely that a multi-instruction call will get split into two blocks and not
    // detected. Multi-instruction calls are an obfuscation technique.
    Sawyer::TemporaryCallback<BasicBlockCallback::Ptr>
        tcb(partitioner->basicBlockCallbacks(), Modules::BasicBlockSizeLimiter::instance(20)); // arbitrary

    while (AddressInterval unusedVas = partitioner->aum().nextUnused(startVa)) {

        // The unused interval must have executable addresses, otherwise skip to the next unused interval.
        AddressInterval unusedExecutableVas = memoryMap()->within(unusedVas).require(MemoryMap::EXECUTABLE).available();
        if (unusedExecutableVas.isEmpty()) {
            if (unusedVas.greatest() == MAX_ADDR) {
                startVa = MAX_ADDR;
                return NO_FUNCTIONS;
            } else {
                startVa = unusedVas.greatest() + 1;
                continue;
            }
        }
        startVa = unusedExecutableVas.least();
        SAWYER_MESG(debug) <<me <<"examining interval " <<StringUtility::addrToString(unusedExecutableVas.least())
                           <<".." <<StringUtility::addrToString(unusedExecutableVas.greatest()) <<"\n";

        while (startVa <= unusedExecutableVas.greatest()) {
            // Discover the basic block. It's possible that the partitioner already knows about this block location but just
            // hasn't tried looking for its instructions yet.  I don't think this happens within the stock engine because it
            // tries to recursively discover all basic blocks before it starts scanning things that might be data. But users
            // might call this before they've processed all the outstanding placeholders.  Consider the following hypothetical
            // user's partitioner state
            //          B1: push ebp            ; this block's insns are discovered
            //              mov ebp, esp
            //              test eax, eax
            //              je B3
            //          B2: inc eax             ; this block's insns are discovered
            //          B3: ???                 ; this block is known, but no instructions discovered yet
            //              ???                 ; arbitrary number of blocks
            //          Bn: push ebp            ; this block's insns are discovered
            //              mov ebp, esp
            // To this analysis, the region (B3+1)..Bn is ambiguous. It could be code or data or some of both. Ideally, we
            // should have used the recursive disassembly to process this area already. We'll just pretend it's all unknown and
            // process it with a linear sweep like normal. This is probably fine for normal code since linear and recursive are
            // mostly the same and we'll eventually discover the correct blocks anyway when we finally do the recursive (this
            // analysis doesn't actually create blocks in this region -- it only looks for call sites).
            BasicBlock::Ptr bb;
            if (partitioner->placeholderExists(startVa)) {
#if 0 // DEBUGGING [Robb P Matzke 2016-06-30]
                if (mlog[WARN]) {
                    mlog[WARN] <<me <<"va " <<StringUtility::addrToString(startVa) <<" has ambiguous disposition:\n";
                    static bool emitted = false;
                    if (!emitted) {
                        mlog[WARN] <<"  it is a basic block (with undiscovered instructions),\n"
                                   <<"  and it is absent from the address usage map\n"
                                   <<"  this analysis should be called after all pending instructions are discovered\n";
                        mlog[WARN] <<"  interval " <<StringUtility::addrToString(startVa)
                                   <<".." <<StringUtility::addrToString(unusedExecutableVas.greatest())
                                   <<" treated as unknown\n";
                        mlog[WARN] <<"  the CFG contains "
                                   <<StringUtility::plural(partitioner->undiscoveredVertex()->nInEdges(), "blocks")
                                   <<" lacking instructions\n";
                        emitted = true;
                    }
                }
#endif
            } else {
                bb = partitioner->discoverBasicBlock(startVa);
            }

            // Increment the startVa to be the next unused address. We can't just use the fall-through address of the basic
            // block we just discovered because it might not be contiguous in memory.  Watch out for overflow since it's
            // possible that startVa is already the last address in the address space (in which case we leave startVa as is and
            // return).
            if (bb == nullptr || bb->nInstructions() == 0) {
                if (startVa == MAX_ADDR)
                    return NO_FUNCTIONS;
                ++startVa;
                continue;
            }
            if (debug) {
                debug <<me <<bb->printableName() <<"\n";
                for (SgAsmInstruction *insn: bb->instructions())
                    debug <<me <<"  " <<partitioner->unparse(insn) <<"\n";
            }
            AddressIntervalSet bbVas = bb->insnAddresses();
            if (!bbVas.leastNonExistent(bb->address()).assignTo(startVa)) // address of first hole, or following address
                startVa = MAX_ADDR;                                       // bb ends at max address

            // Basic block sanity checks because we're not sure that we're actually disassembling real code. The basic block
            // should not overlap with anything (basic block, data block, function) already attached to the CFG.
            if (partitioner->aum().anyExists(bbVas)) {
                SAWYER_MESG(debug) <<me <<"candidate basic block overlaps with another; skipping\n";
                continue;
            }

            if (!partitioner->basicBlockIsFunctionCall(bb, Precision::LOW)) {
                SAWYER_MESG(debug) <<me <<"candidate basic block is not a function call; skipping\n";
                continue;
            }

            // Look at the basic block successors to find those which appear to be function calls. Note that the edge types are
            // probably all E_NORMAL at this point rather than E_FUNCTION_CALL, and the call-return edges are not yet present.
            std::set<rose_addr_t> candidateFunctionVas; // entry addresses for potential new functions
            BasicBlock::Successors successors = partitioner->basicBlockSuccessors(bb, Precision::LOW);
            for (const BasicBlock::Successor &succ: successors) {
                if (auto targetVa = succ.expr()->toUnsigned()) {
                    if (*targetVa == bb->fallthroughVa()) {
                        SAWYER_MESG(debug) <<me <<"successor " <<StringUtility::addrToString(*targetVa) <<" is fall-through\n";
                    } else if (partitioner->functionExists(*targetVa)) {
                        // We already know about this function, so move on -- nothing to see here.
                        SAWYER_MESG(debug) <<me <<"successor " <<StringUtility::addrToString(*targetVa) <<" already exists\n";
                    } else if (partitioner->aum().exists(*targetVa)) {
                        // Target is inside some basic block, data block, or function but not a function entry. The basic block
                        // we just discovered is probably bogus, therefore ignore everything about it.
                        candidateFunctionVas.clear();
                        SAWYER_MESG(debug) <<me <<"successor " <<StringUtility::addrToString(*targetVa) <<" has a conflict\n";
                        break;
                    } else if (!memoryMap()->at(*targetVa).require(MemoryMap::EXECUTABLE).exists()) {
                        // Target is in an unmapped area or is not executable. The basic block we just discovered is probably
                        // bogus, therefore ignore everything about it.
                        SAWYER_MESG(debug) <<me <<"successor " <<StringUtility::addrToString(*targetVa) <<" not executable\n";
                        candidateFunctionVas.clear();
                        break;
                    } else {
                        // Looks good.
                        candidateFunctionVas.insert(*targetVa);
                    }
                }
            }

            // Create new functions containing only the entry blocks. We'll discover the rest of their blocks later by
            // recursively following their control flow.
            if (!candidateFunctionVas.empty()) {
                std::vector<Function::Ptr> newFunctions;
                for (rose_addr_t functionVa: candidateFunctionVas) {
                    Function::Ptr newFunction = Function::instance(functionVa, SgAsmFunction::FUNC_CALL_INSN);
                    newFunction->reasonComment("from " + bb->instructions().back()->toString());
                    newFunctions.push_back(partitioner->attachOrMergeFunction(newFunction));
                    SAWYER_MESG(debug) <<me <<"created " <<newFunction->printableName() <<" from " <<bb->printableName() <<"\n";
                }
                return newFunctions;
            }

            // Avoid overflow or infinite loop
            if (startVa == MAX_ADDR)
                return NO_FUNCTIONS;
        }
    }
    return NO_FUNCTIONS;
}

void
EngineBinary::discoverFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);
    rose_addr_t nextPrologueVa = 0;                     // where to search for function prologues
    rose_addr_t nextInterFunctionCallVa = 0;            // where to search for inter-function call instructions
    rose_addr_t nextReadAddr = 0;                       // where to look for read-only function addresses

    while (1) {
        // Find as many basic blocks as possible by recursively following the CFG as we build it.
        discoverBasicBlocks(partitioner);

        // No pending basic blocks, so look for a function prologue. This creates a pending basic block for the function's
        // entry block, so go back and look for more basic blocks again.
        if (nextPrologueVa < partitioner->memoryMap()->hull().greatest()) {
            std::vector<Function::Ptr> newFunctions =
                makeNextPrologueFunction(partitioner, nextPrologueVa, nextPrologueVa /*out*/);
            if (nextPrologueVa < partitioner->memoryMap()->hull().greatest())
                ++nextPrologueVa;
            if (!newFunctions.empty())
                continue;
        }

        // Scan inter-function code areas to find basic blocks that look reasonable and process them with instruction semantics
        // to find calls to functions that we don't know about yet.
        if (settings().partitioner.findingInterFunctionCalls) {
            std::vector<Function::Ptr> newFunctions =
                makeFunctionFromInterFunctionCalls(partitioner, nextInterFunctionCallVa /*in,out*/);
            if (!newFunctions.empty())
                continue;
        }

        // Try looking at literal constants inside existing instructions to find possible pointers to new functions
        if (settings().partitioner.findingCodeFunctionPointers) {
            if (Function::Ptr function = makeNextCodeReferencedFunction(partitioner)) {
                partitioner->attachFunction(function);
                continue;
            }
        }

        // Try looking for a function address mentioned in read-only memory
        if (settings().partitioner.findingDataFunctionPointers) {
            if (Function::Ptr function = makeNextDataReferencedFunction(partitioner, nextReadAddr /*in,out*/)) {
                partitioner->attachFunction(function);
                continue;
            }
        }

        // Nothing more to do
        break;
    }
}

std::set<rose_addr_t>
EngineBinary::attachDeadCodeToFunction(const Partitioner::Ptr &partitioner, const Function::Ptr &function, size_t maxIterations) {
    ASSERT_not_null(partitioner);
    ASSERT_not_null(function);
    std::set<rose_addr_t> retval;

    for (size_t i=0; i<maxIterations; ++i) {
        // Find ghost edges
        std::set<rose_addr_t> ghosts = partitioner->functionGhostSuccessors(function);
        if (ghosts.empty())
            break;

        // Insert placeholders for all ghost edge targets
        partitioner->detachFunction(function);          // so we can modify its basic block ownership list
        for (rose_addr_t ghost: ghosts) {
            if (retval.find(ghost)==retval.end()) {
                partitioner->insertPlaceholder(ghost);  // ensure a basic block gets created here
                function->insertBasicBlock(ghost);      // the function will own this basic block
                retval.insert(ghost);
            }
        }

        // If we're about to do more iterations then we should recursively discover instructions for pending basic blocks. Once
        // we've done that we should traverse the function's CFG to see if some of those new basic blocks are reachable and
        // should also be attached to the function.
        if (i+1 < maxIterations) {
            while (makeNextBasicBlock(partitioner)) /*void*/;
            partitioner->discoverFunctionBasicBlocks(function);
        }
    }

    partitioner->attachFunction(function);               // no-op if still attached
    return retval;
}

DataBlock::Ptr
EngineBinary::attachPaddingToFunction(const Partitioner::Ptr &partitioner, const Function::Ptr &function) {
    ASSERT_not_null(partitioner);
    ASSERT_not_null(function);
    if (DataBlock::Ptr padding = partitioner->matchFunctionPadding(function)) {
        partitioner->attachDataBlockToFunction(padding, function);
        return padding;
    }
    return DataBlock::Ptr();
}

std::vector<DataBlock::Ptr>
EngineBinary::attachPaddingToFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);
    std::vector<DataBlock::Ptr> retval;
    for (const Function::Ptr &function: partitioner->functions()) {
        if (DataBlock::Ptr padding = attachPaddingToFunction(partitioner, function))
            insertUnique(retval, padding, sortDataBlocks);
    }
    return retval;
}

size_t
EngineBinary::attachAllSurroundedCodeToFunctions(const Partitioner::Ptr &partitioner) {
    Sawyer::Message::Stream where(mlog[WHERE]);
    size_t retval = 0;
    for (size_t i = 0; i < settings().partitioner.findingIntraFunctionCode; ++i) {
        SAWYER_MESG(where) <<"searching for intra-function code (pass " <<(i+1) <<")\n";
        size_t n = attachSurroundedCodeToFunctions(partitioner);
        if (0 == n)
            break;
        retval += n;
        discoverBasicBlocks(partitioner);
        if (settings().partitioner.findingFunctionCallFunctions)
            makeCalledFunctions(partitioner);
        attachBlocksToFunctions(partitioner);
    }
    return retval;
}

// Assumes that each unused address interaval that's surrounded by a single function begins coincident with the beginning of an
// as yet undiscovered basic block and adds a basic block placeholder to the surrounding function.  This could be further
// improved by testing to see if the candidate address looks like a valid basic block.
size_t
EngineBinary::attachSurroundedCodeToFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);
    size_t nNewBlocks = 0;
    if (partitioner->aum().isEmpty())
        return 0;
    rose_addr_t va = partitioner->aum().hull().least() + 1;
    while (va < partitioner->aum().hull().greatest()) {
        // Find an address interval that's unused and also executable.
        AddressInterval unusedAum = partitioner->aum().nextUnused(va);
        if (!unusedAum || unusedAum.greatest() > partitioner->aum().hull().greatest())
            break;
        AddressInterval interval = partitioner->memoryMap()->within(unusedAum).require(MemoryMap::EXECUTABLE).available();
        if (interval == unusedAum) {
            // Is this interval immediately surrounded by a single function?
            typedef std::vector<Function::Ptr> Functions;
            Functions beforeFuncs = partitioner->functionsOverlapping(interval.least()-1);
            Functions afterFuncs = partitioner->functionsOverlapping(interval.greatest()+1);
            Functions enclosingFuncs(beforeFuncs.size());
            Functions::iterator final = std::set_intersection(beforeFuncs.begin(), beforeFuncs.end(),
                                                              afterFuncs.begin(), afterFuncs.end(), enclosingFuncs.begin());
            enclosingFuncs.resize(final-enclosingFuncs.begin());
            if (1 == enclosingFuncs.size()) {
                Function::Ptr function = enclosingFuncs[0];

                // Add the address to the function
                mlog[DEBUG] <<"attachSurroundedCodeToFunctions: basic block " <<StringUtility::addrToString(interval.least())
                            <<" is attached now to function " <<function->printableName() <<"\n";
                partitioner->detachFunction(function);
                if (function->insertBasicBlock(interval.least()))
                    ++nNewBlocks;
                partitioner->attachFunction(function);
            }
        }

        // Advance to next unused interval
        if (unusedAum.greatest() > partitioner->aum().hull().greatest())
            break;                                      // prevent possible overflow
        va = unusedAum.greatest() + 1;
    }
    return nNewBlocks;
}

void
EngineBinary::attachBlocksToFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);
    std::vector<Function::Ptr> retval;
    for (const Function::Ptr &function: partitioner->functions()) {
        partitioner->detachFunction(function);           // must be detached in order to modify block ownership
        partitioner->discoverFunctionBasicBlocks(function);
        partitioner->attachFunction(function);
    }
}

// Finds dead code and adds it to the function to which it seems to belong.
std::set<rose_addr_t>
EngineBinary::attachDeadCodeToFunctions(const Partitioner::Ptr &partitioner, size_t maxIterations) {
    ASSERT_not_null(partitioner);
    std::set<rose_addr_t> retval;
    for (const Function::Ptr &function: partitioner->functions()) {
        std::set<rose_addr_t> deadVas = attachDeadCodeToFunction(partitioner, function, maxIterations);
        retval.insert(deadVas.begin(), deadVas.end());
    }
    return retval;
}

std::vector<DataBlock::Ptr>
EngineBinary::attachSurroundedDataToFunctions(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);

    // Find executable addresses that are not yet used in the CFG/AUM
    AddressIntervalSet executableSpace;
    for (const MemoryMap::Node &node: partitioner->memoryMap()->nodes()) {
        if ((node.value().accessibility() & MemoryMap::EXECUTABLE) != 0)
            executableSpace.insert(node.key());
    }
    AddressIntervalSet unused = partitioner->aum().unusedExtent(executableSpace);

    // Iterate over the large unused address intervals and find their surrounding functions
    std::vector<DataBlock::Ptr> retval;
    for (const AddressInterval &interval: unused.intervals()) {
        if (interval.least()<=executableSpace.least() || interval.greatest()>=executableSpace.greatest())
            continue;
        typedef std::vector<Function::Ptr> Functions;
        Functions beforeFuncs = partitioner->functionsOverlapping(interval.least()-1);
        Functions afterFuncs = partitioner->functionsOverlapping(interval.greatest()+1);

        // What functions are in both sets?
        Functions enclosingFuncs(beforeFuncs.size());
        Functions::iterator final = std::set_intersection(beforeFuncs.begin(), beforeFuncs.end(),
                                                          afterFuncs.begin(), afterFuncs.end(), enclosingFuncs.begin());
        enclosingFuncs.resize(final-enclosingFuncs.begin());

        // Add the data block to all enclosing functions
        if (!enclosingFuncs.empty()) {
            DataBlock::Ptr dblock = DataBlock::instanceBytes(interval.least(), interval.size());
            dblock->comment("data encapsulated by function");
            for (const Function::Ptr &function: enclosingFuncs) {
                dblock = partitioner->attachDataBlockToFunction(dblock, function);
                insertUnique(retval, dblock, sortDataBlocks);
            }
        }
    }
    return retval;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Partitioner low-level stuff
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// Called every time an instructionis added to a basic block.
bool
EngineBinary::BasicBlockFinalizer::operator()(bool chain, const Args &args) {
    if (chain) {
        BasicBlock::Ptr bb = args.bblock;
        ASSERT_not_null(bb);
        ASSERT_require(bb->nInstructions() > 0);

        fixFunctionReturnEdge(args);
        fixFunctionCallEdges(args);
        addPossibleIndeterminateEdge(args);
    }
    return chain;
}

// If the block is a function return (e.g., ends with an x86 RET instruction) to an indeterminate location, then that successor
// type should be E_FUNCTION_RETURN instead of E_NORMAL.
void
EngineBinary::BasicBlockFinalizer::fixFunctionReturnEdge(const Args &args) {
    if (args.partitioner->basicBlockIsFunctionReturn(args.bblock)) {
        bool hadCorrectEdge = false, edgeModified = false;
        BasicBlock::Successors successors = args.partitioner->basicBlockSuccessors(args.bblock);
        for (size_t i = 0; i < successors.size(); ++i) {
            if (!successors[i].expr()->isConcrete() ||
                (successors[i].expr()->get_expression()->flags() & SymbolicExpression::Node::INDETERMINATE) != 0) {
                if (successors[i].type() == E_FUNCTION_RETURN) {
                    hadCorrectEdge = true;
                    break;
                } else if (successors[i].type() == E_NORMAL && !edgeModified) {
                    successors[i].type(E_FUNCTION_RETURN);
                    edgeModified = true;
                }
            }
        }
        if (!hadCorrectEdge && edgeModified) {
            args.bblock->clearSuccessors();
            args.bblock->successors(successors);
            SAWYER_MESG(mlog[DEBUG]) <<args.bblock->printableName() <<": fixed function return edge type\n";
        }
    }
}

// If the block is a function call (e.g., ends with an x86 CALL instruction) then change all E_NORMAL edges to E_FUNCTION_CALL
// edges.
void
EngineBinary::BasicBlockFinalizer::fixFunctionCallEdges(const Args &args) {
    if (args.partitioner->basicBlockIsFunctionCall(args.bblock)) {
        BasicBlock::Successors successors = args.partitioner->basicBlockSuccessors(args.bblock);
        bool changed = false;
        for (BasicBlock::Successor &successor: successors) {
            if (successor.type() == E_NORMAL) {
                successor.type(E_FUNCTION_CALL);
                changed = true;
            }
        }
        if (changed) {
            args.bblock->clearSuccessors();
            args.bblock->successors(successors);
            SAWYER_MESG(mlog[DEBUG]) <<args.bblock->printableName() <<": fixed function call edge(s) type\n";
        }
    }
}

// Should we add an indeterminate CFG edge from this basic block?  For instance, a "JMP [ADDR]" instruction should get an
// indeterminate edge if ADDR is a writable region of memory. There are two situations: ADDR is non-writable, in which case
// RiscOperators::peekMemory would have returned a free variable to indicate an indeterminate value, or ADDR is writable but
// its MemoryMap::INITIALIZED bit is set to indicate it has a valid value already, in which case RiscOperators::peekMemory
// would have returned the value stored there but also marked the value as being INDETERMINATE.  The
// SymbolicExpression::TreeNode::INDETERMINATE bit in the expression should have been carried along so that things like "MOV
// EAX, [ADDR]; JMP EAX" will behave the same as "JMP [ADDR]".
void
EngineBinary::BasicBlockFinalizer::addPossibleIndeterminateEdge(const Args &args) {
    BasicBlockSemantics sem = args.bblock->semantics();
    if (sem.finalState() == nullptr)
        return;
    ASSERT_not_null(sem.operators);

    bool addIndeterminateEdge = false;
    size_t addrWidth = 0;
    for (const BasicBlock::Successor &successor: args.partitioner->basicBlockSuccessors(args.bblock)) {
        if (!successor.expr()->isConcrete()) {          // BB already has an indeterminate successor?
            addIndeterminateEdge = false;
            break;
        } else if (!addIndeterminateEdge &&
                   (successor.expr()->get_expression()->flags() & SymbolicExpression::Node::INDETERMINATE) != 0) {
            addIndeterminateEdge = true;
            addrWidth = successor.expr()->nBits();
        }
    }

    // Add an edge
    if (addIndeterminateEdge) {
        ASSERT_require(addrWidth != 0);
        BaseSemantics::SValue::Ptr addr = sem.operators->undefined_(addrWidth);
        EdgeType type = args.partitioner->basicBlockIsFunctionReturn(args.bblock) ? E_FUNCTION_RETURN : E_NORMAL;
        args.bblock->insertSuccessor(addr, type);
        SAWYER_MESG(mlog[DEBUG]) <<args.bblock->printableName()
                                 <<": added indeterminate successor for initialized, non-constant memory read\n";
    }
}

// Add basic block to worklist(s)
bool
EngineBinary::BasicBlockWorkList::operator()(bool chain, const AttachedBasicBlock &args) {
    if (chain) {
        ASSERT_not_null(args.partitioner);
        Partitioner::ConstPtr partitioner = args.partitioner;

        // Basic block that is not yet discovered. We could use the special "undiscovered" CFG vertex, but there is no ordering
        // guarantee for its incoming edges.  We want to process undiscovered vertices in a depth-first manner, which is why we
        // maintain our own list instead.  The reason for depth-first discovery is that some analyses are recursive in nature
        // and we want to try to have children discovered and analyzed before we try to analyze the parent.  For instance,
        // may-return analysis for one vertex probably depends on the may-return analysis of its successors.
        if (args.bblock == nullptr) {
            undiscovered_.pushBack(args.startVa);
            return chain;
        }

        // If a new function call is inserted and it has no E_CALL_RETURN edge and at least one of its callees has an
        // indeterminate value for its may-return analysis, then add this block to the list of blocks for which we may need to
        // later add a call-return edge. The engine can be configured to also just assume that all function calls may return
        // (or never return).
        if (partitioner->basicBlockIsFunctionCall(args.bblock)) {
            ControlFlowGraph::ConstVertexIterator placeholder = partitioner->findPlaceholder(args.startVa);
            boost::logic::tribool mayReturn;
            switch (engine_->settings().partitioner.functionReturnAnalysis) {
                case MAYRETURN_ALWAYS_YES:
                    mayReturn = true;
                    break;
                case MAYRETURN_ALWAYS_NO:
                    mayReturn = false;
                    break;
                case MAYRETURN_DEFAULT_YES:
                case MAYRETURN_DEFAULT_NO: {
                    ASSERT_require(placeholder != partitioner->cfg().vertices().end());
                    mayReturn = hasAnyCalleeReturn(partitioner, placeholder);
                    break;
                }
            }
            if (!hasCallReturnEdges(placeholder) && (mayReturn || boost::logic::indeterminate(mayReturn)))
                pendingCallReturn_.pushBack(args.startVa);
        }
    }
    return chain;
}

// Remove basic block from worklist(s). We probably don't really need to erase things since the items are revalidated when
// they're consumed from the list, and avoiding an erase will keep the list in its original order when higher level functions
// make a minor adjustment with a detach-adjust-attach sequence.  On the other hand, perhaps such adjustments SHOULD move the
// block to the top of the stack.
bool
EngineBinary::BasicBlockWorkList::operator()(bool chain, const DetachedBasicBlock &args) {
    if (chain) {
        pendingCallReturn_.erase(args.startVa);
        processedCallReturn_.erase(args.startVa);
        finalCallReturn_.erase(args.startVa);
        undiscovered_.erase(args.startVa);
    }
    return chain;
}

typedef std::pair<rose_addr_t, size_t> AddressOrder;

static bool
isSecondZero(const AddressOrder &a) {
    return 0 == a.second;
}

static bool
sortBySecond(const AddressOrder &a, const AddressOrder &b) {
    return a.second < b.second;
}

// Move pendingCallReturn items into the finalCallReturn list and (re)sort finalCallReturn items according to the CFG so that
// descendents appear after their ancestors (i.e., descendents will be processed first since we always use popBack).  This is a
// fairly expensive operation: O((V+E) ln N) where V and E are the number of edges in the CFG and N is the number of addresses
// in the combined lists.
void
EngineBinary::BasicBlockWorkList::moveAndSortCallReturn(const Partitioner::ConstPtr &partitioner) {
    using namespace Sawyer::Container::Algorithm;       // graph traversals

    if (processedCallReturn().isEmpty())
        return;                                         // nothing to move, and finalCallReturn list was previously sorted

    if (maxSorts_ == 0) {
        for (rose_addr_t va: processedCallReturn_.items())
            finalCallReturn().pushBack(va);
        processedCallReturn_.clear();

    } else {
        if (0 == --maxSorts_)
            mlog[WARN] <<"may-return sort limit reached; reverting to unsorted analysis\n";

        // Get the list of virtual addresses that need to be processed
        std::vector<AddressOrder> pending;
        pending.reserve(finalCallReturn_.size() + processedCallReturn_.size());
        for (rose_addr_t va: finalCallReturn_.items())
            pending.push_back(AddressOrder(va, (size_t)0));
        for (rose_addr_t va: processedCallReturn_.items())
            pending.push_back(AddressOrder(va, (size_t)0));
        finalCallReturn_.clear();
        processedCallReturn_.clear();

        // Find the CFG vertex for each pending address and insert its "order" value. Blocks that are leaves (after arbitrarily
        // breaking cycles) have lower numbers than blocks higher up in the global CFG.
        std::vector<size_t> order = graphDependentOrder(partitioner->cfg());
        for (AddressOrder &pair: pending) {
            ControlFlowGraph::ConstVertexIterator vertex = partitioner->findPlaceholder(pair.first);
            if (vertex != partitioner->cfg().vertices().end() && vertex->value().type() == V_BASIC_BLOCK) {
                pair.second = order[vertex->id()];
            }
        }

        // Sort the pending addresses based on their calculated "order", skipping those that aren't CFG basic blocks, and save
        // the result.
        pending.erase(std::remove_if(pending.begin(), pending.end(), isSecondZero), pending.end());
        std::sort(pending.begin(), pending.end(), sortBySecond);
        for (const AddressOrder &pair: pending)
            finalCallReturn().pushBack(pair.first);
    }
}

// Add new basic block's instructions to list of instruction addresses to process
bool
EngineBinary::CodeConstants::operator()(bool chain, const AttachedBasicBlock &attached) {
    if (chain && attached.bblock) {
        for (SgAsmInstruction *insn: attached.bblock->instructions()) {
            if (wasExamined_.find(insn->get_address()) == wasExamined_.end())
                toBeExamined_.insert(insn->get_address());
        }
    }
    return chain;
}

// Remove basic block's instructions from list of instructions to process
bool
EngineBinary::CodeConstants::operator()(bool chain, const DetachedBasicBlock &detached) {
    if (chain && detached.bblock) {
        for (SgAsmInstruction *insn: detached.bblock->instructions()) {
            toBeExamined_.erase(insn->get_address());
            if (insn->get_address() == inProgress_)
                constants_.clear();
        }
    }
    return chain;
}

// Return the next constant from the next instruction
Sawyer::Optional<rose_addr_t>
EngineBinary::CodeConstants::nextConstant(const Partitioner::ConstPtr &partitioner) {
    if (!constants_.empty()) {
        rose_addr_t constant = constants_.back();
        constants_.pop_back();
        return constant;
    }

    while (!toBeExamined_.empty()) {
        inProgress_ = *toBeExamined_.begin();
        toBeExamined_.erase(inProgress_);
        if (SgAsmInstruction *insn = partitioner->instructionExists(inProgress_).insn()) {

            struct T1: AstSimpleProcessing {
                std::set<rose_addr_t> constants;
                virtual void visit(SgNode *node) override {
                    if (SgAsmIntegerValueExpression *ival = isSgAsmIntegerValueExpression(node)) {
                        if (ival->get_significantBits() <= 64)
                            constants.insert(ival->get_absoluteValue());
                    }
                }
            } t1;
            t1.traverse(insn, preorder);
            constants_ = std::vector<rose_addr_t>(t1.constants.begin(), t1.constants.end());
        }

        if (!constants_.empty()) {
            rose_addr_t constant = constants_.back();
            constants_.pop_back();
            return constant;
        }
    }

    return Sawyer::Nothing();
}

// Return true if a new CFG edge was added.
bool
EngineBinary::makeNextCallReturnEdge(const Partitioner::Ptr &partitioner, boost::logic::tribool assumeReturns) {
    ASSERT_not_null(partitioner);
    Sawyer::Container::DistinctList<rose_addr_t> &workList = basicBlockWorkList()->pendingCallReturn();
    while (!workList.isEmpty()) {
        rose_addr_t va = workList.popBack();
        ControlFlowGraph::VertexIterator caller = partitioner->findPlaceholder(va);

        // Some sanity checks because it could be possible for this list to be out-of-date if the user monkeyed with the
        // partitioner's CFG adjuster.
        if (caller == partitioner->cfg().vertices().end()) {
            SAWYER_MESG(mlog[WARN]) <<StringUtility::addrToString(va) <<" was present on the basic block worklist "
                                    <<"but not in the CFG\n";
            continue;
        }
        BasicBlock::Ptr bb = caller->value().bblock();
        if (!bb)
            continue;
        if (!partitioner->basicBlockIsFunctionCall(bb))
            continue;
        if (hasCallReturnEdges(caller))
            continue;

        // If the new vertex lacks a call-return edge (tested above) and its callee has positive or indeterminate may-return
        // then we may need to add a call-return edge depending on whether assumeCallReturns is true.
        boost::logic::tribool mayReturn;
        Confidence confidence = PROVED;
        switch (settings().partitioner.functionReturnAnalysis) {
            case MAYRETURN_ALWAYS_NO:
                mayReturn = false;
                confidence = ASSUMED;
                break;
            case MAYRETURN_ALWAYS_YES:
                mayReturn = true;
                confidence = ASSUMED;
                break;
            case MAYRETURN_DEFAULT_YES:
            case MAYRETURN_DEFAULT_NO:
                mayReturn = hasAnyCalleeReturn(partitioner, caller);
                if (boost::logic::indeterminate(mayReturn)) {
                    mayReturn = assumeReturns;
                    confidence = ASSUMED;
                }
                break;
        }

        if (mayReturn) {
            size_t nBits = partitioner->instructionProvider().instructionPointerRegister().nBits();
            partitioner->detachBasicBlock(bb);
            bb->insertSuccessor(bb->fallthroughVa(), nBits, E_CALL_RETURN, confidence);
            partitioner->attachBasicBlock(caller, bb);
            return true;
        } else if (!mayReturn) {
            return false;
        } else {
            // We're not sure yet whether a call-return edge should be inserted, so save vertex for later.
            ASSERT_require(boost::logic::indeterminate(mayReturn));
            basicBlockWorkList()->processedCallReturn().pushBack(va);
        }
    }
    return false;
}

// Discover a basic block's instructions for some placeholder that has no basic block yet.
BasicBlock::Ptr
EngineBinary::makeNextBasicBlockFromPlaceholder(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(partitioner);

    // Pick the first (as LIFO) item from the undiscovered worklist. Make sure the item is truly undiscovered
    while (!basicBlockWorkList()->undiscovered().isEmpty()) {
        rose_addr_t va = basicBlockWorkList()->undiscovered().popBack();
        ControlFlowGraph::VertexIterator placeholder = partitioner->findPlaceholder(va);
        if (placeholder == partitioner->cfg().vertices().end()) {
            mlog[WARN] <<"makeNextBasicBlockFromPlaceholder: block " <<StringUtility::addrToString(va)
                       <<" was on the undiscovered worklist but not in the CFG\n";
            continue;
        }
        ASSERT_require(placeholder->value().type() == V_BASIC_BLOCK);
        if (placeholder->value().bblock()) {
            SAWYER_MESG(mlog[DEBUG]) <<"makeNextBasicBlockFromPlacholder: block " <<StringUtility::addrToString(va)
                                     <<" was on the undiscovered worklist but is already discovered\n";
            continue;
        }
        BasicBlock::Ptr bb = partitioner->discoverBasicBlock(placeholder);
        partitioner->attachBasicBlock(placeholder, bb);
        return bb;
    }

    // The user probably monkeyed with basic blocks without notifying this engine, so just consume a block that we don't know
    // about. The order in which such placeholder blocks are discovered is arbitrary.
    if (partitioner->undiscoveredVertex()->nInEdges() > 0) {
        mlog[WARN] <<"partitioner engine undiscovered worklist is empty but CFG undiscovered vertex is not\n";
        ControlFlowGraph::VertexIterator placeholder = partitioner->undiscoveredVertex()->inEdges().begin()->source();
        ASSERT_require(placeholder->value().type() == V_BASIC_BLOCK);
        BasicBlock::Ptr bb = partitioner->discoverBasicBlock(placeholder);
        partitioner->attachBasicBlock(placeholder, bb);
        return bb;
    }

    // Nothing to discover
    return BasicBlock::Ptr();
}

// make a new basic block for an arbitrary placeholder
BasicBlock::Ptr
EngineBinary::makeNextBasicBlock(const Partitioner::Ptr &partitioner) {
    ASSERT_not_null(basicBlockWorkList());

    while (1) {
        // If there's an undiscovered basic block then discover it.
        if (BasicBlock::Ptr bb = makeNextBasicBlockFromPlaceholder(partitioner))
            return bb;

        // If there's a function call that needs a new call-return edge then add such an edge, but only if we know the callee
        // has a positive may-return analysis. If we don't yet know with certainty whether the call may return or will never
        // return then move the vertex to the processedCallReturn list to save it for later (this happens as part of
        // makeNextCallReturnEdge().
        if (!basicBlockWorkList()->pendingCallReturn().isEmpty()) {
            makeNextCallReturnEdge(partitioner, boost::logic::indeterminate);
            continue;
        }

        // We've added call-return edges everwhere possible, but may have delayed adding them to blocks where the analysis was
        // indeterminate. If so, sort all those blocks approximately by their height in the global CFG and run may-return
        // analysis on each one
        if (!basicBlockWorkList()->processedCallReturn().isEmpty() || !basicBlockWorkList()->finalCallReturn().isEmpty()) {
            ASSERT_require(basicBlockWorkList()->pendingCallReturn().isEmpty());
            if (!basicBlockWorkList()->processedCallReturn().isEmpty())
                basicBlockWorkList()->moveAndSortCallReturn(partitioner);
            while (!basicBlockWorkList()->finalCallReturn().isEmpty()) {
                basicBlockWorkList()->pendingCallReturn().pushBack(basicBlockWorkList()->finalCallReturn().popFront());
                makeNextCallReturnEdge(partitioner, partitioner->assumeFunctionsReturn());
            }
            continue;
        }

        // Nothing to do
        break;
    }

    // Nothing more to do; all lists are empty
    ASSERT_require(basicBlockWorkList()->undiscovered().isEmpty());
    ASSERT_require(basicBlockWorkList()->pendingCallReturn().isEmpty());
    ASSERT_require(basicBlockWorkList()->processedCallReturn().isEmpty());
    ASSERT_require(basicBlockWorkList()->finalCallReturn().isEmpty());
    return BasicBlock::Ptr();
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Build AST
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
SgAsmBlock*
EngineBinary::buildAst(const std::vector<std::string> &fileNames) {
    try {
        Partitioner::Ptr partitioner = partition(fileNames);
        return Modules::buildAst(partitioner, interpretation(), settings().astConstruction);
    } catch (const std::runtime_error &e) {
        if (settings().engine.exitOnError) {
            mlog[FATAL] <<e.what() <<"\n";
            exit(1);
        } else {
            throw;
        }
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Settings and Properties
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

BinaryLoader::Ptr
EngineBinary::binaryLoader() const {
    return binaryLoader_;
}

void
EngineBinary::binaryLoader(const BinaryLoader::Ptr &loader) {
    binaryLoader_ = loader;
}

ThunkPredicates::Ptr
EngineBinary::functionMatcherThunks() const {
    return functionMatcherThunks_;
}

void
EngineBinary::functionMatcherThunks(const ThunkPredicates::Ptr &p) {
    functionMatcherThunks_ = p;
}

ThunkPredicates::Ptr
EngineBinary::functionSplittingThunks() const {
    return functionSplittingThunks_;
}

void
EngineBinary::functionSplittingThunks(const ThunkPredicates::Ptr &p) {
    functionSplittingThunks_ = p;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Python API support
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef ROSE_ENABLE_PYTHON_API

template<class T>
std::vector<T>
pythonListToVector(boost::python::list &list) {
    std::vector<T> retval;
    for (int i = 0; i < len(list); ++i)
        retval.push_back(boost::python::extract<T>(list[i]));
    return retval;
}

Partitioner::Ptr
EngineBinary::pythonParseVector(boost::python::list &pyArgs, const std::string &purpose, const std::string &description) {
    reset();
    std::vector<std::string> args = pythonListToVector<std::string>(pyArgs);
    std::vector<std::string> specimenNames = parseCommandLine(args, purpose, description).unreachedArgs();
    return partition(specimenNames);
}

Partitioner::Ptr
EngineBinary::pythonParseSingle(const std::string &specimen, const std::string &purpose, const std::string &description) {
    return partition(std::vector<std::string>(1, specimen));
}

#endif

} // namespace
} // namespace
} // namespace

#endif
