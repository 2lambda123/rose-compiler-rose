#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <sage3basic.h>
#include <Rose/BinaryAnalysis/CallingConvention.h>

#include <Rose/BinaryAnalysis/DataFlow.h>
#include <Rose/BinaryAnalysis/Disassembler/Base.h>
#include <Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics/MemoryCellList.h>
#include <Rose/BinaryAnalysis/Partitioner2/DataFlow.h>    // Dataflow components that we can re-use
#include <Rose/BinaryAnalysis/Partitioner2/Partitioner.h> // Fast binary analysis data structures
#include <Rose/BinaryAnalysis/Partitioner2/Function.h>    // Fast function data structures
#include <Rose/BinaryAnalysis/RegisterDictionary.h>
#include <Rose/BinaryAnalysis/RegisterNames.h>
#include <Rose/BinaryAnalysis/SymbolicExpression.h>
#include <Rose/BinaryAnalysis/Unparser/Base.h>
#include <Rose/CommandLine.h>
#include <Rose/Diagnostics.h>

#include <Sawyer/ProgressBar.h>

using namespace Rose::Diagnostics;
using namespace Rose::BinaryAnalysis::InstructionSemantics;
using namespace Rose::BinaryAnalysis::InstructionSemantics::BaseSemantics;
namespace P2 = Rose::BinaryAnalysis::Partitioner2;

namespace Rose {
namespace BinaryAnalysis {
namespace CallingConvention {

Sawyer::Message::Facility mlog;

void
initDiagnostics() {
    static bool initialized = false;
    if (!initialized) {
        initialized = true;
        Diagnostics::initAndRegister(&mlog, "Rose::BinaryAnalysis::CallingConvention");
        mlog.comment("computing function calling conventions");
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Dictionaries
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const Dictionary&
dictionaryAarch32() {
    static Dictionary dict;
    // FIXME[Robb Matzke 2020-12-23]: none defined yet
    return dict;
}

const Dictionary&
dictionaryAarch64() {
    static Dictionary dict;
    // FIXME[Robb P. Matzke 2015-08-21]: none defind yet
    return dict;
}

const Dictionary&
dictionaryM68k() {
    static Dictionary dict;
    if (dict.empty()) {
        // https://m680x0.github.io/doc/abi.html
        const RegisterDictionary::Ptr regdict = RegisterDictionary::instanceColdfire();
        const RegisterDescriptor SP = regdict->findOrThrow("a7"); // a.k.a., "sp" in some dictionaries

        Definition::Ptr cc = Definition::instance(SP.nBits(), "sysv", "m68k-sysv", regdict);

        //==== Address locations ====
        cc->instructionPointerRegister(regdict->findOrThrow("pc"));
        cc->returnAddressLocation(ConcreteLocation(SP, 0));

        //==== Stack characteristics ====
        cc->stackPointerRegister(SP);
        cc->stackDirection(StackDirection::GROWS_DOWN);
        cc->nonParameterStackSize(cc->wordWidth() >> 3); // return address

        //====  Function parameters ====
        // All parameters are passed on the stack.
        cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
        cc->stackCleanup(StackCleanup::BY_CALLER);

        //==== Other inputs ====


        //==== Return values ====
        cc->appendOutputParameter(regdict->findOrThrow("d0"));
        cc->appendOutputParameter(regdict->findOrThrow("a0"));
        cc->appendOutputParameter(regdict->findOrThrow("fp0"));
        cc->appendOutputParameter(SP);                  // final value is usually one word greater than initial value

        //====  Scratch registers ====
        // (i.e., modified, not callee-saved, not return registers
        cc->scratchRegisters().insert(regdict->findOrThrow("d0"));
        cc->scratchRegisters().insert(regdict->findOrThrow("d1"));
        cc->scratchRegisters().insert(regdict->findOrThrow("a0"));
        cc->scratchRegisters().insert(regdict->findOrThrow("a1"));
        cc->scratchRegisters().insert(regdict->findOrThrow("pc"));
        cc->scratchRegisters().insert(regdict->findOrThrow("ccr"));
        cc->scratchRegisters().insert(regdict->findOrThrow("fp0"));
        cc->scratchRegisters().insert(regdict->findOrThrow("fp1"));


        //==== Callee-saved registers
        // Everything else
        RegisterParts regParts = regdict->getAllParts() - cc->getUsedRegisterParts();
        std::vector<RegisterDescriptor> registers = regParts.extract(regdict);
        cc->calleeSavedRegisters().insert(registers.begin(), registers.end());

        dict.push_back(cc);
    }

    return dict;
}

const Dictionary&
dictionaryMips() {
    static Dictionary dict;
    // FIXME[Robb P. Matzke 2015-08-21]: none defind yet
    return dict;
}

const Dictionary&
dictionaryPowerpc32() {
    static Dictionary dict;
    if (dict.empty())
        dict.push_back(Definition::ppc_32bit_ibm());
    return dict;
}

const Dictionary&
dictionaryPowerpc64() {
    static Dictionary dict;
    // FIXME[Robb Matzke 2019-08-07]: none defined yet
    return dict;
}

const Dictionary&
dictionaryAmd64() {
    static Dictionary dict;
    if (dict.empty()) {
        //--------
        // 64-bit
        //--------

        // Listed first because it's the most common
        dict.push_back(Definition::x86_64bit_sysv());

#if 0 // [Robb P. Matzke 2015-08-21]: don't bother distinguishing because alignment is not used yet.
        // cdecl: gcc < 4.5 uses 4-byte stack alignment
        cc = Definition::x86_64bit_cdecl();
        cc.comment(cc.comment() + " 4-byte alignment");
        cc.stackAlignment(4);
        dict.push_back(cc);

        // cdecl: gcc >= 4.5 uses 16-byte stack alignment
        cc = Definition::x86_64bit_cdecl();
        cc.comment(cc.comment() + " 16-byte alignment");
        cc.stackAlignment(16);
        dict.push_back(cc);
#else
        dict.push_back(Definition::x86_64bit_cdecl());
#endif
        dict.push_back(Definition::x86_64bit_stdcall());

        //--------
        // 32-bit
        //--------

#if 0 // [Robb P. Matzke 2015-08-21]: don't bother distinguishing because alignment is not used yet.
        // cdecl: gcc < 4.5 uses 4-byte stack alignment
        Definition cc = Definition::x86_32bit_cdecl();
        cc.comment(cc.comment() + " 4-byte alignment");
        cc.stackAlignment(4);
        dict.push_back(cc);

        // cdecl: gcc >= 4.5 uses 16-byte stack alignment
        cc = Definition::x86_32bit_cdecl();
        cc.comment(cc.comment() + " 16-byte alignment");
        cc.stackAlignment(16);
        dict.push_back(cc);
#else
        dict.push_back(Definition::x86_32bit_cdecl());
#endif

        // other conventions
        dict.push_back(Definition::x86_32bit_stdcall());
        dict.push_back(Definition::x86_32bit_fastcall());
    }
    return dict;
}

const Dictionary&
dictionaryX86() {
    static Dictionary dict;
    if (dict.empty()) {
        //--------
        // 32-bit
        //--------

#if 0 // [Robb P. Matzke 2015-08-21]: don't bother distinguishing because alignment is not used yet.
        // cdecl: gcc < 4.5 uses 4-byte stack alignment
        Definition cc = Definition::x86_32bit_cdecl();
        cc.comment(cc.comment() + " 4-byte alignment");
        cc.stackAlignment(4);
        dict.push_back(cc);

        // cdecl: gcc >= 4.5 uses 16-byte stack alignment
        cc = Definition::x86_32bit_cdecl();
        cc.comment(cc.comment() + " 16-byte alignment");
        cc.stackAlignment(16);
        dict.push_back(cc);
#else
        dict.push_back(Definition::x86_32bit_cdecl());
#endif

        // other conventions
        dict.push_back(Definition::x86_32bit_stdcall());
        dict.push_back(Definition::x86_32bit_fastcall());
    }
    return dict;
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Definition
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Definition::Definition() {}

Definition::Definition(size_t wordWidth, const std::string &name, const std::string &comment,
                       const RegisterDictionary::Ptr &regDict)
    : name_(name), comment_(comment), wordWidth_(wordWidth), regDict_(regDict) {
    ASSERT_require2(0 == (wordWidth & 7) && wordWidth > 0, "word size must be a positive multiple of eight");
    ASSERT_not_null(regDict);
}

Definition::~Definition() {}

// class method
Definition::Ptr
Definition::x86_32bit_cdecl() {
    static Ptr cc;
    if (!cc)
        cc = x86_cdecl(RegisterDictionary::instancePentium4());
    return cc;
}

// class method
Definition::Ptr
Definition::x86_64bit_cdecl() {
    static Ptr cc;
    if (!cc)
        cc = x86_cdecl(RegisterDictionary::instanceAmd64());
    return cc;
}

// class method
Definition::Ptr
Definition::x86_cdecl(const RegisterDictionary::Ptr &regDict) {
    ASSERT_not_null(regDict);
    const RegisterDescriptor SP = regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp);
    Ptr cc = instance(SP.nBits(), "cdecl",
                      "x86-" + StringUtility::numberToString(SP.nBits()) + " cdecl",
                      regDict);

    //==== Address locations ====
    cc->instructionPointerRegister(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->returnAddressLocation(ConcreteLocation(SP, 0));

    //==== Stack characteristics ====
    cc->stackPointerRegister(SP);
    cc->stackDirection(StackDirection::GROWS_DOWN);
    cc->nonParameterStackSize(cc->wordWidth() >> 3);    // return address

    //==== Function parameters ====
    // All parameters are passed on the stack.
    cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
    cc->stackCleanup(StackCleanup::BY_CALLER);

    //==== Other inputs ====
    // direction flag is always assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("df"), regDict));
    // code segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("cs"), regDict));
    // data segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ds"), regDict));
    // stack segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ss"), regDict));

    //==== Return values ====
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_ax));
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_st, x86_st_0));
    cc->appendOutputParameter(SP);                      // final value is usually one word greater than initial value

    //==== Scratch registers ====
    // (i.e., modified, not callee-saved, not return registers)
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_status));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_fpstatus));

    //==== Callee-saved registers ====
    // Everything else
    RegisterParts regParts = regDict->getAllParts() - cc->getUsedRegisterParts();
    std::vector<RegisterDescriptor> registers = regParts.extract(regDict);
    cc->calleeSavedRegisters().insert(registers.begin(), registers.end());

    return cc;
}

// class method
Definition::Ptr
Definition::ppc_32bit_ibm() {
    static Ptr cc;
    if (!cc)
        cc = ppc_ibm(RegisterDictionary::instancePowerpc32());
    return cc;
}

// class method
Definition::Ptr
Definition::ppc_ibm(const RegisterDictionary::Ptr &regDict) {
    // See https://www.ibm.com/support/knowledgecenter/en/ssw_aix_72/com.ibm.aix.alangref/idalangref_reg_use_conv.htm
    ASSERT_not_null(regDict);
    const RegisterDescriptor SP = regDict->findLargestRegister(powerpc_regclass_gpr, 1);
    Ptr cc = instance(SP.nBits(), "IBM", "PowerPC-" + StringUtility::numberToString(SP.nBits()) + " IBM", regDict);

    //==== Address locations ====
    cc->instructionPointerRegister(regDict->findLargestRegister(powerpc_regclass_iar, 0));
    cc->returnAddressLocation(ConcreteLocation(regDict->findLargestRegister(powerpc_regclass_spr, powerpc_spr_lr)));

    //==== Stack characteristics ====
    cc->stackPointerRegister(SP);
    cc->stackDirection(StackDirection::GROWS_DOWN);
    cc->nonParameterStackSize(0);                       // return address is in link register

    //==== Function parameters ====
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 3));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 4));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 5));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 6));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 7));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 8));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 9));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 10));

    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 1));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 2));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 3));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 4));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 5));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 6));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 7));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 8));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 9));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 10));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 11));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 12));
    cc->appendInputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 13));

    // Stack is generally not used for passing arguments
    cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
    cc->stackCleanup(StackCleanup::BY_CALLER);

    //==== Return values ====
    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 3)); // primary return
    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_gpr, 4)); // secondary return

    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 1));
    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 2));
    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 3));
    cc->appendOutputParameter(regDict->findLargestRegister(powerpc_regclass_fpr, 4));

    //==== Scratch registers ====
    // function arguments that are not return values, plus others.
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 5));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 6));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 7));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 8));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 9));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 10));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 11));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_gpr, 12));

    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 5));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 6));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 7));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 8));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 9));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 10));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 11));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 12));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpr, 13));

    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_cr, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_fpscr, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(powerpc_regclass_iar, 0));

    //==== Callee-saved registers ====
    // Everything else
    RegisterParts regParts = regDict->getAllParts() - cc->getUsedRegisterParts();
    std::vector<RegisterDescriptor> registers = regParts.extract(regDict);
    cc->calleeSavedRegisters().insert(registers.begin(), registers.end());

    return cc;
}

// class method
Definition::Ptr
Definition::x86_32bit_stdcall() {
    static Ptr cc;
    if (!cc)
        cc = x86_stdcall(RegisterDictionary::instancePentium4());
    return cc;
}

// class method
Definition::Ptr
Definition::x86_64bit_stdcall() {
    static Ptr cc;
    if (!cc)
        cc = x86_stdcall(RegisterDictionary::instanceAmd64());
    return cc;
}

// class method
Definition::Ptr
Definition::x86_stdcall(const RegisterDictionary::Ptr &regDict) {
    ASSERT_not_null(regDict);
    const RegisterDescriptor SP = regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp);
    Ptr cc = instance(SP.nBits(), "stdcall",
                      "x86-" + StringUtility::numberToString(SP.nBits()) + " stdcall",
                      regDict);

    //==== Address locations ====
    cc->instructionPointerRegister(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->returnAddressLocation(ConcreteLocation(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp), 0));

    //==== Stack characteristics ====
    cc->stackPointerRegister(SP);
    cc->stackDirection(StackDirection::GROWS_DOWN);
    cc->nonParameterStackSize(cc->wordWidth() >> 3);    // return address

    //==== Function parameters ====
    // All parameters are passed on the stack
    cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
    cc->stackCleanup(StackCleanup::BY_CALLEE);

    //==== Other inputs ====
    // direction flag is always assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("df"), regDict));
    // code segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("cs"), regDict));
    // data segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ds"), regDict));
    // stack segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ss"), regDict));

    //==== Return values ====
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_ax));
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_st, x86_st_0));
    cc->appendOutputParameter(SP);

    //==== Scratch registers ====
    // Modified, not callee-saved, not return registers
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_status));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_fpstatus));

    //==== Callee-saved registers ====
    // Everything else
    RegisterParts regParts = regDict->getAllParts() - cc->getUsedRegisterParts();
    std::vector<RegisterDescriptor> registers = regParts.extract(regDict);
    cc->calleeSavedRegisters().insert(registers.begin(), registers.end());

    return cc;
}

// class method
Definition::Ptr
Definition::x86_32bit_fastcall() {
    static Ptr cc;
    if (!cc)
        cc = x86_fastcall(RegisterDictionary::instancePentium4());
    return cc;
}

// class method
Definition::Ptr
Definition::x86_fastcall(const RegisterDictionary::Ptr &regDict) {
    ASSERT_not_null(regDict);
    const RegisterDescriptor SP = regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp);
    static Ptr cc = instance(SP.nBits(), "fastcall",
                             "x86-" + StringUtility::numberToString(SP.nBits()) + " fastcall",
                             regDict);

    //==== Address locations ====
    cc->instructionPointerRegister(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->returnAddressLocation(ConcreteLocation(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp), 0));

    //==== Stack characteristics ====
    cc->stackPointerRegister(SP);
    cc->stackDirection(StackDirection::GROWS_DOWN);
    cc->nonParameterStackSize(cc->wordWidth() >> 3);    // return address

    //==== Function parameters ====
    // Uses ECX and EDX for first args that fit; all other parameters are passed on the stack.
    cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
    cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx));
    cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
    cc->stackCleanup(StackCleanup::BY_CALLEE);

    //==== Other inputs ====
    // direction flag is always assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("df"), regDict));
    // code segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("cs"), regDict));
    // data segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ds"), regDict));
    // stack segment register is assumed to be valid
    cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ss"), regDict));

    //==== Return values ====
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_ax));
    cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_st, x86_st_0));
    cc->appendOutputParameter(SP);

    //==== Scratch registers ====
    // I.e., modified, not callee-saved, not return registers
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_ip, 0));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_status));
    cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_fpstatus));

    //==== Callee-saved registers ====
    // Everything else
    RegisterParts regParts = regDict->getAllParts() - cc->getUsedRegisterParts();
    std::vector<RegisterDescriptor> registers = regParts.extract(regDict);
    cc->calleeSavedRegisters().insert(registers.begin(), registers.end());

    return cc;
}

// class method
Definition::Ptr
Definition::x86_64bit_sysv() {
    static Ptr cc;
    if (!cc) {
        RegisterDictionary::Ptr regDict = RegisterDictionary::instanceAmd64();
        const RegisterDescriptor SP = regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp);

        cc = instance(64, "sysv", "x86-64 sysv", regDict);

        //==== Address locations ====
        cc->instructionPointerRegister(regDict->findLargestRegister(x86_regclass_ip, 0));
        cc->returnAddressLocation(ConcreteLocation(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_sp), 0));

        //==== Stack characteristics ====
        cc->stackPointerRegister(SP);
        cc->stackDirection(StackDirection::GROWS_DOWN);
        cc->nonParameterStackSize(cc->wordWidth() >> 3); // return address

        //==== Function parameters ====

        // The first six integer or pointer arguments are passed in registers RDI, RSI, RDX, RCX, R8, and R9.
        // These registers are also not preserved across the call.
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_di));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_si));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r8));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r9));

        // The first eight SSE arguments are passed in registers xmm0 through xmm7
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 0));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 1));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 2));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 3));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 4));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 5));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 6));
        cc->appendInputParameter(regDict->findLargestRegister(x86_regclass_xmm, 7));

        // The AL register is an input register that stores the number of SSE registers used for variable argument calls. (It
        // is also part of the first return value).
        cc->appendInputParameter(RegisterDescriptor(x86_regclass_gpr, x86_gpr_ax, 0, 8)); // for varargs calls

        // Arguments that don't fit in the input registers are passed on the stack
        cc->stackParameterOrder(StackParameterOrder::RIGHT_TO_LEFT);
        cc->stackCleanup(StackCleanup::BY_CALLER);

        //==== Other inputs ====

        // direction flag is assuemd to be valid
        cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("df"), regDict));
        // code segment register is assumed to be valid
        cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("cs"), regDict));
        // data segment register is assumed to be valid
        cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ds"), regDict));
        // stack segment register is assumed to be valid
        cc->nonParameterInputs().push_back(ConcreteLocation(regDict->findOrThrow("ss"), regDict));


        //==== Return values ====
        cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_ax));
        cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx)); // second integer return
        cc->appendOutputParameter(SP);                   // final value is usually 8 greater than initial value
        cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_xmm, 0));
        cc->appendOutputParameter(regDict->findLargestRegister(x86_regclass_xmm, 1));
        //cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 0)); // dynamic st(0), overlaps mm<i>
        //cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 1)); // dynamic st(1), overlaps mm<i+1>

        //==== Scratch registers ====
        // Modified, not callee-saved, not return values

        // Registers that hold arguments are also scratch registers (as long as they're not return values)
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_di));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_si));
        //cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_dx)); this is a return reg
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_cx));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r8));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r9));

        //cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 0)); this is a return reg
        //cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 1)); this is a return reg
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 2));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 3));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 4));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 5));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 6));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 7));

        // These registers are almost always modified by a function
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_ip, 0));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_status));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_flags, x86_flags_fpstatus));

        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r10)); //static chain ptr
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_gpr, x86_gpr_r11));

        // Floating point registers are pretty much all scratch.
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 8));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 9));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 10));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 11));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 12));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 13));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 14));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_xmm, 15));

        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 0)); // i.e., statically mm0
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 1)); // mm1, etc. Since mm<i> could
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 2)); // overlap with st(0) or st(1),
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 3)); // two of these could also be
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 4)); // return values.
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 5));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 6));
        cc->scratchRegisters().insert(regDict->findLargestRegister(x86_regclass_st, 7));

        //==== Callee-saved registers ====
        // Everything else
        RegisterParts regParts = regDict->getAllParts() - cc->getUsedRegisterParts();
        std::vector<RegisterDescriptor> registers = regParts.extract(regDict);
        cc->calleeSavedRegisters().insert(registers.begin(), registers.end());
    }
    return cc;
}

RegisterDictionary::Ptr
Definition::registerDictionary() const {
    return regDict_;
}

void
Definition::registerDictionary(const RegisterDictionary::Ptr &dict) {
    regDict_ = dict;
}

void
Definition::appendInputParameter(const ConcreteLocation &newLocation) {
#ifndef NDEBUG
    for (const ConcreteLocation &existingLocation: inputParameters_)
        ASSERT_forbid(newLocation == existingLocation);
#endif
    inputParameters_.push_back(newLocation);
}

void
Definition::appendOutputParameter(const ConcreteLocation &newLocation) {
#ifndef NDEBUG
    for (const ConcreteLocation &existingLocation: outputParameters_)
        ASSERT_forbid(newLocation == existingLocation);
#endif
    outputParameters_.push_back(newLocation);
}

RegisterParts
Definition::outputRegisterParts() const {
    RegisterParts retval;
    for (const ConcreteLocation &loc: outputParameters_) {
        if (loc.type() == ConcreteLocation::REGISTER)
            retval.insert(loc.reg());
    }
    return retval;
}

RegisterParts
Definition::inputRegisterParts() const {
    RegisterParts retval;
    for (const ConcreteLocation &loc: inputParameters_) {
        if (loc.type() == ConcreteLocation::REGISTER)
            retval.insert(loc.reg());
    }
    for (const ConcreteLocation &loc: nonParameterInputs_) {
        if (loc.type() == ConcreteLocation::REGISTER)
            retval.insert(loc.reg());
    }
    return retval;
}

RegisterParts
Definition::scratchRegisterParts() const {
    RegisterParts retval;
    for (RegisterDescriptor reg: scratchRegisters_)
        retval.insert(reg);
    return retval;
}

RegisterParts
Definition::calleeSavedRegisterParts() const {
    RegisterParts retval;
    for (RegisterDescriptor reg: calleeSavedRegisters_)
        retval.insert(reg);
    return retval;
}

RegisterParts
Definition::getUsedRegisterParts() const {
    RegisterParts retval = inputRegisterParts();
    retval |= outputRegisterParts();
    if (!stackPointerRegister_.isEmpty())
        retval.insert(stackPointerRegister_);
    if (thisParameter_.type() == ConcreteLocation::REGISTER)
        retval.insert(thisParameter_.reg());
    retval |= calleeSavedRegisterParts();
    retval |= scratchRegisterParts();
    return retval;
}

void
Definition::print(std::ostream &out) const {
    print(out, RegisterDictionary::Ptr());
}

void
Definition::print(std::ostream &out, const RegisterDictionary::Ptr &regDictOverride/*=NULL*/) const {
    using namespace StringUtility;
    ASSERT_require(regDictOverride || regDict_);
    RegisterDictionary::Ptr regDict = regDictOverride ? regDictOverride : regDict_;
    RegisterNames regNames(regDict);

    out <<cEscape(name_);
    if (!comment_.empty())
        out <<" (" <<cEscape(comment_) <<")";
    out <<" = {" <<wordWidth_ <<"-bit words";

    if (instructionPointerRegister_)
        out <<", instructionAddressLocation=" <<regNames(instructionPointerRegister_);

    if (returnAddressLocation_.isValid()) {
        out <<", returnAddress=";
        returnAddressLocation_.print(out, regDict_);
    }

    if (!inputParameters_.empty()) {
        out <<", input-parameters={";
        for (const ConcreteLocation &loc: inputParameters_) {
            out <<" ";
            loc.print(out, regDict ? regDict : loc.registerDictionary());
        }
        out <<" }";
    }

    if (!nonParameterInputs_.empty()) {
        out <<", non-parameter-inputs={";
        for (const ConcreteLocation &loc: nonParameterInputs_) {
            out <<" ";
            loc.print(out, regDict ? regDict : loc.registerDictionary());
        }
        out <<" }";
    }

    if (stackParameterOrder_ != StackParameterOrder::UNSPECIFIED) {
        out <<", implied={";
        switch (stackParameterOrder_) {
            case StackParameterOrder::LEFT_TO_RIGHT: out <<" left-to-right"; break;
            case StackParameterOrder::RIGHT_TO_LEFT: out <<" right-to-left"; break;
            case StackParameterOrder::UNSPECIFIED: ASSERT_not_reachable("invalid stack parameter order");
        }

        if (!stackPointerRegister_.isEmpty()) {
            out <<" " <<regNames(stackPointerRegister_) <<"-based stack";
        } else {
            out <<" NO-STACK-REGISTER";
        }

        switch (stackCleanup_) {
            case StackCleanup::BY_CALLER: out <<" cleaned up by caller"; break;
            case StackCleanup::BY_CALLEE: out <<" cleaned up by callee"; break;
            case StackCleanup::UNSPECIFIED: out <<" with UNSPECIFIED cleanup"; break;
        }
        out <<" }";
    }

    if (nonParameterStackSize_ > 0)
        out <<", " <<nonParameterStackSize_ <<"-byte return";

    if (stackParameterOrder_ != StackParameterOrder::UNSPECIFIED || nonParameterStackSize_ > 0) {
        switch (stackDirection_) {
            case StackDirection::GROWS_UP: out <<", upward-growing stack"; break;
            case StackDirection::GROWS_DOWN: out <<", downward-growing stack"; break;
        }
    }

    if (thisParameter_.isValid()) {
        out <<", this=";
        thisParameter_.print(out, regDict ? regDict : thisParameter_.registerDictionary());
    }

    if (!outputParameters_.empty()) {
        out <<", outputs={";
        for (const ConcreteLocation &loc: outputParameters_) {
            out <<" ";
            loc.print(out, regDict ? regDict : loc.registerDictionary());
        }
        out <<" }";
    }

    if (!scratchRegisters_.empty()) {
        out <<", scratch={";
        for (RegisterDescriptor loc: scratchRegisters_)
            out <<" " <<regNames(loc);
        out <<" }";
    }

    if (!calleeSavedRegisters_.empty()) {
        out <<", saved={";
        for (RegisterDescriptor loc: calleeSavedRegisters_)
            out <<" " <<regNames(loc);
        out <<" }";
    }
}

std::ostream&
operator<<(std::ostream &out, const Definition &x) {
    x.print(out);
    return out;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                      Analysis
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

Analysis::Analysis()
    : hasResults_(false), didConverge_(false) {}

Analysis::Analysis(const Disassembler::BasePtr &d)
    : hasResults_(false), didConverge_(false) {
    init(d);
}

Analysis::Analysis(const InstructionSemantics::BaseSemantics::Dispatcher::Ptr &cpu)
    : cpu_(cpu), hasResults_(false), didConverge_(false) {}

Analysis::~Analysis() {}

void
Analysis::init(const Disassembler::Base::Ptr &disassembler) {
    if (disassembler) {
        RegisterDictionary::Ptr registerDictionary = disassembler->registerDictionary();
        ASSERT_not_null(registerDictionary);
        size_t addrWidth = disassembler->instructionPointerRegister().nBits();

        SmtSolverPtr solver = SmtSolver::instance(Rose::CommandLine::genericSwitchArgs.smtSolver);
        SymbolicSemantics::RiscOperators::Ptr ops = SymbolicSemantics::RiscOperators::instanceFromRegisters(registerDictionary, solver);

        cpu_ = disassembler->dispatcher()->create(ops, addrWidth, registerDictionary);
    }
}

void
Analysis::clearResults() {
    hasResults_ = didConverge_ = false;
    restoredRegisters_.clear();
    inputRegisters_.clear();
    outputRegisters_.clear();
    inputStackParameters_.clear();
    outputStackParameters_.clear();
    stackDelta_ = Sawyer::Nothing();
}

void
Analysis::clearNonResults() {
    cpu_ = Dispatcher::Ptr();
}

RegisterDictionary::Ptr
Analysis::registerDictionary() const {
    return regDict_;
}

void
Analysis::registerDictionary(const RegisterDictionary::Ptr &d) {
    regDict_ = d;
}

class TransferFunction: public P2::DataFlow::TransferFunction {
    using Super = P2::DataFlow::TransferFunction;
    P2::Partitioner::ConstPtr partitioner_;

public:
    std::string dfEngineName;

public:
    TransferFunction(const P2::Partitioner::ConstPtr &partitioner, const Dispatcher::Ptr &cpu)
        : Super(cpu), partitioner_(partitioner) {
        ASSERT_not_null(partitioner);
    }

    // Just add some debugging to the P2::DataFlow::TransferFunction.
    State::Ptr operator()(const P2::DataFlow::DfCfg &dfCfg, size_t vertexId, const State::Ptr &incomingState) const {
        Sawyer::Message::Stream out(Rose::BinaryAnalysis::DataFlow::mlog[DEBUG]);
        if (out) {
            P2::DataFlow::DfCfg::ConstVertexIterator vertex = dfCfg.findVertex(vertexId);
            const std::string prefix = dfEngineName + (dfEngineName.empty()?"":": ") + "  ";
            ASSERT_require(vertex != dfCfg.vertices().end());
            switch (vertex->value().type()) {
                case P2::DataFlow::DfCfgVertex::BBLOCK: {
                    out <<prefix <<"vertex #" <<vertex->id() <<": " <<vertex->value().bblock()->printableName() <<"\n";
                    if (auto parentFunction = vertex->value().parentFunction())
                        out <<prefix <<"  in " <<parentFunction->printableName() <<"\n";
                    for (const auto &edge: vertex->inEdges())
                        out <<prefix <<"  cfg from vertex #" <<edge.source()->id() <<"\n";
                    auto unparser = partitioner_->unparser()->copy();
                    unparser->settings().linePrefix = prefix + "    ";
                    unparser->settings().bblock.cfg.showingPredecessors = false;
                    unparser->settings().bblock.cfg.showingSuccessors = false;
                    unparser->settings().bblock.cfg.showingSharing = false;
                    unparser->settings().bblock.cfg.showingArrows = false;
                    unparser->unparse(out, partitioner_, vertex->value().bblock());
                    for (const auto &edge: vertex->outEdges())
                        out <<prefix <<"  cfg to vertex #" <<edge.target()->id() <<"\n";
                    break;
                }

                case P2::DataFlow::DfCfgVertex::FAKED_CALL:
                    out <<prefix <<"vertex #" <<vertex->id() <<": faked call to ";
                    if (auto callee = vertex->value().callee()) {
                        out <<callee->printableName() <<"\n";
                    } else {
                        out <<"indeterminate address\n";
                    }
                    if (auto parentFunction = vertex->value().parentFunction())
                        out <<prefix <<"  called from " <<parentFunction->printableName() <<"\n";
                    for (const auto &edge: vertex->inEdges())
                        out <<prefix <<"  cfg from vertex #" <<edge.source()->id() <<"\n";
                    for (const auto &edge: vertex->outEdges())
                        out <<prefix <<"  cfg to vertex #" <<edge.target()->id() <<"\n";
                    break;

                case P2::DataFlow::DfCfgVertex::FUNCRET:
                    out <<prefix <<"vertex #" <<vertex->id() <<": function return from "
                        <<vertex->value().parentFunction()->printableName() <<"\n";
                    for (const auto &edge: vertex->inEdges())
                        out <<prefix <<"  cfg from vertex #" <<edge.source()->id() <<"\n";
                    for (const auto &edge: vertex->outEdges())
                        out <<prefix <<"  cfg to vertex #" <<edge.target()->id() <<"\n";
                    break;

                case P2::DataFlow::DfCfgVertex::INDET:
                    out <<prefix <<"vertex #" <<vertex->id() <<": indeterminate address\n";
                    for (const auto &edge: vertex->inEdges())
                        out <<prefix <<"  cfg from vertex #" <<edge.source()->id() <<"\n";
                    for (const auto &edge: vertex->outEdges())
                        out <<prefix <<"  cfg to vertex #" <<edge.target()->id() <<"\n";
                    break;
            }
        }
        return Super::operator()(dfCfg, vertexId, incomingState);
    }
};

void
Analysis::analyzeFunction(const P2::Partitioner::ConstPtr &partitioner, const P2::Function::Ptr &function) {
    ASSERT_not_null(partitioner);
    mlog[DEBUG] <<"analyzing " <<function->printableName() <<"\n";
    clearResults();

    // Build the CFG used by the dataflow: dfCfg.  The dfCfg includes only those vertices that are reachable from the entry
    // point for the function we're analyzing and which belong to that function.  All return points in the function will flow
    // into a special CALLRET vertex (which is absent if there are no returns).
    typedef P2::DataFlow::DfCfg DfCfg;
    DfCfg dfCfg = P2::DataFlow::buildDfCfg(partitioner, partitioner->cfg(), partitioner->findPlaceholder(function->address()));
#if 0 // DEBUGGING [Robb P Matzke 2017-02-24]
    {
        boost::filesystem::path debugDir = "./rose-debug/BinaryAnalysis/CallingConvention";
        boost::filesystem::create_directories(debugDir);
        boost::filesystem::path fileName = debugDir /
                                           ("F_" + StringUtility::addrToString(function->address()).substr(2) + ".dot");
        std::ofstream f(fileName.string().c_str());
        P2::DataFlow::dumpDfCfg(f, dfCfg);
    }
#endif
    size_t startVertexId = 0;
    DfCfg::ConstVertexIterator returnVertex = dfCfg.vertices().end();
    for (const DfCfg::Vertex &vertex: dfCfg.vertices()) {
        if (vertex.value().type() == P2::DataFlow::DfCfgVertex::FUNCRET) {
            returnVertex = dfCfg.findVertex(vertex.id());
            break;
        }
    }
    if (returnVertex == dfCfg.vertices().end()) {
        mlog[DEBUG] <<"  function CFG has no return vertex\n";
        return;
    }

    // Build the dataflow engine.  If an instruction dispatcher is already provided then use it, otherwise create one and store
    // it in this analysis object.
    typedef DataFlow::Engine<DfCfg, State::Ptr, TransferFunction, DataFlow::SemanticsMerge> DfEngine;
    if (!cpu_ && NULL==(cpu_ = partitioner->newDispatcher(partitioner->newOperators()))) {
        mlog[DEBUG] <<"  no instruction semantics\n";
        return;
    }
    P2::DataFlow::MergeFunction merge(cpu_);
    TransferFunction xfer(partitioner, cpu_);
    xfer.defaultCallingConvention(defaultCc_);
    DfEngine dfEngine(dfCfg, xfer, merge);
    dfEngine.name("calling-convention");
    xfer.dfEngineName = dfEngine.name();
    size_t maxIterations = dfCfg.nVertices() * 5;       // arbitrary
    dfEngine.maxIterations(maxIterations);
    regDict_ = cpu_->registerDictionary();

    // Build the initial state
    State::Ptr initialState = xfer.initialState();
    RegisterStateGeneric::Ptr initialRegState = RegisterStateGeneric::promote(initialState->registerState());
    initialRegState->initialize_large();
#if 0 // [Robb Matzke 2022-07-12]
    // Initializing the stack pointer register to a constant value will interfere with detecting local variables, since the
    // detection looks for the stack pointer's initial value plus a constant. If the stack pointer were initialized to a
    // constant here, then all such offsets from the stack pointer would be simplified to just constants and the local variable
    // detection wouldn't be able to find anything. However, it might also be possible to change the local variable detector
    // so it looks for constants that are near the stack pointer's concrete value. [Robb Matzke 2022-07-12]
    const RegisterDescriptor SP = partitioner->instructionProvider().stackPointerRegister();
    rose_addr_t initialStackPointer = 0xcf000000;       // arbitrary
    initialRegState->writeRegister(SP, cpu_->operators()->number_(SP.nBits(), initialStackPointer),
                                   cpu_->operators().get());
#endif
    // x86 has segment registers ss, ds, and cs that should be initialized to zero.  The local variable detector gets confused
    // when local variable addresses have a segment component. Setting them to zero causes them to be simplified out of the
    // addresses.
    if (RegisterDescriptor ss = regDict_->find("ss"))
        initialState->writeRegister(ss, cpu_->operators()->number_(ss.nBits(), 0), cpu_->operators().get());
    if (RegisterDescriptor cs = regDict_->find("cs"))
        initialState->writeRegister(cs, cpu_->operators()->number_(cs.nBits(), 0), cpu_->operators().get());
    if (RegisterDescriptor ds = regDict_->find("ds"))
        initialState->writeRegister(ds, cpu_->operators()->number_(ds.nBits(), 0), cpu_->operators().get());

    // Run data flow analysis
    bool converged = true;
    try {
        // Use this rather than runToFixedPoint because it lets us show a progress report
        Sawyer::ProgressBar<size_t> progress(maxIterations, mlog[MARCH], function->printableName());
        progress.suffix(" iterations");
        dfEngine.reset(State::Ptr());
        dfEngine.insertStartingVertex(startVertexId, initialState);
        while (dfEngine.runOneIteration())
            ++progress;
    } catch (const DataFlow::NotConverging &e) {
        mlog[WARN] <<e.what() <<" for " <<function->printableName() <<"\n";
        converged = false;                              // didn't converge, so just use what we have
    } catch (const BaseSemantics::NotImplemented &e) {
        mlog[WHERE] <<e.what() <<" for " <<function->printableName() <<"\n";
        converged = false;
    } catch (const BaseSemantics::Exception &e) {
        mlog[WARN] <<e.what() <<" for " <<function->printableName() <<"\n";
        converged = false;
    }

    // Get the final dataflow state
    State::Ptr finalState = dfEngine.getInitialState(returnVertex->id());
    if (finalState == NULL) {
        mlog[DEBUG] <<"  data flow analysis did not reach final state\n";
        return;
    }
    if (mlog[DEBUG]) {
        if (!converged) {
            mlog[DEBUG] <<"  data flow analysis did not converge to a solution (using partial solution)\n";
        } else {
            SymbolicSemantics::Formatter fmt;
            fmt.set_line_prefix("    ");
            fmt.expr_formatter.max_depth = 10;          // prevent really long output
            mlog[DEBUG] <<"  final state:\n" <<(*finalState+fmt);
        }
    }
    RegisterStateGeneric::Ptr finalRegs = RegisterStateGeneric::promote(finalState->registerState());

    // Update analysis results
    updateRestoredRegisters(initialState, finalState);
    updateInputRegisters(finalState);
    updateOutputRegisters(finalState);
    updateStackParameters(function, initialState, finalState);
    updateStackDelta(initialState, finalState);
    hasResults_ = true;
    didConverge_ = converged;

    SAWYER_MESG(mlog[DEBUG]) <<"  analysis results for " <<function->printableName() <<": " <<*this <<"\n";
}

void
Analysis::updateRestoredRegisters(const State::Ptr &initialState, const State::Ptr &finalState) {
    restoredRegisters_.clear();

    RegisterStateGeneric::Ptr initialRegs = RegisterStateGeneric::promote(initialState->registerState());
    RegisterStateGeneric::Ptr finalRegs = RegisterStateGeneric::promote(finalState->registerState());
    ASSERT_not_null2(cpu_, "analyzer is not properly initialized");
    RiscOperators::Ptr ops = cpu_->operators();

    InputOutputPropertySet props;
    props.insert(IO_READ_BEFORE_WRITE);
    props.insert(IO_WRITE);
    for (RegisterDescriptor reg: finalRegs->findProperties(props)) {
        SValue::Ptr initialValue = initialRegs->peekRegister(reg, ops->undefined_(reg.nBits()), ops.get());
        SValue::Ptr finalValue = finalRegs->peekRegister(reg, ops->undefined_(reg.nBits()), ops.get());
        SymbolicExpression::Ptr initialExpr = SymbolicSemantics::SValue::promote(initialValue)->get_expression();
        SymbolicExpression::Ptr finalExpr = SymbolicSemantics::SValue::promote(finalValue)->get_expression();
        if (finalExpr->flags() == initialExpr->flags() && finalExpr->mustEqual(initialExpr, ops->solver()))
            restoredRegisters_.insert(reg);
    }
}

void
Analysis::updateInputRegisters(const State::Ptr &state) {
    inputRegisters_.clear();
    RegisterStateGeneric::Ptr regs = RegisterStateGeneric::promote(state->registerState());
    for (RegisterDescriptor reg: regs->findProperties(IO_READ_BEFORE_WRITE))
        inputRegisters_.insert(reg);
    inputRegisters_ -= restoredRegisters_;
}

void
Analysis::updateOutputRegisters(const State::Ptr &state) {
    outputRegisters_.clear();
    RegisterStateGeneric::Ptr regs = RegisterStateGeneric::promote(state->registerState());
    for (RegisterDescriptor reg: regs->findProperties(IO_WRITE))
        outputRegisters_.insert(reg);
    outputRegisters_ -= restoredRegisters_;
}

void
Analysis::updateStackParameters(const P2::Function::Ptr &function, const State::Ptr &initialState, const State::Ptr &finalState) {
    inputStackParameters_.clear();
    outputStackParameters_.clear();

    ASSERT_not_null2(cpu_, "analyzer is not properly initialized");
    RiscOperators::Ptr ops = cpu_->operators();
    RegisterDescriptor SP = cpu_->stackPointerRegister();
    SValue::Ptr initialStackPointer = initialState->peekRegister(SP, ops->undefined_(SP.nBits()), ops.get());
    ops->currentState(finalState);
    Variables::StackVariables vars = P2::DataFlow::findFunctionArguments(function, ops, initialStackPointer);
    for (const Variables::StackVariable &var: vars.values()) {
        if (var.ioProperties().exists(IO_READ_BEFORE_WRITE)) {
            inputStackParameters_.insert(var.interval(), var);
        } else if (var.ioProperties().exists(IO_WRITE) && var.ioProperties().exists(IO_READ_AFTER_WRITE)) {
            outputStackParameters_.insert(var.interval(), var);
        }
    }
}

void
Analysis::updateStackDelta(const State::Ptr &initialState, const State::Ptr &finalState) {
    ASSERT_not_null2(cpu_, "analyzer is not properly initialized");
    RiscOperators::Ptr ops = cpu_->operators();
    RegisterDescriptor SP = cpu_->stackPointerRegister();
    SValue::Ptr initialStackPointer = initialState->peekRegister(SP, ops->undefined_(SP.nBits()), ops.get());
    SValue::Ptr finalStackPointer = finalState->peekRegister(SP, ops->undefined_(SP.nBits()), ops.get());
    SValue::Ptr stackDelta = ops->subtract(finalStackPointer, initialStackPointer);
    stackDelta_ = stackDelta->toSigned();
}

void
Analysis::print(std::ostream &out, bool multiLine) const {
    RegisterNames regName(regDict_);
    std::string separator;

    if (!inputRegisters_.isEmpty() || !inputStackParameters_.isEmpty()) {
        out <<separator <<"inputs={";
        if (!inputRegisters_.isEmpty()) {
            for (RegisterDescriptor reg: inputRegisters_.listAll(regDict_))
                out <<" " <<regName(reg);
        }
        if (!inputStackParameters_.isEmpty()) {
            Variables::StackVariables vars = inputStackParameters();
            for (const Variables::StackVariable &var: vars.values())
                out <<" stack[" <<var.frameOffset() <<"]+" <<var.maxSizeBytes();
        }
        out <<" }";
        separator = multiLine ? "\n" : ", ";
    }

    if (!outputRegisters_.isEmpty() || !outputStackParameters_.isEmpty()) {
        out <<separator <<"outputs={";
        if (!outputRegisters_.isEmpty()) {
            for (RegisterDescriptor reg: outputRegisters_.listAll(regDict_))
                out <<" " <<regName(reg);
        }
        if (!outputStackParameters_.isEmpty()) {
            Variables::StackVariables vars = outputStackParameters();
            for (const Variables::StackVariable &var: vars.values())
                out <<" stack[" <<var.frameOffset() <<"]+" <<var.maxSizeBytes();
        }
        out <<" }";
        separator = multiLine ? "\n" : ", ";
    }

    if (!restoredRegisters_.isEmpty()) {
        out <<separator <<"saved={";
        for (RegisterDescriptor reg: restoredRegisters_.listAll(regDict_))
            out <<" " <<regName(reg);
        out <<" }";
        separator = multiLine ? "\n" : ", ";
    }

    if (stackDelta_) {
        out <<separator <<"stackDelta=" <<(*stackDelta_>=0?"+":"") <<*stackDelta_;
        separator = multiLine ? "\n" : ", ";
    }

    if (separator.empty())
        out <<"no I/O";
}

bool
Analysis::match(const Definition::Ptr &cc) const {
    ASSERT_not_null2(cpu_, "analyzer is not properly initialized");
    ASSERT_not_null(cc);

    Sawyer::Message::Stream debug(mlog[DEBUG]);
    SAWYER_MESG(debug) <<"matching calling convention definition to analysis\n"
                       <<"  definition: " <<*cc <<"\n"
                       <<"  analysis results: " <<*this <<"\n";

    if (!hasResults_) {
        SAWYER_MESG(debug) <<"  mismatch: no analysis results\n";
        return false;
    }

    if (cc->wordWidth() != cpu_->stackPointerRegister().nBits()) {
        SAWYER_MESG(debug) <<"  mismatch: defn word size (" <<cc->wordWidth() <<") != analysis word size ("
                           <<cpu_->stackPointerRegister().nBits() <<")\n";
        return false;
    }

    // Gather up definition's input registers. We always add EIP (or similar) because the analysis will have read it to obtain
    // the function's first instruction before ever writing to it.  Similarly, we add ESP (or similar) because pushing,
    // popping, aligning, and allocating local variable space all read ESP before writing to it.
    RegisterParts ccInputRegisters = cc->inputRegisterParts();
    ccInputRegisters.insert(cpu_->instructionPointerRegister());
    ccInputRegisters.insert(cpu_->stackPointerRegister());
    if (cc->thisParameter().type() == ConcreteLocation::REGISTER)
        ccInputRegisters.insert(cc->thisParameter().reg());

    // Gather up definition's output registers.  We always add EIP (or similar) because the final RET instruction will write
    // the return address into the EIP register and not subsequently read it. The stack pointer register is not added by
    // default because not all functions use the stack (e.g., architectures that have link registers); it must be added (or
    // not) when the definition is created.
    RegisterParts ccOutputRegisters = cc->outputRegisterParts() | cc->scratchRegisterParts();
    ccOutputRegisters.insert(cpu_->instructionPointerRegister());

    // Stack delta checks
    if (stackDelta_) {
        int64_t normalization = (cc->stackDirection() == StackDirection::GROWS_UP ? -1 : +1);
        int64_t normalizedStackDelta = *stackDelta_ * normalization; // in bytes

        // All callees must pop the non-parameter area (e.g., return address) of the stack.
        if (normalizedStackDelta < 0 || (uint64_t)normalizedStackDelta < cc->nonParameterStackSize()) {
            SAWYER_MESG(debug) <<"  mismatch: callee did not pop " <<cc->nonParameterStackSize() <<"-byte"
                               <<" non-parameter area from stack\n";
            return false;
        }
        normalizedStackDelta -= cc->nonParameterStackSize();

        switch (cc->stackCleanup()) {
            case StackCleanup::BY_CALLER:
                if (normalizedStackDelta != 0) {
                    // Any stack arguments were already pushed by the caller and will be popped by the caller. If instead the
                    // callee pops them, then the stack delta will be non-zero.
                    SAWYER_MESG(debug) <<"  mismatch: callee popped stack parameters but definition is caller-cleanup\n";
                    return false;
                }
                break;

            case StackCleanup::BY_CALLEE: {
                // The callee must pop all the stack variables. It's required to pop all its arguments, even those it didn't
                // use.
                int64_t normalizedEnd = 0; // one-past first-pushed argument normalized for downward-growing stack
                for (const Variables::StackVariable &var: inputStackParameters_.values())
                    normalizedEnd = std::max(normalizedEnd, (int64_t)(var.frameOffset() * normalization + var.maxSizeBytes()));
                for (const Variables::StackVariable &var: outputStackParameters_.values())
                    normalizedEnd = std::max(normalizedEnd, (int64_t)(var.frameOffset() * normalization + var.maxSizeBytes()));
                if (normalizedStackDelta < normalizedEnd) {
                    SAWYER_MESG(debug) <<"  mismatch: callee failed to pop callee-cleanup stack parameters\n";
                    return false;
                }
                break;
            }

            case StackCleanup::UNSPECIFIED:
                ASSERT_not_reachable("invalid stack cleanup");
        }
    } else {
        SAWYER_MESG(debug) <<"  stack delta checks not performed\n";
    }

    // All analysis output registers must be a definition's output or scratch register.
    if (!(outputRegisters_ - ccOutputRegisters).isEmpty()) {
        if (debug) {
            RegisterNames regName(registerDictionary());
            debug <<"  mismatch: actual outputs are not defined outputs or scratch registers: ";
            RegisterParts parts = outputRegisters_ - ccOutputRegisters;
            for (RegisterDescriptor reg: parts.listAll(registerDictionary()))
                debug <<" " <<regName(reg);
            debug <<"\n";
        }
        return false;
    }

    // All analysis input registers must be a definition's input parameters, non-parameter inputs, or "this" register.
    if (!(inputRegisters_ - ccInputRegisters).isEmpty()) {
        if (debug) {
            RegisterNames regName(registerDictionary());
            debug <<"  mismatch: actual inputs are not defined inputs or \"this\" register: ";
            RegisterParts parts = inputRegisters_ - ccInputRegisters;
            for (RegisterDescriptor reg: parts.listAll(registerDictionary()))
                debug <<" " <<regName(reg);
            debug <<"\n";
        }
        return false;
    }

    // All analysis restored registers must be a definition's callee-saved register.
    if (!(restoredRegisters_ - cc->calleeSavedRegisterParts()).isEmpty()) {
        if (debug) {
            debug <<"  mismatch: restored registers that are not defined as callee-saved:";
            RegisterParts parts = restoredRegisters_ - cc->calleeSavedRegisterParts();
            RegisterNames regName(registerDictionary());
            for (RegisterDescriptor reg: parts.listAll(registerDictionary()))
                debug <<" " <<regName(reg);
            debug <<"\n";
        }
        return false;
    }

    // If the definition has an object pointer ("this" parameter) then it should not be an anlysis output or scratch register,
    // but must be an analysis input register.
    if (cc->thisParameter().type() == ConcreteLocation::REGISTER) {
        if (ccOutputRegisters.existsAny(cc->thisParameter().reg())) {
            SAWYER_MESG(debug) <<"  mismatch: actual output defined as \"this\" register: "
                               <<RegisterNames(registerDictionary())(cc->thisParameter().reg()) <<"\n";
            return false;
        }
        if (!ccInputRegisters.existsAll(cc->thisParameter().reg())) {
            SAWYER_MESG(debug) <<"  mismatch: actual input does not include \"this\" register: "
                               <<RegisterNames(registerDictionary())(cc->thisParameter().reg()) <<"\n";
            return false;
        }
    }

    // If the analysis has stack inputs or outputs then the definition must have a valid stack parameter direction.
    if ((!inputStackParameters().isEmpty() || !outputStackParameters().isEmpty()) &&
        cc->stackParameterOrder() == StackParameterOrder::UNSPECIFIED) {
        SAWYER_MESG(debug) <<"  mismatch: stack parameters detected but not allowed by definition\n";
        return false;
    }

    SAWYER_MESG(debug) <<"  analysis matches definition " <<cc->name() <<"\n";
    return true;
}

Dictionary
Analysis::match(const Dictionary &conventions) const {
    Dictionary retval;
    for (const Definition::Ptr &cc: conventions) {
        if (match(cc))
            retval.push_back(cc);
    }
    return retval;
}

std::ostream&
operator<<(std::ostream &out, const Analysis &x) {
    x.print(out);
    return out;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Functions
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

SValue::Ptr
readArgument(const RiscOperators::Ptr &ops, const Definition::Ptr &ccDef, size_t argNumber) {
    ASSERT_not_null(ops);
    ASSERT_not_null(ccDef);
    ops->comment("reading function argument #" + boost::lexical_cast<std::string>(argNumber) +
                 " using calling convention " + ccDef->name());
    const size_t nBits = ccDef->wordWidth();
    SValue::Ptr retval;
    if (argNumber < ccDef->inputParameters().size()) {
        // Argument is explicit in the definition
        const ConcreteLocation &loc = ccDef->inputParameters()[argNumber];

        switch (loc.type()) {
            case ConcreteLocation::REGISTER:
                retval = ops->readRegister(loc.reg());
                break;

            case ConcreteLocation::RELATIVE: {
                const auto base = ops->readRegister(loc.reg());
                const auto offset = ops->signExtend(ops->number_(64, loc.offset()), base->nBits());
                const auto address = ops->add(base, offset);
                const auto dflt = ops->undefined_(nBits);
                retval = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
                break;
            }

            case ConcreteLocation::ABSOLUTE: {
                auto address = ops->number_(64, loc.address());
                const auto dflt = ops->undefined_(nBits);
                retval = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
                break;
            }

            case ConcreteLocation::NO_LOCATION:
                break;
        }

    } else {
        // Argument is at an implied stack location
        argNumber = argNumber - ccDef->inputParameters().size();
        ASSERT_require(argNumber >= 0);
        switch (ccDef->stackParameterOrder()) {
            case StackParameterOrder::RIGHT_TO_LEFT:
                break;
            case StackParameterOrder::LEFT_TO_RIGHT:
                ASSERT_not_implemented("we need to know how many parameters were pushed");
            case StackParameterOrder::UNSPECIFIED:
                ASSERT_not_implemented("invalid stack paramter order");
        }
        int64_t stackOffset = ccDef->nonParameterStackSize() + argNumber * nBits/8;
        switch (ccDef->stackDirection()) {
            case StackDirection::GROWS_DOWN:
                break;
            case StackDirection::GROWS_UP:
                stackOffset = -stackOffset - nBits/8;
                break;
        }

        const RegisterDescriptor reg_sp = ccDef->stackPointerRegister();
        const auto base = ops->readRegister(reg_sp);
        const auto offset = ops->signExtend(ops->number_(64, stackOffset), base->nBits());
        const auto address = ops->add(base, offset);
        const auto dflt = ops->undefined_(nBits);
        retval = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
    }

    ASSERT_always_not_null2(retval, "invalid parameter location");
    ops->comment("argument value is " + retval->toString());
    return retval;
}

void
writeArgument(const RiscOperators::Ptr &ops, const Definition::Ptr &ccDef, size_t argNumber, const SValue::Ptr &value) {
    ASSERT_not_null(ops);
    ASSERT_not_null(ccDef);
    ops->comment("writing function argument #" + boost::lexical_cast<std::string>(argNumber) +
                 " using calling convention " + ccDef->name());
    const size_t nBits = ccDef->wordWidth();
    if (argNumber < ccDef->inputParameters().size()) {
        // Argument is explicit in the definition
        const ConcreteLocation &loc = ccDef->inputParameters()[argNumber];

        switch (loc.type()) {
            case ConcreteLocation::REGISTER:
                ops->writeRegister(loc.reg(), value);
                ops->comment("argument written");
                return;

            case ConcreteLocation::RELATIVE: {
                const auto base = ops->readRegister(loc.reg());
                const auto offset = ops->signExtend(ops->number_(64, loc.offset()), base->nBits());
                const auto address = ops->add(base, offset);
                ops->writeMemory(RegisterDescriptor(), address, value, ops->boolean_(true));
                ops->comment("argument written");
                return;
            }

            case ConcreteLocation::ABSOLUTE: {
                auto address = ops->number_(64, loc.address());
                ops->writeMemory(RegisterDescriptor(), address, value, ops->boolean_(true));
                ops->comment("argument written");
                return;
            }

            case ConcreteLocation::NO_LOCATION:
                break;
        }
        ASSERT_not_reachable("invalid parameter location type");

    } else {
        // Argument is at an implied stack location
        ASSERT_require(argNumber >= ccDef->inputParameters().size());
        argNumber = argNumber - ccDef->inputParameters().size();
        switch (ccDef->stackParameterOrder()) {
            case StackParameterOrder::RIGHT_TO_LEFT:
                break;
            case StackParameterOrder::LEFT_TO_RIGHT:
                ASSERT_not_implemented("we need to know how many parameters were pushed");
            case StackParameterOrder::UNSPECIFIED:
                ASSERT_not_implemented("invalid stack paramter order");
        }
        int64_t stackOffset = ccDef->nonParameterStackSize() + argNumber * nBits/8;
        switch (ccDef->stackDirection()) {
            case StackDirection::GROWS_DOWN:
                break;
            case StackDirection::GROWS_UP:
                stackOffset = -stackOffset - nBits/8;
                break;
        }

        const RegisterDescriptor reg_sp = ccDef->stackPointerRegister();
        const auto base = ops->readRegister(reg_sp);
        const auto offset = ops->signExtend(ops->number_(64, stackOffset), base->nBits());
        const auto address = ops->add(base, offset);
        ops->writeMemory(RegisterDescriptor(), address, value, ops->boolean_(true));
        ops->comment("argument written");
    }
}

SValue::Ptr
readReturnValue(const RiscOperators::Ptr &ops, const Definition::Ptr &ccDef) {
    ASSERT_not_null(ops);
    ASSERT_not_null(ccDef);
    ops->comment("reading function return value using calling convention " + ccDef->name());

    if (ccDef->outputParameters().empty())
        throw Exception("calling convention has no output parameters");

    // Assume that the first output parameter is the main integer return location.
    const ConcreteLocation &loc = ccDef->outputParameters()[0];
    SValue::Ptr retval;
    switch (loc.type()) {
        case ConcreteLocation::REGISTER:
            retval = ops->readRegister(loc.reg());
            break;

        case ConcreteLocation::RELATIVE: {
            const auto base = ops->readRegister(loc.reg());
            const auto offset = ops->signExtend(ops->number_(64, loc.offset()), base->nBits());
            const auto address = ops->add(base, offset);
            const auto dflt = ops->undefined_(loc.reg().nBits());
            retval = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
            break;
        }

        case ConcreteLocation::ABSOLUTE: {
            auto address = ops->number_(64, loc.address());
            const auto dflt = ops->undefined_(loc.reg().nBits());
            retval = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
            break;
        }

        case ConcreteLocation::NO_LOCATION:
            break;
    }
    ASSERT_always_not_null2(retval, "invalid parameter location type");
    ops->comment("return value is " + retval->toString());
    return retval;
}

void
writeReturnValue(const RiscOperators::Ptr &ops, const Definition::Ptr &ccDef, const SValue::Ptr &returnValue) {
    ASSERT_not_null(ops);
    ASSERT_not_null(ccDef);
    ASSERT_not_null(returnValue);
    ops->comment("writing function return value using calling convention " + ccDef->name());

    if (ccDef->outputParameters().empty())
        throw Exception("calling convention has no output parameters");

    // Assume that the first output parameter is the main integer return location.
    const ConcreteLocation &loc = ccDef->outputParameters()[0];
    switch (loc.type()) {
        case ConcreteLocation::REGISTER:
            ops->writeRegister(loc.reg(), returnValue);
            ops->comment("return value written");
            return;

        case ConcreteLocation::RELATIVE: {
            const auto base = ops->readRegister(loc.reg());
            const auto offset = ops->signExtend(ops->number_(64, loc.offset()), base->nBits());
            const auto address = ops->add(base, offset);
            ops->writeMemory(RegisterDescriptor(), address, returnValue, ops->boolean_(true));
            ops->comment("return value written");
            return;
        }

        case ConcreteLocation::ABSOLUTE: {
            auto address = ops->number_(64, loc.address());
            ops->writeMemory(RegisterDescriptor(), address, returnValue, ops->boolean_(true));
            ops->comment("return value written");
            return;
        }

        case ConcreteLocation::NO_LOCATION:
            break;
    }
    ASSERT_not_reachable("invalid parameter location type");
}

void
simulateFunctionReturn(const RiscOperators::Ptr &ops, const Definition::Ptr &ccDef) {
    ASSERT_not_null(ops);
    ASSERT_not_null(ccDef);
    ops->comment("simulating function return using calling convention " + ccDef->name());

    // Assume that the current stack pointer is the same as it was when this function was entered.
    const RegisterDescriptor SP = ccDef->stackPointerRegister();
    ASSERT_require(SP);
    const auto originalSp = ops->readRegister(SP);

    // How many input parameters to be popped from the stack by the callee?
    //
    // FIXME[Robb Matzke 2022-07-13]: This assumes that each parameter is one word, which is often not the case, but
    // we don't currently have any information about parameter sizes.
    int64_t nArgBytes = 0;
    if (StackCleanup::BY_CALLEE == ccDef->stackCleanup()) {
        for (const ConcreteLocation &loc: ccDef->inputParameters()) {
            if (ConcreteLocation::RELATIVE == loc.type())
                nArgBytes += ccDef->wordWidth() / 8;
        }
    }

    // How many other things need to be popped from the stack by the callee as part of returning?
    int64_t nNonArgBytes = ccDef->nonParameterStackSize();

    // Obtain the return address
    const ConcreteLocation &retVaLoc = ccDef->returnAddressLocation();
    SValue::Ptr retVa;
    switch (retVaLoc.type()) {
        case ConcreteLocation::REGISTER:
            retVa = ops->readRegister(retVaLoc.reg());
            break;

        case ConcreteLocation::RELATIVE: {
            const auto base = ops->readRegister(retVaLoc.reg());
            const auto offset = ops->signExtend(ops->number_(64, retVaLoc.offset()), base->nBits());
            const auto address = ops->add(base, offset);
            const auto dflt = ops->undefined_(ccDef->wordWidth());
            retVa = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
            break;
        }

        case ConcreteLocation::ABSOLUTE: {
            auto address = ops->number_(64, retVaLoc.address());
            const auto dflt = ops->undefined_(ccDef->wordWidth());
            retVa = ops->readMemory(RegisterDescriptor(), address, dflt, ops->boolean_(true));
            break;
        }

        case ConcreteLocation::NO_LOCATION:
            break;
    }
    ASSERT_not_null2(retVa, "unknown location for fuction return address");

    // Pop things from the stack
    SValue::Ptr newSp;
    switch (ccDef->stackDirection()) {
        case StackDirection::GROWS_DOWN:
            newSp = ops->add(originalSp, ops->number_(originalSp->nBits(), nArgBytes + nNonArgBytes));
            break;
        case StackDirection::GROWS_UP:
            newSp = ops->subtract(originalSp, ops->number_(originalSp->nBits(), nArgBytes + nNonArgBytes));
            break;
    }
    ASSERT_not_null2(newSp, "invalid stack growth direction");
    ops->writeRegister(SP, newSp);

    // Change the instruction pointer to be the return address.
    const RegisterDescriptor IP = ccDef->instructionPointerRegister();
    ops->writeRegister(IP, retVa);
    ops->comment("function return has been simulated");
}

} // namespace
} // namespace
} // namespace

#endif
