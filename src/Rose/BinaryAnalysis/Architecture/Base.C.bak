#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include <sage3basic.h>
#include <Rose/BinaryAnalysis/Architecture/Base.h>

#include <Rose/BinaryAnalysis/Architecture/Exception.h>
#include <Rose/BinaryAnalysis/CallingConvention.h>
#include <Rose/BinaryAnalysis/Disassembler/Base.h>
#include <Rose/BinaryAnalysis/InstructionSemantics/BaseSemantics.h>
#include <Rose/BinaryAnalysis/RegisterDictionary.h>
#include <Rose/BinaryAnalysis/Unparser.h>
#include <Rose/StringUtility/Escape.h>

#include <sstream>

namespace Rose {
namespace BinaryAnalysis {
namespace Architecture {

Base::Base(const std::string &name)
    : name_(name) {}

Base::~Base() {}

const std::string&
Base::name() const {
    return name_;
}

void
Base::name(const std::string &s) {
    name_ = s;
}

Disassembler::Base::Ptr
Base::instructionDecoderFactory() const {
    return instructionDecoderFactory_;
}

void
Base::instructionDecoderFactory(const Disassembler::Base::Ptr &decoder) {
    instructionDecoderFactory_ = decoder;
}

Disassembler::Base::Ptr
Base::newInstructionDecoder() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->clone();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDictionary::Ptr
Base::registerDictionary() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->registerDictionary();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

size_t
Base::bytesPerWord() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->wordSizeBytes();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

size_t
Base::bitsPerWord() const {
    return bytesPerWord() * 8;
}

ByteOrder::Endianness
Base::byteOrder() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->byteOrder();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

size_t
Base::instructionAlignment() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->instructionAlignment();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDescriptor
Base::instructionPointerRegister() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->instructionPointerRegister();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDescriptor
Base::stackPointerRegister() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->stackPointerRegister();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDescriptor
Base::stackFrameRegister() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->stackFrameRegister();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDescriptor
Base::stackSegmentRegister() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->stackSegmentRegister();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

RegisterDescriptor
Base::callReturnRegister() const {
    if (instructionDecoderFactory_)
        return instructionDecoderFactory_->callReturnRegister();
    throw NotFound("no instruction decoder for \"" + StringUtility::cEscape(name()) + "\"");
}

InstructionSemantics::BaseSemantics::Dispatcher::Ptr
Base::instructionDispatcherFactory() const {
    return instructionDispatcherFactory_;
}

void
Base::instructionDispatcherFactory(const InstructionSemantics::BaseSemantics::Dispatcher::Ptr &dispatcher) {
    instructionDispatcherFactory_ = dispatcher;
}

InstructionSemantics::BaseSemantics::Dispatcher::Ptr
Base::newInstructionDispatcher(const InstructionSemantics::BaseSemantics::RiscOperators::Ptr &ops) const {
    if (instructionDispatcherFactory_) {
        return instructionDispatcherFactory_->create(ops, bytesPerWord(), registerDictionary());
    } else {
        return {};
    }
}

const CallingConvention::Dictionary&
Base::callingConventions() const {
    return callingConventions_;
}

CallingConvention::Dictionary&
Base::callingConventions() {
    return callingConventions_;
}

void
Base::callingConventions(const CallingConvention::Dictionary &ccdict) {
    callingConventions_ = ccdict;
}

Unparser::Base::Ptr
Base::unparser() const {
    return unparser_;
}

void
Base::unparser(const Unparser::Base::Ptr &u) {
    unparser_ = u;
    if (u && !instructionUnparser_) {
        instructionUnparser_ = u->copy();
        instructionUnparser_->settings() = Unparser::Settings::minimal();
        instructionUnparser_->settings().insn.address.showing = true;
        instructionUnparser_->settings().insn.address.useLabels = false;
        instructionUnparser_->settings().insn.address.fieldWidth = 1;
        instructionUnparser_->settings().insn.mnemonic.fieldWidth = 1;
        instructionUnparser_->settings().insn.operands.fieldWidth = 1;
        instructionUnparser_->settings().insn.bytes.showing = false;
        instructionUnparser_->settings().insn.stackDelta.showing = false;
        instructionUnparser_->settings().insn.comment.showing = false;
        instructionUnparser_->settings().insn.semantics.showing = false;
    }
}

Unparser::Base::Ptr
Base::instructionUnparser() const {
    return instructionUnparser_;
}

void
Base::instructionUnparser(const Unparser::Base::Ptr &u) {
    instructionUnparser_ = u;
}

} // namespace
} // namespace
} // namespace

#endif
