
/* JH (02/02/2006) ROSETTA generated code, do not change!! */

//############################################################################
/* JH (02/02/2006) Constructor of the IR node $CLASSNAME that takes its 
 * corresponding StorageClass as parameter
 */
$CLASSNAME :: $CLASSNAME ( const $CLASSNAMEStorageClass& storageSource )  $PARENT_CLASSNAME
   {

CONSTRUCTOR_SOURCE

   }

//############################################################################
/* JH (11/23/2005) : computing the pointer to the passed global index, specific 
 * within the working AST. 
 */
$CLASSNAME*
$CLASSNAME::getPointerFromGlobalIndex ( unsigned long globalIndex )
   {
     $CLASSNAME* returnPointer = NULL;
     if ( globalIndex != 0 )
        {

#if FILE_IO_EXTRA_CHECK
          assert ( ( AST_FILE_IO::getAccumulatedPoolSizeOfNewAst( V_$CLASSNAME ) ) <= globalIndex ) ;
          assert ( globalIndex < (AST_FILE_IO::getAccumulatedPoolSizeOfNewAst ( V_$CLASSNAME + 1 ) ) );
#endif
          unsigned long localIndex = globalIndex - AST_FILE_IO::getAccumulatedPoolSizeOfNewAst ( V_$CLASSNAME )  
                                                 + AST_FILE_IO::getSizeOfMemoryPool ( V_$CLASSNAME );
          unsigned long positionInPool = localIndex % CLASS_ALLOCATION_POOL_SIZE ;
          unsigned long memoryBlock = (localIndex - positionInPool) / CLASS_ALLOCATION_POOL_SIZE ;

#if FILE_IO_EXTRA_CHECK
          // assert ( 0 <= memoryBlock && memoryBlock < Memory_Block_List.size() ) ;
          // assert ( 0 <= positionInPool && positionInPool < (unsigned long)(CLASS_ALLOCATION_POOL_SIZE) );
#endif

          returnPointer = &( ( ($CLASSNAME*)(Memory_Block_List[memoryBlock]) ) [positionInPool]) ;

#if FILE_IO_EXTRA_CHECK
          assert ( returnPointer != NULL ) ;
#endif
        }
     return returnPointer ;
   }

//############################################################################
/*JH (11/23/2005) : computing the pointer to the passed global index, specific 
  for the AST with the index astIndex
*/
$CLASSNAME*
$CLASSNAME::getPointerFromGlobalIndex ( AstSpecificDataManagingClass *astInPool, unsigned long globalIndex )
   {
     $CLASSNAME* returnPointer = NULL;
     if ( globalIndex != 0 )
        {

#if FILE_IO_EXTRA_CHECK
          assert ( ( AST_FILE_IO::getAccumulatedPoolSizeOfAst( astInPool, V_$CLASSNAME ) ) <= globalIndex ) ;
          assert ( globalIndex < (AST_FILE_IO::getAccumulatedPoolSizeOfAst ( astInPool, V_$CLASSNAME + 1 ) ) );
#endif
          unsigned long localIndex = globalIndex - AST_FILE_IO::getAccumulatedPoolSizeOfAst ( astInPool, V_$CLASSNAME )
                                                 + AST_FILE_IO::getSizeOfMemoryPoolUpToAst ( astInPool, V_$CLASSNAME );
          unsigned long positionInPool = localIndex % CLASS_ALLOCATION_POOL_SIZE ;
          unsigned long memoryBlock = (localIndex - positionInPool) / CLASS_ALLOCATION_POOL_SIZE ;

#if FILE_IO_EXTRA_CHECK
          // assert ( 0 <= memoryBlock && memoryBlock < Memory_Block_List.size() ) ;
          // assert ( 0 <= positionInPool && positionInPool < (unsigned long)(CLASS_ALLOCATION_POOL_SIZE) );
#endif

          returnPointer = &( ( ($CLASSNAME*)(Memory_Block_List[memoryBlock]) ) [positionInPool]) ;

#if FILE_IO_EXTRA_CHECK
          assert ( returnPointer != NULL ) ;
#endif
        }
     return returnPointer ;
   }

//############################################################################
/* JH (01/14/2006) Traverse memory pool, set global ids and return accumulated
 * pool size! We set for every valid object in the memory pool the freepointer
 * to the global index and increase the global index afterwards. For all the 
 * invalid objects (means address ranges within the memory pool that were not
 * returned by the new operator) the freepointer is set to NULL, in order to 
 * distinguish valid from invalid objects! 
 */
unsigned long
$CLASSNAME::getNumberOfValidNodesAndSetGlobalIndexInFreepointer( unsigned long numberOfPreviousNodes )
   {
     assert ( AST_FILE_IO::areFreepointersContainingGlobalIndices() == false );
     $CLASSNAME* pointer = NULL;
     unsigned long globalIndex = numberOfPreviousNodes ;
     std::vector < unsigned char* > :: const_iterator block;
     for ( block = Memory_Block_List.begin(); block != Memory_Block_List.end() ; ++block )
        {
          pointer = ($CLASSNAME*)(*block);
          for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE; ++i )
             {
               if ( pointer[i].p_freepointer == AST_FileIO::IS_VALID_POINTER() )
                  {
                    pointer[i].p_freepointer = ($CLASSNAME*)(globalIndex) ;
                    globalIndex++;
                  }
               else
                  {
                    pointer[i].p_freepointer = NULL ;
                  }
              }
        }
     return globalIndex;
   }

//############################################################################
// JH (01/14/2006)
void
$CLASSNAME::resetValidFreepointers( )
   {
     assert ( AST_FILE_IO::areFreepointersContainingGlobalIndices() == true );
     $CLASSNAME* pointer = NULL;
     std::vector < unsigned char* > :: const_iterator block;
     $CLASSNAME* pointerOfLinkedList = NULL;
     for ( block = Memory_Block_List.begin(); block != Memory_Block_List.end() ; ++block )
        {
          pointer = ($CLASSNAME*)(*block);
          for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE; ++i )
             {
               if ( pointer[i].p_freepointer != NULL )
                  {
                    pointer[i].p_freepointer = AST_FileIO::IS_VALID_POINTER() ;
                  }
               else
                  {
                    if ( pointerOfLinkedList == NULL )
                       {
                         Current_Link = &(pointer[i]);
                       }
                    else
                       {
                         pointerOfLinkedList->p_freepointer = &(pointer[i]);
                       }
                    pointerOfLinkedList = &(pointer[i]);
                  }
              }
        }
     if ( pointerOfLinkedList != NULL )
        {
          pointerOfLinkedList->p_freepointer = NULL;
        }
     return ;
   }

//############################################################################
/* JH (01/14/2006) clearing the memory pool. This method deletes all objects 
 * within the memory pool and resets the freepointers, in order to achieve a 
 * linked list, that has no jumps and starts at the beginning! This function 
 * does not extend the memory pool, since we do not delete any memory blocks,
 * but delete the valid objects.  
 */
void
$CLASSNAME::clearMemoryPool( )
   {
     $CLASSNAME* pointer = NULL, *tempPointer = NULL;
     std::vector < unsigned char* > :: const_iterator block;
     if ( Memory_Block_List.empty() == false )
        {
  // JH (08/08/2006) commented out, since this deletion of the 
  // memory pool contents caused the problems. We now delete the 
  // memory pools entities by calling an delete on the roots of the 
  // stored ASTs, done in AST_FILE_IO::clearAllMemoryPools()
#if 0
       // first, we delete the valid objects within the memory pool
          block = Memory_Block_List.begin();
          while (  block != Memory_Block_List.end() )
             {
               pointer = ($CLASSNAME*) (*block);
               for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE; ++i)
                  {
                    if (pointer->p_freepointer != NULL )
                       {
                         delete ( pointer );
                       }
                     pointer++;
                  }
                ++block;
             }
#endif
  // JH (08/08/2006) However, since the deletion may leave the memory pool
  // not in the the strict ordering we want it to be, we still reset the 
  // freepointers, in order to have a linked list, without any jumps
          block = Memory_Block_List.begin() ;
          Current_Link = ($CLASSNAME*) (*block); 
           
       // second, we reset the freepointers,in order to yield a valid linked list
          while ( block != Memory_Block_List.end() )
             {
               pointer = ($CLASSNAME*) (*block);
               if ( tempPointer != NULL )
                  {
                    tempPointer->p_freepointer = pointer;
                  }
               for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE - 1; ++i)
                  {
                    pointer[i].p_freepointer = &(pointer[i+1]);
                  }
                pointer[CLASS_ALLOCATION_POOL_SIZE-1].p_freepointer = NULL;
                tempPointer = &(pointer[CLASS_ALLOCATION_POOL_SIZE-1]);
                ++block;
             }
        }
   }


//############################################################################
// JH (01/14/2006) Traversal for the MemoryPool, used for Ast file io
#if 0
void
$CLASSNAME::extendMemoryPoolForFileIO( )
   {
     $CLASSNAME* pointer = NULL;
     int blockIndex = Memory_Block_List.size();
     unsigned long newPoolSize = AST_FILE_IO::getSizeOfMemoryPool(V_$CLASSNAME) + 
                                 AST_FILE_IO::getPoolSizeOfNewAst(V_$CLASSNAME);
     while ( (unsigned long) (blockIndex * CLASS_ALLOCATION_POOL_SIZE) < newPoolSize)
       {
         pointer = ($CLASSNAME*) ROSE_MALLOC ( CLASS_ALLOCATION_POOL_SIZE * sizeof($CLASSNAME) );
         assert( pointer != NULL );
         Memory_Block_List.push_back( (unsigned char*)(pointer) );
         if ( 0 < blockIndex )
            {
              (($CLASSNAME*)(Memory_Block_List[blockIndex-1]))[ CLASS_ALLOCATION_POOL_SIZE - 1 ].p_freepointer = pointer;
            }
         else
            {
              Current_Link = pointer;
            }
         for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE-1; ++i)
            {
              pointer [ i ].p_freepointer = &(pointer[i+1]);
            }
         pointer[ CLASS_ALLOCATION_POOL_SIZE -1 ].p_freepointer = NULL;
         blockIndex++;
       }
   }
#endif

// DQ (4/30/2006): New version of code added (from Jochen) to fix bug in
//                 reading multiple binary files to for a single AST.
/////////// new version ////////////////////////////////
//############################################################################
// JH (01/14/2006) Traversal for the MemoryPool, used for Ast file io
void
$CLASSNAME::extendMemoryPoolForFileIO( )
  {
    $CLASSNAME* pointer = NULL;
    int blockIndex = Memory_Block_List.size();
    unsigned long newPoolSize = AST_FILE_IO::getSizeOfMemoryPool(V_$CLASSNAME) +
                                AST_FILE_IO::getPoolSizeOfNewAst(V_$CLASSNAME);
    while ( (unsigned long) (blockIndex * CLASS_ALLOCATION_POOL_SIZE) < newPoolSize)
      {
        pointer = ($CLASSNAME*) ROSE_MALLOC ( CLASS_ALLOCATION_POOL_SIZE * sizeof($CLASSNAME) );
        assert( pointer != NULL );
        Memory_Block_List.push_back( (unsigned char*)(pointer) );
        if ( 0 < blockIndex )
           {
             (($CLASSNAME*)(Memory_Block_List[blockIndex-1]))[ CLASS_ALLOCATION_POOL_SIZE - 1 ].p_freepointer = pointer;
           }
        if ( Current_Link == NULL )
           {
             Current_Link = pointer;
           }
        for (int i = 0; i < CLASS_ALLOCATION_POOL_SIZE-1; ++i)
           {
             pointer [ i ].p_freepointer = &(pointer[i+1]);
           }
        pointer[ CLASS_ALLOCATION_POOL_SIZE -1 ].p_freepointer = NULL;
        blockIndex++;
      }
  }

//############################################################################
/* JH (04/01/2006) Method that delivers the last valid object within a memory
 * pool. This could be used, to read new ASTs even, if the memory pools are 
 * not compressed. However, that stuff is not yet implemented! 
 */
unsigned long
$CLASSNAME::getNumberOfLastValidPointer()
   {
      $CLASSNAME* testPointer = ($CLASSNAME*)(Memory_Block_List.back());
      unsigned long localIndex = CLASS_ALLOCATION_POOL_SIZE - 1;
      while (testPointer[localIndex].p_freepointer !=  AST_FileIO::IS_VALID_POINTER() )
         {
           localIndex--;
         }
      return (localIndex + CLASS_ALLOCATION_POOL_SIZE * (Memory_Block_List.size()-1));
   }

//############################################################################
/* JH (01/14/2006) function that steps through the valid IR nodes in the 
 * memory pool and initializes the data member in class $CLASSNAMEStroageClass
 * from its counterpart of $CLASSNAME. The return value is just for checking, 
 * that the whole StorageClassArray is initialized!
 */
unsigned long
$CLASSNAME::initializeStorageClassArray( $CLASSNAMEStorageClass *storageArray )
   {
     unsigned long storageCounter = 0;
     std::vector < unsigned char* > :: const_iterator block = Memory_Block_List.begin();
     $CLASSNAME* pointer = NULL;
     while ( block < Memory_Block_List.end() )
        {
          pointer = ($CLASSNAME*) (*block);
          for ( int i = 0; i < CLASS_ALLOCATION_POOL_SIZE; ++i )
             {
               if ( pointer->p_freepointer != NULL )
                  {
                    storageArray->pickOutIRNodeData (pointer) ;
                    storageArray++;
                    storageCounter++;
                  }
               pointer++;
             }
           block++;
        }
     return storageCounter;
   }

