// #########################################################    -*- C++ -*-
// #########################################################
//                      HEADER CODE
// #########################################################
// #########################################################

HEADER_START

//! This class represents the base class of all the expressions within this grammar.
/*! It contains all the base functionality for the construction, manipulation, and unparsing support.
 */
     public:
       // $CLASSNAME();
       // $CLASSNAME(Sg_File_Info* info);

      //! Function to get user defined attributes (as I recall)
      //  SgAttributePtrList& get_uattributes();

      //! Replace an expression child of this node with another one.
          virtual int replace_expression(SgExpression *oldChild,SgExpression *newChild);

      //! unparsing support for pragmas
      //  void output_pragma(ostream& os);

       // Set pragmas associated with this expression
       // note: pragmas are typically associated with statements not expressions
       // void set_pragma() ROSE_DEPRECATED_FUNCTION;

      //! get the type associated with this expression
          virtual SgType* get_type() const;

       // set the type \attention{why does this not take a parameter?}

      //! return precedence (scale of 0-10, as I recall)
          virtual int precedence() const ;

     public:

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
    // Overriding SgNode versions of these
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int index) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual unsigned int cfgFindNextChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isDefinable() const;
          virtual bool isUsedAsDefinable() const;
          virtual bool isLValue() const;
          virtual bool isUsedAsLValue() const; // Calls parent.isChildUsedAsLValue(this)
          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (11/6/2006): use this to return the operatorPosition
       // (instead of the startOfConstruct as it is used for SgStatement objects)
          virtual Sg_File_Info* get_file_info(void) const override;
          virtual void set_file_info(Sg_File_Info* X) override;

#if ALT_FIXUP_COPY
       // DQ (11/7/2007): These need to be called separately (see documentation)
          virtual void fixupCopy_scopes     (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_symbols    (SgNode* copy, SgCopyHelp & help) const override;
          virtual void fixupCopy_references (SgNode* copy, SgCopyHelp & help) const override;
#else
       // DQ (11/1/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
          virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;
#endif

       // DQ (5/29/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the type referenced by this expression.
          SgName get_qualified_name_prefix() const;

       // DQ (6/2/2011): Added to support for new qualified name generation
      //! This function generates the qualified name prefix to be used with the type referenced by this expression.
          SgName get_qualified_name_prefix_for_referenced_type() const;

       // DQ (6/2/2011): Added virtual functions so that we can define specialized versions at specific IR nodes.
          virtual int  get_name_qualification_length () const;
          virtual void set_name_qualification_length ( int name_qualification_length );
          virtual bool get_type_elaboration_required () const;
          virtual void set_type_elaboration_required ( bool type_elaboration_required );
          virtual bool get_global_qualification_required () const;
          virtual void set_global_qualification_required ( bool global_qualification_required );

       // DQ (4/16/2019): Added virtual functions so that we can define specialized versions at specific IR nodes.
          virtual int  get_name_qualification_for_pointer_to_member_class_length () const;
          virtual void set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length );
          virtual bool get_type_elaboration_for_pointer_to_member_class_required () const;
          virtual void set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required );
          virtual bool get_global_qualification_for_pointer_to_member_class_required () const;
          virtual void set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required );

       // DQ (9/23/2011): Use the vitual function version so that we can test within ROSE (part of incremental testing of new original expression tree support).
       // DQ (9/19/2011): Put back the original code (non-virtual functions) so that we can test against previously passing tests.
       // DQ (9/16/2011): Modified to make this a virtual function and added set_originalExpressionTree().
       // DQ (6/21/2011): Get the original expression if this is an IR node where it is defined and it is a valid pointer.
          virtual SgExpression* get_originalExpressionTree() const;
       // DQ (9/19/2011): Modify this to be virtual as a single step for testing ROSE.
          virtual void set_originalExpressionTree(SgExpression* X);

      /*! \brief Some expressions store internal SgType pointers explicitly while others compute them from other expressions.  This function is true if it has a data member that is a type (pointer, array, etc.).

          Result is true if it stores a type explicitly as a data member, else false.

          \internal True only if this is either a SgTemplateParameterVal, SgComplexVal, SgSizeOfOp, SgAlignOfOp,
                    SgJavaInstanceOfOp, SgJavaAnnotation, SgTypeIdOp, SgVarArgStartOp, SgVarArgStartOneOperandOp,
                    SgVarArgOp, SgVarArgEndOp, SgVarArgCopyOp, SgNewExp, SgRefExp, SgAggregateInitializer, SgCompoundInitializer,
                    SgConstructorInitializer, SgAssignInitializer, SgPseudoDestructorRefExp.
       */
          bool hasExplicitType();

      /*! \brief Some expressions store internal SgType pointers explicitly, this allows these IR nodes to be reset with new types (used in the snippet support).
       */
          void set_explicitly_stored_type( SgType* type );

HEADER_END


HEADER_X_EXPRESSION_START

HEADER_X_EXPRESSION_END


HEADER_NON_X_EXPRESSION_START

HEADER_NON_X_EXPRESSION_END


HEADER_FUNCTIONS_START
HEADER_FUNCTIONS_END

HEADER_GET_TYPE_START
          SgType* get_type() const override;
HEADER_GET_TYPE_END


HEADER_SET_TYPE_START


HEADER_SET_TYPE_END


HEADER_POST_CONSTRUCTION_INITIALIZATION_START
          void post_construction_initialization() override;
HEADER_POST_CONSTRUCTION_INITIALIZATION_END


HEADER_PRECEDENCE_START
          int precedence() const override { return PRECEDENCE_VALUE; }
HEADER_PRECEDENCE_END


HEADER_GET_NEXT_EXPRESSION_START
          SgExpression *get_next( int& n) const ROSE_DEPRECATED_FUNCTION;
          int replace_expression( SgExpression *, SgExpression *) override ROSE_DEPRECATED_FUNCTION;
HEADER_GET_NEXT_EXPRESSION_END


HEADER_EXTRA_FUNCTIONS_START
          int length() const ROSE_DEPRECATED_FUNCTION;
          bool empty() const ROSE_DEPRECATED_FUNCTION;
       // void operator_unparse( const char *, Unparse_Info &, ostream & );
HEADER_EXTRA_FUNCTIONS_END

HEADER_LIST_FUNCTIONS_START
          void append_LIST_NAME(SgExpression* what);
       // void insert_LIST_NAME(const SgExpression::iterator & where, SgExpression* what);
       // void insert_LIST_NAME(const SgExpressionPtrList::iterator & where, SgExpression* what);
HEADER_LIST_FUNCTIONS_END

HEADER_UNARY_EXPRESSION_START

          SgExpression* get_operand() const;
          void set_operand (SgExpression * exp);
          SgType* get_type() const override;

       // Enums are not properly scoped in the class declaration and are assigned
       // to a global scope so we have to change the name to make it unique across
       // different grammars
      /*! \brief Enum value defines operators as prefix or postfix, as appropriate, e.g. operator++().

          This enum type provides support for specification of prefix/postfix operators such
          as operator++() using a simpler mechanism thatn that provided by C++.  See C++
          standard for details of specification of prefix and postfix operators.

          \internal There should be an additional value added to support unknown setting (with value 0)
       */
          enum Sgop_mode
             {
               prefix=0 /*! Prefix Operator Specifier */,
               postfix  /*! Postfix Operator Specifier */
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_UNARY_EXPRESSION_END

HEADER_BINARY_EXPRESSION_START
          SgExpression* get_lhs_operand() const;
          void set_lhs_operand(SgExpression * exp);
          SgExpression* get_rhs_operand() const;
          void set_rhs_operand(SgExpression * exp);
          SgType* get_type() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_BINARY_EXPRESSION_END


HEADER_EXPRESSION_ROOT_EXPRESSION_START
       // QY: 9/30/2004: removed stmt pointer inside exprRoot. Use parent pointer instead.
       // void initialize_root (SgExpression* exp, SgStatement* stmt);

       // DQ (12/17/2006): Removed to clean up code (not used, I think).
       // void set_statement( SgStatement* stmt );
       // SgStatement* get_statement() const;

HEADER_EXPRESSION_ROOT_EXPRESSION_END


HEADER_EXPRESSION_LIST_EXPRESSION_START

          SgExpressionPtrList& get_expressions();
          const SgExpressionPtrList& get_expressions() const;

HEADER_LIST_DECLARATIONS

          void prepend_expression(SgExpression *what);

          bool empty() const ROSE_DEPRECATED_FUNCTION;

          //SgExpression* get_first() const ROSE_DEPRECATED_FUNCTION;
          //SgExpression* get_end() const ROSE_DEPRECATED_FUNCTION;
          //int get_index(SgExpression*) const ROSE_DEPRECATED_FUNCTION;

        // void insert_expression(const SgExpressionPtrList::iterator &, SgExpression*);
        // void insert_expression( SgExpression*, SgExpression*, int);

          int replace_expression(SgExpression *o, SgExpression *n) override ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child
HEADER_EXPRESSION_LIST_EXPRESSION_END


HEADER_MATRIX_EXP_START
HEADER_MATRIX_EXP_END

HEADER_RANGE_EXP_START
//Append an expression to the range
SgRangeExp* append(SgExpression *exp);
HEADER_RANGE_EXP_END

HEADER_VAR_REF_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (11/7/2007): I think this is not used any more.
       // DQ (10/5/2007): Added fixup function to set scopes not set properly by the ROSETTA generated copy!
       // virtual void fixupCopy(SgNode* copy, SgCopyHelp & help) const;

       // get lvalue
          virtual bool isDefinable() const override;
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_VAR_REF_EXPRESSION_END

HEADER_NONREAL_REF_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;
HEADER_NONREAL_REF_EXPRESSION_END

HEADER_COMPOUND_LITERAL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isDefinable() const override;
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child
HEADER_COMPOUND_LITERAL_EXPRESSION_END


HEADER_LABEL_REF_EXPRESSION_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          SgName get_name() const;
       // const SgName & get_name() const;

          int get_numeric_label_value() const;

       // DQ (12/30/2007): I don't think there is any control flow through this sorts of variables, but this
       // should be discussed (might apply to assigned goto).
       // virtual unsigned int cfgIndexForEnd() const;
       // virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
       // virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);

       // DQ (2/2/2011): This is support for Fortran alternative return type arguments.
      //! Support for recognition of Fortran alternative return type arguments.
          bool isFunctionCallArgumentForAlternativeReturnType() const;

HEADER_LABEL_REF_EXPRESSION_END


HEADER_LAMBDA_EXPRESSION_START
HEADER_LAMBDA_EXPRESSION_END


HEADER_CLASS_NAME_REF_EXPRESSION_START
HEADER_CLASS_NAME_REF_EXPRESSION_END


HEADER_FUNCTION_REF_EXPRESSION_START
          SgFunctionSymbol* get_symbol() const;
          void set_symbol(SgFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionDeclaration* getAssociatedFunctionDeclaration() const;

//       // get lvalue
//          virtual bool isLValue() const;
//          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_FUNCTION_REF_EXPRESSION_END


HEADER_MEMBER_FUNCTION_REF_EXPRESSION_START
          SgMemberFunctionSymbol* get_symbol() const;
          void set_symbol(SgMemberFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          //! This is helpful in chasing down the associated declaration to this member function reference.
      //! Note: This function can return NULL - for example when the function call occurs through a function
      //! pointer.
          SgMemberFunctionDeclaration* getAssociatedMemberFunctionDeclaration() const;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_MEMBER_FUNCTION_REF_EXPRESSION_END


HEADER_TEMPLATE_FUNCTION_REF_EXPRESSION_START
       // SgTemplateSymbol* get_symbol() const;
       // void set_symbol(SgTemplateSymbol * symbol);
          SgTemplateFunctionSymbol* get_symbol() const;
          void set_symbol(SgTemplateFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgTemplateFunctionDeclaration* getAssociatedFunctionDeclaration() const;

//       // get lvalue
//          virtual bool isLValue() const;
//          virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_TEMPLATE_FUNCTION_REF_EXPRESSION_END


HEADER_TEMPLATE_MEMBER_FUNCTION_REF_EXPRESSION_START
       // SgTemplateSymbol* get_symbol() const;
       // void set_symbol(SgTemplateSymbol * symbol);
          SgTemplateMemberFunctionSymbol* get_symbol() const;
          void set_symbol(SgTemplateMemberFunctionSymbol * symbol);

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

        //! This is helpful in chasing down the associated declaration to this member function reference.
      //! Note: This function can return NULL - for example when the function call occurs through a function
      //! pointer.
          SgTemplateMemberFunctionDeclaration* getAssociatedMemberFunctionDeclaration() const;

       // DQ (12/15/2011): We might require this...
       // get lvalue
       // virtual bool isLValue() const;
       // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int  get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_TEMPLATE_MEMBER_FUNCTION_REF_EXPRESSION_END


HEADER_VALUE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (2/12/2011): Added const so that this could be called in get_mangled() (and more generally).
       // DQ (8/18/2009): Added support to get the constant folded value as a string instead of the expression tree.
       // std::string get_constant_folded_value_as_string();
          std::string get_constant_folded_value_as_string() const;

HEADER_VALUE_EXPRESSION_END


HEADER_BOOLEAN_VALUE_EXPRESSION_START
HEADER_BOOLEAN_VALUE_EXPRESSION_END


HEADER_NULLPTR_VALUE_EXPRESSION_START
HEADER_NULLPTR_VALUE_EXPRESSION_END


HEADER_VOID_VALUE_EXPRESSION_START
HEADER_VOID_VALUE_EXPRESSION_END


HEADER_STRING_VALUE_EXPRESSION_START
      // DQ (3/25/2006): This is not generated by ROSETTA automatically (using C++ style string type)
      // $CLASSNAME( Sg_File_Info* file_info = NULL, char* value = NULL );
      // ~$CLASSNAME();

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // PP (4/25/21) implement usesSingleQuote and usesDoubleQuote based on
       //              stringDelimiter for backward compatibility.
          bool get_usesSingleQuotes() const    { return get_stringDelimiter() == '\''; }
          bool get_usesDoubleQuotes() const    { return get_stringDelimiter() == '"'; }

          void set_usesSingleQuotes(bool usesSingleQuotes);
          void set_usesDoubleQuotes(bool usesDoubleQuotes);
HEADER_STRING_VALUE_EXPRESSION_END


HEADER_SHORT_VALUE_EXPRESSION_START
HEADER_SHORT_VALUE_EXPRESSION_END


HEADER_CHAR_VALUE_EXPRESSION_START
HEADER_CHAR_VALUE_EXPRESSION_END


HEADER_UNSIGNED_CHAR_VALUE_EXPRESSION_START
HEADER_UNSIGNED_CHAR_VALUE_EXPRESSION_END


HEADER_WCHAR_VALUE_EXPRESSION_START
          wchar_t get_value() const;
          void set_value(wchar_t new_val);

HEADER_WCHAR_VALUE_EXPRESSION_END


HEADER_CHAR16_VALUE_EXPRESSION_START
       // DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
       // char16_t get_value() const;
       // void set_value(char16_t new_val);
          unsigned short get_value() const;
          void set_value(unsigned short new_val);

HEADER_CHAR16_VALUE_EXPRESSION_END


HEADER_CHAR32_VALUE_EXPRESSION_START
       // DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
       // char32_t get_value() const;
       // void set_value(char32_t new_val);
          unsigned int get_value() const;
          void set_value(unsigned int new_val);

HEADER_CHAR32_VALUE_EXPRESSION_END


HEADER_UNSIGNED_SHORT_VALUE_EXPRESSION_START
HEADER_UNSIGNED_SHORT_VALUE_EXPRESSION_END


HEADER_INT_VALUE_EXPRESSION_START
HEADER_INT_VALUE_EXPRESSION_END


HEADER_ENUM_VALUE_EXPRESSION_START

       // DQ (2/5/2020): Addedin custom get_type() function so that we can pass the associated SgEnumDeclaration.
       // This code is already generated by ROSETTA, so we don't need to specify this here.
       // SgType* get_type() const override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_ENUM_VALUE_EXPRESSION_END


HEADER_UNSIGNED_INT_VALUE_EXPRESSION_START
HEADER_UNSIGNED_INT_VALUE_EXPRESSION_END


HEADER_LONG_INT_VALUE_EXPRESSION_START
HEADER_LONG_INT_VALUE_EXPRESSION_END


HEADER_LONG_LONG_VALUE_EXPRESSION_START
HEADER_LONG_LONG_VALUE_EXPRESSION_END


HEADER_UNSIGNED_LONG_LONG_VALUE_EXPRESSION_START
HEADER_UNSIGNED_LONG_LONG_VALUE_EXPRESSION_END


HEADER_UNSIGNED_LONG_VALUE_EXPRESSION_START
HEADER_UNSIGNED_LONG_VALUE_EXPRESSION_END


HEADER_FLOAT_VALUE_EXPRESSION_START
HEADER_FLOAT_VALUE_EXPRESSION_END


HEADER_DOUBLE_VALUE_EXPRESSION_START
HEADER_DOUBLE_VALUE_EXPRESSION_END


HEADER_LONG_DOUBLE_VALUE_EXPRESSION_START
HEADER_LONG_DOUBLE_VALUE_EXPRESSION_END

HEADER_FLOAT_80_VALUE_EXPRESSION_START
HEADER_FLOAT_80_VALUE_EXPRESSION_END

HEADER_FLOAT_128_VALUE_EXPRESSION_START
HEADER_FLOAT_128_VALUE_EXPRESSION_END

HEADER_ADA_FLOAT_VALUE_EXPRESSION_START
HEADER_ADA_FLOAT_VALUE_EXPRESSION_END

HEADER_JOVIAL_BIT_VALUE_EXPRESSION_START
HEADER_JOVIAL_BIT_VALUE_EXPRESSION_END

HEADER_ADA_UNIT_REF_EXPRESSION_START
//~ SgType* get_type() const override;
HEADER_ADA_UNIT_REF_EXPRESSION_END

HEADER_ADA_TASK_REF_EXPRESSION_START
//~ SgType* get_type() const override;
HEADER_ADA_TASK_REF_EXPRESSION_END

HEADER_ADA_PROTECTED_REF_EXPRESSION_START
//~ SgType* get_type() const override;
HEADER_ADA_PROTECTED_REF_EXPRESSION_END

HEADER_ADA_RENAMING_REF_EXPRESSION_START
//~ SgType* get_type() const override;
HEADER_ADA_RENAMING_REF_EXPRESSION_END

HEADER_ADA_ATTRIBUTE_EXPRESSION_START
//~ HEADER_LIST_DECLARATIONS
//~ SgType* get_type() const override;
HEADER_ADA_ATTRIBUTE_EXPRESSION_END

HEADER_TEMPLATE_PARAMETER_VALUE_EXPRESSION_START

       // DQ (11/28/2011): Added to support template declarations in the AST.
          SgName get_template_parameter_name() const;

          SgType* get_type() const override;

HEADER_TEMPLATE_PARAMETER_VALUE_EXPRESSION_END


HEADER_COMPLEX_VALUE_EXPRESSION_START
HEADER_COMPLEX_VALUE_EXPRESSION_END

// HEADER_LABEL_ADDRESS_VALUE_EXPRESSION_START
// HEADER_LABEL_ADDRESS_VALUE_EXPRESSION_END

HEADER_UPC_THREADS_EXPRESSION_START
HEADER_UPC_THREADS_EXPRESSION_END

HEADER_UPC_MYTHREAD_EXPRESSION_START
HEADER_UPC_MYTHREAD_EXPRESSION_END

HEADER_YIELD_EXPRESSION_START
HEADER_YIELD_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_AWAIT_EXPRESSION_START
HEADER_AWAIT_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_FOLD_EXPRESSION_START
HEADER_FOLD_EXPRESSION_END

// DQ (7/25/2020): Adding C++17 language features (required for C++20 support).
HEADER_CHOOSE_EXPRESSION_START
HEADER_CHOOSE_EXPRESSION_END

// DQ (7/25/2020): Adding C++20 language features.
HEADER_SPACESHIP_OPERATOR_START
HEADER_SPACESHIP_OPERATOR_END


HEADER_CALL_EXPRESSION_START
HEADER_LIST_DECLARATIONS
HEADER_CALL_EXPRESSION_END

HEADER_FUNCTION_CALL_EXPRESSION_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

      /** Returns the associated function declaration, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionDeclaration* getAssociatedFunctionDeclaration() const;

      /** Returns the associated function symbol, if it can be resolved statically. In some cases,
      * such as function pointers and virtual functions, the function called cannot be resolved statically;
      * for those cases this function returns NULL. The actual function expression is available through
      * get_function(). */
          SgFunctionSymbol* getAssociatedFunctionSymbol() const;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_FUNCTION_CALL_EXPRESSION_END

HEADER_TYPE_TRAIT_BUILTIN_OPERATOR_START

       // DQ (7/13/2013): I have verified that we need implementations of these functions for the CFG support.
       // DQ (7/12/2013): Not clear if we need these functions since the buildin functions are all pure and lack definitions.
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (7/12/2013): Not clear if we need these functions since the buildin functions are all pure.
       // get lvalue
       // virtual bool isLValue() const;
       // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

HEADER_TYPE_TRAIT_BUILTIN_OPERATOR_END

HEADER_ARROW_EXPRESSION_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (7/16/2014): Shared types from expressions in UPC have some expected symantics that are not a matter of returning the result of get_type().
       // This function supports the get_type() function.
          SgType* checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const;

HEADER_ARROW_EXPRESSION_END


HEADER_DOT_EXPRESSION_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_DOT_EXPRESSION_END


HEADER_DOT_STAR_OPERATOR_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_DOT_STAR_OPERATOR_END


HEADER_ARROW_STAR_OPERATOR_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_ARROW_STAR_OPERATOR_END


HEADER_BOOLEAN_GET_TYPE_START
       // DQ (6/20/2006): Used for all relational operators
          virtual SgType* get_type() const override;
HEADER_BOOLEAN_GET_TYPE_END

HEADER_EQUALITY_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_EQUALITY_OPERATOR_END

HEADER_LESS_THAN_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_LESS_THAN_OPERATOR_END

HEADER_GREATER_THAN_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_GREATER_THAN_OPERATOR_END

HEADER_NOT_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_NOT_EQUAL_OPERATOR_END

HEADER_LESS_OR_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_LESS_OR_EQUAL_OPERATOR_END

HEADER_GREATER_OR_EQUAL_OPERATOR_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_GREATER_OR_EQUAL_OPERATOR_END


HEADER_ADD_OPERATOR_START
HEADER_ADD_OPERATOR_END

HEADER_DOTDOT_EXPRESSION_START
   SgType* get_type() const override;

   // get lvalue
//   virtual bool isLValue() const;
//   virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child
HEADER_DOTDOT_EXPRESSION_END

HEADER_SUBTRACT_OPERATOR_START
HEADER_SUBTRACT_OPERATOR_END


HEADER_MULTIPLY_OPERATOR_START
HEADER_MULTIPLY_OPERATOR_END


HEADER_DIVIDE_OPERATOR_START
HEADER_DIVIDE_OPERATOR_END


HEADER_INTEGER_DIVIDE_OPERATOR_START
HEADER_INTEGER_DIVIDE_OPERATOR_END


HEADER_MOD_OPERATOR_START
HEADER_MOD_OPERATOR_END

HEADER_MEMBERSHIP_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_MEMBERSHIP_OP_END

HEADER_NON_MEMBERSHIP_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_NON_MEMBERSHIP_OP_END

HEADER_IS_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_IS_OP_END

HEADER_IS_NOT_OP_START
HEADER_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
HEADER_IS_NOT_OP_END

HEADER_NARY_OP_START

    SgExpressionPtrList& get_operands();
    const SgExpressionPtrList& get_operands() const;

    VariantTList& get_operators();
    const VariantTList& get_operators() const;

    virtual void append_operation(VariantT sg_operator, SgExpression* operand);

HEADER_NARY_OP_END

HEADER_NARY_COMPARISON_OP_START
    virtual SgType* get_type() const override;
HEADER_NARY_COMPARISON_OP_END

HEADER_NARY_BOOLEAN_OP_START
    virtual SgType* get_type() const override;
HEADER_NARY_BOOLEAN_OP_END


HEADER_AND_OPERATOR_START
          SgType* get_type() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_AND_OPERATOR_END


HEADER_OR_OPERATOR_START
          SgType* get_type() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_OR_OPERATOR_END


HEADER_BIT_XOR_OPERATOR_START
HEADER_BIT_XOR_OPERATOR_END

HEADER_BIT_AND_OPERATOR_START
HEADER_BIT_AND_OPERATOR_END

HEADER_BIT_OR_OPERATOR_START
HEADER_BIT_OR_OPERATOR_END

// CR (4/28/2020): Added SgBitEqvOp to support the Jovial bitwise operator.
HEADER_BIT_EQV_OPERATOR_START
HEADER_BIT_EQV_OPERATOR_END


HEADER_COMMA_OPERATOR_EXPRESSION_START

       // get the type associated with this expression (using the rhs)
          virtual SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_COMMA_OPERATOR_EXPRESSION_END


HEADER_LEFT_SHIFT_OPERATOR_START
HEADER_LEFT_SHIFT_OPERATOR_END


HEADER_RIGHT_SHIFT_OPERATOR_START
HEADER_RIGHT_SHIFT_OPERATOR_END

HEADER_JAVA_UNSIGNED_RIGHT_SHIFT_OPERATOR_START
HEADER_JAVA_UNSIGNED_RIGHT_SHIFT_OPERATOR_END

HEADER_MINUS_OPERATOR_START
HEADER_MINUS_OPERATOR_END

HEADER_MATRIX_TRANSPOSE_OPERATOR_START
HEADER_MATRIX_TRANSPOSE_OPERATOR_END

HEADER_UNARY_ADD_OPERATOR_START
HEADER_UNARY_ADD_OPERATOR_END


HEADER_SIZEOF_OPERATOR_START
 // Liao, 11/17/2009
          int replace_expression(SgExpression*, SgExpression*) override ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const override;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const override;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const override;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) override;

HEADER_SIZEOF_OPERATOR_END


HEADER_ALIGNOF_OPERATOR_START
          int replace_expression(SgExpression*, SgExpression*) override ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int  get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_ALIGNOF_OPERATOR_END


HEADER_NOEXCEPT_OPERATOR_START
       // DQ (2/4/2015): Let's not build this if we don't need it.
       // int replace_expression(SgExpression*, SgExpression*) ROSE_DEPRECATED_FUNCTION;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_NOEXCEPT_OPERATOR_END


HEADER_JAVA_INSTANCEOF_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_JAVA_INSTANCEOF_OPERATOR_END


HEADER_TYPE_ID_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const override;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const override;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const override;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) override;

HEADER_TYPE_ID_OPERATOR_END

HEADER_VARARG_START_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_VARARG_START_OPERATOR_END

HEADER_VARARG_OPERATOR_START

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          int replace_expression(SgExpression*, SgExpression*) override ROSE_DEPRECATED_FUNCTION;
       // void set_type( SgType* type );

HEADER_VARARG_OPERATOR_END

HEADER_VARARG_END_OPERATOR_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          int replace_expression(SgExpression*, SgExpression*) override ROSE_DEPRECATED_FUNCTION;

HEADER_VARARG_END_OPERATOR_END

HEADER_NOT_OPERATOR_START
          SgType* get_type() const override;

HEADER_NOT_OPERATOR_END


HEADER_POINTER_DEREF_EXPRESSION_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_POINTER_DEREF_EXPRESSION_END


HEADER_ADDRESS_OF_OPERATOR_START
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (7/16/2014): Shared types from expressions in UPC have some expected symantics that are not a matter of returning the result of get_type().
       // This function supports the get_type() function.
          SgType* checkForSharedTypeAndReturnSharedType( SgType* possibleReturnType ) const;

HEADER_ADDRESS_OF_OPERATOR_END


HEADER_MINUS_MINUS_OPERATOR_START
          $CLASSNAME ( Sg_File_Info* file_info, SgExpression* operand_i, Sgop_mode a_mode );
          $CLASSNAME ( SgExpression* operand_i, Sgop_mode a_mode );

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_MINUS_MINUS_OPERATOR_END


HEADER_PLUS_PLUS_OPERATOR_START
          $CLASSNAME ( Sg_File_Info* file_info, SgExpression* operand_i, Sgop_mode a_mode );
          $CLASSNAME ( SgExpression* operand_i, Sgop_mode a_mode );

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_PLUS_PLUS_OPERATOR_END


HEADER_BIT_COMPLEMENT_OPERATOR_START
HEADER_BIT_COMPLEMENT_OPERATOR_END


HEADER_REAL_PART_OPERATOR_START
HEADER_REAL_PART_OPERATOR_END


HEADER_IMAG_PART_OPERATOR_START
HEADER_IMAG_PART_OPERATOR_END


HEADER_CONJUGATE_OPERATOR_START
HEADER_CONJUGATE_OPERATOR_END


HEADER_ATEXP_EXPRESSION_START
HEADER_ATEXP_EXPRESSION_END

HEADER_FINISHEXP_EXPRESSION_START
HEADER_FINISHEXP_EXPRESSION_END


HEADER_CONDITIONAL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual bool cfgIsIndexInteresting(unsigned int) const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_CONDITIONAL_EXPRESSION_END


HEADER_CAST_EXPRESSION_START
       // DQ (6/14/2005): Modified to make enum name consistant with elsewhere in ROSE (Sage III)
       // enum Sg_e_cast_type
      /*! \brief Classification of Casts

          Must be either C style cast or C++ style const_cast<>, static_cast<>,
          dynamic_cast<>, or reinterpret_cast<>.

          \internal Only a single value is permited.
       */
          enum cast_type_enum
             {
               e_unknown               = 0, /*!< Unknown value (error value) */
               e_default               = 1, /*!< Default value (default) */
               e_C_style_cast          = 2, /*!< C style cast */
               e_const_cast            = 3, /*!< C++ const cast */
               e_static_cast           = 4, /*!< C++ static cast */
               e_dynamic_cast          = 5, /*!< C++ dynamic cast */
               e_reinterpret_cast      = 6,  /*!< C++ reinterpret cast */
            // DQ (8/22/2016): Adding more comprehensive setting of cast semantics (as part of improved C++ cast support).
            // Not clear if these really need to be present.
            // e_reference_cast        = 7, /*!< C++ reference cast (base class cast) */
            // e_rvalue_reference_cast = 8,  /*!< C++ rvalue reference cast (base class cast to rvalue) */
               e_safe_cast             = 8, /*!< C++ MSVC specific safe cast */
               e_ada_type_qualification = 9, /*!< Ada qualified expression */
               e_last_cast  /*!< Last entry in enum of cast types */
             };

       // Sg_e_cast_type cast_type();
          cast_type_enum cast_type() const;

       // DQ (1/16/2006): Added to support special version of get_type which uses the p_expression_type
       // (one of the few places where we have to store the expression type explicitly).
          SgType* get_type() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgFindChildIndex(SgNode* n) override; // CFG children do not match traversalSuccessorContainer
#endif

       // DQ (1/17/2008): Added to permit the type to be set.
          void set_type (SgType* type);

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

       // DQ (10/24/2014): Added support to determine when cast should be allowable.
       // This is used in the SageInterace support for evaluation of constant expressions.
          bool cast_looses_precision();

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

          static std::string cast_type_to_string ( enum cast_type_enum );

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const override;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const override;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const override;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) override;

HEADER_CAST_EXPRESSION_END


HEADER_POINTER_ARRAY_REFERENCE_EXPRESSION_START
       // DQ (1/16/2006): Added to support special version of get_type.
       // returns get_lhs_operand()->get_type()  (maybe we should call get_base_type() ???)
          SgType* get_type() const override;

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_POINTER_ARRAY_REFERENCE_EXPRESSION_END


HEADER_NEW_OPERATOR_EXPRESSION_START
       // DQ (1/16/2006): Added to support special version of get_type.
       // returns SgPointerType::createType(p_expression_type)
       // SgType* get_type() const;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_for_pointer_to_member_class_length() const override;
          void set_name_qualification_for_pointer_to_member_class_length(int name_qualification_length) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_for_pointer_to_member_class_required() const override;
          void set_type_elaboration_for_pointer_to_member_class_required(bool type_elaboration_required) override;

       // DQ (4/15/2019): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_for_pointer_to_member_class_required() const override;
          void set_global_qualification_for_pointer_to_member_class_required(bool global_qualification_required) override;

HEADER_NEW_OPERATOR_EXPRESSION_END


HEADER_DELETE_OPERATOR_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_DELETE_OPERATOR_EXPRESSION_END

HEADER_HERE_EXPRESSION_START
HEADER_HERE_EXPRESSION_END

HEADER_THIS_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_THIS_EXPRESSION_END

HEADER_SUPER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_SUPER_EXPRESSION_END

HEADER_CLASS_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_CLASS_EXPRESSION_END

HEADER_TUPLE_EXP_START
HEADER_TUPLE_EXP_END

HEADER_LIST_EXP_START
HEADER_LIST_EXP_END

HEADER_COMPREHENSION_START
HEADER_COMPREHENSION_END

HEADER_LIST_COMPREHENSION_START
HEADER_LIST_COMPREHENSION_END

HEADER_SET_COMPREHENSION_START
HEADER_SET_COMPREHENSION_END

HEADER_DICTIONARY_COMPREHENSION_START
HEADER_DICTIONARY_COMPREHENSION_END

HEADER_DICTIONARY_EXP_START
SgKeyDatumPairPtrList& get_key_datum_pairs();
const SgKeyDatumPairPtrList& get_key_datum_pairs() const;
void append_pair(SgKeyDatumPair *what);
HEADER_DICTIONARY_EXP_END

HEADER_KEY_DATUM_PAIR_START
HEADER_KEY_DATUM_PAIR_END

HEADER_STRING_CONVERSION_START
HEADER_STRING_CONVERSION_END

HEADER_SCOPE_OPERATOR_START
       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child
HEADER_SCOPE_OPERATOR_END


HEADER_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_ASSIGNMENT_OPERATOR_END


HEADER_COMPOUND_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_COMPOUND_ASSIGNMENT_OPERATOR_END


HEADER_ELEMENT_WISE_OP_START


          // virtual bool isLValue() const;
          // virtual bool isChildUsedAsLValue(const SgExpression* child) const; // INTERNAL Recursively call up the chain to answer the child

HEADER_ELEMENT_WISE_OP_END



HEADER_POINTER_ASSIGNMENT_OPERATOR_START

       // get lvalue
          virtual bool isDefinable() const override;

HEADER_POINTER_ASSIGNMENT_OPERATOR_END

HEADER_INTEGER_DIVIDE_ASSIGN_OP_START
HEADER_INTEGER_DIVIDE_ASSIGN_OP_END

HEADER_EXPONENTIATION_ASSIGN_OP_START
HEADER_EXPONENTIATION_ASSIGN_OP_END

HEADER_REFERENCE_EXPRESSION_START
HEADER_REFERENCE_EXPRESSION_END


HEADER_THROW_OPERATOR_START

      //! Throw IR node can be used in three different ways.
          enum e_throw_kind
             {
               unknown_throw = 0             /*! error value */,
               throw_expression              /*! throw expression (takes an expression) */,
               // throw_exception_specification /*! takes a list of types */, JJW (8/6/2008) -- SgThrowOp is not used for exception specifications
               rethrow                       /*! rethow expression (as in \"rethrow;\") */
             };

       // DQ (1/16/2006): Added to support special version of get_type()
          SgType* get_type() const override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          unsigned int cfgIndexForEnd() const override;
          std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_THROW_OPERATOR_END


HEADER_CONCATENATION_OPERATOR_START
HEADER_CONCATENATION_OPERATOR_END

HEADER_REPLICATION_OPERATOR_START
HEADER_REPLICATION_OPERATOR_END

HEADER_REM_OPERATOR_START
HEADER_REM_OPERATOR_END

HEADER_ABS_OPERATOR_START
HEADER_ABS_OPERATOR_END

HEADER_AT_OPERATOR_START
HEADER_AT_OPERATOR_END

HEADER_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
#endif

HEADER_INITIALIZER_EXPRESSION_END


HEADER_AGGREGATE_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_requiresGlobalNameQualificationOnType() const;
          void set_requiresGlobalNameQualificationOnType(bool requiresGlobalNameQualificationOnType);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length_for_type() const;
          void set_name_qualification_length_for_type(int name_qualification_length_for_type);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required_for_type() const;
          void set_type_elaboration_required_for_type(bool type_elaboration_required_for_type);

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required_for_type() const;
          void set_global_qualification_required_for_type(bool global_qualification_required_for_type);

HEADER_AGGREGATE_INITIALIZER_EXPRESSION_END

HEADER_COMPOUND_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_COMPOUND_INITIALIZER_EXPRESSION_END

HEADER_CONSTRUCTOR_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
          virtual unsigned int cfgIndexForEnd() const override;
#endif

      /*! \brief Get the SgClassDeclaration associated with this constructor call.

          Note that in rare cases where the constructor is associated with a primative type
          this function will return a NULL pointer.  In which case p_expression_type is a
          pointer to a SgType which is not a SgClassType, but is a valid pointer to a
          primative type.

          \internal if p_declaration is NULL then p_associated_class_unknown is true.
       */
          SgClassDeclaration* get_class_decl () const;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (6/11/2015): Added support for non ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

HEADER_CONSTRUCTOR_INITIALIZER_EXPRESSION_END


HEADER_ASSIGNMENT_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          SgExpression * get_operand() const;
          void set_operand(SgExpression * exp);

       // get lvalue
          virtual bool isLValue() const override;
          virtual bool isChildUsedAsLValue(const SgExpression* child) const override; // INTERNAL Recursively call up the chain to answer the child

HEADER_ASSIGNMENT_INITIALIZER_EXPRESSION_END

HEADER_ADA_ANCESTOR_INITIALIZER_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

          /// returns the ancestor (operand)
          SgExpression * get_operand() const;

          /// sets the ancestor (operand) and the ancestor's parent
          void set_operand(SgExpression * exp);

          // SgType* get_type() const;

       // get lvalue
          bool isLValue() const override;
          bool isChildUsedAsLValue(const SgExpression*) const override;

HEADER_ADA_ANCESTOR_INITIALIZER_EXPRESSION_END


HEADER_BRACED_INITIALIZER_EXPRESSION_START
HEADER_LIST_DECLARATIONS
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_BRACED_INITIALIZER_EXPRESSION_END


HEADER_REPLACE_EXPRESSION_START
          int replace_expression(SgExpression*, SgExpression*) override ROSE_DEPRECATED_FUNCTION;
HEADER_REPLACE_EXPRESSION_END

HEADER_NULL_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_NULL_EXPRESSION_END

HEADER_ADA_OTHERS_EXPRESSION_START
HEADER_ADA_OTHERS_EXPRESSION_END


HEADER_VARIANT_EXPRESSION_START
HEADER_VARIANT_EXPRESSION_END

HEADER_STATEMENT_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_STATEMENT_EXPRESSION_END

HEADER_ASM_OP_START

       // DQ (7/22/2006): Added support for asm operands and their modifiers
      /*! \brief ASM Operand modifiers (multiple values can be specified)

          \internal Multiple values can be specified
       */
           enum asm_operand_modifier_enum
             {
               e_unknown           = 0x00, /*!< error */
               e_input             = 0x01, /*!< no mod: input operand */
               e_output            = 0x02, /*!< =: output operand */
               e_modify            = 0x03, /*!< +: read-mod-write operand */
               e_earlyclobber      = 0x04, /*!< &: modified early, cannot overlap inputs */
               e_commutative       = 0x08, /*!< %: commutative with next operand */
               e_ignore_next       = 0x10, /*!< *: ignore next letter as a register pref */
               e_ignore_till_comma = 0x20, /*!< #: ignore up to comma as a register pref */
               e_poor_choice       = 0x40, /*!< ?: avoid choosing this */
               e_bad_choice        = 0x80  /*!< !: really avoid choosing this */
             };

       // DQ (7/22/2006): Added support for asm operands and their constraints
      /*! \brief ASM operand constraints (multiple values can be specified)

          \internal Only one value can be specified
       */
          enum asm_operand_constraint_enum
             {
               e_invalid = 0,
               e_end_of_constraint,/*!< ,: For cases with multiple constraints, indicates
                                           the end of the current constraint (other
                                           constraints may follow); represented by a comma
                                           in the input stream. */
               /* modifiers */
               /* Note that these are parsed, but not acted upon by the front end. */
               e_mod_earlyclobber, /*!< &: modified early, cannot overlap inputs */
               e_mod_commutative_ops,
                                   /*!< %: operands are commutative */
               e_mod_ignore,       /*!< #: ignore the rest of this constraint */
               e_mod_ignore_char,  /*!< *: ignore following character when choosing
                                           register preferences */
               e_mod_disparage_slightly,
                                   /*!< ?: disparage alternative slightly */
               e_mod_disparage_severely,
                                   /*!< !: disparage alternative severely */
            /* misc */
               e_any,              /*!< X: unconstrained */
               e_general,          /*!< g: r or i or m */
               e_match_0, e_match_1, e_match_2, e_match_3, e_match_4,
               e_match_5, e_match_6, e_match_7, e_match_8, e_match_9,
                                   /*!< 0-9: same as a previous operand */
            /* registers constraints */
               e_reg_integer,      /*!< r: any integer register */
               e_reg_float,        /*!< f: any float register */
            /* memory constraints */
               e_mem_any,          /*!< m: any memory location */
               e_mem_load,         /* p: any memory location that is valid for a load/
                                           push operation */
               e_mem_offset,       /*!< o: memory location, if (val + sizeof(object))
                                           is also acceptable in this context */
               e_mem_nonoffset,    /*!< V: m but not o */
               e_mem_autoinc,      /*!< >: mem, ptr incremented before or after op */
               e_mem_autodec,      /*!< <: mem, ptr decremented before or after op */
            /* immediate constraints */
               e_imm_int,          /*!< i: any integer (including symbolic references) */
               e_imm_number,       /*!< n: any number known to the compiler (no symbols) */
               e_imm_symbol,       /*!< s: any symbolic reference */
               e_imm_float,        /*!< E, F: any floating point constant */

            // DQ (7/22/2006): Let's assume we want to include these (controled by EDG's setting of GNU_X86_ASM_EXTENSIONS_ALLOWED start)
            /* register constraints */
               e_reg_a,            /*!< a: ax */
               e_reg_b,            /*!< b: bx */
               e_reg_c,            /*!< c: cx */
               e_reg_d,            /*!< d: dx */
               e_reg_si,           /*!< s: si */
               e_reg_di,           /*!< d: di */
               e_reg_legacy,       /*!< R: ax bx cx dx si di bp sp (avail. on non-x86-64) */
               e_reg_q,            /* q: ax bx cx dx, lower part only (non-x86-64),
                                           same as 'r' (x86-64) */
               e_reg_Q,            /* Q: ax bx cx dx (non-x86-64), same as 'r' (x86-64) */
               e_reg_ad,           /*!< A: ax dx */
               e_reg_float_tos,    /*!< t: %st(0) */
               e_reg_float_second, /*!< u: %st(1) */
               e_reg_sse,          /*!< x: any SSE register */
               e_reg_sse2,         /*!< Y: any SSE2 register */
               e_reg_mmx,          /*!< y: any MMX register */
            /* immediate constraints */
               e_imm_short_shift,  /*!< I: [0, 32) */
               e_imm_long_shift,   /*!< J: [0, 64) */
               e_imm_lea_shift,    /*!< M: [0, 4) */
               e_imm_signed8,      /*!< K: [-128, 127] */
               e_imm_unsigned8,    /*!< N: [0, 255] */
               e_imm_and_zext,     /*!< L: {0xFF, 0xFFFF} */
               e_imm_80387,        /*!< G: any 80387 standard constant */
               e_imm_sse,          /*!< H: any SSE standard constant */
               e_imm_sext32,       /*!< e: any 32-bit quantity sign extended to 64 bits */
               e_imm_zext32,       /*!< Z: any 32-bit quantity zero extended to 64 bits */
            // DQ (7/22/2006): Let's assume we want to include these (controled by EDG's setting of GNU_X86_ASM_EXTENSIONS_ALLOWED end)
               e_last
             };

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ASM_OP_END


// HEADER_INTRINSICFN_EXPRESSION_START
//         void append_arg($GRAMMAR_PREFIX_Expression*);
// HEADER_INTRINSICFN_EXPRESSION_END

HEADER_SUBSCRIPT_EXPR_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_SUBSCRIPT_EXPR_EXPRESSION_END

// HEADER_SUBSCRIPT_COLON_EXPRESSION_START
// HEADER_SUBSCRIPT_COLON_EXPRESSION_END

HEADER_COLON_SHAPE_EXPRESSION_START
HEADER_COLON_SHAPE_EXPRESSION_END

// HEADER_SUBSCRIPT_ASTERISK_EXPRESSION_START
// HEADER_SUBSCRIPT_ASTERISK_EXPRESSION_END

HEADER_ASTERISK_SHAPE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ASTERISK_SHAPE_EXPRESSION_END

HEADER_USE_ONLY_EXPR_START
HEADER_USE_ONLY_EXPR_END

HEADER_USE_RENAME_EXPR_START
HEADER_USE_RENAME_EXPR_END

HEADER_IO_ITEM_EXPR_START
HEADER_IO_ITEM_EXPR_END

HEADER_IMPLIED_DO_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_IMPLIED_DO_END

HEADER_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_START
HEADER_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_END

HEADER_ACTUAL_ARGUMENT_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_ACTUAL_ARGUMENT_EXPRESSION_END

HEADER_DESIGNATED_INITIALIZER_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
          virtual unsigned int cfgFindChildIndex(SgNode* n) override;
#endif

HEADER_DESIGNATED_INITIALIZER_END

// Rasmussen (6/25/2020): Added SgJovialTablePresetExp to support initializers for Jovial tables
HEADER_JOVIAL_TABLE_PRESET_EXP_START
HEADER_JOVIAL_TABLE_PRESET_EXP_END

// Rasmussen (4/9/2021): Added SgJovialPresetPositionExp to support initialization of Jovial tables
HEADER_JOVIAL_PRESET_POSITION_EXP_START
int replace_expression (SgExpression *o, SgExpression *n) override;
HEADER_JOVIAL_PRESET_POSITION_EXP_END

HEADER_UPC_LOCAL_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_LOCAL_SIZEOF_EXPRESSION_END

HEADER_UPC_BLOCK_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_BLOCK_SIZEOF_EXPRESSION_END

HEADER_UPC_ELEM_SIZEOF_EXPRESSION_START
//        virtual unsigned int cfgIndexForEnd() const;
//        virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index);
//        virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index);
HEADER_UPC_ELEM_SIZEOF_EXPRESSION_END

HEADER_USER_DEFINED_UNARY_EXPRESSION_START
          SgType* get_type() const override;
HEADER_USER_DEFINED_UNARY_EXPRESSION_END

HEADER_USER_DEFINED_BINARY_EXPRESSION_START
          SgType* get_type() const override;
HEADER_USER_DEFINED_BINARY_EXPRESSION_END

HEADER_PSEUDO_DESTRUCTOR_REF_START

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          int get_name_qualification_length() const override;
          void set_name_qualification_length(int name_qualification_length) override;

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_type_elaboration_required() const override;
          void set_type_elaboration_required(bool type_elaboration_required) override;

       // DQ (1/18/2020): Added support for none ROSETTA generated access functions to avoid isModified flag setting semantics.
          bool get_global_qualification_required() const override;
          void set_global_qualification_required(bool global_qualification_required) override;

#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_PSEUDO_DESTRUCTOR_REF_END

// FMZ (2/5/2009) Added for CAFCoExpression
HEADER_CO_EXPRESSION_START

HEADER_CO_EXPRESSION_END

HEADER_LAMBDA_REF_EXP_START

    SgFunctionParameterList* get_parameterList();
    SgStatement* get_body();

HEADER_LAMBDA_REF_EXP_END

HEADER_CUDA_KERNEL_EXEC_CONFIG_START
HEADER_CUDA_KERNEL_EXEC_CONFIG_END

HEADER_CUDA_KERNEL_CALL_EXPRESSION_START
HEADER_CUDA_KERNEL_CALL_EXPRESSION_END

HEADER_JAVA_ANNOTATION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_JAVA_ANNOTATION_END

HEADER_JAVA_MARKER_ANNOTATION_START
HEADER_JAVA_MARKER_ANNOTATION_END

HEADER_JAVA_SINGLE_MEMBER_ANNOTATION_START
HEADER_JAVA_SINGLE_MEMBER_ANNOTATION_END

HEADER_JAVA_NORMAL_ANNOTATION_START

  // DQ (1/13/2014): Added append and prepend member functions to support Java annotations.
     void append_value_pair (SgJavaMemberValuePair *what);
     void prepend_value_pair(SgJavaMemberValuePair *what);

HEADER_JAVA_NORMAL_ANNOTATION_END

HEADER_JAVA_TYPE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_JAVA_TYPE_EXPRESSION_END

HEADER_TYPE_EXPRESSION_START
#ifndef ROSE_USE_INTERNAL_FRONTEND_DEVELOPMENT
          virtual unsigned int cfgIndexForEnd() const override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgOutEdges(unsigned int index) override;
          virtual std::vector<VirtualCFG::CFGEdge> cfgInEdges(unsigned int index) override;
#endif

HEADER_TYPE_EXPRESSION_END


HEADER_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_START

       // DQ (8/11/2014): Added support for C++11 decltype used in new function return syntax.

HEADER_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_END


// #########################################################
// #########################################################
//                      SOURCE CODE
// #########################################################
// #########################################################

NOTES: SgAggregateInitializer, SgConstructorInitializer, and
       SgAssignInitializer all have different set_type functions
       (is this a bug?).

       set_type in SgPlusAssignOp is different from every other SgxxxAssignOp

       SgBitComplementOp set_type function is different from all other Bit operators

// #########################################################
// #########################################################


SOURCE_BASECLASS_EXPRESSION_START
SOURCE_BASECLASS_EXPRESSION_END

SOURCE_X_EXPRESSION_START
SOURCE_X_EXPRESSION_END

SOURCE_X_EXPRESSION_UNKNOWN_START
SOURCE_X_EXPRESSION_UNKNOWN_END

SOURCE_NON_X_EXPRESSION_START
SOURCE_NON_X_EXPRESSION_END

SOURCE_UNARY_EXPRESSION_START
SOURCE_UNARY_EXPRESSION_END

SOURCE_BINARY_EXPRESSION_START
SOURCE_BINARY_EXPRESSION_END

SOURCE_EXPRESSION_ROOT_START
SOURCE_EXPRESSION_ROOT_END

SOURCE_EXPRESSION_LIST_EXPRESSION_START
SOURCE_EXPRESSION_LIST_EXPRESSION_END

SOURCE_VARIABLE_REFERENCE_EXPRESSION_START
SOURCE_VARIABLE_REFERENCE_EXPRESSION_END

SOURCE_NONREAL_REF_EXPRESSION_START
SOURCE_NONREAL_REF_EXPRESSION_END

SOURCE_COMPOUND_LITERAL_EXPRESSION_START
SOURCE_COMPOUND_LITERAL_EXPRESSION_END

SOURCE_LABEL_REFERENCE_EXPRESSION_START
SOURCE_LABEL_REFERENCE_EXPRESSION_END

SOURCE_CLASS_NAME_REFERENCE_EXPRESSION_START
SOURCE_CLASS_NAME_REFERENCE_EXPRESSION_END

SOURCE_LAMBDA_EXPRESSION_START
SOURCE_LAMBDA_EXPRESSION_END

SOURCE_FUNCTION_REFERENCE_EXPRESSION_START
SOURCE_FUNCTION_REFERENCE_EXPRESSION_END

SOURCE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_START
SOURCE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_END

SOURCE_TEMPLATE_FUNCTION_REFERENCE_EXPRESSION_START
SOURCE_TEMPLATE_FUNCTION_REFERENCE_EXPRESSION_END

SOURCE_TEMPLATE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_START
SOURCE_TEMPLATE_MEMBER_FUNCTION_REFERENCE_EXPRESSION_END

SOURCE_VALUE_EXPRESSION_START
SOURCE_VALUE_EXPRESSION_END

SOURCE_BOOLEAN_VALUE_EXPRESSION_START
SOURCE_BOOLEAN_VALUE_EXPRESSION_END

SOURCE_NULLPTR_VALUE_EXPRESSION_START
SOURCE_NULLPTR_VALUE_EXPRESSION_END

SOURCE_VOID_VALUE_EXPRESSION_START
SOURCE_VOID_VALUE_EXPRESSION_END

SOURCE_STRING_VALUE_EXPRESSION_START

void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_value = (char*)0L;
   }

void $CLASSNAME::set_usesSingleQuotes(bool usesSingleQuotes)
{
  if (usesSingleQuotes)
  {
    set_stringDelimiter('\'');
  }
  else if (get_usesSingleQuotes())
  {
    // unset only if the current delimiter uses single quotes
    set_stringDelimiter(0);
  }
}

void $CLASSNAME::set_usesDoubleQuotes(bool usesDoubleQuotes)
{
  if (usesDoubleQuotes)
  {
    set_stringDelimiter('"');
  }
  else if (get_usesDoubleQuotes())
  {
    // unset only if the current delimiter uses double quotes
    set_stringDelimiter(0);
  }
}

SOURCE_STRING_VALUE_EXPRESSION_END


SOURCE_SHORT_VALUE_EXPRESSION_START
SOURCE_SHORT_VALUE_EXPRESSION_END


SOURCE_CHAR_VALUE_EXPRESSION_START
SOURCE_CHAR_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_CHAR_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_CHAR_VALUE_EXPRESSION_END


SOURCE_WCHAR_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

wchar_t
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

void
$CLASSNAME::set_value(wchar_t new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_WCHAR_VALUE_EXPRESSION_END


SOURCE_CHAR16_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

// DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
// char16_t
unsigned short
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

// void $CLASSNAME::set_value(char16_t new_val)
void
$CLASSNAME::set_value(unsigned short new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_CHAR16_VALUE_EXPRESSION_END


SOURCE_CHAR32_VALUE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
  // We can't initialize this to NULL since it might have just been set!
  // p_valueUL = 0L;
   }

// DQ (2/16/2018): ROSE needs to be able to be compiled on non C++11 systems where char_32_t is not defiled.
// char32_t
unsigned int
$CLASSNAME::get_value() const
   {
     return p_valueUL;
   }

// void $CLASSNAME::set_value(char32_t new_val)
void
$CLASSNAME::set_value(unsigned int new_val)
   {
     p_valueUL = new_val;
   }

SOURCE_CHAR32_VALUE_EXPRESSION_END


SOURCE_UNSIGNED_SHORT_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_SHORT_VALUE_EXPRESSION_END


SOURCE_INTEGER_VALUE_EXPRESSION_START
SOURCE_INTEGER_VALUE_EXPRESSION_END


SOURCE_ENUM_VALUE_EXPRESSION_START
SOURCE_ENUM_VALUE_EXPRESSION_END

SOURCE_UNSIGNED_INTEGER_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_INTEGER_VALUE_EXPRESSION_END

SOURCE_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_LONG_INTEGER_VALUE_EXPRESSION_END

SOURCE_LONG_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_LONG_LONG_INTEGER_VALUE_EXPRESSION_END

SOURCE_UNSIGNED_LONG_LONG_INTEGER_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_LONG_LONG_INTEGER_VALUE_EXPRESSION_END

SOURCE_UNSIGNED_LONG_VALUE_EXPRESSION_START
SOURCE_UNSIGNED_LONG_VALUE_EXPRESSION_END

SOURCE_FLOAT_VALUE_EXPRESSION_START
SOURCE_FLOAT_VALUE_EXPRESSION_END

SOURCE_DOUBLE_VALUE_EXPRESSION_START
SOURCE_DOUBLE_VALUE_EXPRESSION_END

SOURCE_LONG_DOUBLE_VALUE_EXPRESSION_START
SOURCE_LONG_DOUBLE_VALUE_EXPRESSION_END

SOURCE_FLOAT_80_VALUE_EXPRESSION_START
SOURCE_FLOAT_80_VALUE_EXPRESSION_END

SOURCE_FLOAT_128_VALUE_EXPRESSION_START
SOURCE_FLOAT_128_VALUE_EXPRESSION_END

SOURCE_ADA_FLOAT_VALUE_EXPRESSION_START
SOURCE_ADA_FLOAT_VALUE_EXPRESSION_END

SOURCE_JOVIAL_BIT_VALUE_EXPRESSION_START
SOURCE_JOVIAL_BIT_VALUE_EXPRESSION_END

SOURCE_ADA_UNIT_REF_EXPRESSION_START
SOURCE_ADA_UNIT_REF_EXPRESSION_END

SOURCE_ADA_TASK_REF_EXPRESSION_START
SOURCE_ADA_TASK_REF_EXPRESSION_END

SOURCE_ADA_PROTECTED_REF_EXPRESSION_START
SOURCE_ADA_PROTECTED_REF_EXPRESSION_END

SOURCE_ADA_RENAMING_REF_EXPRESSION_START
SOURCE_ADA_RENAMING_REF_EXPRESSION_END

SOURCE_ADA_ATTRIBUTE_EXPRESSION_START
SOURCE_ADA_ATTRIBUTE_EXPRESSION_END


SOURCE_TEMPLATE_PARAMETER_VALUE_EXPRESSION_START
SOURCE_TEMPLATE_PARAMETER_VALUE_EXPRESSION_END

SOURCE_COMPLEX_VALUE_EXPRESSION_START
SOURCE_COMPLEX_VALUE_EXPRESSION_END

SOURCE_UPC_THREADS_EXPRESSION_START
SOURCE_UPC_THREADS_EXPRESSION_END

SOURCE_UPC_MYTHREAD_EXPRESSION_START
SOURCE_UPC_MYTHREAD_EXPRESSION_END

SOURCE_YIELD_EXPRESSION_START
SOURCE_YIELD_EXPRESSION_END

SOURCE_AWAIT_EXPRESSION_START
SOURCE_AWAIT_EXPRESSION_END

SOURCE_FOLD_EXPRESSION_START
SOURCE_FOLD_EXPRESSION_END

SOURCE_CHOOSE_EXPRESSION_START
SOURCE_CHOOSE_EXPRESSION_END

SOURCE_SPACESHIP_OPERATOR_START
SOURCE_SPACESHIP_OPERATOR_END

SOURCE_CALL_EXPRESSION_START
SOURCE_CALL_EXPRESSION_END

SOURCE_FUNCTION_CALL_EXPRESSION_START
SOURCE_FUNCTION_CALL_EXPRESSION_END

SOURCE_TYPE_TRAIT_BUILTIN_OPERATOR_START
SOURCE_TYPE_TRAIT_BUILTIN_OPERATOR_END

SOURCE_ARROW_EXPRESSION_START
SOURCE_ARROW_EXPRESSION_END

SOURCE_DOT_EXPRESSION_START
SOURCE_DOT_EXPRESSION_END


SOURCE_DOT_STAR_OPERATOR_EXPRESSION_START
SOURCE_DOT_STAR_OPERATOR_EXPRESSION_END

SOURCE_ARROW_STAR_OPERATOR_EXPRESSION_START
SOURCE_ARROW_STAR_OPERATOR_EXPRESSION_END

SOURCE_BOOLEAN_GET_TYPE_START

// DQ (6/20/2006): Used for all relational operators: ==, !=, <, >, <=, >=, !
SgType*
$CLASSNAME::get_type() const
   {
  // DQ (8/27/2006): We can get this result more quickly without searching the AST backward to the root and
  // if we do so it will be more consistant with what we have to do for the SgTypeBool which similarly must
  // be unparsed differently for C99 and C++ (gnu gcc also accepts "_Bool" as a type).
     SgType* returnType = (SageInterface::is_C_language() == true) ?
                               static_cast<SgType*>(SgTypeInt::createType()) :
                               static_cast<SgType*>(SgTypeBool::createType());
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
SOURCE_BOOLEAN_GET_TYPE_END

SOURCE_EQUALITY_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_EQUALITY_OPERATOR_EXPRESSION_END

SOURCE_LESS_THAN_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_LESS_THAN_OPERATOR_EXPRESSION_END

SOURCE_GREATER_THAN_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_GREATER_THAN_OPERATOR_EXPRESSION_END

SOURCE_NOT_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NOT_EQUAL_OPERATOR_EXPRESSION_END

SOURCE_LESS_OR_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_LESS_OR_EQUAL_OPERATOR_EXPRESSION_END

SOURCE_GREATER_OR_EQUAL_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_GREATER_OR_EQUAL_OPERATOR_EXPRESSION_END

SOURCE_NOT_OPERATOR_EXPRESSION_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NOT_OPERATOR_EXPRESSION_END

SOURCE_ADD_OPERATOR_EXPRESSION_START
SOURCE_ADD_OPERATOR_EXPRESSION_END

SOURCE_DOTDOT_EXPRESSION_START
SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = get_rhs_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }
SOURCE_DOTDOT_EXPRESSION_END

SOURCE_SUBTRACT_OPERATOR_EXPRESSION_START
SOURCE_SUBTRACT_OPERATOR_EXPRESSION_END

SOURCE_MULTIPLY_OPERATOR_EXPRESSION_START
SOURCE_MULTIPLY_OPERATOR_EXPRESSION_END

SOURCE_DIVIDE_OPERATOR_EXPRESSION_START
SOURCE_DIVIDE_OPERATOR_EXPRESSION_END

SOURCE_INTEGER_DIVIDE_OPERATOR_EXPRESSION_START
SOURCE_INTEGER_DIVIDE_OPERATOR_EXPRESSION_END

SOURCE_MOD_OPERATOR_EXPRESSION_START
SOURCE_MOD_OPERATOR_EXPRESSION_END

SOURCE_MEMBERSHIP_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_MEMBERSHIP_OP_END

SOURCE_NON_MEMBERSHIP_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_NON_MEMBERSHIP_OP_END

SOURCE_IS_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_IS_OP_END

SOURCE_IS_NOT_OP_START
SOURCE_BOOLEAN_GET_TYPE_MEMBER_FUNCTION
SOURCE_IS_NOT_OP_END

SOURCE_NARY_OP_START
SOURCE_NARY_OP_END

SOURCE_NARY_COMPARISON_OP_START
SOURCE_NARY_COMPARISON_OP_END

SOURCE_NARY_BOOLEAN_OP_START
SOURCE_NARY_BOOLEAN_OP_END

SOURCE_AND_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an integer representing the logical type

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_AND_OPERATOR_EXPRESSION_END

SOURCE_OR_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an integer representing the logical type

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // DQ (7/20/2006): Modified to remove redundant SgTypeInt qualifier.
     SgType* returnType = SgTypeInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_OR_OPERATOR_EXPRESSION_END

SOURCE_BIT_XOR_OPERATOR_EXPRESSION_START
SOURCE_BIT_XOR_OPERATOR_EXPRESSION_END

SOURCE_BIT_AND_OPERATOR_EXPRESSION_START
SOURCE_BIT_AND_OPERATOR_EXPRESSION_END

SOURCE_BIT_OR_OPERATOR_EXPRESSION_START
SOURCE_BIT_OR_OPERATOR_EXPRESSION_END

SOURCE_BIT_EQV_OPERATOR_EXPRESSION_START
SOURCE_BIT_EQV_OPERATOR_EXPRESSION_END

SOURCE_COMMA_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (10/2/2006): Comma operator's get_type function didn't previously exist, but it should
  // because its semantics is different from the default SgBinaryOp::get_type() which returns
  // the type associated with the lhs.  This returns the type of the rhs.
     ROSE_ASSERT(get_lhs_operand() != NULL);
     ROSE_ASSERT(get_rhs_operand() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = get_rhs_operand()->get_type();
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_COMMA_OPERATOR_EXPRESSION_END

SOURCE_LEFT_SHIFT_OPERATOR_EXPRESSION_START
SOURCE_LEFT_SHIFT_OPERATOR_EXPRESSION_END

SOURCE_RIGHT_SHIFT_OPERATOR_EXPRESSION_START
SOURCE_RIGHT_SHIFT_OPERATOR_EXPRESSION_END

SOURCE_JAVA_UNSIGNED_RIGHT_SHIFT_OPERATOR_EXPRESSION_START
SOURCE_JAVA_UNSIGNED_RIGHT_SHIFT_OPERATOR_EXPRESSION_END

SOURCE_MINUS_OPERATOR_EXPRESSION_START
SOURCE_MINUS_OPERATOR_EXPRESSION_END

SOURCE_UNARY_ADD_OPERATOR_EXPRESSION_START
SOURCE_UNARY_ADD_OPERATOR_EXPRESSION_END

SOURCE_SIZE_OF_OPERATOR_EXPRESSION_START
SOURCE_SIZE_OF_OPERATOR_EXPRESSION_END

SOURCE_ALIGN_OF_OPERATOR_EXPRESSION_START
SOURCE_ALIGN_OF_OPERATOR_EXPRESSION_END

SOURCE_NOEXCEPT_OPERATOR_EXPRESSION_START
SOURCE_NOEXCEPT_OPERATOR_EXPRESSION_END

SOURCE_JAVA_INSTANCEOF_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_operand_expr != NULL || p_operand_type != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_JAVA_INSTANCEOF_OPERATOR_EXPRESSION_END

SOURCE_TYPE_ID_OPERATOR_EXPRESSION_START
SOURCE_TYPE_ID_OPERATOR_EXPRESSION_END

SOURCE_VARARG_START_OPERATOR_START
SOURCE_VARARG_START_OPERATOR_END

SOURCE_VARARG_OPERATOR_START
SOURCE_VARARG_OPERATOR_END

SOURCE_VARARG_END_OPERATOR_START
SOURCE_VARARG_END_OPERATOR_END

SOURCE_POINTER_DEREFERENCE_EXPRESSION_START
SOURCE_POINTER_DEREFERENCE_EXPRESSION_END

SOURCE_ADDRESS_OF_OPERATOR_EXPRESSION_START
SOURCE_ADDRESS_OF_OPERATOR_EXPRESSION_END


SOURCE_MINUS_MINUS_OPERATOR_EXPRESSION_START
$CLASSNAME::$CLASSNAME(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(fi, exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

$CLASSNAME::$CLASSNAME(SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

void
$CLASSNAME::post_construction_initialization()
   {
     set_mode(SgUnaryOp::prefix);
   }

SOURCE_MINUS_MINUS_OPERATOR_EXPRESSION_END


SOURCE_PLUS_PLUS_OPERATOR_EXPRESSION_START
$CLASSNAME::$CLASSNAME(Sg_File_Info * fi, SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(fi, exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

$CLASSNAME::$CLASSNAME( SgExpression * exp, Sgop_mode a_mode)
   : $BASECLASS(exp, NULL)
   {
     set_mode(a_mode);
     if (exp)
          exp->set_parent(this);
   }

void
$CLASSNAME::post_construction_initialization()
   {
     set_mode(SgUnaryOp::prefix);
   }

SOURCE_PLUS_PLUS_OPERATOR_EXPRESSION_END


SOURCE_BIT_COMPLEMENT_OPERATOR_EXPRESSION_START
SOURCE_BIT_COMPLEMENT_OPERATOR_EXPRESSION_END

SOURCE_REAL_PART_OPERATOR_EXPRESSION_START
SOURCE_REAL_PART_OPERATOR_EXPRESSION_END

SOURCE_IMAG_PART_OPERATOR_EXPRESSION_START
SOURCE_IMAG_PART_OPERATOR_EXPRESSION_END

SOURCE_CONJUGATE_OPERATOR_EXPRESSION_START
SOURCE_CONJUGATE_OPERATOR_EXPRESSION_END

SOURCE_ATEXP_EXPRESSION_START
SOURCE_ATEXP_EXPRESSION_END

SOURCE_FINISHEXP_EXPRESSION_START
SOURCE_FINISHEXP_EXPRESSION_END

SOURCE_CONDITIONAL_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
     if (p_conditional_exp != NULL)
          p_conditional_exp->set_parent(this);
     if (p_true_exp != NULL)
          p_true_exp->set_parent(this);
     if (p_false_exp != NULL)
          p_false_exp->set_parent(this);
   }

SgType*
$CLASSNAME::get_type() const
   {
  // In this function we want to return the type of the true of false option but it only makes sense for them to be the same type.

  // DQ (1/14/2006): p_expression_type has been removed, we have to compute the appropriate type (IR specific code)
  // printf ("$CLASSNAME::get_type(): p_expression_type has been removed, we have to compute the appropriate type \n");

  // Jeremiah (7/20/2006): Despite the comments, SOURCE_CONDITIONAL_EXPRESSION refers to a p_expression_type member,
  // but then ignores it.  I think you may want to store the type explicitly for this operator, as computing it is
  // difficult (requires handling user-defined conversions and such).  The return type can be either the true or false
  // types, and they can be different.

     ROSE_ASSERT(p_true_exp  != NULL);
     ROSE_ASSERT(p_false_exp != NULL);

     SgType* trueType   = p_true_exp->get_type();
     ROSE_ASSERT(trueType != NULL);

     SgType* falseType  = p_false_exp->get_type();
     ROSE_ASSERT(falseType != NULL);

#if PRINT_DEVELOPER_WARNINGS
     string expression_type_name = "NULL";
     if (p_expression_type != NULL)
          expression_type_name = p_expression_type->class_name();

  // ROSE_ASSERT(trueType == falseType);
     if (trueType != falseType)
        {
          printf ("Warning: In SgConditionalExp::get_type(): trueType = %s != falseType = %s  (p_expression_type = %s) \n",
               trueType->class_name().c_str(),falseType->class_name().c_str(),expression_type_name.c_str());
       // get_file_info()->display("Warning: In SgConditionalExp::get_type(): trueType != falseType");
        }
#endif

  // This was the previous choice for how p_expression_type was set,
  // so to be consistant we will select the same branch.
     SgType* returnType = trueType;

  // PC (10/12/2009): If returnType is in fact an SgArrayType it will undergo array-to-pointer conversion
     SgType *retElemType = SageInterface::getElementType(returnType);
     if (retElemType != NULL)
        {
          returnType = SgPointerType::createType(retElemType);
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SgExpression*
$CLASSNAME::get_next(int& n) const
   {
     SgExpression *tmp = NULL;
     switch (n)
        {
          case 0: tmp = get_conditional_exp(); n++; break;
          case 1: tmp = get_true_exp(); n++; break;
          case 2: tmp = get_false_exp(); n++; break;
        }

     return tmp;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_conditional_exp() == o)
        {
          set_conditional_exp(n);
          n->set_parent(this);
          return 1;
        }
       else
        {
          if (get_true_exp() == o)
             {
               set_true_exp(n);
               n->set_parent(this);
               return 1;
             }
            else
             {
               if (get_false_exp() == o)
                  {
                    set_false_exp(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }

SOURCE_CONDITIONAL_EXPRESSION_END

SOURCE_CAST_EXPRESSION_START
SOURCE_CAST_EXPRESSION_END

SOURCE_POINTER_ARRAY_REFERENCE_EXPRESSION_START
SOURCE_POINTER_ARRAY_REFERENCE_EXPRESSION_END


SOURCE_NEW_OPERATOR_EXPRESSION_START
SOURCE_NEW_OPERATOR_EXPRESSION_END

SOURCE_DELETE_OPERATOR_EXPRESSION_START
SOURCE_DELETE_OPERATOR_EXPRESSION_END

SOURCE_HERE_EXPRESSION_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SgType*
$CLASSNAME::get_type() const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgType* returnType = SgTypeDefault::createType();
     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }
SOURCE_HERE_EXPRESSION_END

SOURCE_THIS_EXPRESSION_START
SOURCE_THIS_EXPRESSION_END

SOURCE_SUPER_EXPRESSION_START
SOURCE_SUPER_EXPRESSION_END

SOURCE_CLASS_EXPRESSION_START
SOURCE_CLASS_EXPRESSION_END

SOURCE_TUPLE_EXP_START
SOURCE_TUPLE_EXP_END

SOURCE_LIST_EXP_START
SOURCE_LIST_EXP_END

SOURCE_MATRIX_EXP_START
SOURCE_MATRIX_EXP_END

SOURCE_RANGE_EXP_START
SOURCE_RANGE_EXP_END

SOURCE_COMPREHENSION_START
SOURCE_COMPREHENSION_END

SOURCE_LIST_COMPREHENSION_START
SOURCE_LIST_COMPREHENSION_END

SOURCE_SET_COMPREHENSION_START
SOURCE_SET_COMPREHENSION_END

SOURCE_DICTIONARY_COMPREHENSION_START
SOURCE_DICTIONARY_COMPREHENSION_END

SOURCE_DICTIONARY_EXP_START
SOURCE_DICTIONARY_EXP_END

SOURCE_KEY_DATUM_PAIR_START
SOURCE_KEY_DATUM_PAIR_END

SOURCE_STRING_CONVERSION_START
SOURCE_STRING_CONVERSION_END

SOURCE_SCOPE_OPERATOR_EXPRESSION_START
SOURCE_SCOPE_OPERATOR_EXPRESSION_END

SOURCE_ASSIGN_OPERATOR_EXPRESSION_START
SOURCE_ASSIGN_OPERATOR_EXPRESSION_END

SOURCE_POINTER_ASSIGN_OPERATOR_EXPRESSION_START
SOURCE_POINTER_ASSIGN_OPERATOR_EXPRESSION_END

SOURCE_INTEGER_DIVIDE_ASSIGN_OP_START
SOURCE_INTEGER_DIVIDE_ASSIGN_OP_END

SOURCE_EXPONENTIATION_ASSIGN_OP_START
SOURCE_EXPONENTIATION_ASSIGN_OP_END

SOURCE_REFERENCE_EXPRESSION_START
SOURCE_REFERENCE_EXPRESSION_END

SOURCE_THROW_OPERATOR_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (1/14/2006): For a list of types held internally it is not clear what to return.
  // So return a SgDefaultType as in Sage II previously.  Might be better to research
  // this in more details later.
     SgType* returnType = SgTypeDefault::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_THROW_OPERATOR_EXPRESSION_END

SOURCE_CONCATENATION_OPERATOR_EXPRESSION_START
SOURCE_CONCATENATION_OPERATOR_EXPRESSION_END

SOURCE_REPLICATION_OPERATOR_EXPRESSION_START
SOURCE_REPLICATION_OPERATOR_EXPRESSION_END

SOURCE_REM_OPERATOR_EXPRESSION_START
SOURCE_REM_OPERATOR_EXPRESSION_END

SOURCE_ABS_OPERATOR_EXPRESSION_START
SOURCE_ABS_OPERATOR_EXPRESSION_END

SOURCE_AT_OPERATOR_EXPRESSION_START
SOURCE_AT_OPERATOR_EXPRESSION_END

SOURCE_INITIALIZER_EXPRESSION_START
SOURCE_INITIALIZER_EXPRESSION_END

SOURCE_AGGREGATE_INITIALIZER_EXPRESSION_START
SOURCE_AGGREGATE_INITIALIZER_EXPRESSION_END

SOURCE_COMPOUND_INITIALIZER_EXPRESSION_START
SOURCE_COMPOUND_INITIALIZER_EXPRESSION_END

SOURCE_CONSTRUCTOR_INITIALIZER_EXPRESSION_START
SOURCE_CONSTRUCTOR_INITIALIZER_EXPRESSION_END

SOURCE_ASSIGNMENT_INITIALIZER_EXPRESSION_START

SgExpression*
$CLASSNAME::get_operand() const
   { return get_operand_i(); }

void
$CLASSNAME::post_construction_initialization()
   {
     if (get_operand() != NULL)
          get_operand()->set_parent(this);
   }

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_operand() != NULL);

     SgType* returnType = p_expression_type ? p_expression_type : get_operand()->get_type();

     ROSE_ASSERT(returnType != NULL);

     if (!p_expression_type && get_operand()->variantT() != V_SgStringVal)
        {
          SgType* retElemType = SageInterface::getElementType(returnType);
          if (retElemType != NULL)
             {
               returnType = SgPointerType::createType(retElemType);
             }
        }

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

void
$CLASSNAME::set_operand(SgExpression * exp)
   {
     set_operand_i(exp);
     if (exp)
          exp->set_parent(this);
   }

SgExpression*
$CLASSNAME::get_next(int& n) const
   {
     if(n==0)
        {
          n++;
          return get_operand();
        }
       else
          return 0;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_operand()==o)
        {
          set_operand(n);
          n->set_parent(this);
          return 1;
        }
       else
          return 0;
   }

SOURCE_ASSIGNMENT_INITIALIZER_EXPRESSION_END


SOURCE_ADA_ANCESTOR_INITIALIZER_EXPRESSION_START

SgExpression*
$CLASSNAME::get_operand() const
{ return get_ancestor(); }

void
$CLASSNAME::post_construction_initialization()
   {
     if (get_operand() != NULL)
          get_operand()->set_parent(this);
   }

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_operand() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return get_operand()->get_type();
   }

void
$CLASSNAME::set_operand(SgExpression * exp)
   {
     set_ancestor(exp);

     if (exp)
          exp->set_parent(this);
   }

SgExpression*
$CLASSNAME::get_next(int& n) const
   {
     if(n==0)
      {
        n=1;
        return get_operand();
      }

     return nullptr;
   }

int
$CLASSNAME::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_operand()==o)
        {
          set_operand(n);
          return 1;
        }

     return 0;
   }

SOURCE_ADA_ANCESTOR_INITIALIZER_EXPRESSION_END


SOURCE_BRACED_INITIALIZER_EXPRESSION_START
SOURCE_BRACED_INITIALIZER_EXPRESSION_END


// ######################################################
// ######################################################
// ######################################################
// ######################################################
// ######################################################
// ######################################################

// ******************************************************
// $CLASSNAME::post_construction_initialization() function
// ******************************************************

SOURCE_EMPTY_POST_CONSTRUCTION_INITIALIZATION_START
void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_EMPTY_POST_CONSTRUCTION_INITIALIZATION_END


SOURCE_POST_CONSTRUCTION_INITIALIZATION_USING_SET_TYPE_START

SOURCE_POST_CONSTRUCTION_INITIALIZATION_USING_SET_TYPE_END


// *******************************************
//       $CLASSNAME::set_Type() function
// *******************************************

// SgExprListExp
// SgVarRefExp
// SgClassNameRefExp
// SgValueExp
// SgNewExp
// SgDeleteExp
// SgThisExp
// SgAggregateInitializer
SOURCE_EMPTY_SET_TYPE_FUNCTION_START

SOURCE_EMPTY_SET_TYPE_FUNCTION_END


// SgEqualityOp
// SgLessThanOp
// SgGreaterThanOp
// SgNotEqualOp
// SgLessOrEqualOp
// SgGreaterOrEqualOp
SOURCE_SET_TYPE_BOOLEAN_OPERATOR_EXPRESSION_START

SOURCE_SET_TYPE_BOOLEAN_OPERATOR_EXPRESSION_END


// SgAddOp
// SgSubtractOp
// SgMultiplyOp
// SgDivideOp
// SgIntegerDivideOp
// SgModOp
SOURCE_ARITHMETIC_OPERATOR_EXPRESSION_START

SOURCE_ARITHMETIC_OPERATOR_EXPRESSION_END


// SgAndOp
// SgOrOp
// SgNotOp
SOURCE_INTEGER_OPERATOR_EXPRESSION_START

SOURCE_INTEGER_OPERATOR_EXPRESSION_END


// SgBitXorOp
// SgBitAndOp
// SgBitOrOp
// SgBitEqvOp
SOURCE_BIT_OPERATOR_EXPRESSION_START

SOURCE_BIT_OPERATOR_EXPRESSION_END

// SgFunctionCallExp
// SgFunctionRefExp
SOURCE_GET_FUNCTION_SET_TYPE_FUNCTION_EXPRESSION_START
SOURCE_GET_FUNCTION_SET_TYPE_FUNCTION_EXPRESSION_END

// SgArrowExp
// SgDotExp
// SgScopeOp
SOURCE_GET_RHS_OPERAND_FUNCTION_EXPRESSION_START
SOURCE_GET_RHS_OPERAND_FUNCTION_EXPRESSION_END


// SgLshiftOp
// SgRshiftOp
// SgAssignOp
// SgPlusAssignOp (not used currently, suspected bug?)
// SgMinusAssignOp
// SgAndAssignOp
// SgIorAssignOp
// SgMinusAssignOp
// SgMultAssignOp
// SgDivAssignOp
// SgModAssignOp
// SgXorAssignOp
// SgLshiftAssignOp
// SgRshiftAssignOp
SOURCE_SET_TYPE_SHIFT_OPERATOR_EXPRESSION_START

SOURCE_SET_TYPE_SHIFT_OPERATOR_EXPRESSION_END

// SgMinusOp
// SgUnaryAddOp
// SgMinusMinusOp
// SgPlusPlusOp
// SgBitComplementOp  // Why is this not like the other Bit operators?
// SgAssignInitializer
SOURCE_SET_TYPE_UNARY_OPERATOR_EXPRESSION_START

SOURCE_SET_TYPE_UNARY_OPERATOR_EXPRESSION_END

// SgSizeOfOp
// SgTypeIdOp
SOURCE_SET_TYPE_SIZEOF_TYPEID_OPERATOR_EXPRESSION_START

SOURCE_SET_TYPE_SIZEOF_TYPEID_OPERATOR_EXPRESSION_END

// SgThrowOp
SOURCE_SET_TYPE_DEFAULT_TYPE_EXPRESSION_START

SOURCE_SET_TYPE_DEFAULT_TYPE_EXPRESSION_END


// *******************************************
//       CLASSNAME::get_Type() function
// *******************************************


// SgExprListExp
SOURCE_DEFAULT_GET_TYPE_START
SgType*

$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(this != NULL);

     SgType* returnType = SgTypeDefault::createType();
     return returnType;
   }

SOURCE_DEFAULT_GET_TYPE_END


SOURCE_GET_TYPE_FROM_SYMBOL_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     SgSymbol* symbol = this->get_symbol();
     if (symbol == NULL)
        {
          printf ("Error: In $CLASSNAME::get_type(): symbol == NULL this = %p = %s \n",this,this->class_name().c_str());
        }
     ROSE_ASSERT(symbol != NULL);

     SgType* type = symbol->get_type();
     if (type == NULL)
        {
          printf ("Error: In $CLASSNAME::get_type(): type == NULL symbol = %p = %s \n",symbol,symbol->class_name().c_str());
        }
     ROSE_ASSERT(type != NULL);

     return type;
   }

SOURCE_GET_TYPE_FROM_SYMBOL_END

// SgFunctionRefExp
// SgMemberFunctionRefExp
SOURCE_GET_TYPE_FUNCTION_REFERENCE_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
  // DQ (7/30/2004): The type of a SgFunctionRefExp should be a SgFunctionType,
  // not the return type of the function associated with the SgFunctionRefExp.

     printf ("$CLASSNAME::get_type() for FUNCTION_REFERENCE_EXPRESSION not implemented (p_function_type removed) \n");
     ROSE_ASSERT(false);

     return NULL;
   }

SOURCE_GET_TYPE_FUNCTION_REFERENCE_EXPRESSION_END

// DQ (8/17/2010): Removed SgStringVal from the list of types using the generic form of get_type()
// SgBoolValExp
// SgShortVal
// SgCharVal
// SgUnsignedCharVal
// SgWcharVal
// SgUnsignedShortVal
// SgIntVal
// SgEnumVal
// SgUnsignedIntVal
// SgLongIntVal
// SgLongLongIntVal
// SgUnsignedLongLongIntVal
// SgUnsignedLongVal
// SgFloatVal
// SgDoubleVal
// SgLongDoubleVal
// SgDeleteExp
SOURCE_GET_TYPE_GENERIC_START

SgType*
$CLASSNAME::get_type(void) const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return GENERIC_TYPE::createType();
   }

SOURCE_GET_TYPE_GENERIC_END

// SgStringVal
SOURCE_GET_TYPE_STRING_START
SOURCE_GET_TYPE_STRING_END

SOURCE_GET_TYPE_COMPLEX_START

SgType*
$CLASSNAME::get_type(void) const
   {
  // Use the stored SgType to return the correct SgTypeComplex using the correct precision.
     ROSE_ASSERT(p_precisionType != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // returns a shared SgTypeComplex type
     return SgTypeComplex::createType(p_precisionType);
   }

SOURCE_GET_TYPE_COMPLEX_END

// SgConstructorInitializer (DQ (8/1/2006): This code fragment is no longer used!)
SOURCE_GET_TYPE_CLASS_DECL_START

// DQ (7/19/2006): Function suggested by Jeremiah Willcock and fixed up for general use by DQ
// A better fix (later) will allow us to save the SgType and not use a SgDefaultType for the
// special case below.
SgType*
$CLASSNAME::get_type(void) const
   {
     ROSE_ASSERT(this != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // DQ (8/5/2006): Now that we store the expression type explicitly this is a simpler function.
     SgType* returnType = p_expression_type;

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_GET_TYPE_CLASS_DECL_END

// SgFunctionCallExp
// SgSizeOfOp
// SgTypeIdOp
// SgConditionalExp
// SgAssignInitializer
SOURCE_GET_TYPE_CALLING_GET_EXPRESSION_TYPE_EXPRESSION_START

SOURCE_GET_TYPE_CALLING_GET_EXPRESSION_TYPE_EXPRESSION_END

SOURCE_GET_TYPE_HERE_EXPRESSION_START
SOURCE_GET_TYPE_HERE_EXPRESSION_END

SOURCE_GET_TYPE_THIS_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     SgType * type = NULL;
     if (get_class_symbol() != NULL) {
       type = get_class_symbol()->get_type();
     }
     if (get_nonreal_symbol() != NULL) {
       type = get_nonreal_symbol()->get_type();
     }

     ROSE_ASSERT(type != NULL);

     return SgPointerType::createType(type);
   }

SOURCE_GET_TYPE_THIS_EXPRESSION_END

SOURCE_GET_TYPE_SUPER_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_class_symbol() != NULL);
     ROSE_ASSERT(get_class_symbol()->get_type() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return SgPointerType::createType(get_class_symbol()->get_type());
   }

SOURCE_GET_TYPE_SUPER_EXPRESSION_END

SOURCE_GET_TYPE_CLASS_EXPRESSION_START

SgType*
$CLASSNAME::get_type() const
   {
     ROSE_ASSERT(get_class_symbol() != NULL);
     ROSE_ASSERT(get_class_symbol()->get_type() != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     return get_class_symbol() -> get_type();
   }

SOURCE_GET_TYPE_CLASS_EXPRESSION_END

SOURCE_NULL_EXPRESSION_START
SOURCE_NULL_EXPRESSION_END

SOURCE_ADA_OTHERS_EXPRESSION_START
SOURCE_ADA_OTHERS_EXPRESSION_END

SOURCE_VARIANT_EXPRESSION_START
SOURCE_VARIANT_EXPRESSION_END

SOURCE_STATEMENT_EXPRESSION_START
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_statement != NULL);

  // DQ (7/21/2006): For now we implement this partially and fix it up later.
  // We might want to store the type explicitly since it might be difficult
  // to compute for complex sequences of statements.  It appears that the
  // type is just the type of the expression in the last statement of the block,
  // but it is not clear if it can be more complex than this!

  // The rules are: The last thing in the compound statement should be an expression
  // followed by a semicolon; the value of this subexpression serves as the value of
  // the entire construct. (If you use some other kind of statement last within the
  // braces, the construct has type void, and thus effectively no value.).

  // printf ("$CLASSNAME::get_type() for GNU Statement Expression extension not implemented p_statement = %p = %s \n",p_statement,p_statement->class_name().c_str());

  // DQ (8/6/2006): The rules for the type of a statement expression are that it is the
  // type of the last expression in the statement list or void if the last statement is
  // not an expression (expression statement, SgExpressionStatement).
     SgBasicBlock* block = isSgBasicBlock(p_statement);
     ROSE_ASSERT(block != NULL);

     SgStatementPtrList & statementList = block->getStatementList();

  // DQ (4/8/2015): Empty statement expressions have to be allowed.
     if (statementList.empty() == true)
        {
       // DQ (4/8/2015): After discusion, this might be better setup as a SgTypeUnknown instead of SgTypeVoid.
          returnType = SgTypeVoid::createType();
        }
       else
        {
          SgStatement* lastStatement = *(statementList.rbegin());
          SgExprStatement* expressionStatement = isSgExprStatement(lastStatement);
          if (expressionStatement != NULL)
             {
            // The type of the statement expression is the
            // SgExpression* expression = expressionStatement->get_the_expr();
               SgExpression* expression = expressionStatement->get_expression();
               ROSE_ASSERT(expression != NULL);
               returnType = expression->get_type();
             }
            else
             {
            // This is the default type if last statement in block is not an expression statement (C++ standard)
               returnType = SgTypeVoid::createType();
             }
        }

     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_STATEMENT_EXPRESSION_END

SOURCE_ASM_OP_START
SgType*
$CLASSNAME::get_type() const
   {
     SgType* returnType = NULL;

     ROSE_ASSERT(p_expression != NULL);

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

  // This is the default case (we can look at the last statement of the block later)
     returnType = p_expression->get_type();
     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

SOURCE_ASM_OP_END



SOURCE_EXPONENTIATION_EXPRESSION_START

void
$CLASSNAME::post_construction_initialization()
   {
   }

SOURCE_EXPONENTIATION_EXPRESSION_END



SOURCE_INTRINSICFN_EXPRESSION_START

SOURCE_INTRINSICFN_EXPRESSION_END


SOURCE_SUBSCRIPT_EXPR_EXPRESSION_START
SOURCE_SUBSCRIPT_EXPR_EXPRESSION_END

SOURCE_SUBSCRIPT_COLON_EXPRESSION_START
SOURCE_SUBSCRIPT_COLON_EXPRESSION_END

SOURCE_COLON_SHAPE_EXPRESSION_START
SOURCE_COLON_SHAPE_EXPRESSION_END

SOURCE_ASTERISK_SHAPE_EXPRESSION_START
SOURCE_ASTERISK_SHAPE_EXPRESSION_END

SOURCE_USE_ONLY_EXPR_START
SOURCE_USE_ONLY_EXPR_END

SOURCE_USE_RENAME_EXPR_START
SOURCE_USE_RENAME_EXPR_END

SOURCE_IO_ITEM_EXPR_START
SOURCE_IO_ITEM_EXPR_END

SOURCE_IMPLIED_DO_START
SOURCE_IMPLIED_DO_END

SOURCE_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_START
SOURCE_UNKNOWN_ARRAY_OR_FUNCTION_REFERENCE_END

SOURCE_ACTUAL_ARGUMENT_EXPRESSION_START
SOURCE_ACTUAL_ARGUMENT_EXPRESSION_END

SOURCE_DESIGNATED_INITIALIZER_START
SOURCE_DESIGNATED_INITIALIZER_END

SOURCE_JOVIAL_TABLE_PRESET_EXP_START
SOURCE_JOVIAL_TABLE_PRESET_EXP_END

SOURCE_JOVIAL_PRESET_POSITION_EXP_START
SOURCE_JOVIAL_PRESET_POSITION_EXP_END

SOURCE_UPC_LOCAL_SIZEOF_EXPRESSION_START
SOURCE_UPC_LOCAL_SIZEOF_EXPRESSION_END

SOURCE_UPC_BLOCK_SIZEOF_EXPRESSION_START
SOURCE_UPC_BLOCK_SIZEOF_EXPRESSION_END

SOURCE_UPC_ELEM_SIZEOF_EXPRESSION_START
SOURCE_UPC_ELEM_SIZEOF_EXPRESSION_END

SOURCE_USER_DEFINED_UNARY_EXPRESSION_START
SOURCE_USER_DEFINED_UNARY_EXPRESSION_END

SOURCE_USER_DEFINED_BINARY_EXPRESSION_START
SOURCE_USER_DEFINED_BINARY_EXPRESSION_END

SOURCE_CO_EXPRESSION_START
SOURCE_CO_EXPRESSION_END

SOURCE_PSEUDO_DESTRUCTOR_REF_START
SOURCE_PSEUDO_DESTRUCTOR_REF_END

SOURCE_LAMBDA_REF_EXP_START
SOURCE_LAMBDA_REF_EXP_END

SOURCE_CUDA_KERNEL_EXEC_CONFIG_START
SOURCE_CUDA_KERNEL_EXEC_CONFIG_END

SOURCE_CUDA_KERNEL_CALL_EXPRESSION_START
SOURCE_CUDA_KERNEL_CALL_EXPRESSION_END

SOURCE_JAVA_ANNOTATION_START

// DQ (1/13/2014): This function helps to provide a uniform interface even though
// the type is held in a field called p_expression_type.  This supports Java annotations
// for the SgJavaMarkerAnnotation, SgJavaSingleMemberAnnotation, and SgJavaNormalAnnotation.
SgType*
$CLASSNAME::get_type() const
   {
  // This function returns an explicitly stored type

     SgType* returnType = p_expression_type;

#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

SOURCE_JAVA_ANNOTATION_END

SOURCE_JAVA_MARKER_ANNOTATION_START
SOURCE_JAVA_MARKER_ANNOTATION_END

SOURCE_JAVA_SINGLE_MEMBER_ANNOTATION_START
SOURCE_JAVA_SINGLE_MEMBER_ANNOTATION_END

SOURCE_JAVA_NORMAL_ANNOTATION_START
SOURCE_JAVA_NORMAL_ANNOTATION_END

SOURCE_JAVA_TYPE_EXPRESSION_START
SOURCE_JAVA_TYPE_EXPRESSION_END

SOURCE_TYPE_EXPRESSION_START
SOURCE_TYPE_EXPRESSION_END

SOURCE_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_START
SOURCE_FUNCTION_PARAMETER_REFERENCE_EXPRESSION_END
