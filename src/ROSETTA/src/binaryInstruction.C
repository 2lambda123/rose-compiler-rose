#line 85 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// THIS FILE IS MACHINE GENERATED
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
#line 87 "src/Rosebud/RosettaGenerator.C"
// This file was generated with ROSE's "rosebud" tool by reading node definitions written in a
// C++-like language and emitting this ROSETTA input.
//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// DO NOT MODIFY THIS FILE MANUALLY!
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


#line 93 "src/Rosebud/RosettaGenerator.C"
#include <featureTests.h>
#ifdef ROSE_ENABLE_BINARY_ANALYSIS
#include "ROSETTA_macros.h"
#include "grammar.h"
#include "AstNodeClass.h"

//#undef DOCUMENTATION -- commented out so IDEs can't figure it out
#ifdef DOCUMENTATION
DOCUMENTATION_should_never_be_defined;
#endif

#ifdef DOCUMENTATION
#define DECLARE_LEAF_CLASS(CLASS_WITHOUT_Sg) /*void*/
#else
#define DECLARE_LEAF_CLASS(CLASS_WITHOUT_Sg) \
    NEW_TERMINAL_MACRO(CLASS_WITHOUT_Sg, #CLASS_WITHOUT_Sg, #CLASS_WITHOUT_Sg "Tag"); \
    CLASS_WITHOUT_Sg.setCppCondition("!defined(DOCUMENTATION)");\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfConstructor(false);\
    CLASS_WITHOUT_Sg.setAutomaticGenerationOfDestructor(false)
#endif

#ifdef DOCUMENTATION
#define DECLARE_HEADERS(CLASS_WITHOUT_Sg) /*void*/
#else
#define DECLARE_HEADERS(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.setPredeclarationString("Sg" #CLASS_WITHOUT_Sg "_HEADERS", \
                          ROSE_AUTOMAKE_ABSOLUTE_PATH_TOP_SRCDIR + "/src/ROSETTA/src/binaryInstruction.C")
#endif

#ifdef DOCUMENTATION
#define DECLARE_OTHERS(CLASS_WITHOUT_Sg) /*void*/
#else
#define DECLARE_OTHERS(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.setFunctionPrototype("Sg" #CLASS_WITHOUT_Sg "_OTHERS", \
                          ROSE_AUTOMAKE_ABSOLUTE_PATH_TOP_SRCDIR + "/src/ROSETTA/src/binaryInstruction.C")
#endif

#ifdef DOCUMENTATION
#define IS_SERIALIZABLE() /*void*/
#else
#define IS_SERIALIZABLE(CLASS_WITHOUT_Sg) \
    CLASS_WITHOUT_Sg.isBoostSerializable(true)
#endif


#line 196 "src/Rosebud/RosettaGenerator.C"
// Since ROSETTA builds classes from the leaves up to the base, and C++ builds classes from the
// base down to the leaves, we need to make sure that doxygen sees the base classes before the derived classes. So
// just list all the non-leaf classes here.
#ifdef DOCUMENTATION
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmBinaryExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmCilDataStream;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmCilMetadata;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmCilNode;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmConstantExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmDwarfConstruct;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmDwarfInformation;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmElfSection;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmExecutableFileFormat;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmGenericHeader;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmGenericSection;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmGenericString;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmGenericStrtab;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmGenericSymbol;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmInstruction;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmJvmAttribute;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmJvmNode;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmNode;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmPESection;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmRegisterReferenceExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmScalarType;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmStatement;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmSynthesizedDeclaration;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmType;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmUnaryExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgAsmValueExpression;
#line 201 "src/Rosebud/RosettaGenerator.C"
class SgNode;
#line 202 "src/Rosebud/RosettaGenerator.C"
#endif // DOCUMENTATION

#line 147 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
void Grammar::setUpBinaryInstructions() {
#endif // !DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmX86Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmX86Instruction);
IS_SERIALIZABLE(AsmX86Instruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmX86Instruction);
#if defined(SgAsmX86Instruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
#include <Rose/BinaryAnalysis/BasicTypes.h>
#include <Rose/BinaryAnalysis/InstructionEnumsX86.h>
#endif // SgAsmX86Instruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
/** Represents one Intel x86 machine instruction. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
class SgAsmX86Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionKind", "kind", "= Rose::BinaryAnalysis::x86_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "baseSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "operandSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86InstructionSize", "addressSize", "= Rose::BinaryAnalysis::x86_insnsize_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "bool", "lockPrefix", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86RepeatPrefix", "repeatPrefix", "= Rose::BinaryAnalysis::x86_repeat_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86BranchPrediction", "branchPrediction", "= Rose::BinaryAnalysis::x86_branch_prediction_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    AsmX86Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::X86SegmentRegister", "segmentOverride", "= Rose::BinaryAnalysis::x86_segreg_none",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmX86Instruction);
#if defined(SgAsmX86Instruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_baseSize);
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_operandSize);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_addressSize);
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_lockPrefix);
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_repeatPrefix);
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_branchPrediction);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_segmentOverride);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
public:
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86InstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::X86InstructionKind const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86InstructionSize const& get_baseSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_baseSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86InstructionSize const& get_operandSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_operandSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86InstructionSize const& get_addressSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_addressSize(Rose::BinaryAnalysis::X86InstructionSize const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_lockPrefix() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_lockPrefix(bool const&);
    /** @} */
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86RepeatPrefix const& get_repeatPrefix() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_repeatPrefix(Rose::BinaryAnalysis::X86RepeatPrefix const&);
    /** @} */
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86BranchPrediction const& get_branchPrediction() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_branchPrediction(Rose::BinaryAnalysis::X86BranchPrediction const&);
    /** @} */
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::X86SegmentRegister const& get_segmentOverride() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_segmentOverride(Rose::BinaryAnalysis::X86SegmentRegister const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmX86Instruction.h"
public:
    /** Converts a size to an instruction size enum.
     *
     *  Given a size in bits, which must be 16, 32, or 64, return the corresponding enum constant. */
    static Rose::BinaryAnalysis::X86InstructionSize instructionSizeForWidth(size_t);

    /** Converts a size enum constant to a size.
     *
     *  Given a size enum constant, return the number of bits that enum represents. */
    static size_t widthForInstructionSize(Rose::BinaryAnalysis::X86InstructionSize);

    /** Return the register dictionary for an x86 architecture.
     *
     *  Given an instruction size enum constant return the register dictionary that describes the x86 architecture with
     *  the specified word size.  See also, @ref registersForWidth. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForInstructionSize(Rose::BinaryAnalysis::X86InstructionSize);

    /** Return the register dictionary for an x86 architecture.
     *
     *  Given an instruction size of 16, 32, or 64 return the register dictionary that describes the x86 architecture with
     *  the specified word size.  See also, @ref registersForInstructionSize. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForWidth(size_t);

    // Overrides are documented in the base class
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*>&,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr()) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmX86Instruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmX86Instruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmX86Instruction(rose_addr_t const& address,
                        std::string const& mnemonic,
                        Rose::BinaryAnalysis::X86InstructionKind const& kind,
                        Rose::BinaryAnalysis::X86InstructionSize const& baseSize,
                        Rose::BinaryAnalysis::X86InstructionSize const& operandSize,
                        Rose::BinaryAnalysis::X86InstructionSize const& addressSize);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmX86Instruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVolatileType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfVolatileType);
IS_SERIALIZABLE(AsmDwarfVolatileType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVolatileType.h"
class SgAsmDwarfVolatileType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfVolatileType);
#if defined(SgAsmDwarfVolatileType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfVolatileType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfVolatileType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfVolatileType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVolatileType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmVectorType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmVectorType);
IS_SERIALIZABLE(AsmVectorType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
/** Base class for vector types. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
class SgAsmVectorType: public SgAsmType {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
    AsmVectorType.setDataPrototype(
        "size_t", "nElmts", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
    AsmVectorType.setDataPrototype(
        "SgAsmType*", "elmtType", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmVectorType);
#if defined(SgAsmVectorType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmType);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
        s & BOOST_SERIALIZATION_NVP(p_nElmts);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
        s & BOOST_SERIALIZATION_NVP(p_elmtType);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmVectorType.h"
public:
    /** Construct a new vector type. */
    SgAsmVectorType(size_t nElmts, SgAsmType *elmtType);

    /** Property: Number of elements in vector. */
    size_t get_nElmts() const;

    /** Property: Type of each vector element. */
    SgAsmType* get_elmtType() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
    virtual size_t get_nBits() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmVectorType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmVectorType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmVectorType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryUnsignedExtend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnaryUnsignedExtend);
IS_SERIALIZABLE(AsmUnaryUnsignedExtend);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryUnsignedExtend.h"
/** Expression representing unsigned extending.
 *
 *  The size of the result is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryUnsignedExtend.h"
class SgAsmUnaryUnsignedExtend: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryUnsignedExtend);
#if defined(SgAsmUnaryUnsignedExtend_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryUnsignedExtend();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryUnsignedExtend();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryUnsignedExtend(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryUnsignedExtend_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryTruncate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnaryTruncate);
IS_SERIALIZABLE(AsmUnaryTruncate);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryTruncate.h"
/** Expression representing truncation.
 *
 *  The amount of truncation is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryTruncate.h"
class SgAsmUnaryTruncate: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryTruncate);
#if defined(SgAsmUnaryTruncate_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryTruncate();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryTruncate();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryTruncate(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryTruncate_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnarySignedExtend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnarySignedExtend);
IS_SERIALIZABLE(AsmUnarySignedExtend);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnarySignedExtend.h"
/** Expression representing sign extending.
 *
 *  The size of the result is based on the sizes of the types for the operand and the result. There is no second argument
 *  that says how large the result should be since this would be redundant and possibly inconsistent with the type for the
 *  resulting expression. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnarySignedExtend.h"
class SgAsmUnarySignedExtend: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnarySignedExtend);
#if defined(SgAsmUnarySignedExtend_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnarySignedExtend();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnarySignedExtend();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnarySignedExtend(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnarySignedExtend_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryRrx           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnaryRrx);
IS_SERIALIZABLE(AsmUnaryRrx);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmUnaryRrx);
#if defined(SgAsmUnaryRrx_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryRrx.h"
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmUnaryRrx_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryRrx.h"
class SgAsmUnaryRrx: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryRrx);
#if defined(SgAsmUnaryRrx_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryRrx();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryRrx();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryRrx(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryRrx_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryPlus           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnaryPlus);
IS_SERIALIZABLE(AsmUnaryPlus);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryPlus.h"
/** Expression representing a (no-op) unary plus operation. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryPlus.h"
class SgAsmUnaryPlus: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryPlus);
#if defined(SgAsmUnaryPlus_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryPlus();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryPlus();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryPlus(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryPlus_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryMinus           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmUnaryMinus);
IS_SERIALIZABLE(AsmUnaryMinus);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryMinus.h"
/** Expression represting negation. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryMinus.h"
class SgAsmUnaryMinus: public SgAsmUnaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryMinus);
#if defined(SgAsmUnaryMinus_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmUnaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryMinus();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryMinus();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryMinus(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryMinus_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmUnaryExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmUnaryExpression = nonTerminalConstructor(
    "AsmUnaryExpression",
    *this,
    "AsmUnaryExpression",
    "AsmUnaryExpressionTag",
    SubclassListBuilder()
        | AsmUnaryMinus
        | AsmUnaryPlus
        | AsmUnaryRrx
        | AsmUnarySignedExtend
        | AsmUnaryTruncate
        | AsmUnaryUnsignedExtend
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmUnaryExpression.associatedGrammar != nullptr);
AsmUnaryExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmUnaryExpression.isBoostSerializable(true);
AsmUnaryExpression.setAutomaticGenerationOfConstructor(false);
AsmUnaryExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"
/** Base class for unary expressions. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"
class SgAsmUnaryExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"
    AsmUnaryExpression.setDataPrototype(
        "SgAsmExpression*", "operand", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmUnaryExpression);
#if defined(SgAsmUnaryExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_operand);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_operand() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_operand(SgAsmExpression* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmUnaryExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmUnaryExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmUnaryExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmUnaryExpression(SgAsmExpression* const& operand);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmUnaryExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedFieldDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmSynthesizedFieldDeclaration);
IS_SERIALIZABLE(AsmSynthesizedFieldDeclaration);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmSynthesizedFieldDeclaration);
#if defined(SgAsmSynthesizedFieldDeclaration_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
// FIXME[Robb P Matzke 2017-02-13]: what is this?
#endif // SgAsmSynthesizedFieldDeclaration_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
class SgAsmSynthesizedFieldDeclaration: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
    AsmSynthesizedFieldDeclaration.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
    AsmSynthesizedFieldDeclaration.setDataPrototype(
        "uint64_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmSynthesizedFieldDeclaration);
#if defined(SgAsmSynthesizedFieldDeclaration_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(std::string const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
    // FIXME[Robb P Matzke 2017-02-13]: Is this bytes, bits, or what?
    // Not clear if we want to store the offset explicitly
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset(uint64_t const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedFieldDeclaration.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedFieldDeclaration();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmSynthesizedFieldDeclaration();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmSynthesizedFieldDeclaration(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedFieldDeclaration_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedDataStructureDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmSynthesizedDataStructureDeclaration);
IS_SERIALIZABLE(AsmSynthesizedDataStructureDeclaration);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedDataStructureDeclaration.h"
/** Declaration-like nodes that encapsulate multiple instructions.
 *
 *  Binary ASTs have two sides: the container side that corresponds to the ELF/PE/etc. file formats, and the interpretation
 *  side that corresponds to instructions and data from multiple sources (specimen + dynamic libraries) organized into
 *  multiple SgAsmInterpretation where each interpretation makes a coherent binary entity such as the DOS part of a PE
 *  executable.  The declaration-like nodes that follow appear on the interpretation side of the AST.  We may add other
 *  declaration nodes to the container side of the AST at a later time.
 *
 *  These interpretation-side declaration-like nodes are used by the projects/BinaryDataStructureRecognition even if they
 *  aren't used internally by ROSE. */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedDataStructureDeclaration.h"
class SgAsmSynthesizedDataStructureDeclaration: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmSynthesizedDataStructureDeclaration);
#if defined(SgAsmSynthesizedDataStructureDeclaration_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedDataStructureDeclaration.h"
protected:
      SgAsmSynthesizedDeclarationPtrList p_declarationList;

public:
    /** Appends another declaration. */
    void append_declaration(SgAsmSynthesizedDeclaration *declaration) {
        p_declarationList.push_back(declaration);
    }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedDataStructureDeclaration();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmSynthesizedDataStructureDeclaration();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmSynthesizedDataStructureDeclaration(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedDataStructureDeclaration_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStringStorage           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmStringStorage);
IS_SERIALIZABLE(AsmStringStorage);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
/** Strings stored in an ELF or PE container. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
class SgAsmStringStorage: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    AsmStringStorage.setDataPrototype(
        "SgAsmGenericStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    AsmStringStorage.setDataPrototype(
        "std::string", "string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    AsmStringStorage.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmStringStorage);
#if defined(SgAsmStringStorage_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
        s & BOOST_SERIALIZATION_NVP(p_strtab);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
        s & BOOST_SERIALIZATION_NVP(p_string);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericStrtab* const& get_strtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strtab(SgAsmGenericStrtab* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_string() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_string(std::string const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset(rose_addr_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStringStorage.h"
public:
    SgAsmStringStorage(SgAsmGenericStrtab *strtab, const std::string &string, rose_addr_t offset);

    void dump(FILE *s, const char *prefix, ssize_t idx) const;

    /* Accessors. The set_* accessors are private because we don't want anyone messing with them. These data members are
     * used to control string allocation in ELF string tables and must only be modified by allocators in closely related
     * classes.  For instance, to change the value of the string one should call SgAsmGenericString::set_string()
     * instead. */

 private:
      friend class SgAsmStoredString;                     /*allowed to set private data members*/
      friend class SgAsmStoredStrtab;                     /*allowed to set private data members*/
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmStringStorage();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmStringStorage();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStringStorage_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStoredString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmStoredString);
IS_SERIALIZABLE(AsmStoredString);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
/** Strings stored in an ELF or PE container. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
class SgAsmStoredString: public SgAsmGenericString {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
    AsmStoredString.setDataPrototype(
        "SgAsmStringStorage*", "storage", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmStoredString);
#if defined(SgAsmStoredString_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericString);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
        s & BOOST_SERIALIZATION_NVP(p_storage);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmStringStorage* const& get_storage() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_storage(SgAsmStringStorage* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStoredString.h"
public:
    /** Construct a string existing in a string table. */
    SgAsmStoredString(SgAsmGenericStrtab*, rose_addr_t offset);

    /** Construct a new string in a string table. */
    SgAsmStoredString(SgAsmGenericStrtab*, const std::string&);

    /** Construct a string that shares storage with another. */
    explicit SgAsmStoredString(class SgAsmStringStorage*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Returns the string table that holds this string.
     *
     *  Returns the table even if the string value isn't currently allocated in the table. */
    SgAsmGenericStrtab *get_strtab();

    /** Returns the std::string associated with the SgAsmStoredString. */
    virtual std::string get_string(bool escape=false) const override;

    /** Give the string a new value.
     *
     *  This also deallocates the previous value. */
    virtual void set_string(const std::string&) override;

    /** Give the string a new value.
     *
     *  The string is given a new value by specifying the offset of a string that already exists in the string table. */
    virtual void set_string(rose_addr_t) override;

    /** Returns the offset into the string table where the string is allocated.
     *
     *  If the string is not allocated then this call triggers an allocation. */
    virtual rose_addr_t get_offset() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmStoredString();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmStoredString();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStoredString_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStaticData           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmStaticData);
IS_SERIALIZABLE(AsmStaticData);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
/** Represents static data in an executable.
 *
 *  For now, we don't associate any type with the data because ROSE's data type infrastructure (source or binary) is not
 *  capable of representing the information we need: multiple interpretations of overlapping parts of memory (i.e., two or
 *  more types for the same bytes); arbitrary offsets and padding in structured types; size-specific integers and
 *  floating-point types; regions of unknown type; ease of improving type information by filling in more details as the
 *  type is discovered; etc. */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
class SgAsmStaticData: public SgAsmStatement {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
    AsmStaticData.setDataPrototype(
        "SgUnsignedCharList", "raw_bytes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmStaticData);
#if defined(SgAsmStaticData_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
        s & BOOST_SERIALIZATION_NVP(p_raw_bytes);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_raw_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_raw_bytes(SgUnsignedCharList const&);
    /** @} */
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStaticData.h"
public:
    /** Property: Size of static data in bytes.
     *
     *  This returns the number of raw data bytes rather than the size of any data type painted onto those bytes. */
    size_t get_size() const { return p_raw_bytes.size(); }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmStaticData();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmStaticData();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmStaticData(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStaticData_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStackExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmStackExpression);
IS_SERIALIZABLE(AsmStackExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"
/** Base class for references to a machine register. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"
class SgAsmStackExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"
    AsmStackExpression.setDataPrototype(
        "int", "stack_position", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmStackExpression);
#if defined(SgAsmStackExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_stack_position);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_stack_position() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stack_position(int const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStackExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmStackExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmStackExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmStackExpression(int const& stack_position);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStackExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRiscOperation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmRiscOperation);
IS_SERIALIZABLE(AsmRiscOperation);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
/** Static representation of instruction semantics.
 *
 *  Instruction semantics are not added to the AST by default since this would make it very, very large.  Instead, ROSE has
 *  a non-traditional approach: instead of ROSE having C++ code to generate a data-centric representation of semantics (a
 *  tree like data structure similar to a syntax tree) and then users writing analyses on that data structure, ROSE's C++
 *  code can be hooked into directly by users via C++ class derivation. If a user really wants a data-centric view they can
 *  either have ROSE create @ref SgAsmRiscOperation nodes in the AST, or they can hook into ROSE's instruction semantics
 *  API and build whatever kind of data-centric representation that suites their need. */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
class SgAsmRiscOperation: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
    AsmRiscOperation.setDataPrototype(
        "SgAsmRiscOperation::RiscOperator", "riscOperator", "= OP_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
    AsmRiscOperation.setDataPrototype(
        "SgAsmExprListExp*", "operands", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmRiscOperation);
#if defined(SgAsmRiscOperation_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
        s & BOOST_SERIALIZATION_NVP(p_riscOperator);
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
        s & BOOST_SERIALIZATION_NVP(p_operands);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** One enum per RISC operator.
     *
     * The names are the same as the RISC operator.  Note that some of these operators aren't normally part of the base
     * set. For instance, "subtract" and comparison operations are usually implemented in terms of more basic operations
     * like add_, invert, and equalToZero. */
    enum RiscOperator {
        OP_NONE,
        OP_bottom,
        OP_undefined,
        OP_unspecified,
        OP_filterCallTarget,
        OP_filterReturnTarget,
        OP_filterIndirectJumpTarget,
        OP_hlt,
        OP_cpuid,
        OP_rdtsc,
        OP_and_,
        OP_or_,
        OP_xor_,
        OP_invert,
        OP_extract,
        OP_concat,
        OP_leastSignificantSetBit,
        OP_mostSignificantSetBit,
        OP_rotateLeft,
        OP_rotateRight,
        OP_shiftLeft,
        OP_shiftRight,
        OP_shiftRightArithmetic,
        OP_equalToZero,
        OP_ite,
        OP_isEqual,
        OP_isNotEqual,
        OP_isUnsignedLessThan,
        OP_isUnsignedLessThanOrEqual,
        OP_isUnsignedGreaterThan,
        OP_isUnsignedGreaterThanOrEqual,
        OP_isSignedLessThan,
        OP_isSignedLessThanOrEqual,
        OP_isSignedGreaterThan,
        OP_isSignedGreaterThanOrEqual,
        OP_unsignedExtend,
        OP_signExtend,
        OP_add,                                     /**< Two args + optional carry bit. */
        OP_addCarries,                              /**< Carries from a 3-arg add operation. */
        OP_subtract,
        OP_negate,
        OP_signedDivide,
        OP_signedModulo,
        OP_signedMultiply,
        OP_unsignedDivide,
        OP_unsignedModulo,
        OP_unsignedMultiply,
        OP_interrupt,
        OP_readRegister,
        OP_peekRegister,
        OP_writeRegister,
        OP_readMemory,                              /**< Three or four args depending on whether segment reg is present. */
        OP_peekMemory,
        OP_writeMemory,                             /**< Three or four args depending on whether segment reg is present. */
        OP_N_OPERATORS                              /**< Number of operators in this enum. */ // MUST BE LAST!
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // Note that the qualification for the type is necessary only for ROSETTA. Remove it when ROSETTA finally goes away.
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmRiscOperation::RiscOperator const& get_riscOperator() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_riscOperator(SgAsmRiscOperation::RiscOperator const&);
    /** @} */
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExprListExp* const& get_operands() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_operands(SgAsmExprListExp* const&);
    /** @} */
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRiscOperation.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmRiscOperation();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmRiscOperation();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmRiscOperation(SgAsmRiscOperation::RiscOperator const& riscOperator);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRiscOperation_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRegisterNames           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmRegisterNames);
IS_SERIALIZABLE(AsmRegisterNames);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
/** An ordered list of registers. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
class SgAsmRegisterNames: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
    AsmRegisterNames.setDataPrototype(
        "SgAsmRegisterReferenceExpressionPtrList", "registers", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
    AsmRegisterNames.setDataPrototype(
        "unsigned", "mask", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmRegisterNames);
#if defined(SgAsmRegisterNames_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
        s & BOOST_SERIALIZATION_NVP(p_registers);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
        s & BOOST_SERIALIZATION_NVP(p_mask);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmRegisterReferenceExpressionPtrList const& get_registers() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmRegisterReferenceExpressionPtrList& get_registers();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_registers(SgAsmRegisterReferenceExpressionPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_mask() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mask(unsigned const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterNames.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmRegisterNames();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmRegisterNames();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRegisterNames_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPowerpcInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPowerpcInstruction);
IS_SERIALIZABLE(AsmPowerpcInstruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmPowerpcInstruction);
#if defined(SgAsmPowerpcInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
#include <Rose/BinaryAnalysis/InstructionEnumsPowerpc.h>
#endif // SgAsmPowerpcInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
/** Represents one PowerPC machine instruction. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
class SgAsmPowerpcInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
    AsmPowerpcInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::PowerpcInstructionKind", "kind", "= Rose::BinaryAnalysis::powerpc_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPowerpcInstruction);
#if defined(SgAsmPowerpcInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
public:
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::PowerpcInstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::PowerpcInstructionKind const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPoerpcInstruction.h"
public:
    /** Description of conditional branch BO constant.
     *
     *  Given a BO constant from a PowerPC conditional branch instruction, convert it to a description of the condition
     *  that causes the branch to be taken. "BO" is the term used in the PowerPC documentation to denote the first argument
     *  of the conditional instruction; it is a 5-bit integer constant. */
    std::string conditionalBranchDescription() const;

    /** Return the register dictionary for a PowerPC architecture.
     *
     *  Given an instruction size of 32 or 64 return the register dictionary that describes the PowerPC architecture with
     *  the specified word size. */
    static Rose::BinaryAnalysis::RegisterDictionaryPtr registersForWidth(size_t);

    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *retva) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *retva) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPowerpcInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPowerpcInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmPowerpcInstruction(rose_addr_t const& address,
                            std::string const& mnemonic,
                            Rose::BinaryAnalysis::PowerpcInstructionKind const& kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPowerpcInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEStringSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEStringSection);
IS_SERIALIZABLE(AsmPEStringSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
/** String section. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
class SgAsmPEStringSection: public SgAsmPESection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
    AsmPEStringSection.setDataPrototype(
        "SgAsmCoffStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEStringSection);
#if defined(SgAsmPEStringSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
        s & BOOST_SERIALIZATION_NVP(p_strtab);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCoffStrtab* const& get_strtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strtab(SgAsmCoffStrtab* const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEStringSection.h"
public:
    SgAsmPEStringSection(SgAsmPEFileHeader*);
    virtual SgAsmPEStringSection* parse() override;
    virtual bool reallocate() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    virtual void set_size(rose_addr_t newsize) override;
    virtual void unparse(std::ostream&) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEStringSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEStringSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEStringSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPESectionTable);
IS_SERIALIZABLE(AsmPESectionTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTable.h"
/** Section table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTable.h"
class SgAsmPESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPESectionTable);
#if defined(SgAsmPESectionTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTable.h"
public:
    explicit SgAsmPESectionTable(SgAsmPEFileHeader*);
    virtual SgAsmPESectionTable* parse() override;

    /** Attaches a previously unattached PE Section to the PE Section Table.
     *
     *  This method complements SgAsmPESection::init_from_section_table. This method initializes the section table from the
     *  section while init_from_section_table() initializes the section from the section table. */
    void add_section(SgAsmPESection *section);
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPESectionTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPESectionTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESectionTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPESectionTableEntry);
IS_SERIALIZABLE(AsmPESectionTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
/** Section table entry. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
class SgAsmPESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "virtual_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physical_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 98 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physical_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "coff_line_nums", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "n_relocs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "n_coff_line_nums", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    AsmPESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPESectionTableEntry);
#if defined(SgAsmPESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_virtual_size);
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_rva);
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_physical_size);
#line 98 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_physical_offset);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_coff_line_nums);
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_n_relocs);
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_n_coff_line_nums);
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. All fields are little endian. Sections are ordered by RVA. */
    struct PESectionTableEntry_disk {
        char     name[8];          /* NUL-padded */
        uint32_t virtual_size;     /* virtual memory size, >= physical_size and difference is zero filled */
        uint32_t rva;              /* relative virt addr wrt Image Base; multiple of section_align; dense space */
        uint32_t physical_size;    /* bytes of initialized data on disk; multiple of file_align & <= virtual_size*/
        uint32_t physical_offset;  /* location of initialized data on disk; multiple of file_align */
        uint32_t coff_line_nums;   /* file offset of COFF line number info or zero */
        uint32_t n_relocs;         /* number of relocation entries; should be zero for executables */
        uint32_t n_coff_line_nums; /* number of COFF line number entries */
        uint32_t flags;            /* PESectionFlags bits: code, data, caching, paging, shared, permissions, etc.*/
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* These come from the windows PE documentation and
     * http://en.wikibooks.org/wiki/X86_Disassembly/Windows_Executable_Files */
    enum PESectionFlags {
        OF_CODE             = 0x00000020,   /* section contains code */
        OF_IDATA            = 0x00000040,   /* initialized data */
        OF_UDATA            = 0x00000080,   /* uninitialized data */
        OF_INFO             = 0x00000200,   /* comments or some other type of info */
        OF_REMOVE           = 0x00000800,   /* section will not become part of image */
        OF_COMDAT           = 0x00001000,   /* section contains comdat */
        OF_NO_DEFER_SPEC_EXC= 0x00004000,   /* reset speculative exception handling bits in the TLB entires for
                                             * this section */
        OF_GPREL            = 0x00008000,   /* section content can be access relative to GP */
        OF_ALIGN_1          = 0x00100000,   /* no alignment */
        OF_ALIGN_2          = 0x00200000,   /* 2-byte alignment */
        OF_ALIGN_4          = 0x00300000,   /* 4-byte alignment */
        OF_ALIGN_8          = 0x00400000,   /* 8-byte alignment */
        OF_ALIGN_16         = 0x00500000,   /* 16-byte alignment (default if not other alignment specified) */
        OF_ALIGN_32         = 0x00600000,   /* 32-byte alignment */
        OF_ALIGN_64         = 0x00700000,   /* 64-byte alignment */
        OF_ALIGN_128        = 0x00800000,   /* 128-byte alignment */
        OF_ALIGN_256        = 0x00900000,   /* 256-byte alignment */
        OF_ALIGN_512        = 0x00a00000,   /* 512-byte alignment */
        OF_ALIGN_1k         = 0x00b00000,   /* 1024-byte alignment */
        OF_ALIGN_2k         = 0x00c00000,   /* 2048-byte alignment */
        OF_ALIGN_4k         = 0x00d00000,   /* 4096-byte alignment */
        OF_ALIGN_8k         = 0x00e00000,   /* 8192-byte alignment */
        OF_ALIGN_MASK       = 0x00f00000,   /* mask for alignment value */
        OF_NRELOC_OVFL      = 0x01000000,   /* section contains extended relocations */
        OF_DISCARDABLE      = 0x02000000,   /* can be discarded */
        OF_NO_CACHE         = 0x04000000,   /* section must not be cached */
        OF_NO_PAGING        = 0x08000000,   /* section is not pageable */
        OF_SHARED           = 0x10000000,   /* section is shared */
        OF_EXECUTABLE       = 0x20000000,   /* execute permission */
        OF_READABLE         = 0x40000000,   /* read permission */
        OF_WRITABLE         = 0x80000000    /* write permission */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(std::string const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_virtual_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_virtual_size(rose_addr_t const&);
    /** @} */
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_rva() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_rva(rose_addr_t const&);
    /** @} */
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_physical_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_physical_size(rose_addr_t const&);
    /** @} */
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_physical_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_physical_offset(rose_addr_t const&);
    /** @} */
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_coff_line_nums() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_coff_line_nums(unsigned const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_n_relocs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_n_relocs(unsigned const&);
    /** @} */
#line 111 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_n_coff_line_nums() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_n_coff_line_nums(unsigned const&);
    /** @} */
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPESectionTableEntry(const SgAsmPESectionTableEntry::PESectionTableEntry_disk *disk);

    /** Update this section table entry with newer information from the section */
    void update_from_section(SgAsmPESection *section);
    void *encode(SgAsmPESectionTableEntry::PESectionTableEntry_disk*) const;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPESectionTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPESectionTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESectionTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPERVASizePairList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPERVASizePairList);
IS_SERIALIZABLE(AsmPERVASizePairList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
/** List of SgAsmPERVASizePair AST nodes.
 *
 *  The only reason this AST node exists rather than storing the list directly in the nodes that need it is due to ROSETTA
 *  limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
class SgAsmPERVASizePairList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
    AsmPERVASizePairList.setDataPrototype(
        "SgAsmPERVASizePairPtrList", "pairs", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPERVASizePairList);
#if defined(SgAsmPERVASizePairList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
        s & BOOST_SERIALIZATION_NVP(p_pairs);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPERVASizePairPtrList const& get_pairs() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmPERVASizePairPtrList& get_pairs();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_pairs(SgAsmPERVASizePairPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePairList.h"
public:
    explicit SgAsmPERVASizePairList(SgAsmPEFileHeader *parent);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPERVASizePairList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPERVASizePairList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPERVASizePairList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPERVASizePair           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPERVASizePair);
IS_SERIALIZABLE(AsmPERVASizePair);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
/** RVA/size pair. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
class SgAsmPERVASizePair: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    AsmPERVASizePair.setDataPrototype(
        "rose_rva_t", "e_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    AsmPERVASizePair.setDataPrototype(
        "rose_addr_t", "e_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    AsmPERVASizePair.setDataPrototype(
        "SgAsmGenericSection*", "section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPERVASizePair);
#if defined(SgAsmPERVASizePair_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
        s & BOOST_SERIALIZATION_NVP(p_e_rva);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
        s & BOOST_SERIALIZATION_NVP(p_e_size);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
        s & BOOST_SERIALIZATION_NVP(p_section);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** File format for an RVA/Size pair.
     *
     *  Such pairs are considered to be part of the PE file header.  All fields are little endian. */
    struct RVASizePair_disk {
        uint32_t    e_rva;
        uint32_t    e_size;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_e_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_e_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_rva(rose_rva_t const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_size(rose_addr_t const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPERVASizePair.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, const SgAsmPERVASizePair::RVASizePair_disk*);
    SgAsmPERVASizePair(SgAsmPERVASizePairList *parent, rose_addr_t rva, rose_addr_t size);

    /** Sets or removes the section associated with an RVA/size pair.
     *
     *  Setting or removing the section also updates the RVA and size according to the preferred mapping address and mapped
     *  size of the section. */
    void set_section(SgAsmGenericSection *section);

    /** Returns the section associated with an RVA/size pair.
     *
     *  This is the same as the ROSETTA-generated accessor, but we need a custom version of set_section(). */
    SgAsmGenericSection *get_section() const;

    void *encode(SgAsmPERVASizePair::RVASizePair_disk *disk) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPERVASizePair();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPERVASizePair();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPERVASizePair_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEImportSection);
IS_SERIALIZABLE(AsmPEImportSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
/** Portable Executable Import Section.
 *
 *  Constructs an SgAsmPEImportSection that represents either a PE ".idata" section as defined by the PE Section Table, or
 *  a PE Import Table as described by the RVA/Size pairs at the end of the NT Optional Header. The ".idata" section and PE
 *  Import Table both have the same format (only important fields shown):
 *
 *  @par Import Section
 *  An Import Section consists of a list of Import Directory Entries ("Directories"), one per dynamically linked library,
 *  followed by an all-zero Directory entry that marks the end of the list.  ROSE does not explicitly store the terminating
 *  entry, and wherever "Directories" appears in the following description it does not include this null directory.
 *
 *  @par Import Directory
 *  Each directory points to (by relative virtual address (RVA)) both an Import Lookup Table (ILT) and Import Address Table
 *  (IAT).
 *
 *  @par Import Lookup Table (and Import Address Table)
 *  The Import Lookup Table (ILT) and Import Address Table (IAT) have identical structure.  ROSE represents them as a list
 *  of SgAsmPEImportItem in the Import Directory.  The ILT and IAT are parallel arrays of 32- or 64-bit (PE32 or PE32+)
 *  entries terminated with an all-zero entry.  The terminating entry is not stored explicitly by ROSE.  The entries are
 *  identical for both ILTs and IATs.
 *
 *  @par Import Lookup Table Entry (and Import Address Table Entry)
 *  Entries for ILTs and IATs are structurally identical.  They are 32- or 64-bit vectors.  The most significant bit
 *  (31/63) indicates whether the remaining bits are an Ordinal (when set) or Hint/Name address (when clear).  Ordinals are
 *  represented by the low-order 16 bits and Hint/Name addresses are stored in the low-order 31 bits.  All other bits must
 *  be zero according to the PE specification.  Hint/Name addresses are relative virtual addresses of entries in the
 *  (implicit) Hint/Name Table. When a function is bound by the dynamic linkter, its IAT Entry within process memory is
 *  overwritten with the virtual address of the bound function.
 *
 *  @par Hint/Name Table
 *  Some Import Lookup Table (and Import Address Table) entries contain a Hint/Name Table Entry RVA.  The Hint/Name Table
 *  Entries collectively form the Hint/Name Table, but there is no requirement that the entries appear in any particular
 *  order or even that they appear contiguously in memory.  In other words, the Hint/Name Table is a conceptual object
 *  rather than a true table in the PE file.
 *
 *
 * @verbatim
    +------------ Import Section -------------+                         (SgAsmPEImportSection)
    |                                         |
    |                                         |
    |  +------- Import Directory #0 ------+   |                         (SgAsmPEImportDirectory)
    |  |   1. Import Lookup Table RVA     |   |
    |  |   2. Date/time stamp             |   |
    |  |   3. Forwarder chain index       |   |
    |  |   4. Name RVA                    |   |
    |  |   5. Import Address Table RVA    |   |
    |  +----------------------------------+   |
    |                                         |
    |                                         |
    |  +------- Import Directory #1 ------+   |
    |  |   1. Import Lookup Table RVA     |--------+
    |  |   2. Date/time stamp             |   |    |
    |  |   3. Forwarder chain index       |   |    |
    |  |   4. Name RVA                    |   |    |
    |  |   5. Import Address Table RVA    |------- | -------+
    |  +----------------------------------+   |    |        |
    |                                         |    |        |
    |         . . .                           |    |        |
    |                                         |    |        |
    |  +------- Import Directory #N ------+   |    |        |
    |  |                                  |   |    |        |
    |  |   Terminating directory is       |   |    |        |
    |  |   zero filled.                   |   |    |        |
    |  |                                  |   |    |        |
    |  |                                  |   |    |        |
    |  +----------------------------------+   |    |        |
    |                                         |    |        |
    +-----------------------------------------+    |        |           (Entries of the ILT and IAT are combined into
                                                   |        |            SgAsmPEImportItem objects.)
                                                   |        |
                                                   |        |
    +----------- Import Lookup Table ---------+ <--+        +-->  +----------- Import Address Table --------+
    | #0  32/64-bit vector                    |                   | #0  32/64-bit vector or VA when bound   |
    |                                         |   These arrays    |                                         |
    | #1  32/64-bit vector                    |   are parallel    | #1  32/64-bit vector or VA when bound   |
    |                      \                  |                   |                                         |
    |     ...               \when used as     |                   |     ...                                 |
    |                        \a Hint/Name     |                   |                                         |
    | #N  32/64-bit zero      \RVA            |                   | #N  32/64-bit zero                      |
    +--------------------------\--------------+                   +-----------------------------------------+
                                \
                                 \
                                  |
    + - - - - -  Hint/Name Table  | - - - - - +           The Hint/Name Table doesn't actually
                                  v                       exist explicitly--there is no pointer
    |  +------ Hint/Name ----------------+    |           to the beginning of the table and no
       |  1. 2-byte index ENPT           |                requirement that the entries be in any
    |  |  2. NUL-terminated name         |    |           particular order, or even contiguous.
       |  3. Optional extran NUL         |
    |  +---------------------------------+    |           "ENPT" means Export Name Pointer Table,
                                                          which is a table in the linked-to
    |          . . .                          |           shared library.

    |  +------ Hint/Name ----------------+    |
       |  1. 2-byte index ENPT           |                              (SgAsmPEImportHNTEntry)
    |  |  2. NUL-terminated name         |    |
       |  3. Optional extran NUL         |
    |  +---------------------------------+    |

    + - - - - - - - - - - - - - - - - - - - - +
@endverbatim
 *
 * When parsing an Import Directory, ROSE assumes that the IAT contains ordinals and/or hint/name addresses rather than
 * bound addresses.  ROSE checks that the IAT entries are compatible with the ILT entries there were already parsed and if
 * an inconsistency is detected then a warning is issued and ROSE assumes that the IAT entry is a bound value instead.
 * Passing true as the @p assume_bound argument for the parser will cause ROSE to not issue such warnings and immediately
 * assume that all IAT entries are bound addresses.  One can therefore find the conflicting entries by looking for
 * SgAsmImportItem objects that are created with a non-zero bound address.
 *
 * The IAT is often required to be allocated at a fixed address, often the beginning of the ".rdata" section.  Increasing
 * the size of the IAT by adding more items to the import list(s) can be problematic because ROSE is unable to safely write
 * beyond the end of the original IAT.  We require the user to manually allocate space for the new IAT and tell the
 * SgAsmPEImportDirectory object the location and size of the allocated space before unparsing.  On a related note, due to
 * ROSE allocators being section-local, reallocation of an Import Section does not cause reallocation of ILTs, Hint/Name
 * pairs, or DLL names that have addresses outside the Import Section.  If these items' sizes increase, the items will be
 * truncated when written back to disk.  The reallocation happens automatically for all import-related objects that are
 * either bound to the import section or have a null RVA, so one method of getting things reallocated is to traverse the
 * AST and null their RVAs:
 *
 * @code
 *  struct Traversal: public AstSimpleTraversal {
 *      void visit(SgNode *node) {
 *          SgAsmPEImportDirectory *idir = isSgAsmPEImportDirectory(node);
 *          SgAsmPEImportItem *import = isSgAsmPEImportItem(node);
 *          static const rose_rva_t nil(0);
 *
 *          if (idir) {
 *              idir->set_dll_name_rva(nil);
 *              idir->set_ilt_rva(nil);
 *              idir->set_iat_rva(nil);
 *          }
 *
 *          if (import)
 *              idir->set_hintname_rva(nil);
 *     }
 *  };
 * @endcode
 *
 * @sa
 *      SgAsmPEImportDirectory
 *      SgAsmPEImportItem
 */
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
class SgAsmPEImportSection: public SgAsmPESection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
    AsmPEImportSection.setDataPrototype(
        "SgAsmPEImportDirectoryList*", "import_directories", "= createAndParent<SgAsmPEImportDirectoryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEImportSection);
#if defined(SgAsmPEImportSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
        s & BOOST_SERIALIZATION_NVP(p_import_directories);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportDirectoryList* const& get_import_directories() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_import_directories(SgAsmPEImportDirectoryList* const&);
    /** @} */
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportSection.h"
public:
    explicit SgAsmPEImportSection(SgAsmPEFileHeader*);
    virtual SgAsmPEImportSection *parse() override;
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Add an import directory to the end of the import directory list. */
    void add_import_directory(SgAsmPEImportDirectory*);

    /** Remove an import directory from the import directory list. Does not delete it. */
    void remove_import_directory(SgAsmPEImportDirectory*);
    static bool show_import_mesg();
    static void import_mesg_reset() { mesg_nprinted=0; }

    /** Reallocate space for all Import Address Table.
     *
     *  This method traverses the AST beginning at this PE Import Section and assigns addresses and sizes to all Import
     *  Address Tables (IATs).  The first IAT is given the @p start_at RVA and its size is reset to what ever size is
     *  needed to store the entire table.  Each subsequent IAT is given the next available address and it's size is also
     *  updated.  The result is that all the IATs under this Import Section are given addresses and sizes that make them
     *  contiguous in memory. This method returns the total number of bytes required for all the IATs. */
    size_t reallocate_iats(rose_rva_t start_at);

private:
    static size_t mesg_nprinted; //counter for import_mesg()
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEImportSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEImportSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportItemList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEImportItemList);
IS_SERIALIZABLE(AsmPEImportItemList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"
/** A list of imported items.
 *
 *  The only purpose of this node is to hold a list of pointers to other nodes. This list cannot be contained directly in the nodes
 *  that need it due to ROSETTA limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"
class SgAsmPEImportItemList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"
    AsmPEImportItemList.setDataPrototype(
        "SgAsmPEImportItemPtrList", "vector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEImportItemList);
#if defined(SgAsmPEImportItemList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"
        s & BOOST_SERIALIZATION_NVP(p_vector);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportItemPtrList const& get_vector() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportItemPtrList& get_vector();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vector(SgAsmPEImportItemPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItemList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEImportItemList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEImportItemList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportItemList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportItem           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEImportItem);
IS_SERIALIZABLE(AsmPEImportItem);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
/** A single imported object.
 *
 *  Each of these nodes is created from a combination of the PE Import Lookup Table and the PE Import Address Table, pointers to
 *  which are stored in the Import Directory (@ref SgAsmPEImportDirectory). This node represents a single import object described by
 *  data structures referenced by a PE Import Directory.  Such a node represents data from two, possibly three, distinct data
 *  structures in the PE file: (1) An entry in the Import Lookup Table, (2) an entry in the Import Address Table, and (3) an
 *  optional Hint/Name pair in the (implicit) Hint/Name Table. */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
class SgAsmPEImportItem: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "bool", "by_ordinal", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "unsigned", "ordinal", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "unsigned", "hint", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "rose_rva_t", "hintname_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "size_t", "hintname_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "rose_rva_t", "bound_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    AsmPEImportItem.setDataPrototype(
        "bool", "iat_written", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEImportItem);
#if defined(SgAsmPEImportItem_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_by_ordinal);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_ordinal);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_hint);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_hintname_rva);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_hintname_nalloc);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_bound_rva);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
        s & BOOST_SERIALIZATION_NVP(p_iat_written);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_by_ordinal() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_by_ordinal(bool const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_ordinal() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ordinal(unsigned const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_hint() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hint(unsigned const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(SgAsmGenericString* const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_hintname_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_hintname_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hintname_rva(rose_rva_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_hintname_nalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hintname_nalloc(size_t const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_bound_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_bound_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bound_rva(rose_rva_t const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_iat_written() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iat_written(bool const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportItem.h"
public:
    explicit SgAsmPEImportItem(SgAsmPEImportItemList *parent);
    explicit SgAsmPEImportItem(SgAsmPEImportDirectory*);
    SgAsmPEImportItem(SgAsmPEImportDirectory*, const std::string &name, unsigned hint=0);
    SgAsmPEImportItem(SgAsmPEImportDirectory*, const unsigned ordinal);

    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Bytes needed to store hint/name pair.
     *
     *  A hint/name pair consists of a two-byte, little endian, unsigned hint and a NUL-terminated ASCII string.  An
     *  optional zero byte padding appears after the string's NUL terminator if necessary to make the total size of the
     *  hint/name pair a multiple of two. */
    size_t hintname_required_size() const;

    /** Virtual address of an IAT entry.
     *
     *  Returns the virtual address of the IAT slot for this import item.  This import item must be linked into the AST in
     *  order for this method to succeed. */
    rose_addr_t get_iat_entry_va() const;

private:
    void initFromParent(SgAsmPEImportItemList *parent);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEImportItem();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEImportItem();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportItem_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportDirectoryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEImportDirectoryList);
IS_SERIALIZABLE(AsmPEImportDirectoryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"
/** A list of PE Import Directories.
 *
 *  The only purpose of this class is to store a list of node pointers which cannot be stored in the nodes that need it due to
 *  ROSETTA limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"
class SgAsmPEImportDirectoryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"
    AsmPEImportDirectoryList.setDataPrototype(
        "SgAsmPEImportDirectoryPtrList", "vector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEImportDirectoryList);
#if defined(SgAsmPEImportDirectoryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"
        s & BOOST_SERIALIZATION_NVP(p_vector);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportDirectoryPtrList const& get_vector() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportDirectoryPtrList& get_vector();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vector(SgAsmPEImportDirectoryPtrList const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectoryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEImportDirectoryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEImportDirectoryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportDirectoryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEImportDirectory           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEImportDirectory);
IS_SERIALIZABLE(AsmPEImportDirectory);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
/** One import directory per library.
 *
 *  The import directory points to the Import Lookup Table and Import Address Table. ROSE no longer represents the ILT and IAT with
 *  separate IR nodes. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
class SgAsmPEImportDirectory: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "SgAsmGenericString*", "dll_name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "rose_rva_t", "dll_name_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "dll_name_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "time_t", "time", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "unsigned", "forwarder_chain", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "rose_rva_t", "ilt_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "ilt_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "rose_rva_t", "iat_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "size_t", "iat_nalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    AsmPEImportDirectory.setDataPrototype(
        "SgAsmPEImportItemList*", "imports", "= createAndParent<SgAsmPEImportItemList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEImportDirectory);
#if defined(SgAsmPEImportDirectory_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_dll_name);
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_dll_name_rva);
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_dll_name_nalloc);
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_time);
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_forwarder_chain);
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_ilt_rva);
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_ilt_nalloc);
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_iat_rva);
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_iat_nalloc);
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_imports);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct PEImportDirectory_disk {
        uint32_t ilt_rva;               /* 0x00 Import Lookup Table RVA */
        uint32_t time;                  /* 0x04 Zero until the image is bound, then time stamp of the DLL */
        uint32_t forwarder_chain;       /* 0x08 Index of the first forwarder chain */
        uint32_t dll_name_rva;          /* 0x0c address of NUL-terminated DLL name */
        uint32_t iat_rva;               /* 0x10 Import Address Table (Thunk Table) RVA */
    }                                       /* 0x14 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_dll_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dll_name(SgAsmGenericString* const&);
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_dll_name_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_dll_name_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dll_name_rva(rose_rva_t const&);
    /** @} */
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_dll_name_nalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dll_name_nalloc(size_t const&);
    /** @} */
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    time_t const& get_time() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_time(time_t const&);
    /** @} */
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_forwarder_chain() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_forwarder_chain(unsigned const&);
    /** @} */
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_ilt_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_ilt_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ilt_rva(rose_rva_t const&);
    /** @} */
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_ilt_nalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ilt_nalloc(size_t const&);
    /** @} */
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_iat_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_iat_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iat_rva(rose_rva_t const&);
    /** @} */
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_iat_nalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iat_nalloc(size_t const&);
    /** @} */
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEImportItemList* const& get_imports() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_imports(SgAsmPEImportItemList* const&);
    /** @} */
#line 90 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEImportDirectory.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEImportDirectory(SgAsmPEImportSection *isec, const std::string &dll_name="");

    /** Parse an import directory.
     *
     *  The import directory is parsed from the specified virtual address via the PE header's loader map. Return value is
     *  this directory entry on success, or the null pointer if the entry is all zero (which marks the end of the directory
     *  list). The @p isLastEntry is true if the caller thinks this should be an all-zero entry. */
    SgAsmPEImportDirectory *parse(rose_addr_t va, bool isLastEntry);

    /** Allocates space for this import directory's name, import lookup table, and import address table.
     *
     *  The items are allocated beginning at the specified relative virtual address. Items are reallocated if they are not
     *  allocated or if they are allocated in the same section to which start_rva points (the import section).  They are
     *  not reallocated if they already exist in some other section. The return value is the number of bytes allocated in
     *  the import section.  Upon return, this directory's address data members are initialized with possibly new
     *  values. */
    size_t reallocate(rose_rva_t starting_rva);

    /** Encode an import directory entry back into disk format */
    void *encode(SgAsmPEImportDirectory::PEImportDirectory_disk*) const;
    virtual void unparse(std::ostream&, const SgAsmPEImportSection*, size_t idx) const;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Number of bytes required for the table.
     *
     *  Returns the number of bytes required for the entire IAT or ILT (including the zero terminator) as it is currently
     *  defined in the Import Directory.  The returned size does not include space required to store any Hint/Name pairs,
     *  which are outside the ILT/IAT but pointed to by the ILT/IAT. */
    size_t iat_required_size() const;

    /** Find an import item in an import directory.
     *
     *  Returns the index of the specified import item in this directory, or -1 if the import item is not a child of this
     *  directory.  The hint index is checked first. */
    int find_import_item(const SgAsmPEImportItem *item, int hint=0) const;

    /** Obtains the virtual address of the Hint/Name Table.
     *
     *  The Hint/Name Table is an implicit table--the PE file format specification talks about such a table, but it is not
     *  actually defined anywhere in the PE file.  Instead, various Import Lookup Table and Import Address Table entries
     *  might point to individual Hint/Name pairs, which collectively form an implicit Hint/Name Table.  There is no
     *  requirement that the Hint/Name pairs are contiguous in the address space, and indeed they often are not.
     *  Therefore, the only way to describe the location of the Hint/Name Table is by a list of addresses.
     *
     *  This function will scan this Import Directory's import items, observe which items make references to Hint/Name
     *  pairs that have known addresses, and add those areas of virtual memory to the specified extent map.  This function
     *  returns the number of ILT entries that reference a Hint/Name pair. */
    size_t hintname_table_extent(AddressIntervalSet &extent/*in,out*/) const;

private:
    void parse_ilt_iat(const rose_rva_t &table_start, bool assume_bound);
    void unparse_ilt_iat(std::ostream&,const rose_rva_t &table_start, bool assume_bound, size_t nalloc) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEImportDirectory();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEImportDirectory();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEImportDirectory_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEFileHeader);
IS_SERIALIZABLE(AsmPEFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
/** Windows PE file header.
 *
 *  Most of the properties come directly from the PE specification and their documentation is not repeated here. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
class SgAsmPEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_cpu_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_nsections", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_time", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "rose_addr_t", "e_coff_symtab", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nt_hdr_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 190 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_coff_nsyms", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 196 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 202 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_opt_magic", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 208 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_lmajor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 214 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_lminor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 220 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_code_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 226 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_data_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 232 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_bss_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 238 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "rose_rva_t", "e_code_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 244 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "rose_rva_t", "e_data_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 250 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_section_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 256 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_file_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 262 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_os_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 268 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_os_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 274 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_user_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 280 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_user_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 286 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsys_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 292 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsys_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 298 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_reserved9", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 304 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_image_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 310 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_header_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 316 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_file_checksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 322 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_subsystem", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 328 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_dll_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 334 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_stack_reserve_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 340 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_stack_commit_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 346 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_heap_reserve_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 352 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_heap_commit_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 358 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_loader_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 364 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "unsigned", "e_num_rvasize_pairs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 370 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "SgAsmPERVASizePairList*", "rvasize_pairs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 376 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "SgAsmPESectionTable*", "section_table", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 382 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    AsmPEFileHeader.setDataPrototype(
        "SgAsmCoffSymbolTable*", "coff_symtab", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEFileHeader);
#if defined(SgAsmPEFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_cpu_type);
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nsections);
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_time);
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_coff_symtab);
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nt_hdr_size);
#line 190 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_coff_nsyms);
#line 196 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
#line 202 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_opt_magic);
#line 208 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_lmajor);
#line 214 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_lminor);
#line 220 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_code_size);
#line 226 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_data_size);
#line 232 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_bss_size);
#line 238 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_code_rva);
#line 244 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_data_rva);
#line 250 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_section_align);
#line 256 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_file_align);
#line 262 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_os_major);
#line 268 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_os_minor);
#line 274 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_user_major);
#line 280 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_user_minor);
#line 286 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_subsys_major);
#line 292 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_subsys_minor);
#line 298 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_reserved9);
#line 304 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_image_size);
#line 310 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_header_size);
#line 316 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_file_checksum);
#line 322 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_subsystem);
#line 328 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_dll_flags);
#line 334 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_stack_reserve_size);
#line 340 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_stack_commit_size);
#line 346 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_heap_reserve_size);
#line 352 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_heap_commit_size);
#line 358 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_loader_flags);
#line 364 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_num_rvasize_pairs);
#line 370 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_rvasize_pairs);
#line 376 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_section_table);
#line 382 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_coff_symtab);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a PE File Header. All fields are little endian. */
    struct PEFileHeader_disk {
        unsigned char e_magic[4];       /* 0x00 magic number "PE\0\0" */
        uint16_t    e_cpu_type;         /* 0x04 e.g., 0x014c = Intel 386 */
        uint16_t    e_nsections;        /* 0x06 number of sections defined in the Section Table */
        uint32_t    e_time;             /* 0x08 time and date file was created or modified by the linker */
        uint32_t    e_coff_symtab;      /* 0x0c offset to COFF symbol table */
        uint32_t    e_coff_nsyms;       /* 0x10 number of symbols in COFF symbol table */
        uint16_t    e_nt_hdr_size;      /* 0x14 num remaining bytes in the header following the 'flags' field */
        uint16_t    e_flags;            /* 0x16 Bit flags: exe file, program/library image, fixed address, etc. */
    }                                       /* 0x18 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct PE32OptHeader_disk {
        uint16_t    e_opt_magic;        /* 0x18 magic number */
        uint16_t    e_lmajor;           /* 0x1a linker version */
        uint16_t    e_lminor;           /* 0x1c */
        uint16_t    e_code_size;        /* 0x1e Size of .text or sum of all code sections */
        uint32_t    e_data_size;        /* 0x20 Sum size of initialized data */
        uint32_t    e_bss_size;         /* 0x24 Sum size of uninitialized data */
        uint32_t    e_entrypoint_rva;   /* 0x28 RVA="relative virtual address"; relative to 'image_base', below */
        uint32_t    e_code_rva;         /* 0x2c Addr relative to image base for code section when memory mapped */
        uint32_t    e_data_rva;         /* 0x30 Address relative to image base for data section */
        uint32_t    e_image_base;       /* 0x34 Virt base of image (first byte of file, DOS header). 64k aligned */
        uint32_t    e_section_align;    /* 0x38 Alignment of sections in memory. Power of two 512<=x<=256M */
        uint32_t    e_file_align;       /* 0x3c Alignment factor (in bytes) for image pages */
        uint16_t    e_os_major;         /* 0x40 OS version number required to run this image */
        uint16_t    e_os_minor;         /* 0x42 */
        uint16_t    e_user_major;       /* 0x44 User-specified for differentiating between image revs */
        uint16_t    e_user_minor;       /* 0x46 */
        uint16_t    e_subsys_major;     /* 0x48 Subsystem version number */
        uint16_t    e_subsys_minor;     /* 0x4a */
        uint32_t    e_reserved9;        /* 0x4c */
        uint32_t    e_image_size;       /* 0x50 Virtual size of the image inc. all headers; section_align */
        uint32_t    e_header_size;      /* 0x54 Total header size (DOS Header + PE Header + Section table */
        uint32_t    e_file_checksum;    /* 0x58 Checksum for entire file; Set to zero by the linker */
        uint16_t    e_subsystem;        /* 0x5c Native, WindowsGUI, WindowsCharacter, OS/2 Character, etc. */
        uint16_t    e_dll_flags;        /* 0x5e Bit flags for library init/terminate per process or thread */
        uint32_t    e_stack_reserve_size;/*0x60 Virtual mem reserved for stack; non-committed pages are guards */
        uint32_t    e_stack_commit_size;/* 0x64 Size of valid stack; other pages are guards; <=stack_reserve_size*/
        uint32_t    e_heap_reserve_size;/* 0x68 Size (bytes) of local heap to reserve */
        uint32_t    e_heap_commit_size; /* 0x6c Size (bytes) of valid local heap */
        uint32_t    e_loader_flags;     /* 0x70 Reserved, must be zero */
        uint32_t    e_num_rvasize_pairs;/* 0x74 Num RVASizePair entries that follow this member; part of header */
    }                                       /* 0x78 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct PE64OptHeader_disk {
        uint16_t    e_opt_magic;        /* 0x18 */
        uint16_t    e_lmajor;           /* 0x1a */
        uint16_t    e_lminor;           /* 0x1c */
        uint16_t    e_code_size;        /* 0x1e */
        uint32_t    e_data_size;        /* 0x20 */
        uint32_t    e_bss_size;         /* 0x24 */
        uint32_t    e_entrypoint_rva;   /* 0x28 */
        uint32_t    e_code_rva;         /* 0x2c */
        // uint32_t  e_data_rva;             /* Not present in PE32+ */
        uint64_t    e_image_base;       /* 0x30 */
        uint32_t    e_section_align;    /* 0x38 */
        uint32_t    e_file_align;       /* 0x3c */
        uint16_t    e_os_major;         /* 0x40 */
        uint16_t    e_os_minor;         /* 0x42 */
        uint16_t    e_user_major;       /* 0x44 */
        uint16_t    e_user_minor;       /* 0x46 */
        uint16_t    e_subsys_major;     /* 0x48 */
        uint16_t    e_subsys_minor;     /* 0x4a */
        uint32_t    e_reserved9;        /* 0x4c */
        uint32_t    e_image_size;       /* 0x50 */
        uint32_t    e_header_size;      /* 0x54 */
        uint32_t    e_file_checksum;    /* 0x58 */
        uint16_t    e_subsystem;        /* 0x5c */
        uint16_t    e_dll_flags;        /* 0x5e */
        uint64_t    e_stack_reserve_size;/*0x60 */
        uint64_t    e_stack_commit_size;/* 0x68 */
        uint64_t    e_heap_reserve_size;/* 0x70 */
        uint64_t    e_heap_commit_size; /* 0x78 */
        uint32_t    e_loader_flags;     /* 0x80 */
        uint32_t    e_num_rvasize_pairs;/* 0x84 */
    }                                       /* 0x88 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
        ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* Bit flags for the PE header 'flags' member */
    enum HeaderFlags {
        HF_PROGRAM          = 0x0000,       /* Program image (no non-reserved bits set) */
        HF_EXECUTABLE       = 0x0002,       /* Clear indicates can't load: link errors or incrementally linked */
        HF_FIXED            = 0x0200,       /* Image *must* be loaded at image_base address or error */
        HF_LIBRARY          = 0x2000,       /* Library image */
        HF_RESERVED_MASK    = 0xddfd        /* Reserved bits */
    };

    /* Values for the PE header 'subsystem' member */
    enum Subsystem {
        HF_SPEC_UNKNOWN     = 0x0000,       /* Specified as 'unknown' in the file */
        HF_NATIVE           = 0x0001,       /* Native */
        HF_WINGUI           = 0x0002,       /* Windows GUI */
        HF_WINCHAR          = 0x0003,       /* Windows character */
        HF_OS2CHAR          = 0x0005,       /* OS/2 character */
        HF_POSIX            = 0x0007        /* POSIX character */
    };

    /* Bit flags for the PE header 'dll_flags' member */
    enum DLLFlags {
        DLL_PROC_INIT       = 0x0001,       /* Per-process library initialization */
        DLL_PROC_TERM       = 0x0002,       /* Per-process library termination */
        DLL_THRD_INIT       = 0x0004,       /* Per-thread library initialization */
        DLL_THRD_TERM       = 0x0008,       /* Per-thread library termination */
        DLL_RESERVED_MASK   = 0xfff0        /* Reserved bits */
    };

    /** Reason for each rva/size pair in the PE header. */
    enum PairPurpose {              // Values are important
        PAIR_EXPORTS            = 0,
        PAIR_IMPORTS            = 1,
        PAIR_RESOURCES          = 2,
        PAIR_EXCEPTIONS         = 3,
        PAIR_CERTIFICATES       = 4,
        PAIR_BASERELOCS         = 5,
        PAIR_DEBUG              = 6,
        PAIR_ARCHITECTURE       = 7,
        PAIR_GLOBALPTR          = 8,
        PAIR_TLS                = 9,    // Thread local storage
        PAIR_LOADCONFIG         = 10,
        PAIR_BOUNDIMPORT        = 11,
        PAIR_IAT                = 12,   // Import address table
        PAIR_DELAYIMPORT        = 13,   // Delay import descriptor
        PAIR_CLRRUNTIME         = 14,   // CLR(?) runtime header
        PAIR_RESERVED15         = 15    // Reserved (always zero according to specification)
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_cpu_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_cpu_type(unsigned const&);
    /** @} */
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nsections() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nsections(unsigned const&);
    /** @} */
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_time() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_time(unsigned const&);
    /** @} */
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_coff_symtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_coff_symtab(rose_addr_t const&);
    /** @} */
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 181 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_nt_hdr_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nt_hdr_size(rose_addr_t const&);
    /** @} */
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 187 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_coff_nsyms() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_coff_nsyms(unsigned const&);
    /** @} */
#line 191 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 193 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_flags(unsigned const&);
    /** @} */
#line 197 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 199 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_opt_magic() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_opt_magic(unsigned const&);
    /** @} */
#line 203 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 205 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_lmajor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_lmajor(unsigned const&);
    /** @} */
#line 209 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 211 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_lminor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_lminor(unsigned const&);
    /** @} */
#line 215 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 217 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_code_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_code_size(unsigned const&);
    /** @} */
#line 221 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 223 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_data_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_data_size(unsigned const&);
    /** @} */
#line 227 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 229 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_bss_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_bss_size(unsigned const&);
    /** @} */
#line 233 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 235 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_e_code_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_e_code_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_code_rva(rose_rva_t const&);
    /** @} */
#line 239 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 241 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_e_data_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_e_data_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_data_rva(rose_rva_t const&);
    /** @} */
#line 245 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 247 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_section_align() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_section_align(unsigned const&);
    /** @} */
#line 251 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 253 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_file_align() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_file_align(unsigned const&);
    /** @} */
#line 257 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 259 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_os_major() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_os_major(unsigned const&);
    /** @} */
#line 263 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 265 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_os_minor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_os_minor(unsigned const&);
    /** @} */
#line 269 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 271 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_user_major() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_user_major(unsigned const&);
    /** @} */
#line 275 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 277 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_user_minor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_user_minor(unsigned const&);
    /** @} */
#line 281 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 283 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_subsys_major() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_subsys_major(unsigned const&);
    /** @} */
#line 287 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 289 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_subsys_minor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_subsys_minor(unsigned const&);
    /** @} */
#line 293 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 295 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_reserved9() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_reserved9(unsigned const&);
    /** @} */
#line 299 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 301 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_image_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_image_size(unsigned const&);
    /** @} */
#line 305 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 307 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_header_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_header_size(unsigned const&);
    /** @} */
#line 311 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 313 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_file_checksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_file_checksum(unsigned const&);
    /** @} */
#line 317 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 319 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_subsystem() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_subsystem(unsigned const&);
    /** @} */
#line 323 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 325 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_dll_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_dll_flags(unsigned const&);
    /** @} */
#line 329 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 331 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_stack_reserve_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_stack_reserve_size(unsigned const&);
    /** @} */
#line 335 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 337 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_stack_commit_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_stack_commit_size(unsigned const&);
    /** @} */
#line 341 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 343 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_heap_reserve_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_heap_reserve_size(unsigned const&);
    /** @} */
#line 347 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 349 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_heap_commit_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_heap_commit_size(unsigned const&);
    /** @} */
#line 353 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 355 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_loader_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_loader_flags(unsigned const&);
    /** @} */
#line 359 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 361 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_num_rvasize_pairs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_num_rvasize_pairs(unsigned const&);
    /** @} */
#line 365 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 367 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPERVASizePairList* const& get_rvasize_pairs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_rvasize_pairs(SgAsmPERVASizePairList* const&);
    /** @} */
#line 371 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 373 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPESectionTable* const& get_section_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_table(SgAsmPESectionTable* const&);
    /** @} */
#line 377 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 379 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCoffSymbolTable* const& get_coff_symtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_coff_symtab(SgAsmCoffSymbolTable* const&);
    /** @} */
#line 383 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEFileHeader(SgAsmGenericFile*);

    virtual const char *format_name() const override {return "PE";}

    /** Return true if the file looks like it might be a PE file according to the magic number.
     *
     *  The file must contain what appears to be a DOS File Header at address zero, and what appears to be a PE File Header
     *  at a file offset specified in part of the DOS File Header (actually, in the bytes that follow the DOS File
     *  Header). */
    static bool is_PE (SgAsmGenericFile*);

    /** Convert an RVA/Size Pair index number into a section name.
     *
     *  This is different than @ref stringifySgAsmPEFileHeaderPairPurpose because it returns a section name rather than an
     *  enum name. */
    std::string rvasize_pair_name(PairPurpose, const char **short_name);

    /** Define an RVA/Size pair in the PE file header. */
    void set_rvasize_pair(PairPurpose, SgAsmPESection*);

    /** Update all the RVA/Size pair info from the section to which it points. */
    void update_rvasize_pairs();

    void add_rvasize_pairs();

    virtual SgAsmPEFileHeader *parse() override;
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    void create_table_sections();

    /* Loader memory maps */
    Rose::BinaryAnalysis::MemoryMap::Ptr get_loader_map() const {return p_loader_map;}
    void set_loader_map(const Rose::BinaryAnalysis::MemoryMap::Ptr &map) {p_loader_map=map;}

private:
    void *encode(SgAsmPEFileHeader::PEFileHeader_disk*) const;
    void *encode(SgAsmPEFileHeader::PE32OptHeader_disk*) const;
    void *encode(SgAsmPEFileHeader::PE64OptHeader_disk*) const;
    Rose::BinaryAnalysis::MemoryMap::Ptr p_loader_map;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEExportSection);
IS_SERIALIZABLE(AsmPEExportSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
/** Export file section. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
class SgAsmPEExportSection: public SgAsmPESection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
    AsmPEExportSection.setDataPrototype(
        "SgAsmPEExportDirectory*", "export_dir", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
    AsmPEExportSection.setDataPrototype(
        "SgAsmPEExportEntryList*", "exports", "= createAndParent<SgAsmPEExportEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEExportSection);
#if defined(SgAsmPEExportSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmPESection);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
        s & BOOST_SERIALIZATION_NVP(p_export_dir);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
        s & BOOST_SERIALIZATION_NVP(p_exports);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEExportDirectory* const& get_export_dir() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_export_dir(SgAsmPEExportDirectory* const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEExportEntryList* const& get_exports() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exports(SgAsmPEExportEntryList* const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportSection.h"
public:
    /** The PE Export Address Table is an array of expaddr_n 4-byte RVAs.
     *
     *  If the address is not in the export section (as defined by the address and length that are indicated in the NT Optional
     *  Header) then the RVA is an actual address in code or data. Otherwise its a Forwarder RVA that names a symbol in another
     *  DLL. */
    typedef uint32_t ExportAddress_disk;

    /** The PE Export Name Pointer Table is an array of nameptr_n 4-byte RVAs pointing into the Export Name Table. The pointers are
     *  ordered lexically to allow binary searches.  An export name is defined only if the export name pointer table contains a
     *  pointer to it. */
    typedef uint32_t ExportNamePtr_disk;

    /** The PE Export Ordinal Table is an array of nameptr_n (yes) 2-byte indices into the Export Address Table biased by
     *  ord_base. In other words, the ord_base must be subtracted from the ordinals to obtain true indices into the Export Address
     *  Table. */
    typedef uint16_t ExportOrdinal_disk;

    SgAsmPEExportSection(SgAsmPEFileHeader*);
    virtual SgAsmPEExportSection *parse() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    void add_entry(SgAsmPEExportEntry*);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEExportSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEExportSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmPESection = nonTerminalConstructor(
    "AsmPESection",
    *this,
    "AsmPESection",
    "AsmPESectionTag",
    SubclassListBuilder()
        | AsmPEExportSection
        | AsmPEImportSection
        | AsmPEStringSection
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmPESection.associatedGrammar != nullptr);
AsmPESection.setCppCondition("!defined(DOCUMENTATION)");
AsmPESection.isBoostSerializable(true);
AsmPESection.setAutomaticGenerationOfConstructor(false);
AsmPESection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
/** Base class for PE sections. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
class SgAsmPESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
    AsmPESection.setDataPrototype(
        "SgAsmPESectionTableEntry*", "section_entry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPESection);
#if defined(SgAsmPESection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
        s & BOOST_SERIALIZATION_NVP(p_section_entry);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPESectionTableEntry* const& get_section_entry() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_entry(SgAsmPESectionTableEntry* const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPESection.h"
public:
    explicit SgAsmPESection(SgAsmPEFileHeader*);

    /** Initializes the section from data parsed from the PE Section Table.
     *
     *  This includes the section offset, size, memory mapping, alignments, permissions, etc. This function complements
     *  SgAsmPESectionTable::add_section(): this function initializes this section from the section table while
     *  add_section() initializes the section table from the section. */
    SgAsmPESection *init_from_section_table(SgAsmPESectionTableEntry *entry, int id);
    virtual bool reallocate() override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPESection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPESection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPESection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEExportEntryList);
IS_SERIALIZABLE(AsmPEExportEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"
/** List of pointers to other AST nodes.
 *
 *  The only purpose of this node is to hold a list of pointers to other nodes. We cannot store the list directly in the nodes that
 *  need it due to ROSETTA limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"
class SgAsmPEExportEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"
    AsmPEExportEntryList.setDataPrototype(
        "SgAsmPEExportEntryPtrList", "exports", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEExportEntryList);
#if defined(SgAsmPEExportEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_exports);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEExportEntryPtrList const& get_exports() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmPEExportEntryPtrList& get_exports();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exports(SgAsmPEExportEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEExportEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEExportEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEExportEntry);
IS_SERIALIZABLE(AsmPEExportEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
/** Export entry. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
class SgAsmPEExportEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    AsmPEExportEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    AsmPEExportEntry.setDataPrototype(
        "unsigned", "ordinal", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    AsmPEExportEntry.setDataPrototype(
        "rose_rva_t", "export_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    AsmPEExportEntry.setDataPrototype(
        "SgAsmGenericString*", "forwarder", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEExportEntry);
#if defined(SgAsmPEExportEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_ordinal);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_export_rva);
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_forwarder);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    void set_name(SgAsmGenericString*);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_ordinal() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ordinal(unsigned const&);
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_export_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_export_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_export_rva(rose_rva_t const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_forwarder() const;
    /** @} */
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportEntry.h"
    void set_forwarder(SgAsmGenericString*);
    /** @} */

public:
    SgAsmPEExportEntry(SgAsmGenericString *name, unsigned ordinal, rose_rva_t export_rva, SgAsmGenericString *forwarder);
    void dump(FILE *f,const char *prefix,ssize_t idx) const;
    /* Accessors. Override ROSETTA because we adjust parents. */

    /** Property: Biased ordinal.
     *
     *  This is the biased ordinal, which is the unbiased ordinal plus the ordinal base from the export directory.
     *  This is a read-only value calculated by following the parent pointer to the SgAsmPEExportSection node and
     *  then down to its SgAsmPEExportDirectory. If any links are missing then an error is returned. */
    Sawyer::Result<unsigned /*ordinal*/, std::string /*reason*/> biasedOrdinal() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEExportEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEExportEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmPEExportDirectory           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmPEExportDirectory);
IS_SERIALIZABLE(AsmPEExportDirectory);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
/** Export directory. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
class SgAsmPEExportDirectory: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "time_t", "timestamp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "vmajor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "vminor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "rose_rva_t", "name_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "unsigned", "ord_base", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "size_t", "expaddr_n", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "size_t", "nameptr_n", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "rose_rva_t", "expaddr_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "rose_rva_t", "nameptr_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "rose_rva_t", "ordinals_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    AsmPEExportDirectory.setDataPrototype(
        "SgAsmGenericString*", "name", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmPEExportDirectory);
#if defined(SgAsmPEExportDirectory_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_res1);
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_timestamp);
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_vmajor);
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_vminor);
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_name_rva);
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_ord_base);
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_expaddr_n);
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_nameptr_n);
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_expaddr_rva);
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_nameptr_rva);
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_ordinals_rva);
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* An Export Section begins with the Export Directory */
    struct PEExportDirectory_disk {
        uint32_t res1;         /* 0x00 Reserved, must be zero */
        uint32_t timestamp;    /* 0x04 Time that export data was created */
        uint16_t vmajor;       /* 0x08 Major version number (user defined) */
        uint16_t vminor;       /* 0x0a Minor version number (user defined) */
        uint32_t name_rva;     /* 0x0c Location of name of DLL */
        uint32_t ord_base;     /* 0x10 Starting ordinal for exports in this image (usually 1) */
        uint32_t expaddr_n;    /* 0x14 Number of entries in the export address table */
        uint32_t nameptr_n;    /* 0x18 Number of entries in the name pointer table and ordinal table */
        uint32_t expaddr_rva;  /* 0x1c Location of Export Address Table */
        uint32_t nameptr_rva;  /* 0x20 Location of Export Name Pointer Table */
        uint32_t ordinals_rva; /* 0x24 Location of Ordinal Table */
    }                               /* 0x28 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_res1(unsigned const&);
    /** @} */
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    time_t const& get_timestamp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_timestamp(time_t const&);
    /** @} */
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_vmajor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vmajor(unsigned const&);
    /** @} */
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_vminor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vminor(unsigned const&);
    /** @} */
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_name_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_name_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_rva(rose_rva_t const&);
    /** @} */
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_ord_base() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ord_base(unsigned const&);
    /** @} */
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_expaddr_n() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_expaddr_n(size_t const&);
    /** @} */
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_nameptr_n() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_nameptr_n(size_t const&);
    /** @} */
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_expaddr_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_expaddr_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_expaddr_rva(rose_rva_t const&);
    /** @} */
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 90 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_nameptr_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_nameptr_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_nameptr_rva(rose_rva_t const&);
    /** @} */
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_ordinals_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_ordinals_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ordinals_rva(rose_rva_t const&);
    /** @} */
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 102 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(SgAsmGenericString* const&);
    /** @} */
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmPEExportDirectory.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmPEExportDirectory(SgAsmPEExportSection*);
    void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmPEExportDirectory();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmPEExportDirectory();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmPEExportDirectory_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmOperandList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmOperandList);
IS_SERIALIZABLE(AsmOperandList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
/** List of operands for an instruction. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
class SgAsmOperandList: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
    AsmOperandList.setDataPrototype(
        "SgAsmExpressionPtrList", "operands", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmOperandList);
#if defined(SgAsmOperandList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
        s & BOOST_SERIALIZATION_NVP(p_operands);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpressionPtrList const& get_operands() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpressionPtrList& get_operands();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_operands(SgAsmExpressionPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmOperandList.h"
public:
    /** Append another operand expression to this node. */
    void append_operand(SgAsmExpression* operand);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmOperandList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmOperandList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmOperandList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNullInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNullInstruction);
IS_SERIALIZABLE(AsmNullInstruction);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNullInstruction.h"
class SgAsmNullInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNullInstruction);
#if defined(SgAsmNullInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNullInstruction.h"
public:
    // there's only one kind of null instruction
    enum Kind { null_unknown };

public: // overrides
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*> &insns,
                                    rose_addr_t *target/*out*/, rose_addr_t *ret/*out*/) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*> &insns) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*> &insns) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*>&,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr()) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNullInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNullInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmNullInstruction(rose_addr_t const& address,
                         std::string const& mnemonic);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNullInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEStringTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNEStringTable);
IS_SERIALIZABLE(AsmNEStringTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEStringTable.h"
class SgAsmNEStringTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNEStringTable);
#if defined(SgAsmNEStringTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEStringTable.h"
public:
    SgAsmNEStringTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    std::string get_string(rose_addr_t offset);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNEStringTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNEStringTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEStringTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNESectionTable);
IS_SERIALIZABLE(AsmNESectionTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
class SgAsmNESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
    AsmNESectionTable.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
    AsmNESectionTable.setDataPrototype(
        "unsigned", "sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
    AsmNESectionTable.setDataPrototype(
        "rose_addr_t", "physical_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
    AsmNESectionTable.setDataPrototype(
        "rose_addr_t", "virtual_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNESectionTable);
#if defined(SgAsmNESectionTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
        s & BOOST_SERIALIZATION_NVP(p_sector);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
        s & BOOST_SERIALIZATION_NVP(p_physical_size);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
        s & BOOST_SERIALIZATION_NVP(p_virtual_size);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_sector() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sector(unsigned const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_physical_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_physical_size(rose_addr_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_virtual_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_virtual_size(rose_addr_t const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTable.h"
public:
    explicit SgAsmNESectionTable(SgAsmNEFileHeader*);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNESectionTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNESectionTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESectionTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNESectionTableEntry);
IS_SERIALIZABLE(AsmNESectionTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
class SgAsmNESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    AsmNESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    AsmNESectionTableEntry.setDataPrototype(
        "unsigned", "sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    AsmNESectionTableEntry.setDataPrototype(
        "rose_addr_t", "physical_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    AsmNESectionTableEntry.setDataPrototype(
        "rose_addr_t", "virtual_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNESectionTableEntry);
#if defined(SgAsmNESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sector);
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_physical_size);
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_virtual_size);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. All fields are little endian. */
    struct NESectionTableEntry_disk {
        uint16_t    sector;                 /* 0x00 File offset (sector size defined in hdr); zero means no file data */
        uint16_t    physical_size;          /* 0x02 Length of segment in file; zero means 64k if sector is non-zero */
        uint16_t    flags;                  /* 0x04 Segment bit flags */
        uint16_t    virtual_size;           /* 0x06 Total size of segment when mapped to memory; zero means 64k */
    }                                     /* 0x08 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    enum NESectionFlags {
        SF_RESERVED         = 0x0e08,       /* these bits are reserved */

        SF_TYPE_MASK        = 0x0007,       /* segment-type field */
        SF_CODE             = 0x0000,       /* code-segment type */
        SF_DATA             = 0x0001,       /* data-segment (otherwise segment is code) */
        SF_ALLOC            = 0x0002,       /* loader allocates memory */
        SF_LOAD             = 0x0004,       /* load the segment */

        SF_MOVABLE          = 0x0010,       /* segment is not fixed */
        SF_PURE             = 0x0020,       /* segment is pure, or sharable; otherwise impure or non-sharable */
        SF_PRELOAD          = 0x0040,       /* segment will be preloaded; read-only if this is a data segment */
        SF_NOT_WRITABLE     = 0x0080,       /* code segment is execute only; data segment is read-only */
        SF_RELOCINFO        = 0x0100,       /* segment has relocation records */
        SF_DISCARDABLE      = 0x1000,       /* discardable */
        SF_DISCARD          = 0xf000        /* discard priority */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_sector() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sector(unsigned const&);
    /** @} */
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_physical_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_physical_size(rose_addr_t const&);
    /** @} */
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_virtual_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_virtual_size(rose_addr_t const&);
    /** @} */
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmNESectionTableEntry(const SgAsmNESectionTableEntry::NESectionTableEntry_disk *disk);
    void *encode(SgAsmNESectionTableEntry::NESectionTableEntry_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {dump(f, prefix, idx, NULL);}
    void dump(FILE*, const char *prefix, ssize_t idx, SgAsmNEFileHeader *fhdr) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNESectionTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNESectionTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESectionTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNESection);
IS_SERIALIZABLE(AsmNESection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
class SgAsmNESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
    AsmNESection.setDataPrototype(
        "SgAsmNESectionTableEntry*", "st_entry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
    AsmNESection.setDataPrototype(
        "SgAsmNERelocTable*", "reloc_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNESection);
#if defined(SgAsmNESection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
        s & BOOST_SERIALIZATION_NVP(p_st_entry);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
        s & BOOST_SERIALIZATION_NVP(p_reloc_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNESectionTableEntry* const& get_st_entry() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_entry(SgAsmNESectionTableEntry* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocTable* const& get_reloc_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reloc_table(SgAsmNERelocTable* const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNESection.h"
public:
    explicit SgAsmNESection(SgAsmNEFileHeader *fhdr);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNESection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNESection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNESection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNERelocTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNERelocTable);
IS_SERIALIZABLE(AsmNERelocTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocTable.h"
class SgAsmNERelocTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocTable.h"
    AsmNERelocTable.setDataPrototype(
        "SgAsmNERelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNERelocTable);
#if defined(SgAsmNERelocTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocTable.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmNERelocEntryPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocTable.h"
public:
    explicit SgAsmNERelocTable(SgAsmNEFileHeader *fhdr, SgAsmNESection *section);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNERelocTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNERelocTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNERelocTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNERelocEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNERelocEntry);
IS_SERIALIZABLE(AsmNERelocEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
class SgAsmNERelocEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 126 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocSrcType", "src_type", "= SgAsmNERelocEntry::RF_SRCTYPE_8OFF",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocModifiers", "modifier", "= SgAsmNERelocEntry::RF_MODIFIER_SINGLE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocTgtType", "tgt_type", "= SgAsmNERelocEntry::RF_TGTTYPE_IREF",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::NERelocFlags", "flags", "= SgAsmNERelocEntry::RF_ADDITIVE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 138 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "rose_addr_t", "src_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iref_type", "iref", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iord_type", "iord", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::iname_type", "iname", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    AsmNERelocEntry.setDataPrototype(
        "SgAsmNERelocEntry::osfixup_type", "osfixup", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNERelocEntry);
#if defined(SgAsmNERelocEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 126 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_src_type);
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_modifier);
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_tgt_type);
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 138 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_src_offset);
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_iref);
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_iord);
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_iname);
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_osfixup);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /* NERelocEntry_disk -- variable size with multiple levels of 'union'. It's easier to just parse it in NERelocEntry::ctor()
     * than defining it here as a struct. */
    enum NERelocSrcType {
        RF_SRCTYPE_8OFF     = 0,            /* Byte offset */
        RF_SRCTYPE_WORDSEG  = 2,            /* Word segment, 16-bit selector */
        RF_SRCTYPE_16PTR    = 3,            /* 16-bit far pointer */
        RF_SRCTYPE_16OFF    = 5,            /* 16-bit offset */
        RF_SRCTYPE_32PTR    = 6,            /* 32-bit far pointer */
        RF_SRCTYPE_32OFF    = 7,            /* 32-bit offset */
        RF_SRCTYPE_NEARCALL = 8,            /* near call or jump, WORD/DWROD based on section attribute */
        RF_SRCTYPE_48PTR    = 11,           /* 48-bit pointer */
        RF_SRCTYPE_32OFF_b  = 13            /* 32-bit offset (not sure how this differs from case 7) */
    };

    enum NERelocTgtType {
        RF_TGTTYPE_IREF     = 0,            /* Internal reference */
        RF_TGTTYPE_IORD     = 1,            /* Imported (extern) ordinal */
        RF_TGTTYPE_INAME    = 2,            /* Imported (extern) name */
        RF_TGTTYPE_OSFIXUP  = 3             /* Operating system fixup */
    };

    enum NERelocModifiers {
        RF_MODIFIER_SINGLE  = 1,
        RF_MODIFIER_MULTI   = 3
    };

    enum NERelocFlags {
        RF_ADDITIVE         = 0x01,         /* add target to source rather than replace source with target */
        RF_RESERVED         = 0x02,         /* reserved bits */
        RF_2EXTRA           = 0x04,         /* relocation info has size with new two bytes at end */
        RF_32ADD            = 0x08,         /* addition with 32-bits rather than 16 */
        RF_16SECTION        = 0x10,         /* 16-bit object number & module name rather than 8-bit */
        RF_8ORDINAL         = 0x20          /* Ordinal is 8-bits rather than 16 */
    };

    // DQ (8/7/2008): At only (I hope) the risk of using more memory that required, break the union so that we can better support
    // this in ROSETTA. One solution might be to implement a common base class of unsigned, unsigned, rose_addr_t; and then use
    // member functions to access the data in the base class.
    struct iref_type { /*tgt_type==0x00: internal reference*/
        unsigned    sect_idx;       /* section index (1-origin) */
        unsigned    res1;           /* reserved */
        rose_addr_t tgt_offset;

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(sect_idx);
            s & BOOST_SERIALIZATION_NVP(res1);
            s & BOOST_SERIALIZATION_NVP(tgt_offset);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iref_type & x );

        iref_type();
    };

    struct iord_type { /*tgt_type==0x01: imported ordinal*/
        unsigned    modref;         /* 1-based index into import module table */
        unsigned    ordinal;
        rose_addr_t      addend;         /* value to add (only present for flags & RF_2EXTRA) */

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(modref);
            s & BOOST_SERIALIZATION_NVP(ordinal);
            s & BOOST_SERIALIZATION_NVP(addend);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iord_type & x );

        iord_type();
    };

    struct iname_type { /*tgt_type==0x02: imported name*/
        unsigned    modref;         /* 1-based index into import module table */
        unsigned    nm_off;         /* offset into import procedure names */
        rose_addr_t      addend;    /* value to add (only present for flags & RF_2EXTRA) */

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(modref);
            s & BOOST_SERIALIZATION_NVP(nm_off);
            s & BOOST_SERIALIZATION_NVP(addend);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const iname_type & x );

        iname_type();
    };

    struct osfixup_type { /*tgt_type==0x03: operating system fixup*/
        unsigned    type;
        unsigned    res3;

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(type);
            s & BOOST_SERIALIZATION_NVP(res3);
        }
#endif

        // Added to support RTI support in ROSE
        friend std::ostream & operator<< ( std::ostream & os, const osfixup_type & x );

        osfixup_type();
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::NERelocSrcType const& get_src_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_src_type(SgAsmNERelocEntry::NERelocSrcType const&);
    /** @} */
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::NERelocModifiers const& get_modifier() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_modifier(SgAsmNERelocEntry::NERelocModifiers const&);
    /** @} */
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::NERelocTgtType const& get_tgt_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_tgt_type(SgAsmNERelocEntry::NERelocTgtType const&);
    /** @} */
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::NERelocFlags const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(SgAsmNERelocEntry::NERelocFlags const&);
    /** @} */
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_src_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_src_offset(rose_addr_t const&);
    /** @} */
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::iref_type const& get_iref() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iref(SgAsmNERelocEntry::iref_type const&);
    /** @} */
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::iord_type const& get_iord() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iord(SgAsmNERelocEntry::iord_type const&);
    /** @} */
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::iname_type const& get_iname() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_iname(SgAsmNERelocEntry::iname_type const&);
    /** @} */
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNERelocEntry::osfixup_type const& get_osfixup() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_osfixup(SgAsmNERelocEntry::osfixup_type const&);
    /** @} */
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNERelocEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNERelocEntry(SgAsmGenericSection *relocs, rose_addr_t at, rose_addr_t *rec_size);
    rose_addr_t unparse(std::ostream&, const SgAsmGenericSection*, rose_addr_t spos) const;
    void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNERelocEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNERelocEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNERelocEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNENameTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNENameTable);
IS_SERIALIZABLE(AsmNENameTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
class SgAsmNENameTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
    AsmNENameTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
    AsmNENameTable.setDataPrototype(
        "SgUnsignedList", "ordinals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNENameTable);
#if defined(SgAsmNENameTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
        s & BOOST_SERIALIZATION_NVP(p_names);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
        s & BOOST_SERIALIZATION_NVP(p_ordinals);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgStringList const& get_names() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_names(SgStringList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedList const& get_ordinals() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ordinals(SgUnsignedList const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNENameTable.h"
public:
    SgAsmNENameTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    std::vector<std::string> get_names_by_ordinal(unsigned ordinal);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNENameTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNENameTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNENameTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEModuleTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNEModuleTable);
IS_SERIALIZABLE(AsmNEModuleTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
class SgAsmNEModuleTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
    AsmNEModuleTable.setDataPrototype(
        "SgAsmNEStringTable*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
    AsmNEModuleTable.setDataPrototype(
        "SgAddressList", "name_offsets", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
    AsmNEModuleTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNEModuleTable);
#if defined(SgAsmNEModuleTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
        s & BOOST_SERIALIZATION_NVP(p_strtab);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
        s & BOOST_SERIALIZATION_NVP(p_name_offsets);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
        s & BOOST_SERIALIZATION_NVP(p_names);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEStringTable* const& get_strtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strtab(SgAsmNEStringTable* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAddressList const& get_name_offsets() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_offsets(SgAddressList const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgStringList const& get_names() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_names(SgStringList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEModuleTable.h"
public:
    SgAsmNEModuleTable(SgAsmNEFileHeader *fhdr, SgAsmNEStringTable *strtab, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNEModuleTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNEModuleTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEModuleTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNEFileHeader);
IS_SERIALIZABLE(AsmNEFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
class SgAsmNEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_linker_major", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_linker_minor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 91 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_checksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_flags1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_autodata_sn", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_bss_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_stack_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_csip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_sssp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nsections", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nmodrefs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nnonresnames", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nmovable_entries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_sector_align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_nresources", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_exetype", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_flags2", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "unsigned", "e_winvers", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_sectab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_rsrctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 154 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_resnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_modreftab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_importnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nonresnametab_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fastload_sector", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fastload_nsectors", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmDOSExtendedHeader*", "dos2_header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNESectionTable*", "section_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNENameTable*", "resname_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 181 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNENameTable*", "nonresname_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNEModuleTable*", "module_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 187 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    AsmNEFileHeader.setDataPrototype(
        "SgAsmNEEntryTable*", "entry_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNEFileHeader);
#if defined(SgAsmNEFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_linker_major);
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_linker_minor);
#line 91 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_checksum);
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_flags1);
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_autodata_sn);
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_bss_size);
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_stack_size);
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_csip);
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_sssp);
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nsections);
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nmodrefs);
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nnonresnames);
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nmovable_entries);
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_sector_align);
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nresources);
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_exetype);
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_flags2);
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_winvers);
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_rfo);
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_size);
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_sectab_rfo);
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_rfo);
#line 154 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_resnametab_rfo);
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_modreftab_rfo);
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_importnametab_rfo);
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_offset);
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fastload_sector);
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fastload_nsectors);
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_dos2_header);
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_section_table);
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_resname_table);
#line 181 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_nonresname_table);
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_module_table);
#line 187 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of an NE File Header. All fields are little endian.
     *
     * NOTES
     *
     * e_sssp: The value specified in SS is an index (1-origin) into the segment table. If SS addresses the automatic data segment
     *         and SP is zero then SP is set to the address obtained by adding the size of the automatic data segment to the size
     *         of the stack. */
    struct NEFileHeader_disk {
         unsigned char e_magic[2];           /* 0x00 magic number "NE" */
         unsigned char e_linker_major;       /* 0x02 linker major version number */
         unsigned char e_linker_minor;       /* 0x03 linker minor version number */
         uint16_t    e_entrytab_rfo;         /* 0x04 entry table offset relative to start of header */
         uint16_t    e_entrytab_size;        /* 0x06 size of entry table in bytes */
         uint32_t    e_checksum;             /* 0x08 32-bit CRC of entire file (this word is taken a zero during the calculation) */
         uint16_t    e_flags1;               /* 0x0c file-level bit flags (see HeaderFlags1) */
         uint16_t    e_autodata_sn;          /* 0x0e auto data section number if (flags & 0x3)==0; else zero */
         uint16_t    e_bss_size;             /* 0x10 num bytes added to data segment for BSS */
         uint16_t    e_stack_size;           /* 0x12 num bytes added to data segment for stack (zero of SS!=DS registers) */
         uint32_t    e_csip;                 /* 0x14 section number:offset of CS:IP */
         uint32_t    e_sssp;                 /* 0x18 section number:offset of SS:SP (see note 1 above) */
         uint16_t    e_nsections;            /* 0x1c number of entries in the section table */
         uint16_t    e_nmodrefs;             /* 0x1e number of entries in the module reference table */
         uint16_t    e_nnonresnames;         /* 0x20 number of entries in the non-resident name table */
         uint16_t    e_sectab_rfo;           /* 0x22 offset of section table relative to start of header */
         uint16_t    e_rsrctab_rfo;          /* 0x24 offset of resource table relative to start of header */
         uint16_t    e_resnametab_rfo;       /* 0x26 offset of resident name table relative to start of header */
         uint16_t    e_modreftab_rfo;        /* 0x28 offset of module reference table relative to start of header */
         uint16_t    e_importnametab_rfo;    /* 0x2a offset of imported names table relative to start of header */
         uint32_t    e_nonresnametab_offset; /* 0x2c file offset of non-resident name table */
         uint16_t    e_nmovable_entries;     /* 0x30 number of movable entries in Entry Table */
         uint16_t    e_sector_align;         /* 0x32 sector alignment shift count (log2 of segment sector size) */
         uint16_t    e_nresources;           /* 0x34 number of resource entries */
         unsigned char e_exetype;            /* 0x36 executable type (2==windows) */
         unsigned char e_flags2;             /* 0x37 additional flags (see HeaderFlags2) */
         uint16_t    e_fastload_sector;      /* 0x38 sector offset to fast-load area (only for Windows) */
         uint16_t    e_fastload_nsectors;    /* 0x3a size of fast-load area in sectors (only for Windows) */
         uint16_t    e_res1;                 /* 0x3c reserved */
         uint16_t    e_winvers;              /* 0x3e expected version number for Windows (only for Windows) */
       }                                     /* 0x40 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* Bit flags for the NE header 'e_flags' member.
     *
     * If HF_LIBRARY (bit 15) is set then the CS:IP registers point to an initialization procedure called with the value in the AX
     * register equal to the module handle. The initialization procedure must execute a far return to the caller. The resulting
     * value in AX is a status indicator (non-zero for success, zero for failure). */
    enum HeaderFlags1 {
         HF1_RESERVED         = 0x57f4,      /* Reserved bits */
         HF1_NO_DATA          = 0x0000,      /* (flags&0x03==0) => an exe not containing a data segment */
         HF1_SINGLE_DATA      = 0x0001,      /* Executable contains one data segment; set if file is a DLL */
         HF1_MULTIPLE_DATA    = 0x0002,      /* Exe with multiple data segments; set if a windows application */
         HF1_LOADER_SEGMENT   = 0x0800,      /* First segment contains code that loads the application */
         HF1_FATAL_ERRORS     = 0x2000,      /* Errors detected at link time; module will not load */
         HF1_LIBRARY          = 0x8000       /* Module is a library */
       };

    /* Bit flags for the NE header 'e_flags2' member. */
    enum HeaderFlags2 {
         HF2_RESERVED         = 0xf1,        /* Reserved bits */
         HF2_PROTECTED_MODE   = 0x02,        /* Windows 2.x application that runs in 3.x protected mode */
         HF2_PFONTS           = 0x04,        /* Windows 2.x application that supports proportional fonts */
         HF2_FASTLOAD         = 0x08         /* Executable contains a fast-load area */
       };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_linker_major() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_linker_major(unsigned const&);
    /** @} */
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_linker_minor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_linker_minor(unsigned const&);
    /** @} */
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_checksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_checksum(unsigned const&);
    /** @} */
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_flags1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_flags1(unsigned const&);
    /** @} */
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_autodata_sn() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_autodata_sn(unsigned const&);
    /** @} */
#line 98 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_bss_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_bss_size(unsigned const&);
    /** @} */
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_stack_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_stack_size(unsigned const&);
    /** @} */
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_csip() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_csip(unsigned const&);
    /** @} */
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_sssp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_sssp(unsigned const&);
    /** @} */
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nsections() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nsections(unsigned const&);
    /** @} */
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nmodrefs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nmodrefs(unsigned const&);
    /** @} */
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nnonresnames() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nnonresnames(unsigned const&);
    /** @} */
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nmovable_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nmovable_entries(unsigned const&);
    /** @} */
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_sector_align() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_sector_align(unsigned const&);
    /** @} */
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nresources() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nresources(unsigned const&);
    /** @} */
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_exetype() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_exetype(unsigned const&);
    /** @} */
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_flags2() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_flags2(unsigned const&);
    /** @} */
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res1(unsigned const&);
    /** @} */
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_winvers() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_winvers(unsigned const&);
    /** @} */
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_entrytab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_entrytab_rfo(rose_addr_t const&);
    /** @} */
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_entrytab_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_entrytab_size(rose_addr_t const&);
    /** @} */
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_sectab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_sectab_rfo(rose_addr_t const&);
    /** @} */
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_rsrctab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_rsrctab_rfo(rose_addr_t const&);
    /** @} */
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_resnametab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_resnametab_rfo(rose_addr_t const&);
    /** @} */
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_modreftab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_modreftab_rfo(rose_addr_t const&);
    /** @} */
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_importnametab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_importnametab_rfo(rose_addr_t const&);
    /** @} */
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_nonresnametab_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nonresnametab_offset(rose_addr_t const&);
    /** @} */
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fastload_sector() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fastload_sector(rose_addr_t const&);
    /** @} */
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fastload_nsectors() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fastload_nsectors(rose_addr_t const&);
    /** @} */
#line 170 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDOSExtendedHeader* const& get_dos2_header() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dos2_header(SgAsmDOSExtendedHeader* const&);
    /** @} */
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNESectionTable* const& get_section_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_table(SgAsmNESectionTable* const&);
    /** @} */
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNENameTable* const& get_resname_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_resname_table(SgAsmNENameTable* const&);
    /** @} */
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNENameTable* const& get_nonresname_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_nonresname_table(SgAsmNENameTable* const&);
    /** @} */
#line 182 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEModuleTable* const& get_module_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_module_table(SgAsmNEModuleTable* const&);
    /** @} */
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEEntryTable* const& get_entry_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_table(SgAsmNEEntryTable* const&);
    /** @} */
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNEFileHeader(SgAsmGenericFile *f, rose_addr_t offset);

    static bool is_NE (SgAsmGenericFile*);
    static SgAsmNEFileHeader *parse(SgAsmDOSFileHeader*);
    virtual void unparse(std::ostream&) const override;
    virtual const char *format_name() const override {return "NE";}
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

private:
    void *encode(SgAsmNEFileHeader::NEFileHeader_disk*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNEFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNEFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEEntryTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNEEntryTable);
IS_SERIALIZABLE(AsmNEEntryTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
class SgAsmNEEntryTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
    AsmNEEntryTable.setDataPrototype(
        "SgSizeTList", "bundle_sizes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
    AsmNEEntryTable.setDataPrototype(
        "SgAsmNEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNEEntryTable);
#if defined(SgAsmNEEntryTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
        s & BOOST_SERIALIZATION_NVP(p_bundle_sizes);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgSizeTList const& get_bundle_sizes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bundle_sizes(SgSizeTList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEEntryPointPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEEntryPointPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmNEEntryPointPtrList const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryTable.h"
public:
    SgAsmNEEntryTable(SgAsmNEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    void populate_entries();
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNEEntryTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNEEntryTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEEntryTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNEEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmNEEntryPoint);
IS_SERIALIZABLE(AsmNEEntryPoint);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
class SgAsmNEEntryPoint: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    AsmNEEntryPoint.setDataPrototype(
        "SgAsmNEEntryPoint::NEEntryFlags", "flags", "= SgAsmNEEntryPoint::EF_ZERO",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "int3f", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "section_idx", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    AsmNEEntryPoint.setDataPrototype(
        "unsigned", "section_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNEEntryPoint);
#if defined(SgAsmNEEntryPoint_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_int3f);
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_section_idx);
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_section_offset);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum NEEntryFlags {
        EF_ZERO             = 0x00,                     /* No flags set */
        EF_RESERVED         = 0xfc,                     /* Reserved bits */
        EF_EXPORTED         = 0x01,                     /* Exported */
        EF_GLOBAL           = 0x02                      /* Uses a global (shared) data section */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmNEEntryPoint::NEEntryFlags const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(SgAsmNEEntryPoint::NEEntryFlags const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_int3f() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_int3f(unsigned const&);
    /** @} */
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_section_idx() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_idx(unsigned const&);
    /** @} */
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_section_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_offset(unsigned const&);
    /** @} */
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNEEntryPoint.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmNEEntryPoint(SgAsmNEEntryPoint::NEEntryFlags flags, unsigned int3f, unsigned s_idx, unsigned s_off);
    void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNEEntryPoint();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNEEntryPoint();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNEEntryPoint_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmMipsInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmMipsInstruction);
IS_SERIALIZABLE(AsmMipsInstruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmMipsInstruction);
#if defined(SgAsmMipsInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
#include <Rose/BinaryAnalysis/InstructionEnumsMips.h>
#endif // SgAsmMipsInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
/** Represents one MIPS machine instruction. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
class SgAsmMipsInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
    AsmMipsInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::MipsInstructionKind", "kind", "= Rose::BinaryAnalysis::mips_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmMipsInstruction);
#if defined(SgAsmMipsInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::MipsInstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::MipsInstructionKind const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMipsInstruction.h"
public:
    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*> &insns,
                                    rose_addr_t *target/*out*/, rose_addr_t *ret/*out*/) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*> &insns) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*> &insns) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual bool isUnknown() const override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmMipsInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmMipsInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmMipsInstruction(rose_addr_t const& address,
                         std::string const& mnemonic,
                         Rose::BinaryAnalysis::MipsInstructionKind const& kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmMipsInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmMemoryReferenceExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmMemoryReferenceExpression);
IS_SERIALIZABLE(AsmMemoryReferenceExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
/** Reference to memory locations. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
class SgAsmMemoryReferenceExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
    AsmMemoryReferenceExpression.setDataPrototype(
        "SgAsmExpression*", "address", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
    AsmMemoryReferenceExpression.setDataPrototype(
        "SgAsmExpression*", "segment", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmMemoryReferenceExpression);
#if defined(SgAsmMemoryReferenceExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_address);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_segment);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_address() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_address(SgAsmExpression* const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_segment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_segment(SgAsmExpression* const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmMemoryReferenceExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmMemoryReferenceExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmMemoryReferenceExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmMemoryReferenceExpression(SgAsmExpression* const& address,
                                   SgAsmExpression* const& segment);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmMemoryReferenceExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmM68kInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmM68kInstruction);
IS_SERIALIZABLE(AsmM68kInstruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmM68kInstruction);
#if defined(SgAsmM68kInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
#include <Rose/BinaryAnalysis/InstructionEnumsM68k.h>
#endif // SgAsmM68kInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
class SgAsmM68kInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
    AsmM68kInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::M68kInstructionKind", "kind", "= Rose::BinaryAnalysis::m68k_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmM68kInstruction);
#if defined(SgAsmM68kInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
public:
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::M68kInstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::M68kInstructionKind const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmM68kInstruction.h"
public:
    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*> &insns,
                                    rose_addr_t *target/*out*/, rose_addr_t *ret/*out*/) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*> &insns) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*> &insns) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*>&,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr()) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmM68kInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmM68kInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmM68kInstruction(rose_addr_t const& address,
                         std::string const& mnemonic,
                         Rose::BinaryAnalysis::M68kInstructionKind const& kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmM68kInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLESectionTable);
IS_SERIALIZABLE(AsmLESectionTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTable.h"
class SgAsmLESectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLESectionTable);
#if defined(SgAsmLESectionTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTable.h"
public:
    SgAsmLESectionTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLESectionTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLESectionTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESectionTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLESectionTableEntry);
IS_SERIALIZABLE(AsmLESectionTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
class SgAsmLESectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "pagemap_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "pagemap_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "rose_addr_t", "mapped_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    AsmLESectionTableEntry.setDataPrototype(
        "rose_addr_t", "base_addr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLESectionTableEntry);
#if defined(SgAsmLESectionTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_pagemap_index);
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_pagemap_nentries);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_res1);
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_size);
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_base_addr);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of a section table entry. Fields are big- or little-endian depending on file header. */
    struct LESectionTableEntry_disk {
        uint32_t    mapped_size;            /* 0x00 virtual segment size in bytes */
        uint32_t    base_addr;              /* 0x04 relocation base address */
        uint32_t    flags;                  /* 0x08 bit flags, see LESectionFlags */
        uint32_t    pagemap_index;          /* 0x0c */
        uint32_t    pagemap_nentries;       /* 0x10 number of entries in the page map */
        uint32_t    res1;                   /* 0x14 reserved */
    }                                     /* 0x18 */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    /* SF_BIG_BIT: The "big/default" bit, for data segments, controls the setting of the Big bit in the segment descriptor. (The
     *             Big bit, or B-bit, determines whether ESP or SP is used as the stack pointer.) For code segments, this bit
     *             controls the setting of the Default bit in the segment descriptor. (The Default bit, or D-bit, determines
     *             whether the default word size is 32-bits or 16-bits. It also affects the interpretation of the instruction
     *             stream.) */
    enum LESectionFlags {
        SF_RESERVED         = 0xffff0800,   /* Reserved bits (FIXME) */

        SF_READABLE         = 0x00000001,   /**< Read permission granted when mapped */
        SF_WRITABLE         = 0x00000002,   /**< Write permission granted when mapped */
        SF_EXECUTABLE       = 0x00000004,   /**< Execute permission granted when mapped */

        SF_RESOURCE         = 0x00000008,   /**< Section contains resource objects */
        SF_DISCARDABLE      = 0x00000010,   /**< Discardable section */
        SF_SHARED           = 0x00000020,   /**< Section is shared */
        SF_PRELOAD_PAGES    = 0x00000040,   /**< Section has preload pages */
        SF_INVALID_PAGES    = 0x00000080,   /**< Section has invalid pages */

        SF_TYPE_MASK        = 0x00000300,        /*NO_STRINGIFY*/
        SF_TYPE_NORMAL      = 0x00000000,
        SF_TYPE_ZERO        = 0x00000100,   /**< Section has zero-filled pages */
        SF_TYPE_RESIDENT    = 0x00000200,   /**< Section is resident (valid for VDDs and PDDs only) */
        SF_TYPE_RESCONT     = 0x00000300,   /**< Section is resident and contiguous */

        SF_RES_LONG_LOCK    = 0x00000400,   /**< Section is resident and "long-lockable" (VDDs and PDDs only) */
        SF_1616_ALIAS       = 0x00001000,   /**< 16:16 alias required (80x86 specific) */
        SF_BIG_BIT          = 0x00002000,   /**< Big/default bit setting (80x86 specific); see note above */
        SF_CODE_CONFORM     = 0x00004000,   /**< Section is conforming for code (80x86 specific) */
        SF_IO_PRIV          = 0x00008000    /**< Section I/O privilege level (80x86 specific; used only for 16:16 alias objects) */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_pagemap_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_pagemap_index(unsigned const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_pagemap_nentries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_pagemap_nentries(unsigned const&);
    /** @} */
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_res1(unsigned const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_mapped_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_size(rose_addr_t const&);
    /** @} */
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_base_addr() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_base_addr(rose_addr_t const&);
    /** @} */
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLESectionTableEntry(ByteOrder::Endianness sex, const SgAsmLESectionTableEntry::LESectionTableEntry_disk *disk);
    void *encode(ByteOrder::Endianness, SgAsmLESectionTableEntry::LESectionTableEntry_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLESectionTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLESectionTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESectionTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLESection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLESection);
IS_SERIALIZABLE(AsmLESection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESection.h"
class SgAsmLESection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESection.h"
    AsmLESection.setDataPrototype(
        "SgAsmLESectionTableEntry*", "st_entry", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLESection);
#if defined(SgAsmLESection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESection.h"
        s & BOOST_SERIALIZATION_NVP(p_st_entry);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLESectionTableEntry* const& get_st_entry() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_entry(SgAsmLESectionTableEntry* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLESection.h"
public:
    explicit SgAsmLESection(SgAsmLEFileHeader*);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLESection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLESection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLESection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLERelocTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLERelocTable);
IS_SERIALIZABLE(AsmLERelocTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLERelocTable.h"
class SgAsmLERelocTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLERelocTable.h"
    AsmLERelocTable.setDataPrototype(
        "SgAsmLERelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLERelocTable);
#if defined(SgAsmLERelocTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLERelocTable.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLERelocTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLERelocEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmLERelocEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmLERelocEntryPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLERelocTable.h"
public:
    SgAsmLERelocTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLERelocTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLERelocTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLERelocTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEPageTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLEPageTable);
IS_SERIALIZABLE(AsmLEPageTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTable.h"
class SgAsmLEPageTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTable.h"
    AsmLEPageTable.setDataPrototype(
        "SgAsmLEPageTableEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLEPageTable);
#if defined(SgAsmLEPageTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTable.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEPageTableEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEPageTableEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmLEPageTableEntryPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTable.h"
public:
    SgAsmLEPageTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset, rose_addr_t size);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    SgAsmLEPageTableEntry *get_page(size_t idx);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLEPageTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLEPageTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEPageTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEPageTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLEPageTableEntry);
IS_SERIALIZABLE(AsmLEPageTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
class SgAsmLEPageTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
    AsmLEPageTableEntry.setDataPrototype(
        "unsigned", "pageno", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
    AsmLEPageTableEntry.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLEPageTableEntry);
#if defined(SgAsmLEPageTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_pageno);
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /* The object page table provides information about a logical page in a section. A logical page may be an enumerated page, a
     * pseudo page, or an iterated page. The page table allows for efficient access to a page when a page fault occurs, while still
     * allowing the physical page to be located in the preload page, demand load page, or iterated data page sections of the
     * executable file. Entries in the page table use 1-origin indices.  This table is parallel with the Fixup Page Table (they are
     * both indexed by the logical page number). */

#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format for a page table entry */
    struct LEPageTableEntry_disk {
        uint16_t            pageno_hi;
        unsigned char       pageno_lo;
        unsigned char       flags;
    }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_pageno() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_pageno(unsigned const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEPageTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEPageTableEntry(ByteOrder::Endianness sex, const SgAsmLEPageTableEntry::LEPageTableEntry_disk *disk);
    void dump(FILE*, const char *prefix, ssize_t idx) const;
    void *encode(ByteOrder::Endianness, SgAsmLEPageTableEntry::LEPageTableEntry_disk*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLEPageTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLEPageTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEPageTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLENameTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLENameTable);
IS_SERIALIZABLE(AsmLENameTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
class SgAsmLENameTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
    AsmLENameTable.setDataPrototype(
        "SgStringList", "names", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
    AsmLENameTable.setDataPrototype(
        "SgUnsignedList", "ordinals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLENameTable);
#if defined(SgAsmLENameTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
        s & BOOST_SERIALIZATION_NVP(p_names);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
        s & BOOST_SERIALIZATION_NVP(p_ordinals);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgStringList const& get_names() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_names(SgStringList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedList const& get_ordinals() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ordinals(SgUnsignedList const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLENameTable.h"
public:
    /* This table contains a module name followed by the list of exported function names. Each name is associated with an "ordinal"
     * which serves as an index into the Entry Table. The ordinal for the first string (module name) is meaningless and should be
     * zero. In the non-resident name table the first entry is a module description and the functions are not always resident in
     * system memory (they are discardable). */
    SgAsmLENameTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLENameTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLENameTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLENameTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLEFileHeader);
IS_SERIALIZABLE(AsmLEFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
class SgAsmLEFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_byte_order", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_word_order", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 98 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_format_level", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_cpu_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_os_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_module_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_eip_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_esp_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_last_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_page_offset_shift", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_fixup_sect_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_loader_sect_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_secttab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_rsrctab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_fmtdirtab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_import_modtab_nentries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_preload_npages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_nonresnametab_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_nonresnametab_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_auto_ds_section", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_debug_info_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_num_instance_preload", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_num_instance_demand", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "unsigned", "e_heap_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_npages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 170 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_eip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_esp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_sect_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 182 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_loader_sect_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_secttab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_pagetab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 191 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_iterpages_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 194 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_rsrctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 197 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_resnametab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 200 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_entrytab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 203 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fmtdirtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 206 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_pagetab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 209 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_fixup_rectab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 212 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_import_modtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 215 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_import_proctab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 218 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_ppcksumtab_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 221 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_data_pages_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 224 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_nonresnametab_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 227 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "rose_addr_t", "e_debug_info_rfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 230 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmDOSExtendedHeader*", "dos2_header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 233 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLESectionTable*", "section_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 236 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLEPageTable*", "page_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 239 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLENameTable*", "resname_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 242 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLENameTable*", "nonresname_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 245 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLEEntryTable*", "entry_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 248 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    AsmLEFileHeader.setDataPrototype(
        "SgAsmLERelocTable*", "reloc_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLEFileHeader);
#if defined(SgAsmLEFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_byte_order);
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_word_order);
#line 98 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_format_level);
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_cpu_type);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_os_type);
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_module_version);
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_eip_section);
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_esp_section);
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_last_page_size);
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_page_offset_shift);
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_sect_cksum);
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_loader_sect_cksum);
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_secttab_nentries);
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_nentries);
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fmtdirtab_nentries);
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_import_modtab_nentries);
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_preload_npages);
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_size);
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_cksum);
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_auto_ds_section);
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_debug_info_size);
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_num_instance_preload);
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_num_instance_demand);
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_heap_size);
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_npages);
#line 170 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_eip);
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_esp);
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_page_size);
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_sect_size);
#line 182 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_loader_sect_size);
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_secttab_rfo);
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_pagetab_rfo);
#line 191 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_iterpages_offset);
#line 194 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_rsrctab_rfo);
#line 197 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_resnametab_rfo);
#line 200 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_entrytab_rfo);
#line 203 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fmtdirtab_rfo);
#line 206 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_pagetab_rfo);
#line 209 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_fixup_rectab_rfo);
#line 212 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_import_modtab_rfo);
#line 215 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_import_proctab_rfo);
#line 218 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ppcksumtab_rfo);
#line 221 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_data_pages_offset);
#line 224 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nonresnametab_offset);
#line 227 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_debug_info_rfo);
#line 230 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_dos2_header);
#line 233 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_section_table);
#line 236 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_page_table);
#line 239 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_resname_table);
#line 242 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_nonresname_table);
#line 245 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_table);
#line 248 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_reloc_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* File format of an LE/LX File Header (they are identical except bytes 0x2c-0x2f) */
    struct LEFileHeader_disk {
        unsigned char e_magic[2];           /* 0x00 magic number "LX" */
        unsigned char e_byte_order;         /* 0x02 byte order (0=>little endian; otherwise big endian) */
        unsigned char e_word_order;         /* 0x03 word order (0=>little endian; otherwise big endian) */
        uint32_t    e_format_level;         /* 0x04 LX file format version number */
        uint16_t    e_cpu_type;             /* 0x08 1=>80286, 2=>80386, 3=>80486,4=80586, etc. (see ctor) */
        uint16_t    e_os_type;              /* 0x0a 0=>unknown, 1=>0S/2, 2=>Windows, 3=>DOS 4.x, 4=>Windows 386 */
        uint32_t    e_module_version;       /* 0x0c user-specified module version number */
        uint32_t    e_flags;                /* 0x10 bit flags (see LXFileHeaderFlags) */
        uint32_t    e_npages;               /* 0x14 number of physically contained pages (see e_page_size) */
        uint32_t    e_eip_section;          /* 0x18 the section number to which e_eip is relative */
        uint32_t    e_eip;                  /* 0x1c entry address relative to e_eip_section */
        uint32_t    e_esp_section;          /* 0x20 the section number to which e_esp is relative */
        uint32_t    e_esp;                  /* 0x24 starting stack address relative to e_esp_section */
        uint32_t    e_page_size;            /* 0x28 page size in bytes */
        uint32_t    e_lps_or_shift;         /* 0x2c size of last page (LE) or shift for page table's page offset field (LX) */
        uint32_t    e_fixup_sect_size;      /* 0x30 total size of fixup info in bytes (fixup page/record tables + import names) */
        uint32_t    e_fixup_sect_cksum;     /* 0x34 cryptographic checksum of all fixup info, or zero */
        uint32_t    e_loader_sect_size;     /* 0x38 size of memory resident tables (section table through per-page checksum table) */
        uint32_t    e_loader_sect_cksum;    /* 0x3c cryptographic checksum for all loader info, or zero */
        uint32_t    e_secttab_rfo;          /* 0x40 offset of section table relative to this header */
        uint32_t    e_secttab_nentries;     /* 0x44 number of entries in section table */
        uint32_t    e_pagetab_rfo;          /* 0x48 section page table offset relative to this header */
        uint32_t    e_iterpages_offset;     /* 0x4c section iterated pages offset (absolute file offset) */
        uint32_t    e_rsrctab_rfo;          /* 0x50 offset of resource table relative to this header */
        uint32_t    e_rsrctab_nentries;     /* 0x54 number of entries in the resource table */
        uint32_t    e_resnametab_rfo;       /* 0x58 offset of resident name table relative to this header */
        uint32_t    e_entrytab_rfo;         /* 0x5c offset of entry table relative to this header */
        uint32_t    e_fmtdirtab_rfo;        /* 0x60 offset of module format directives relative to this header */
        uint32_t    e_fmtdirtab_nentries;   /* 0x64 number of entries in module format directives table */
        uint32_t    e_fixup_pagetab_rfo;    /* 0x68 offset of fixup page table relative to this header */
        uint32_t    e_fixup_rectab_rfo;     /* 0x6c offset of fixup record table relative to this header */
        uint32_t    e_import_modtab_rfo;    /* 0x70 offset of import module name table relative to this header */
        uint32_t    e_import_modtab_nentries;/*0x74 number of entries in import module name table */
        uint32_t    e_import_proctab_rfo;   /* 0x78 offset of import procedure name table relative to this header */
        uint32_t    e_ppcksumtab_rfo;       /* 0x7c offset of per-page checksum table relative to this header */
        uint32_t    e_data_pages_offset;    /* 0x80 offset of data pages (absolute file offset) */
        uint32_t    e_preload_npages;       /* 0x84 number of preload pages (not respected by OS/2) */
        uint32_t    e_nonresnametab_offset; /* 0x88 offset of non-resident name table (absolute file offset) */
        uint32_t    e_nonresnametab_size;   /* 0x8c size of non-resident name table in bytes */
        uint32_t    e_nonresnametab_cksum;  /* 0x90 cryptographic checksum of the non-resident name table */
        uint32_t    e_auto_ds_section;      /* 0x94 auto data segment section number (not used by 32-bit modules) */
        uint32_t    e_debug_info_rfo;       /* 0x98 offset of debug information relative to this header */
        uint32_t    e_debug_info_size;      /* 0x9c size of debug information in bytes */
        uint32_t    e_num_instance_preload; /* 0xa0 number of instance data pages found in the preload section */
        uint32_t    e_num_instance_demand;  /* 0xa4 number of instance data pages found in the demand section */
        uint32_t    e_heap_size;            /* 0xa8 number of bytes added to auto data segment by loader (not used by 32-bit) */
    }                                       /* 0xac */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
          __attribute__((packed))
#endif
#endif
          ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    enum LEFileHeaderFlags {
        HF_RESERVED         = 0xbffc5ccb,   /* Reserved bits */
        HF_PROC_LIB_INIT    = 0x00000004,   /* Per-process library initialization; not used for executables */
        HF_IFIXUPS_APPLIED  = 0x00000010,   /* Sections have preferred load addresses and internal relocs have been applied */
        HF_EFIXUPS_APPLIED  = 0x00000020,   /* External fixups for the module have been applied */
        HF_PM_WINDOW_NO     = 0x00000100,   /* Incompatible with PM windowing */
        HF_PM_WINDOW_OK     = 0x00000200,   /* Compatible with PM windowing */
        HF_PM_WINDOW_USE    = 0x00000300,   /* Uses PM windowing API */
        HF_NOT_LOADABLE     = 0x00002000,   /* Module is not loadable (has errors or incrementally linked) */
        HF_PROC_LIB_TERM    = 0x40000000,   /* Per-process library termination; not used for executables */

        HF_MODTYPE_MASK     = 0x00038000,   /* Module type mask */
        HF_MODTYPE_PROG     = 0x00000000,   /* Program module (other modules cannot link to this one) */
        HF_MODTYPE_LIB      = 0x00008000,   /* Library module */
        HF_MODTYPE_PLIB     = 0x00018000,   /* Protected memory library module */
        HF_MODTYPE_PDEV     = 0x00020000,   /* Physical device driver module */
        HF_MODTYPE_VDEV     = 0x00028000    /* Virtual device driver module */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_byte_order() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_byte_order(unsigned const&);
    /** @} */
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_word_order() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_word_order(unsigned const&);
    /** @} */
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_format_level() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_format_level(unsigned const&);
    /** @} */
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_cpu_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_cpu_type(unsigned const&);
    /** @} */
#line 102 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_os_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_os_type(unsigned const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_module_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_module_version(unsigned const&);
    /** @} */
#line 108 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_flags(unsigned const&);
    /** @} */
#line 111 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_eip_section() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_eip_section(unsigned const&);
    /** @} */
#line 114 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_esp_section() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_esp_section(unsigned const&);
    /** @} */
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_last_page_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_last_page_size(unsigned const&);
    /** @} */
#line 120 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_page_offset_shift() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_page_offset_shift(unsigned const&);
    /** @} */
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_fixup_sect_cksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fixup_sect_cksum(unsigned const&);
    /** @} */
#line 126 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_loader_sect_cksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_loader_sect_cksum(unsigned const&);
    /** @} */
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_secttab_nentries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_secttab_nentries(unsigned const&);
    /** @} */
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_rsrctab_nentries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_rsrctab_nentries(unsigned const&);
    /** @} */
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_fmtdirtab_nentries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fmtdirtab_nentries(unsigned const&);
    /** @} */
#line 138 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_import_modtab_nentries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_import_modtab_nentries(unsigned const&);
    /** @} */
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_preload_npages() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_preload_npages(unsigned const&);
    /** @} */
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nonresnametab_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nonresnametab_size(unsigned const&);
    /** @} */
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_nonresnametab_cksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nonresnametab_cksum(unsigned const&);
    /** @} */
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_auto_ds_section() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_auto_ds_section(unsigned const&);
    /** @} */
#line 153 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_debug_info_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_debug_info_size(unsigned const&);
    /** @} */
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_num_instance_preload() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_num_instance_preload(unsigned const&);
    /** @} */
#line 159 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_num_instance_demand() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_num_instance_demand(unsigned const&);
    /** @} */
#line 162 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_heap_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_heap_size(unsigned const&);
    /** @} */
#line 165 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_npages() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_npages(rose_addr_t const&);
    /** @} */
#line 168 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_eip() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_eip(rose_addr_t const&);
    /** @} */
#line 171 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_esp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_esp(rose_addr_t const&);
    /** @} */
#line 174 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_page_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_page_size(rose_addr_t const&);
    /** @} */
#line 177 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fixup_sect_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fixup_sect_size(rose_addr_t const&);
    /** @} */
#line 180 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_loader_sect_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_loader_sect_size(rose_addr_t const&);
    /** @} */
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_secttab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_secttab_rfo(rose_addr_t const&);
    /** @} */
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_pagetab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_pagetab_rfo(rose_addr_t const&);
    /** @} */
#line 189 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_iterpages_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_iterpages_offset(rose_addr_t const&);
    /** @} */
#line 192 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_rsrctab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_rsrctab_rfo(rose_addr_t const&);
    /** @} */
#line 195 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_resnametab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_resnametab_rfo(rose_addr_t const&);
    /** @} */
#line 198 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_entrytab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_entrytab_rfo(rose_addr_t const&);
    /** @} */
#line 201 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fmtdirtab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fmtdirtab_rfo(rose_addr_t const&);
    /** @} */
#line 204 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fixup_pagetab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fixup_pagetab_rfo(rose_addr_t const&);
    /** @} */
#line 207 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_fixup_rectab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_fixup_rectab_rfo(rose_addr_t const&);
    /** @} */
#line 210 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_import_modtab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_import_modtab_rfo(rose_addr_t const&);
    /** @} */
#line 213 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_import_proctab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_import_proctab_rfo(rose_addr_t const&);
    /** @} */
#line 216 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_ppcksumtab_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ppcksumtab_rfo(rose_addr_t const&);
    /** @} */
#line 219 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_data_pages_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_data_pages_offset(rose_addr_t const&);
    /** @} */
#line 222 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_nonresnametab_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nonresnametab_offset(rose_addr_t const&);
    /** @} */
#line 225 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_debug_info_rfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_debug_info_rfo(rose_addr_t const&);
    /** @} */
#line 228 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDOSExtendedHeader* const& get_dos2_header() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dos2_header(SgAsmDOSExtendedHeader* const&);
    /** @} */
#line 231 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLESectionTable* const& get_section_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_table(SgAsmLESectionTable* const&);
    /** @} */
#line 234 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEPageTable* const& get_page_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_page_table(SgAsmLEPageTable* const&);
    /** @} */
#line 237 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLENameTable* const& get_resname_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_resname_table(SgAsmLENameTable* const&);
    /** @} */
#line 240 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLENameTable* const& get_nonresname_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_nonresname_table(SgAsmLENameTable* const&);
    /** @} */
#line 243 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEEntryTable* const& get_entry_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_table(SgAsmLEEntryTable* const&);
    /** @} */
#line 246 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLERelocTable* const& get_reloc_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reloc_table(SgAsmLERelocTable* const&);
    /** @} */
#line 249 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEFileHeader(SgAsmGenericFile *f, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    // Overloaded base class virtual function
    const char *format_name() const override;

    static bool is_LE (SgAsmGenericFile*);
    static SgAsmLEFileHeader *parse(SgAsmDOSFileHeader*);

private:
    void *encode(ByteOrder::Endianness sex, SgAsmLEFileHeader::LEFileHeader_disk*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLEFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLEFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEEntryTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLEEntryTable);
IS_SERIALIZABLE(AsmLEEntryTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
class SgAsmLEEntryTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
    AsmLEEntryTable.setDataPrototype(
        "SgSizeTList", "bundle_sizes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
    AsmLEEntryTable.setDataPrototype(
        "SgAsmLEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLEEntryTable);
#if defined(SgAsmLEEntryTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
        s & BOOST_SERIALIZATION_NVP(p_bundle_sizes);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgSizeTList const& get_bundle_sizes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bundle_sizes(SgSizeTList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEEntryPointPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEEntryPointPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmLEEntryPointPtrList const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryTable.h"
public:
    SgAsmLEEntryTable(SgAsmLEFileHeader *fhdr, rose_addr_t offset);
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLEEntryTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLEEntryTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEEntryTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmLEEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmLEEntryPoint);
IS_SERIALIZABLE(AsmLEEntryPoint);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
class SgAsmLEEntryPoint: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "SgAsmLEEntryPointPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "objnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "entry_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "unsigned", "res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    AsmLEEntryPoint.setDataPrototype(
        "rose_addr_t", "entry_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmLEEntryPoint);
#if defined(SgAsmLEEntryPoint_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_objnum);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_type);
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_res1);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_offset);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /* If 0x01 bit of "flags" is clear then the remainder (next 9 bytes) of the entry point is not stored in the file and the
     * next entry point description follows immediately after the flag. */
    struct LEEntryPoint_disk {
        uint8_t     flags;          /* 0x00 Bit flags (0x01=>non-empty bundle; 0x02=>32-bit entry*/
        uint16_t    objnum;         /* 0x01 Object number */
        uint8_t     entry_type;     /* 0x03 Flags for entry type */
        uint32_t    entry_offset;   /* 0x04 Offset of entry point */
        uint16_t    res1;           /* 0x08 Reserved */
    }                               /* 0x0a */
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#ifndef SWIG
#ifndef _MSC_VER
                __attribute__((packed))
#endif
#endif
                ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEEntryPointPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmLEEntryPointPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmLEEntryPointPtrList const&);
    /** @} */
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(unsigned const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_objnum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_objnum(unsigned const&);
    /** @} */
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_entry_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_type(unsigned const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_res1(unsigned const&);
    /** @} */
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_entry_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_offset(rose_addr_t const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmLEEntryPoint.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmLEEntryPoint(ByteOrder::Endianness sex, const SgAsmLEEntryPoint::LEEntryPoint_disk *disk);
    SgAsmLEEntryPoint(ByteOrder::Endianness sex, unsigned flags);
    rose_addr_t unparse(std::ostream&, ByteOrder::Endianness, const SgAsmGenericSection*, rose_addr_t spos) const;
    void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmLEEntryPoint();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmLEEntryPoint();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmLEEntryPoint_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmSourceFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmSourceFile);
IS_SERIALIZABLE(AsmJvmSourceFile);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
/** JVM SourceFile attribute.
 *
 *  A SourceFile attribute stores an index to the name of the class file, see section 4.7.10 of the JVM specification. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
class SgAsmJvmSourceFile: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
    AsmJvmSourceFile.setDataPrototype(
        "uint16_t", "sourcefile_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmSourceFile);
#if defined(SgAsmJvmSourceFile_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
        s & BOOST_SERIALIZATION_NVP(p_sourcefile_index);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_sourcefile_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sourcefile_index(uint16_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSourceFile.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmSourceFile();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmSourceFile();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmSourceFile_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmSignature           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmSignature);
IS_SERIALIZABLE(AsmJvmSignature);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
/** JVM Signature attribute.
 *
 *  A Signature attribute stores a signature for a class, interface, constructor, method, field, or record component, see section
 *  4.7.9 of the JVM specification. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
class SgAsmJvmSignature: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
    AsmJvmSignature.setDataPrototype(
        "uint16_t", "signature_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmSignature);
#if defined(SgAsmJvmSignature_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
        s & BOOST_SERIALIZATION_NVP(p_signature_index);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_signature_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_signature_index(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmSignature.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmSignature();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmSignature();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmSignature_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmModuleMainClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmModuleMainClass);
IS_SERIALIZABLE(AsmJvmModuleMainClass);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
/** JVM ModuleMainClass attribute.
 *
 *  A ModuleMainClass attribute stores a signature for a class, interface, constructor, method, field, or record component, see
 *  section 4.7.27 of the JVM specification. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
class SgAsmJvmModuleMainClass: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
    AsmJvmModuleMainClass.setDataPrototype(
        "uint16_t", "main_class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmModuleMainClass);
#if defined(SgAsmJvmModuleMainClass_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
        s & BOOST_SERIALIZATION_NVP(p_main_class_index);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_main_class_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_main_class_index(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmModuleMainClass.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmModuleMainClass();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmModuleMainClass();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmModuleMainClass_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethodTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmMethodTable);
IS_SERIALIZABLE(AsmJvmMethodTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
/** Represents a JVM method_info table/array.
 *
 *  The JVM Constant Pool is itself a section.  The entries of the table are stored with the section they describe rather than
 *  storing them all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers
 *  that are their original indices in the JVM Section Table. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
class SgAsmJvmMethodTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
    AsmJvmMethodTable.setDataPrototype(
        "SgAsmJvmMethodPtrList", "methods", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmMethodTable);
#if defined(SgAsmJvmMethodTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
        s & BOOST_SERIALIZATION_NVP(p_methods);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmMethodPtrList const& get_methods() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmMethodPtrList& get_methods();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_methods(SgAsmJvmMethodPtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethodTable.h"
public:
    /** Initialize the method table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethodTable(SgAsmJvmFileHeader*);

    /** Parses a JVM method table.
     *
     *  Parses a JVM method table and constructs and parses all methods reachable from the method table section. Returns a pointer
     *  to this object. */
    virtual SgAsmJvmMethodTable* parse() override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethodTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmMethodTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethodTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmMethod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmMethod);
IS_SERIALIZABLE(AsmJvmMethod);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
/** JVM Method.
 *
 *  A method describes an instance of an initialization method (2.9.1) and the class or interface initialization method (2.9.2), see
 *  section 4.6 of the JVM specification. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
class SgAsmJvmMethod: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    AsmJvmMethod.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    AsmJvmMethod.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    AsmJvmMethod.setDataPrototype(
        "SgAsmInstructionList*", "instruction_list", "= createAndParent<SgAsmInstructionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmMethod);
#if defined(SgAsmJvmMethod_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_name_index);
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_instruction_list);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_access_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_access_flags(uint16_t const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_name_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_index(uint16_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_descriptor_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_descriptor_index(uint16_t const&);
    /** @} */
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmInstructionList* const& get_instruction_list() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_instruction_list(SgAsmInstructionList* const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmMethod.h"
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmMethod(SgAsmJvmMethodTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmMethod* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmMethod();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmMethod();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmMethod_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLineNumberTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmLineNumberTable);
IS_SERIALIZABLE(AsmJvmLineNumberTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
/** JVM LineNumberTable attribute.
 *
 *  The LineNumberTable attribute is an optional variable-length attribute in the attributes table of a Code attribute (4.7.3). It
 *  may be used by debuggers to determine which part of the code array corresponds to a given line number in the original source
 *  file.  See section 4.7.10 of the JVM specification. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
class SgAsmJvmLineNumberTable: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
    AsmJvmLineNumberTable.setDataPrototype(
        "SgAsmJvmLineNumberEntryPtrList", "line_number_table", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmLineNumberTable);
#if defined(SgAsmJvmLineNumberTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
        s & BOOST_SERIALIZATION_NVP(p_line_number_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmLineNumberEntryPtrList const& get_line_number_table() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmLineNumberEntryPtrList& get_line_number_table();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_line_number_table(SgAsmJvmLineNumberEntryPtrList const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberTable.h"
public:
    /** Initialize the LineNumberTable attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLineNumberTable(SgAsmJvmAttribute*);

    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmLineNumberTable* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmLineNumberTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmLineNumberTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLineNumberTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmLineNumberEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmLineNumberEntry);
IS_SERIALIZABLE(AsmJvmLineNumberEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
/** JVM LineNumberEntry.
 *
 *  Each line_number is described by a line_number_table anonymous structure.  See the JVM specification, section 4.7.12. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
class SgAsmJvmLineNumberEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
    AsmJvmLineNumberEntry.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
    AsmJvmLineNumberEntry.setDataPrototype(
        "uint16_t", "line_number", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmLineNumberEntry);
#if defined(SgAsmJvmLineNumberEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_line_number);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_start_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_start_pc(uint16_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_line_number() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_line_number(uint16_t const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmLineNumberEntry.h"
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmLineNumberEntry(SgAsmJvmLineNumberTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmLineNumberEntry* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmLineNumberEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmLineNumberEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmLineNumberEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmInstruction);
IS_SERIALIZABLE(AsmJvmInstruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmJvmInstruction);
#if defined(SgAsmJvmInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
#include <Rose/BinaryAnalysis/InstructionEnumsJvm.h>
#endif // SgAsmJvmInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
/** Represents one JVS machine instruction. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
class SgAsmJvmInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
    AsmJvmInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::JvmInstructionKind", "kind", "= Rose::BinaryAnalysis::JvmInstructionKind::unknown",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmInstruction);
#if defined(SgAsmJvmInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::JvmInstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::JvmInstructionKind const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInstruction.h"
public:
    // Make a (moderately deep copy of this instruction.
    SgAsmJvmInstruction* copy() const;

    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*> &insns,
                                    rose_addr_t *target/*out*/, rose_addr_t *ret/*out*/) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*> &insns) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*> &insns) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual bool isUnknown() const override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmJvmInstruction(rose_addr_t const& address,
                        std::string const& mnemonic,
                        Rose::BinaryAnalysis::JvmInstructionKind const& kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInnerClasses           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmInnerClasses);
IS_SERIALIZABLE(AsmJvmInnerClasses);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
/** Represents a JVM InnerClasses attribute.
 *
 *  The InnerClasses attribute is a variable-length attribute in the attributes table of a ClassFile structure. See section 4.7.6 of
 *  the JVM specification.
 */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
class SgAsmJvmInnerClasses: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
    AsmJvmInnerClasses.setDataPrototype(
        "SgAsmJvmInnerClassesEntryPtrList", "classes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmInnerClasses);
#if defined(SgAsmJvmInnerClasses_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
        s & BOOST_SERIALIZATION_NVP(p_classes);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmInnerClassesEntryPtrList const& get_classes() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmInnerClassesEntryPtrList& get_classes();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_classes(SgAsmJvmInnerClassesEntryPtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClasses.h"
public:
    /** Initialize the InnerClasses attribute before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmInnerClasses(SgAsmJvmAttribute*);

    /** Parses a JVM innerclasses attribute.
     *
     *  Parses a JVM innerclasses attribute and constructs and parses all innerclasses entries reachable from the table. Returns a
     *  pointer to this object. */
    SgAsmJvmInnerClasses* parse(SgAsmJvmConstantPool*) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmInnerClasses();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmInnerClasses();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInnerClasses_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmInnerClassesEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmInnerClassesEntry);
IS_SERIALIZABLE(AsmJvmInnerClassesEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
/** A JVM InnerClasses attribute array entry.
 *
 *  See the JVM specification (section 4.7.6) for more information.
 */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
class SgAsmJvmInnerClassesEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_class_info_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "outer_class_info_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    AsmJvmInnerClassesEntry.setDataPrototype(
        "uint16_t", "inner_class_access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmInnerClassesEntry);
#if defined(SgAsmJvmInnerClassesEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_inner_class_info_index);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_outer_class_info_index);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_inner_name_index);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_inner_class_access_flags);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_inner_class_info_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_inner_class_info_index(uint16_t const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_outer_class_info_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_outer_class_info_index(uint16_t const&);
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_inner_name_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_inner_name_index(uint16_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_inner_class_access_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_inner_class_access_flags(uint16_t const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmInnerClassesEntry.h"
public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmInnerClassesEntry(SgAsmJvmInnerClasses*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmInnerClassesEntry* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmInnerClassesEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmInnerClassesEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmInnerClassesEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmFileHeader);
IS_SERIALIZABLE(AsmJvmFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
/** Represents the file header of an JVM binary container.
 *
 *  The file header contains information that the Java Virtual Machine (JVM) uses to find the various parts within the
 *  container. Most of the object properties are defined in the official JVM specification and their documentation is not
 *  replicated here.
 */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
class SgAsmJvmFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "minor_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "major_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "this_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "uint16_t", "super_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmConstantPool*", "constant_pool", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "std::list<uint16_t>", "interfaces", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmFieldTable*", "field_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmMethodTable*", "method_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    AsmJvmFileHeader.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmFileHeader);
#if defined(SgAsmJvmFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_minor_version);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_major_version);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_this_class);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_super_class);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_constant_pool);
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_interfaces);
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_field_table);
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_method_table);
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_minor_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_minor_version(uint16_t const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_major_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_major_version(uint16_t const&);
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_access_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_access_flags(uint16_t const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_this_class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_this_class(uint16_t const&);
    /** @} */
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_super_class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_super_class(uint16_t const&);
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmConstantPool* const& get_constant_pool() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_constant_pool(SgAsmJvmConstantPool* const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::list<uint16_t> const& get_interfaces() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::list<uint16_t>& get_interfaces();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_interfaces(std::list<uint16_t> const&);
    /** @} */
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmFieldTable* const& get_field_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_field_table(SgAsmJvmFieldTable* const&);
    /** @} */
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmMethodTable* const& get_method_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_method_table(SgAsmJvmMethodTable* const&);
    /** @} */
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 73 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFileHeader.h"
public:
    /** Construct a new JVM File Header with default values; ready to be initialized via parse(). */
    explicit SgAsmJvmFileHeader(SgAsmGenericFile *);

    /** Parse header from file.
     *
     *  Initialize this header with information parsed from the file and construct and parse everything that's reachable
     *  from the header. Since the size of the ELF File Header is determined by the contents of the ELF File Header as
     *  stored in the file, the size of the ELF File Header will be adjusted upward if necessary. */
    virtual SgAsmJvmFileHeader* parse() override;

    /** Returns true if a cursory look at the file indicates that it could be a JVM class file. */
    static bool is_JVM(SgAsmGenericFile*);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmFieldTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmFieldTable);
IS_SERIALIZABLE(AsmJvmFieldTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
/** Represents a JVM field_info table/array.
 *
 *  The JVM fields table is a section.  The entries of the table are stored with the section they describe rather than storing them
 *  all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers that are
 *  their original indices in the JVM Section Table. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
class SgAsmJvmFieldTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
    AsmJvmFieldTable.setDataPrototype(
        "SgAsmJvmFieldPtrList", "fields", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmFieldTable);
#if defined(SgAsmJvmFieldTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
        s & BOOST_SERIALIZATION_NVP(p_fields);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmFieldPtrList const& get_fields() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmFieldPtrList& get_fields();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_fields(SgAsmJvmFieldPtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmFieldTable.h"
public:
    /** Initialize the field table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmFieldTable(SgAsmJvmFileHeader*);

    /** Parses a JVM field table.
     *
     *  Parses a JVM field table and constructs and parses all fields reachable from the table. Returns a pointer to this object. */
    virtual SgAsmJvmFieldTable* parse() override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmFieldTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmFieldTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmFieldTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmField           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmField);
IS_SERIALIZABLE(AsmJvmField);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
/** JVM Field.
 *
 *  Each field is described by a field_info structure. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
class SgAsmJvmField: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    AsmJvmField.setDataPrototype(
        "uint16_t", "access_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    AsmJvmField.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    AsmJvmField.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    AsmJvmField.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmField);
#if defined(SgAsmJvmField_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
        s & BOOST_SERIALIZATION_NVP(p_access_flags);
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
        s & BOOST_SERIALIZATION_NVP(p_name_index);
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_access_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_access_flags(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_name_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_index(uint16_t const&);
    /** @} */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_descriptor_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_descriptor_index(uint16_t const&);
    /** @} */
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmField.h"
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmField(SgAsmJvmFieldTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmField* parse(SgAsmJvmConstantPool* pool);

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmField();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmField();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmField_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmExceptionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmExceptionTable);
IS_SERIALIZABLE(AsmJvmExceptionTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
/** Represents a JVM exception_info table/array.
 *
 *  The JVM exceptions table is an SgAsmJvmNode containing SgAsmJvmException entries. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
class SgAsmJvmExceptionTable: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
    AsmJvmExceptionTable.setDataPrototype(
        "SgAsmJvmExceptionPtrList", "exceptions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmExceptionTable);
#if defined(SgAsmJvmExceptionTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
        s & BOOST_SERIALIZATION_NVP(p_exceptions);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmExceptionPtrList const& get_exceptions() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmExceptionPtrList& get_exceptions();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exceptions(SgAsmJvmExceptionPtrList const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmExceptionTable.h"
public:
    /** Initialize the exception table before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmExceptionTable(SgAsmJvmCodeAttribute*);

    /** Parses a JVM exception table.
     *
     *  Parses a JVM exception table and constructs and parses all exceptions reachable from the table.  Returns a pointer to this
     *  object. */
    SgAsmJvmExceptionTable* parse(SgAsmJvmConstantPool*);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmExceptionTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmExceptionTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmExceptionTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmException           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmException);
IS_SERIALIZABLE(AsmJvmException);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
/** JVM Exception.
 *
 *  Each exception is described by an anonymous structure defined in Code_attribute, section 4.7.3 of the JVM specification. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
class SgAsmJvmException: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    AsmJvmException.setDataPrototype(
        "uint16_t", "start_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    AsmJvmException.setDataPrototype(
        "uint16_t", "end_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    AsmJvmException.setDataPrototype(
        "uint16_t", "handler_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    AsmJvmException.setDataPrototype(
        "uint16_t", "catch_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmException);
#if defined(SgAsmJvmException_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
        s & BOOST_SERIALIZATION_NVP(p_start_pc);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
        s & BOOST_SERIALIZATION_NVP(p_end_pc);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
        s & BOOST_SERIALIZATION_NVP(p_handler_pc);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
        s & BOOST_SERIALIZATION_NVP(p_catch_type);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_start_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_start_pc(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_end_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_end_pc(uint16_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_handler_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_handler_pc(uint16_t const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_catch_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_catch_type(uint16_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmException.h"
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmJvmException(SgAsmJvmExceptionTable*);

    /** Initialize the object by parsing content from the class file. */
    SgAsmJvmException* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmException();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmException();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmException_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmEnclosingMethod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmEnclosingMethod);
IS_SERIALIZABLE(AsmJvmEnclosingMethod);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
/** JVM EnclosingMethod attribute.
 *
 *  A class must have an EnclosingMethod attribute if and only if it represents a local class or an anonymous class, see section
 *  4.7.7 of the JVM specification. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
class SgAsmJvmEnclosingMethod: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
    AsmJvmEnclosingMethod.setDataPrototype(
        "uint16_t", "class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
    AsmJvmEnclosingMethod.setDataPrototype(
        "uint16_t", "method_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmEnclosingMethod);
#if defined(SgAsmJvmEnclosingMethod_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_class_index);
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
        s & BOOST_SERIALIZATION_NVP(p_method_index);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_class_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_class_index(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_method_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_method_index(uint16_t const&);
    /** @} */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmEnclosingMethod.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmEnclosingMethod();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmEnclosingMethod();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmEnclosingMethod_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantValue           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmConstantValue);
IS_SERIALIZABLE(AsmJvmConstantValue);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
/** JVM ConstantValue attribute.
 *
 *  A ConstantValue attribute represents the value of a constant expression, see section 4.7.2 of the JVM specification.
 */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
class SgAsmJvmConstantValue: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
    AsmJvmConstantValue.setDataPrototype(
        "uint16_t", "constantvalue_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmConstantValue);
#if defined(SgAsmJvmConstantValue_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
        s & BOOST_SERIALIZATION_NVP(p_constantvalue_index);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_constantvalue_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_constantvalue_index(uint16_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantValue.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantValue();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmConstantValue();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantValue_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantPool           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmConstantPool);
IS_SERIALIZABLE(AsmJvmConstantPool);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
/** Represents an JVM constant pool.
 *
 *  The JVM Constant Pool is itself a section.  The entries of the table are stored with the section they describe rather
 *  than storing them all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have
 *  unique ID numbers that are their original indices in the JVM Section Table. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
class SgAsmJvmConstantPool: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
    AsmJvmConstantPool.setDataPrototype(
        "SgAsmJvmConstantPoolEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmConstantPool);
#if defined(SgAsmJvmConstantPool_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmConstantPoolEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmConstantPoolEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmJvmConstantPoolEntryPtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPool.h"
public:
    /** Non-parsing constructor. */
    explicit SgAsmJvmConstantPool(SgAsmJvmFileHeader*);

    /** Parses a JVM Constant Pool.
     *
     *  Parses a JVM constant pool and constructs and parses all sections reachable from the table. The section is
     *  extended as necessary based on the number of entries and the size of each entry. Returns a pointer to this
     *  object. */
    virtual SgAsmJvmConstantPool* parse() override;

    /** Returns constant pool entry at given index.
     *
     *  Index starts at one.
     * @{ */
    SgAsmJvmConstantPoolEntry* get_entry(size_t index) const;
    /** @} */

    /** Return a string at the given index.
     *
     *  Throws an error if the index is invalid or if the constant pool entry
     *  at the index is not a CONSTANT_Utf8_info.
     */
    std::string get_utf8_string(size_t index) const;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantPool();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmConstantPool();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantPool_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmConstantPoolEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmConstantPoolEntry);
IS_SERIALIZABLE(AsmJvmConstantPoolEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
/** Represents an entry in a JVM constant pool.
 *
 *  Constant pool entries are referenced by index starting at 1.
 */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
class SgAsmJvmConstantPoolEntry: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "SgAsmJvmConstantPoolEntry::Kind", "tag", "= SgAsmJvmConstantPoolEntry::EMPTY",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "hi_bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 171 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint32_t", "low_bytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "bootstrap_method_attr_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "class_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 192 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "descriptor_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 199 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 207 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "name_and_type_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 214 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "reference_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 221 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint8_t", "reference_kind", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 228 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "string_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 235 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "uint16_t", "length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 246 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    AsmJvmConstantPoolEntry.setDataPrototype(
        "char*", "utf8_bytes", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmConstantPoolEntry);
#if defined(SgAsmJvmConstantPoolEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_tag);
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_bytes);
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_hi_bytes);
#line 171 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_low_bytes);
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_bootstrap_method_attr_index);
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_class_index);
#line 192 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_descriptor_index);
#line 199 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name_index);
#line 207 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name_and_type_index);
#line 214 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_reference_index);
#line 221 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_reference_kind);
#line 228 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_string_index);
#line 235 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_length);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constant pool tags.
     *
     * These tags indicate the kind of constant denoted by the pool entry.
     */
    enum Kind {
        EMPTY = 0,
        CONSTANT_Utf8 = 1,
        CONSTANT_Integer = 3,
        CONSTANT_Float = 4,
        CONSTANT_Long = 5,
        CONSTANT_Double = 6,
        CONSTANT_Class = 7,
        CONSTANT_String = 8,
        CONSTANT_Fieldref = 9,
        CONSTANT_Methodref = 10,
        CONSTANT_InterfaceMethodref = 11,
        CONSTANT_NameAndType = 12,
        CONSTANT_MethodHandle = 15,
        CONSTANT_MethodType = 16,
        CONSTANT_Dynamic = 17,
        CONSTANT_InvokeDynamic = 18,
        CONSTANT_Module = 19,
        CONSTANT_Package = 20
    };

#ifdef DOCUMENTATION
    /** These following structs are documented below to indicate which fields are active for each tag
     *    of an SgAsmJvmConstantPoolEntry instance. Other fields may not be accessed.
     */
#endif
    /** 4.4.1 CONSTANT_Class_info table entry. All fields are big endian. */
    struct CONSTANT_Class_info {
        uint8_t tag;
        uint16_t name_index;
    };

    /** 4.4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info, and CONSTANT_InterfaceMethodref_info table
               entries. All fields are big endian. */
    struct CONSTANT_Fieldref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_Methodref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_InterfaceMethodref_info {
        uint8_t tag;
        uint16_t class_index;
        uint16_t name_and_type_index;
    };

    /** 4.4.3 CONSTANT_String_info table entry. All fields are big endian. */
    struct CONSTANT_String_info {
        uint8_t tag;
        uint16_t string_index;
    };

    /** 4.4.4 CONSTANT_Integer_info table entry. All fields are big endian. */
    struct CONSTANT_Integer_info {
        uint8_t tag;
        uint32_t bytes;
    };
    struct CONSTANT_Float_info {
        uint8_t tag;
        uint32_t bytes;
    };
    struct CONSTANT_Long_info {
        uint8_t tag;
        uint32_t hi_bytes;
        uint32_t low_bytes;
    };
    struct CONSTANT_Double_info {
        uint8_t tag;
        uint32_t hi_bytes;
        uint32_t low_bytes;
    };

    /** 4.4.6 CONSTANT_NameAndType_info table entry. All fields are big endian. */
    struct CONSTANT_NameAndType_info {
        uint8_t tag;
        uint16_t name_index;
        uint16_t descriptor_index;
    };

    /** 4.4.7 CONSTANT_Utf8_info table entry. All fields are big endian. */
    struct CONSTANT_Utf8_info {
        uint8_t tag;
        uint16_t length;
        uint8_t* bytes;
    };

    /** 4.4.8 CONSTANT_MethodHandle_info table entry. All fields are big endian. */
    struct CONSTANT_MethodHandle_info {
        uint8_t tag;
        uint8_t reference_kind;
        uint16_t reference_index;
    };

    /** 4.4.9 CONSTANT_MethodType_info table entry. All fields are big endian. */
    struct CONSTANT_MethodType_info {
        uint8_t tag;
        uint16_t descriptor_index;
    };

    /** 4.4.10 CONSTANT_Dynamic_info table entry. All fields are big endian. */
    struct CONSTANT_Dynamic_info {
        uint8_t tag;
        uint16_t bootstrap_method_attr_index;
        uint16_t name_and_type_index;
    };
    struct CONSTANT_InvokeDynamic_info {
        uint8_t tag;
        uint16_t bootstrap_method_attr_index;
        uint16_t name_and_type_index;
    };

    /** 4.4.11 CONSTANT_Module_info table entry. All fields are big endian. */
    struct CONSTANT_Module_info {
        uint8_t tag;
        uint16_t name_index;
    };

    /** 4.4.12 CONSTANT_Package_info table entry. All fields are big endian. */
    struct CONSTANT_Package_info {
        uint8_t tag;
        uint16_t name_index;
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmConstantPoolEntry::Kind const& get_tag() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_tag(SgAsmJvmConstantPoolEntry::Kind const&);
    /** @} */
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bytes(uint32_t const&);
    /** @} */
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_hi_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hi_bytes(uint32_t const&);
    /** @} */
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_low_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_low_bytes(uint32_t const&);
    /** @} */
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 174 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_bootstrap_method_attr_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bootstrap_method_attr_index(uint16_t const&);
    /** @} */
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 181 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_class_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_class_index(uint16_t const&);
    /** @} */
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_descriptor_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_descriptor_index(uint16_t const&);
    /** @} */
#line 193 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 195 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_name_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_index(uint16_t const&);
    /** @} */
#line 200 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 202 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_name_and_type_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_and_type_index(uint16_t const&);
    /** @} */
#line 208 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 210 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_reference_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reference_index(uint16_t const&);
    /** @} */
#line 215 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 217 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_reference_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reference_kind(uint8_t const&);
    /** @} */
#line 222 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 224 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_string_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_string_index(uint16_t const&);
    /** @} */
#line 229 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 231 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_length(uint16_t const&);
    /** @} */
#line 236 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    // [Robb Matzke 2023-03-22]: I (and the serialization) have no idea what this points to, and therefore it cannot be
    // serialized. E.g., how many 'chars' should be serialized? Is the length stored in the `length` property? If so, `utf8_bytes`
    // should probably be an std::vector instead, which is a serializable thing. Furthermore, the data member cannot be 'const'
    // because that prevents it from being initialized by some de-serialization mechanisms (e.g., boost::serialize creates a default
    // constructed object and then fills it in).
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 243 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    char* const& get_utf8_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_utf8_bytes(char* const&);
    /** @} */
#line 247 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmConstantPoolEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor creating an object ready to be initialized via parse(). */
    explicit SgAsmJvmConstantPoolEntry(SgAsmJvmConstantPoolEntry::Kind tag);

    /** Initialize a constant pool entry by parsing the file.
     *
     * @{ */
    SgAsmJvmConstantPoolEntry* parse(SgAsmJvmConstantPool* pool);
    /** @} */

    /** Print some debugging information */
    void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Convert constant pool entry kind to a string */
    static std::string to_string(SgAsmJvmConstantPoolEntry::Kind);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmConstantPoolEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmConstantPoolEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmConstantPoolEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmCodeAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmCodeAttribute);
IS_SERIALIZABLE(AsmJvmCodeAttribute);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
/** JVM Code attribute.
 *
 *  A Code attribute contains the Java Virtual Machine instructions and auxiliary information for a method, including an instance
 *  initialization method and a class or interface initialization method, see section 4.7.3 of the JVM specification.
 */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
class SgAsmJvmCodeAttribute: public SgAsmJvmAttribute {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "uint16_t", "max_stack", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "uint16_t", "max_locals", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "uint32_t", "code_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "const char*", "code", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "SgAsmJvmExceptionTable*", "exception_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "SgAsmJvmAttributeTable*", "attribute_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    AsmJvmCodeAttribute.setDataPrototype(
        "rose_addr_t", "code_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmCodeAttribute);
#if defined(SgAsmJvmCodeAttribute_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmAttribute);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_max_stack);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_max_locals);
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_code_length);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_exception_table);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_table);
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_code_offset);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_max_stack() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_max_stack(uint16_t const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_max_locals() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_max_locals(uint16_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_code_length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_code_length(uint32_t const&);
    /** @} */
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    // FIXME[Robb Matzke 2023-03-20]: is the no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    const char* const& get_code() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_code(const char* const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmExceptionTable* const& get_exception_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exception_table(SgAsmJvmExceptionTable* const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributeTable* const& get_attribute_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_table(SgAsmJvmAttributeTable* const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_code_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_code_offset(rose_addr_t const&);
    /** @} */
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmCodeAttribute.h"
public:
    /** Initialize the attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool* pool) override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmCodeAttribute();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmCodeAttribute();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmCodeAttribute_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmClass);
IS_SERIALIZABLE(AsmJvmClass);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmClass.h"
/** JVM Class.
 *
 *  Each class is described by a CONSTANT_Class_info structure.  See the JVM specification section 4.4.1. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmClass.h"
class SgAsmJvmClass: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmClass);
#if defined(SgAsmJvmClass_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmClass();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmClass();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmClass_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmAttributeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmJvmAttributeTable);
IS_SERIALIZABLE(AsmJvmAttributeTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
/** Represents a JVM attribute_info table/array.
 *
 *  A JVM attribute table is a section.  The entries of the table are stored with the section they describe rather than storing them
 *  all in the SgAsmSectionTable node.  We can reconstruct the JVM Section Table since sections have unique ID numbers that are
 *  their original indices in the JVM Section Table. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
class SgAsmJvmAttributeTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
    AsmJvmAttributeTable.setDataPrototype(
        "SgAsmJvmAttributePtrList", "attributes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmAttributeTable);
#if defined(SgAsmJvmAttributeTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
        s & BOOST_SERIALIZATION_NVP(p_attributes);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributePtrList const& get_attributes() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmJvmAttributePtrList& get_attributes();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attributes(SgAsmJvmAttributePtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttributeTable.h"
public:
    /** Initialize the attribute table before parsing. */
    explicit SgAsmJvmAttributeTable(SgAsmJvmFileHeader*, SgAsmNode*);

    /** Parses a JVM attribute table.
     *
     *  Parses a JVM attribute table and constructs and parses all attributes reachable from the table section. Returns a pointer to
     *  this object. */
    using SgAsmGenericSection::parse; // Removes warning messages on some compilers
                                      // ("hidden virtual overloaded function")
    SgAsmJvmAttributeTable* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmAttributeTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmAttributeTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmAttributeTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmJvmAttribute = nonTerminalConstructor(
    "AsmJvmAttribute",
    *this,
    "AsmJvmAttribute",
    "AsmJvmAttributeTag",
    SubclassListBuilder()
        | AsmJvmCodeAttribute
        | AsmJvmConstantValue
        | AsmJvmEnclosingMethod
        | AsmJvmInnerClasses
        | AsmJvmLineNumberTable
        | AsmJvmModuleMainClass
        | AsmJvmSignature
        | AsmJvmSourceFile
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmJvmAttribute.associatedGrammar != nullptr);
AsmJvmAttribute.setCppCondition("!defined(DOCUMENTATION)");
AsmJvmAttribute.isBoostSerializable(true);
AsmJvmAttribute.setAutomaticGenerationOfConstructor(false);
AsmJvmAttribute.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
/** Base class for a JVM attribute. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
class SgAsmJvmAttribute: public SgAsmJvmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
    AsmJvmAttribute.setDataPrototype(
        "uint16_t", "attribute_name_index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
    AsmJvmAttribute.setDataPrototype(
        "uint32_t", "attribute_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmAttribute);
#if defined(SgAsmJvmAttribute_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmJvmNode);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_name_index);
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_attribute_length);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_attribute_name_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_name_index(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_attribute_length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_attribute_length(uint32_t const&);
    /** @} */
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmAttribute.h"
protected:
#if 0 // [Robb Matzke 2023-03-23]: not defined anywhere?
    /** Protected constructor for derived classes. */
    explicit SgAsmJvmAttribute(const SgAsmJvmConstantPool*);
#endif

public:
    /** Factory method returning a derived class instance. */
    static SgAsmJvmAttribute* create_attribute(SgAsmJvmConstantPool*);

    /** Initialize an attribute by parsing the file. */
    virtual SgAsmJvmAttribute* parse(SgAsmJvmConstantPool*);

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmAttribute();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmAttribute();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmAttribute_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmJvmNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmJvmNode = nonTerminalConstructor(
    "AsmJvmNode",
    *this,
    "AsmJvmNode",
    "AsmJvmNodeTag",
    SubclassListBuilder()
        | AsmJvmAttribute
        | AsmJvmClass
        | AsmJvmConstantPoolEntry
        | AsmJvmException
        | AsmJvmExceptionTable
        | AsmJvmField
        | AsmJvmInnerClassesEntry
        | AsmJvmLineNumberEntry
        | AsmJvmMethod
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmJvmNode.associatedGrammar != nullptr);
AsmJvmNode.setCppCondition("!defined(DOCUMENTATION)");
AsmJvmNode.isBoostSerializable(true);
AsmJvmNode.setAutomaticGenerationOfConstructor(false);
AsmJvmNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmNode.h"
/** Base class for JVM branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmNode.h"
class SgAsmJvmNode: public SgAsmNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmJvmNode);
#if defined(SgAsmJvmNode_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmJvmNode.h"
public:
    /** Print some debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmJvmNode();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmJvmNode();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmJvmNode_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInterpretationList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmInterpretationList);
IS_SERIALIZABLE(AsmInterpretationList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"
class SgAsmInterpretationList: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"
    AsmInterpretationList.setDataPrototype(
        "SgAsmInterpretationPtrList", "interpretations", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmInterpretationList);
#if defined(SgAsmInterpretationList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"
        s & BOOST_SERIALIZATION_NVP(p_interpretations);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmInterpretationPtrList const& get_interpretations() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmInterpretationPtrList& get_interpretations();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_interpretations(SgAsmInterpretationPtrList const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretationList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmInterpretationList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmInterpretationList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInterpretationList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInterpretation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmInterpretation);
IS_SERIALIZABLE(AsmInterpretation);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmInterpretation);
#if defined(SgAsmInterpretation_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
#include <Rose/BinaryAnalysis/BasicTypes.h>
#include <Rose/BinaryAnalysis/MemoryMap.h>
#endif // SgAsmInterpretation_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
/** Represents an interpretation of a binary container.
 *
 *  An interpretation is a collection of the parts of a binary specimen that represent a coherent program, library, core
 *  dump, etc. For instance, a Windows PE executable has a DOS interpretation and a Windows interpretation--really two
 *  executables in the one container. All the DOS-related stuff will be under one SgAsmInterpretation AST and all the
 *  Windows-related stuff will be under another SgAsmInterpretation AST. */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
class SgAsmInterpretation: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    AsmInterpretation.setDataPrototype(
        "SgAsmGenericHeaderList*", "headers", "= createAndParent<SgAsmGenericHeaderList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    AsmInterpretation.setDataPrototype(
        "SgAsmBlock*", "global_block", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    AsmInterpretation.setDataPrototype(
        "bool", "coverageComputed", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    AsmInterpretation.setDataPrototype(
        "double", "percentageCoverage", "= NAN",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmInterpretation);
#if defined(SgAsmInterpretation_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(p_headers);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(p_global_block);
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(p_map);
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(instruction_map);
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(p_coverageComputed);
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
        s & BOOST_SERIALIZATION_NVP(p_percentageCoverage);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericHeaderList* const& get_headers() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_headers(SgAsmGenericHeaderList* const&);
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmBlock* const& get_global_block() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_global_block(SgAsmBlock* const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    // ROSETTA doesn't understand this type, but we want this treated like a property whose data member name is "p_map"
    // and which has automatically generator accessors and mutators named "get_map" and "set_map" and is serialized.
#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    Rose::BinaryAnalysis::MemoryMap::Ptr p_map;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::MemoryMap::Ptr const& get_map() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_map(Rose::BinaryAnalysis::MemoryMap::Ptr const&);
    /** @} */
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    // ROSETTA doesn't understand this type, but we want it serialized. Therfore, we'll define it as a property, but we'll
    // supply our own accessor and no mutator.
#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    mutable InstructionMap instruction_map;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
         // cached instruction map

    InstructionMap& get_instruction_map(bool recompute = false);
    void set_instruction_map(const InstructionMap&);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_coverageComputed() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_coverageComputed(bool const&);
    /** @} */
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    double const& get_percentageCoverage() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_percentageCoverage(double const&);
    /** @} */
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInterpretation.h"
public:
    /** Returns a list of all files referenced by an interpretation.
     *
     *  It does this by looking at the file headers referenced by the interpretation, following their parent pointers up to
     *  an SgAsmGenericFile node, and returning a vector of those nodes with duplicate files removed. */
    SgAsmGenericFilePtrList get_files() const;

    /** Populate a map of instructions indexed by their virtual addresses.
     *
     *  This function traverses the AST rooted at the @ref get_global_block "global_block" and inserts each encountered
     *  instruction into the provided @ref InstructionMap based on its starting virtual address. */
    void insert_instructions(InstructionMap&/*in,out*/);

    /** Erase instructions from a map.
     *
     *  This function traverses the AST rooted at the @ref get_global_block "global_block" and erases each encountered
     *  instruction from the provided @ref InstructionMap based on its starting virtual address. */
    void erase_instructions(InstructionMap&/*in,out*/);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmInterpretation();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmInterpretation();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInterpretation_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIntegerValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmIntegerValueExpression);
IS_SERIALIZABLE(AsmIntegerValueExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
/**  Base class for integer values.
 *
 *  An integer value consists of an offset from an optional base node.  The base node must be some kind of object with a
 *  virtual address, such as an instruction, symbol, segment, etc.  If no base node is associated with the
 *  SgAsmIntegerValueExpression (the default situation), then a zero base address is used.
 *
 *  When a (new) base object is associated with an SgAsmIntegerValueExpression via the makeRelativeTo() method, the value
 *  of the expression does not change.  However, the value does change when the address of the associated base node
 *  changes.  For instance, one way to represent a function call to "main" is to have a CALL instruction whose operand is
 *  an SgAsmIntegerValueExpression that has a base which is either the entry instruction of "main" or the symbol for
 *  "main".  That way, if the address of "main" changes then the target address in the CALL instruction also changes.
 *
 *  The base class stores the bits that are interpretted as the signed offset. The offset is accessed with
 *  get_relativeValue() and set_relativeValue() methods. The class also defines get_absoluteValue() and
 *  set_aabsoluteValue() methods that operate on the absolute value (which isn't actually stored anywhere). */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
class SgAsmIntegerValueExpression: public SgAsmConstantExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
    AsmIntegerValueExpression.setDataPrototype(
        "SgNode*", "baseNode", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmIntegerValueExpression);
#if defined(SgAsmIntegerValueExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmConstantExpression);
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_baseNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgNode* const& get_baseNode() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_baseNode(SgNode* const&);
    /** @} */
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerValueExpression.h"
public:
    /** Construct a new value of specified type.
     *
     *  Creates a new AST node having value @p n of type @p type. See also, the constructor that takes a bit vector as the
     *  first argument, which is useful when the value is non-integral or is too large to fit in a @c uint64_t. */
    SgAsmIntegerValueExpression(uint64_t n, SgAsmType *type);

    /** Construct a new value of specified type.
     *
     *  Creates a new AST node having value @p bv of type @p type.  See also, the constructor that takes a @c uint64_t as
     *  the first argument which might be simpler to call in situations where the value is an integral type not more than
     *  64 bits. */
    SgAsmIntegerValueExpression(const Sawyer::Container::BitVector &bv, SgAsmType *type);

    /** Returns the base address of an addressable IR node. */
    static uint64_t virtualAddress(SgNode*);

    /** Returns a label for the value.
     *
     *  The label consists of the base object name (if available) or address, followed by a plus sign or minus sign,
     *  followed by the offset from that object.  The empty string is returned if this integer value expression has no base
     *  object (i.e., it's absolute).
     *
     *  If the base object has no name and the integer value points directly at the object (offset=0) then one of two
     *  things happen: if @p quiet is true, the empty string is returned, otherwise the label is the name of the node type
     *  enclosed in an extra set of angle brackets.  This is useful to indicate that a value is relative rather than
     *  absolute.  For instance, the instruction listing "call 0x004126bb" is ambiguous as to whether 0x004126bb points to
     *  a known, unnamed function, a non-entry instruction within a function, or some memory location we didn't
     *  disassemble.  But when labeled with @p quiet being false, the output will be:
     *
     *  <ul>
     *    <li>call 0x004126bb<main>; points to a function with a name</li>
     *    <li>call 0x004126bb<<Func>>; points to a function without a name</li>
     *    <li>call 0x004126bb<<Insn>>; points to an instruction that's not a function entry point</li>
     *    <li>call 0x004126bb; points to something that's not been disassembled</li>
     *  </ul> */
    std::string get_label(bool quiet=false) const;

    /** Return the number of significant bits in the value. */
    size_t get_significantBits() const;

    /** Makes the value of this integer relative to some other addressable node.
     *
     *  The absolute value of this expression is unchanged by this operation. The @p baseNode must be a type of IR node
     *  that has a virtual address, such as another instruction.  If @p baseNode is the null pointer, then the
     *  "relativeness" of this constant is removed (i.e., it will be relative to zero). */
    void makeRelativeTo(SgNode *baseNode);

    /** Returns the base address.
     *
     *  The base address is the virtual address of the associated IR node, or zero if no IR node is associated with this
     *  integer value. */
    uint64_t get_baseAddress() const;

    /** Returns the current absolute value zero filled to 64 bits.
     *
     *  The absolute value is the 64-bit sum of the 64-bit address of the base node (or zero if no base node is associated
     *  with this object) and the 64-bit offset. However, this function returns only the specified number of low-order bits
     *  zero extended to the 64-bit return type.  If @p nbits is zero, then get_significantBits() is called. */
    uint64_t get_absoluteValue(size_t nbits=0) const;

    /** Set absolute value.
     *
     *  Changes the absolute value of this integer expression without changing the base node. */
    void set_absoluteValue(uint64_t);

    /** Returns the current absolute value (base+offset) as a signed value. */
    int64_t get_signedValue() const;

    /** Get relative value.
     *
     *  Interprets the bit vector as a signed value, sign extends it to 64-bits if necessary, and returns it. */
    int64_t get_relativeValue() const;

    /** Set relative value without changing the base value.
     *
     *  The relative value is interpretted as a signed value of the specified
     *  width (defaulting to 64-bits). */
    void set_relativeValue(int64_t v, size_t nbits=64);

    uint64_t get_value() const { return get_absoluteValue(); }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmIntegerValueExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmIntegerValueExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIntegerValueExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIntegerType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmIntegerType);
IS_SERIALIZABLE(AsmIntegerType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
/** Integer types. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
class SgAsmIntegerType: public SgAsmScalarType {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
    AsmIntegerType.setDataPrototype(
        "bool", "isSigned", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmIntegerType);
#if defined(SgAsmIntegerType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmScalarType);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
        s & BOOST_SERIALIZATION_NVP(p_isSigned);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIntegerType.h"
    bool get_isSigned() const;
    /** @} */

public:
    /** Constructor with specified member values.
     *
     *  Constructs a new integer type and initializes its properties according to the arguments. */
    SgAsmIntegerType(ByteOrder::Endianness, size_t nBits, bool isSigned);

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmIntegerType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmIntegerType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIntegerType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInstructionList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmInstructionList);
IS_SERIALIZABLE(AsmInstructionList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"
/** List of SgAsmInstruction nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"
class SgAsmInstructionList: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"
    AsmInstructionList.setDataPrototype(
        "SgAsmInstructionPtrList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmInstructionList);
#if defined(SgAsmInstructionList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"
        s & BOOST_SERIALIZATION_NVP(p_instructions);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmInstructionPtrList const& get_instructions() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmInstructionPtrList& get_instructions();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_instructions(SgAsmInstructionPtrList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstructionList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmInstructionList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmInstructionList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInstructionList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmIndirectRegisterExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmIndirectRegisterExpression);
IS_SERIALIZABLE(AsmIndirectRegisterExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
/** Registers accessed indirectly.
 *
 *  An indirect register is a register whose descriptor is computed dynamically.  The dynamic descriptor is computed by
 *  reading "offset" register to obtain an integral value and adding it to the integral "index" modulo the specified
 *  "modulus" to obtain an integer @ref i. (These are all properties of this node.)  Then, the final register descriptor
 *  is calculated by adding @ref i times "stride" to the base register descriptor (@ref get_descriptor). The @ref i times
 *  "stride" multiplies each member of "stride" by @em i, and addition of two register descriptors is defined as the
 *  pair-wise addition of their elements.
 *
 *  An example of an indirect register is x86 ST(1) which has base register "st", stride={0,1,0,0}, offset
 *  register "fpstatus_top", index is 1, and modulus is 8. Thus, the dynamically-computed register is:
 *
 *  @code
 *   i = (read("fpstatus_top") + index) % modulo;
 *   result = descriptor("st") + {0,1,0,0} * i;
 *  @endcode */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
class SgAsmIndirectRegisterExpression: public SgAsmRegisterReferenceExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    AsmIndirectRegisterExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "stride", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    AsmIndirectRegisterExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    AsmIndirectRegisterExpression.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    AsmIndirectRegisterExpression.setDataPrototype(
        "size_t", "modulus", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmIndirectRegisterExpression);
#if defined(SgAsmIndirectRegisterExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmRegisterReferenceExpression);
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_stride);
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_index);
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_modulus);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::RegisterDescriptor const& get_stride() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stride(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::RegisterDescriptor const& get_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_index(size_t const&);
    /** @} */
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_modulus() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_modulus(size_t const&);
    /** @} */
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmIndirectRegisterExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmIndirectRegisterExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmIndirectRegisterExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmIndirectRegisterExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor,
                                    Rose::BinaryAnalysis::RegisterDescriptor const& stride,
                                    Rose::BinaryAnalysis::RegisterDescriptor const& offset,
                                    size_t const& index,
                                    size_t const& modulus);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmIndirectRegisterExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericSymbolList);
IS_SERIALIZABLE(AsmGenericSymbolList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"
/** Node to hold a list of symbol node pointers.
 *
 *  The only reason this node exists is because a ROSETTA limitation prevents us from storing the list directly in the nodes that
 *  need it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"
class SgAsmGenericSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"
    AsmGenericSymbolList.setDataPrototype(
        "SgAsmGenericSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericSymbolList);
#if defined(SgAsmGenericSymbolList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSymbolPtrList const& get_symbols() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSymbolPtrList& get_symbols();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgAsmGenericSymbolPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbolList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericSymbolList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericSymbolList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSymbolList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSectionList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericSectionList);
IS_SERIALIZABLE(AsmGenericSectionList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"
/** List of pointers to file sections.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being stored directly in the
 *  nodes that need it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"
class SgAsmGenericSectionList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"
    AsmGenericSectionList.setDataPrototype(
        "SgAsmGenericSectionPtrList", "sections", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericSectionList);
#if defined(SgAsmGenericSectionList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"
        s & BOOST_SERIALIZATION_NVP(p_sections);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSectionPtrList const& get_sections() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSectionPtrList& get_sections();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sections(SgAsmGenericSectionPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSectionList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericSectionList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericSectionList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSectionList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericHeaderList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericHeaderList);
IS_SERIALIZABLE(AsmGenericHeaderList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"
/** List of generic file headers.
 *
 *  The only purpose of this AST node is to hold a list of pointers which cannot be contained directly in other nodes
 *  because of ROSETTA limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"
class SgAsmGenericHeaderList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"
    AsmGenericHeaderList.setDataPrototype(
        "SgAsmGenericHeaderPtrList", "headers", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericHeaderList);
#if defined(SgAsmGenericHeaderList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"
        s & BOOST_SERIALIZATION_NVP(p_headers);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericHeaderPtrList const& get_headers() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericHeaderPtrList& get_headers();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_headers(SgAsmGenericHeaderPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeaderList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericHeaderList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericHeaderList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericHeaderList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFormat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericFormat);
IS_SERIALIZABLE(AsmGenericFormat);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
/** Basic information about an executable container. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
class SgAsmGenericFormat: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecFamily", "family", "= SgAsmGenericFormat::FAMILY_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecPurpose", "purpose", "= SgAsmGenericFormat::PURPOSE_EXECUTABLE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "ByteOrder::Endianness", "sex", "= ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "unsigned", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "bool", "is_current_version", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "SgAsmGenericFormat::ExecABI", "abi", "= SgAsmGenericFormat::ABI_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "unsigned", "abi_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    AsmGenericFormat.setDataPrototype(
        "size_t", "word_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericFormat);
#if defined(SgAsmGenericFormat_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_family);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_purpose);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_sex);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_version);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_is_current_version);
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_abi);
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_abi_version);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
        s & BOOST_SERIALIZATION_NVP(p_word_size);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFormat::ExecFamily const& get_family() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_family(SgAsmGenericFormat::ExecFamily const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFormat::ExecPurpose const& get_purpose() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_purpose(SgAsmGenericFormat::ExecPurpose const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    ByteOrder::Endianness const& get_sex() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sex(ByteOrder::Endianness const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_version(unsigned const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_is_current_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_is_current_version(bool const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFormat::ExecABI const& get_abi() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_abi(SgAsmGenericFormat::ExecABI const&);
    /** @} */
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_abi_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_abi_version(unsigned const&);
    /** @} */
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_word_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_word_size(size_t const&);
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFormat.h"
public:
    /** Print some debugging info. */
    void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericFormat();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericFormat();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFormat_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFileList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericFileList);
IS_SERIALIZABLE(AsmGenericFileList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"
/** List of AST file node pointers.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being contained directly in the nodes
 *  that need it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"
class SgAsmGenericFileList: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"
    AsmGenericFileList.setDataPrototype(
        "SgAsmGenericFilePtrList", "files", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericFileList);
#if defined(SgAsmGenericFileList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"
        s & BOOST_SERIALIZATION_NVP(p_files);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFilePtrList const& get_files() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFilePtrList& get_files();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_files(SgAsmGenericFilePtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFileList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericFileList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericFileList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFileList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericFile);
IS_SERIALIZABLE(AsmGenericFile);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmGenericFile);
#if defined(SgAsmGenericFile_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
#include <Rose/BinaryAnalysis/MemoryMap.h>
#include "DataConversion.h"
#include "StatSerializer.h"                         // non-intrusive serialization of struct stat
#endif // SgAsmGenericFile_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
/** Base class for binary files. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
class SgAsmGenericFile: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "SgAsmDwarfCompilationUnitList*", "dwarf_info", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "int", "fd", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "struct stat", "sb", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "SgFileContentList", "data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "SgAsmGenericHeaderList*", "headers", "= createAndParent<SgAsmGenericHeaderList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "SgAsmGenericSectionList*", "holes", "= createAndParent<SgAsmGenericSectionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "bool", "truncate_zeros", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "bool", "tracking_references", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "AddressIntervalSet", "referenced_extents", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    AsmGenericFile.setDataPrototype(
        "bool", "neuter", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericFile);
#if defined(SgAsmGenericFile_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_dwarf_info);
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_sb);
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_data);
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_headers);
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_holes);
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_truncate_zeros);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_tracking_references);
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_referenced_extents);
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
        s & BOOST_SERIALIZATION_NVP(p_neuter);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Section modification functions for @ref shift_extend. */
    enum AddressSpace {
        ADDRSP_MEMORY = 0x0001,
        ADDRSP_FILE   = 0x0002,
        ADDRSP_ALL    = 0x0003
    };

    /** Elasticity argument for @ref shift_extend. */
    enum Elasticity {
        ELASTIC_NONE  = 0,                          /**< Nothing is elastic; other parts of space are shifted. */
        ELASTIC_UNREF = 1,                          /**< Unreferenced address space is elastic. */
        ELASTIC_HOLE  = 2                           /**< Unreferenced and "hole" sections are elastic. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfCompilationUnitList* const& get_dwarf_info() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dwarf_info(SgAsmDwarfCompilationUnitList* const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(std::string const&);
    /** @} */
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_fd() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_fd(int const&);
    /** @} */
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    struct stat const& get_sb() const;
    /** @} */
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgFileContentList const& get_data() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_data(SgFileContentList const&);
    /** @} */
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericHeaderList* const& get_headers() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_headers(SgAsmGenericHeaderList* const&);
    /** @} */
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSectionList* const& get_holes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_holes(SgAsmGenericSectionList* const&);
    /** @} */
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_truncate_zeros() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_truncate_zeros(bool const&);
    /** @} */
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_tracking_references() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_tracking_references(bool const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    AddressIntervalSet const& get_referenced_extents() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_referenced_extents(AddressIntervalSet const&);
    /** @} */
#line 73 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_neuter() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_neuter(bool const&);
    /** @} */
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericFile.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    mutable AddressIntervalSet *p_unreferenced_cache = nullptr;
    DataConverter *p_data_converter = nullptr;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Loads file contents into memory. */
    SgAsmGenericFile* parse(std::string file_name);

    /** Call this before unparsing to make sure everything is consistent. */
    void reallocate();

    /** Mirror image of parsing an executable file.
     *
     *  The result (unless the AST has been modified) should be identical to the original file.  If the file's neuter
     *  property is true, then rather than creating a binary file, the output will contain a note indicating that the
     *  neuter property is set.  This is intended to prevent ASTs that represent malicious binaries from accidently being
     *  used to create the binary. */
    void unparse(std::ostream&) const;

    /** Extend the output file by writing the last byte if it hasn't been written yet. */
    void extend_to_eof(std::ostream&) const;

    /** Print basic info about the sections of a file. */
    void dump(FILE*) const;

    /** Print text file containing all known information about a binary file.
     *
     *  If in_cwd is set, then the file is created in the current working directory rather than the directory containing
     *  the binary file (the default is to create the file in the current working directory).  If @p ext is non-null then
     *  these characters are added to the end of the binary file name. The default null pointer causes the string ".dump"
     *  to be appended to the file name. */
    void dump_all(bool in_cwd=true, const char *ext=NULL);

    /** Print text file containing all known information about a binary file. */
    void dump_all(const std::string& dumpname);

    /** Returns the parts of the file that have never been referenced. */
    const AddressIntervalSet& get_unreferenced_extents() const;

    /** Marks part of a file as having been referenced if tracking references. */
    void mark_referenced_extent(rose_addr_t start_rva, rose_addr_t size);

    /** Property: Data converter.
     *
     *  Function to encode/decode data as it's transferred to/from disk.  The default is to do no transformation.
     *
     * @{ */
    void set_data_converter(DataConverter* dc) {p_data_converter=dc;}
    DataConverter* get_data_converter() const {return p_data_converter;}
    /** @} */

    /** Returns current size of file based on section with highest ending address. */
    rose_addr_t get_current_size() const;

    /** Returns original size of file, based on file system. */
    rose_addr_t get_orig_size() const;

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data from the file beginning at the specified byte offset (measured from the beginning
     *  of the file), placing the result in @p dst_buf, and returning the number of bytes read. If the number of bytes read
     *  is less than @p size then one of two things happen: if @p strict is true then an @ref
     *  SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise @p dst_buf is zero padded so that exactly @p
     *  size bytes are always initialized. */
    size_t read_content(rose_addr_t offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data starting at the specified (absolute) virtual address. The @p map specifies how
     *  virtual addresses are mapped to file offsets.  As bytes are read, if we encounter a virtual address that is not
     *  mapped we stop reading and do one of two things: if @p strict is set then a @ref MemoryMap::NotMapped exception is
     *  thrown; otherwise the rest of the @p dst_buf is zero filled and the number of bytes read (not filled) is
     *  returned. */
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, void *dst_buf,
                        rose_addr_t size, bool strict=true);

    /** Reads a string from a file.
     *
     *  Returns the string stored at the specified (absolute) virtual address. The returned string contains the bytes
     *  beginning at the starting virtual address and continuing until we reach a NUL byte or an address which is not
     *  mapped. If we reach an address which is not mapped then one of two things happen: if @p strict is set then a @ref
     *  MemoryMap::NotMapped exception is thrown; otherwise the string is simply terminated. The returned string does not
     *  include the NUL byte. */
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, bool strict=true);

    /** Reads a string from a file.
     *
     *  Returns the NUL-terminated string stored at the specified relative virtual address. The returned string contains
     *  the bytes beginning at the specified starting file offset and continuing until we reach a NUL byte or an invalid
     *  file offset. If we reach an invalid file offset one of two things happen: if @p strict is set (the default) then an
     *  @ref SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise the string is simply terminated. The
     *  returned string does not include the NUL byte. */
    std::string read_content_str(rose_addr_t abs_offset, bool strict=true);

    /** Property: Entire file contents. */
    const SgFileContentList& content() { return p_data; }

    /** Returns a vector that points to part of the file.
     *
     *  Returns a vector that points to part of the file content without actually ever reading or otherwise referencing the
     *  file content until the vector elements are referenced. If the desired extent falls entirely or partially outside
     *  the range of data known to the file then throw an @ref SgAsmExecutableFileFormat::ShortRead exception. This
     *  function never updates reference tracking lists for the file. */
    SgFileContentList content(rose_addr_t offset, rose_addr_t size);

    /** Returns list of all sections in the file that are memory mapped, including headers and holes. */
    SgAsmGenericSectionPtrList get_mapped_sections() const;

    /** Returns list of all sections in the file (including headers, holes, etc). */
    SgAsmGenericSectionPtrList get_sections(bool include_holes=true) const;

    /** Returns sections having specified ID across all headers, including headers and holes. */
    SgAsmGenericSectionPtrList get_sections_by_id(int id) const;

    /** Returns all sections having specified name across all headers, including headers and holes. */
    SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep='\0') const;

    /** Find sections by their offset.
     *
     *  Returns all sections that contain all of the specified portion of the file across all headers, including headers
     *  and holes. */
    SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t offset, rose_addr_t size) const;

    /** Find sections by address.
     *
     *  Returns all sections that are mapped to include the specified relative virtual address across all headers,
     *  including headers and holes. This uses the preferred mapping of the section rather than the actual mapping. */
    SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t rva) const;

    /** Find sections by address.
     *
     *  Returns all sections that are mapped to include the specified virtual address across all headers, including headers
     *  and holes. This uses the preferred mapping rather than the actual mapping. */
    SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t va) const;

    /** Find section with specified ID.
     *
     *  Returns the pointer to section with the specified ID across all headers only if there's exactly one match. Headers
     *  and holes are included in the results. */
    SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;

    /** Find section by name.
     *
     *  Returns pointer to the section with the specified name, or NULL if there isn't exactly one match. Any characters in
     *  the name after the first occurrence of SEP are ignored (default is NUL). For instance, if sep=='$' then the
     *  following names are all equivalent: .idata, .idata$, and .idata$1 */
    SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;

    /** Find section by file offset.
     *
     *  Returns single section that contains all of the specified portion of the file across all headers, including headers
     *  and holes. */
    SgAsmGenericSection *get_section_by_offset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Returns single section that is mapped to include the specified relative virtual file address across all headers,
     *  including headers and holes. */
    SgAsmGenericSection *get_section_by_rva(rose_addr_t rva, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Returns single section that is mapped to include the specified virtual address across all headers. See also
     *  @ref get_best_section_by_va. */
    SgAsmGenericSection *get_section_by_va(rose_addr_t va, size_t *nfound=0) const;

    /** Find section by address.
     *
     *  Similar to @ref get_section_by_va except when more than one section contains the specified virtual address this
     *  choose the "best" one. All candidates must map the virtual address to the same file address or else we fail (return
     *  null and number of candidates). See @ref best_section_by_va for definition of "best". */
    SgAsmGenericSection *get_best_section_by_va(rose_addr_t va, size_t *nfound=0) const;

    /** Definition for "best".
     *
     *  This is the definition of "best" as used by @ref get_best_section_by_va and @ref
     *  SgAsmGenericHeader::get_best_section_by_va.  The specified list of sections is scanned and the best one
     *  containing the specified virtual address is returned.  The operation is equivalent to the successive elimination of
     *  bad sections: first eliminate all sections that do not contain the virtual address.  If more than one remains,
     *  eliminate all but the smallest.  If two or more are tied in size and at least one has a name, eliminate those that
     *  don't have names.  If more than one section remains, return the section that is earliest in the specified list of
     *  sections.  Return the null pointer if no section contains the specified virtual address, or if any two sections
     *  that contain the virtual address map it to different parts of the underlying binary file. */
    static SgAsmGenericSection *best_section_by_va(const SgAsmGenericSectionPtrList &sections, rose_addr_t va);

    /** Moves and enlarges a section.
     *
     *  Shifts (to a higher offset) and/or enlarges the specified section, S, taking all other sections into account. The
     *  positions of sections are based on their preferred virtual mappings rather than the actual mapping.
     *
     *  The neighborhood(S) is S itself and the set of all sections that overlap or are adjacent to the neighborhood of S,
     *  recursively.
     *
     *  The address space can be partitioned into three categories:
     *  @li Section: part of an address space that is referenced by an SgAsmGenericSection other than a "hole" section.
     *  @li Hole:    part of an address space that is referenced only by a "hole" section.
     *  @li Unref:   part of an address space that is not used by any section, including any "hole" section.
     *
     *  The last two categories define parts of the address space that can be optionally elastic--they expand or contract
     *  to take up slack or provide space for neighboring sections. This is controlled by the "elasticity" argument.
     *
     *  Note that when elasticity is ELASTIC_HOLE we simply ignore the "hole" sections, effectively removing their
     *  addresses from the range of addresses under consideration. This avoids complications that arise when a "hole"
     *  overlaps with a real section (due to someone changing offsets in an incompatible manner), but causes the hole
     *  offset and size to remain fixed.  (FIXME RPM 2008-10-20)
     *
     *  When section S is shifted by 'Sa' bytes and/or enlarged by 'Sn' bytes, other sections are affected as follows:
     *  @li Cat L:  Not affected
     *  @li Cat R: Shifted by Sa+Sn if they are in neighborhood(S). Otherwise the amount of shifting depends on the size of
     *      the hole right of neighborhood(S).
     *  @li Cat C:  Shifted Sa and enlarged Sn.
     *  @li Cat O:  If starting address are the same: Shifted Sa. If starting address not equal: Englarged Sa+Sn
     *  @li Cat I:  Shifted Sa, not enlarged
     *  @li Cat B:  Not shifted, but enlarged Sn
     *  @li Cat E:  Shifted Sa and enlarged Sn
     *
     *  Generally speaking, the AddressSpace argument should be SgAsmGenericFile::ADDRSP_ALL in order to adjust both file
     *  and memory offsets and sizes in a consistent manner.
     *
     *  To change the address and/or size of S without regard to other sections in the same file, use set_offset() and
     *  set_size() (for file address space) or set_mapped_preferred_rva() and set_mapped_size() (for memory address
     *  space).
     *
     * @{ */
    void shift_extend(SgAsmGenericSection*, rose_addr_t sa, rose_addr_t sn, AddressSpace, Elasticity);
    void shift_extend(SgAsmGenericSection *s, rose_addr_t sa, rose_addr_t sn) {
        shift_extend(s, sa, sn, ADDRSP_ALL, ELASTIC_UNREF);
    }
    /** @} */

    /** File offset of next section.
     *
     *  Given a file address, return the file offset of the following section.  If there is no following section then
     *  return an address of -1 (when signed) */
    rose_addr_t get_next_section_offset(rose_addr_t offset);

    /** Adds a new hole to the file.
     *
     *  This is called implicitly by the hole constructor. */
    void add_hole(SgAsmGenericSection*);

    /** Removes a hole from the list of holes in a file. */
    void remove_hole(SgAsmGenericSection*);

    /** Find holes in file and create sections to fill them.
     *
     *  Synthesizes "hole" sections to describe the parts of the file that are not yet referenced by other sections.  Note
     *  that holes are used to represent parts of the original file data, before sections were modified by walking the AST
     *  (at this time it is not possible to create a hole outside the original file content). */
    void fill_holes();

    /** Deletes "hole" sections.
     *
     *  Undoes what @ref fill_holes did. */
    void unfill_holes();

    /** Adds a new header to the file.
     *
     *  This is called implicitly by the header constructor */
    void add_header(SgAsmGenericHeader*);

    /** Removes a header from the header list in a file. */
    void remove_header(SgAsmGenericHeader*);

    /** Returns the header for the specified format. */
    SgAsmGenericHeader *get_header(SgAsmExecutableFileFormat::ExecFamily);

    /** Return a string describing the file format.
     *
     *  This uses the last header so that files like PE, NE, LE, LX, etc. which also have a DOS header report the format of
     *  the second (PE, etc.) header rather than the DOS header. */
    const char *format_name() const;

protected:
    // Some extra clean-up actions on destruction
    virtual void destructorHelper() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericFile();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericFile();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericFile_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericDLLList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericDLLList);
IS_SERIALIZABLE(AsmGenericDLLList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"
/** List of pointers to other nodes.
 *
 *  The only reason this node type exists is because ROSETTA limitations prevent the list from being included directly in the nodes
 *  that need the list. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"
class SgAsmGenericDLLList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"
    AsmGenericDLLList.setDataPrototype(
        "SgAsmGenericDLLPtrList", "dlls", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericDLLList);
#if defined(SgAsmGenericDLLList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"
        s & BOOST_SERIALIZATION_NVP(p_dlls);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericDLLPtrList const& get_dlls() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericDLLPtrList& get_dlls();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dlls(SgAsmGenericDLLPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLLList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericDLLList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericDLLList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericDLLList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericDLL           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmGenericDLL);
IS_SERIALIZABLE(AsmGenericDLL);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
/** Base class for dynamically linked library information. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
class SgAsmGenericDLL: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
    AsmGenericDLL.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmGenericString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
    AsmGenericDLL.setDataPrototype(
        "SgStringList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericDLL);
#if defined(SgAsmGenericDLL_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
    void set_name(SgAsmGenericString *s);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgStringList const& get_symbols() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgStringList const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericDLL.h"
public:
    /** Constructor that initializes the name. */
    explicit SgAsmGenericDLL(SgAsmGenericString *s);

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Add a needed symbol to the import list for this DLL. */
    void add_symbol(const std::string &s) {
        p_symbols.push_back(s);
    }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericDLL();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericDLL();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericDLL_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFunction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmFunction);
IS_SERIALIZABLE(AsmFunction);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
/** Represents a synthesized function.
 *
 *  A function is a collection of blocks holding instructions (basic blocks) or static data.  Instructions might have
 *  references to addresses or data which are described by symbols (not to be confused with the binary's symbol table) in
 *  the function's symbol table (@ref get_symbol_table).  Functions do not explicitly exist in a binary, but are
 *  synthesized by ROSE as part of the disassembly and partitioning steps. The individual instructions and/or individual
 *  static data areas need not cover a contiguous region of the address space.  Some synthesized functions will likely not
 *  be a "function" or "produceure" in the strict sense of those words due to such factors as compiler optimizations,
 *  hand-coded routines, exception handling, non-local branching, shortcomings of ROSE's partitioning solvers, etc. In any
 *  case, each function will have one primary entry address.  Although the AST requires that every function have its own
 *  basic block children, which have their own instructions (definition of "tree" data structures), logically two functions
 *  might share basic blocks, although this is uncommon.
 *
 *  Warning: Although currently basic blocks are direct children of function nodes in the AST, this may change in a future
 *  version of ROSE as new node types are introduced to describe scopes and control structures. */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
class SgAsmFunction: public SgAsmSynthesizedDeclaration {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "unsigned", "reason", "= SgAsmFunction::FUNC_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "std::string", "reasonComment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "SgAsmFunction::function_kind_enum", "function_kind", "= SgAsmFunction::e_unknown",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "SgAsmFunction::MayReturn", "may_return", "= SgAsmFunction::RET_UNKNOWN",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "std::string", "name_md5", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "SgAsmStatementPtrList", "statementList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "SgAsmStatementPtrList", "dest", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "rose_addr_t", "entry_va", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 190 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "SgSymbolTable*", "symbol_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 194 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "size_t", "cached_vertex", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 204 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "int64_t", "stackDelta", "= SgAsmInstruction::INVALID_STACK_DELTA",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 213 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    AsmFunction.setDataPrototype(
        "std::string", "callingConvention", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmFunction);
#if defined(SgAsmFunction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmSynthesizedDeclaration);
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_reason);
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_reasonComment);
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_function_kind);
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_may_return);
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_name_md5);
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_statementList);
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_dest);
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_va);
#line 194 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_cached_vertex);
#line 204 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_stackDelta);
#line 213 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
        s & BOOST_SERIALIZATION_NVP(p_callingConvention);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Whether a function returns. */
    enum MayReturn {
            RET_UNKNOWN,                    /**< It is unknown whether this function ever returns or not. */
            RET_NEVER,                      /**< This function is known to never return. */
            RET_SOMETIMES,                  /**< This function may return or not, depending on how it is called. */
            RET_ALWAYS                      /**< This function returns each time it is called. */
    };

    /** Reasons why an instruction might be considered the beginning of a function. These bit flags are also used by
     *  the instruction partitioner (Partitioner class) to determine what heuristics are used when partitioning
     *  instructions into functions. */
    enum FunctionReason {
            // NOTE: If you add more here, then fix Partitioner::parse_switches()
            //       Also fix SgAsmFunction::reason_key()
            FUNC_NONE        = 0x00000000,  /**< Used for initialization; not a bit flag. */
            FUNC_THUNK_TARGET= 0x00004000,  /**< Function is the target of a thunk. */
            FUNC_EXCEPTION_HANDLER
                             = 0x00008000,  /**< Function for handling an exception. */
            FUNC_ENTRY_POINT = 0x00010000,  /**< An entry point specified in the file header. */
            FUNC_CALL_TARGET = 0x00020000,  /**< Target of a function call instruction sequence in the CFG. When used as
                                             *   a partitioning heuristic, the partitioner will create new functions when
                                             *   it discovers a call-like sequence while traversing the CFG. */
            FUNC_CALL_INSN   = 0x00040000,  /**< Target of call, possibly not in the CFG (see Partitioner::mark_call_insns).
                                             *   When used as a partitioning heuristic, the partitioner will search all
                                             *   available instructions for instances of call-like instructions and define
                                             *   a function for each target. The function entry points added in this way
                                             *   become initial nodes of the CFG which is used by some of
                                             *   the other function discovery methods, including FUNC_CALL_TARGET. */
            FUNC_EH_FRAME    = 0x00080000,  /**< Address mentioned in the ELF .eh_frame section. */
            FUNC_SYMBOL      = 0x00100000,  /**< Address of a function symbol in a symbol table. */
            FUNC_PATTERN     = 0x00200000,  /**< Appears to be a function based on pattern of instructions. When used as
                                             *   a partitioning heuristic, the partitioner will search through all available
                                             *   instructions and create function entry points. The function entry points are
                                             *   added to the CFG which is used by some of the other function discovery
                                             *   methods. */
            FUNC_GRAPH       = 0x00400000,  /**< Implied by inter-basicblock branching. When used as a partitioning
                                             *   heuristic, the partitioner creates a new function when it discovers, by
                                             *   CFG traversal, that two different functions branch to a common basic block.
                                             *   The block in common becomes a new function under this rule. */
            FUNC_USERDEF     = 0x00800000,  /**< User-defined algorithm. See Partitioner::addFunctionDetector(). */
            FUNC_PADDING     = 0x01000000,  /**< Created to represent NOP padding between other functions. When used as a
                                             *   partitioning heuristic, the partitioner searches for padding after all
                                             *   CFG-based analysis has completed.  Padding can consist of either NOP
                                             *   instructions or zero bytes. The former requires that instructions at the
                                             *   interfunction addresses have been disassembled. */
            FUNC_DISCONT     = 0x02000000,  /**< Blocks of function are not contiguous in memory. This is not a partitioner
                                             *   heuristic, but rather only an indication of whether the function's basic
                                             *   blocks occupy contiguous memory locations. */
            FUNC_INSNHEAD    = 0x04000000,  /**< Initial instructions not in any other function. (UNUSED?) */
            FUNC_IMPORT      = 0x08000000,  /**< Functions dynamically linked. For ELF containers, these are the entries
                                             *   in the procedure lookup table (PLT). When used as a partitioning heuristic,
                                             *   the partitioner will scan the PLT and define a function for each entry. */
            FUNC_LEFTOVERS   = 0x10000000,  /**< Generated function to hold blocks that are otherwise not part of
                                             *   any function.  If this bit is turned off then the instruction
                                             *   Partitioner will delete instructions that it couldn't assign to
                                             *   a function. */
            FUNC_INTRABLOCK  = 0x20000000,  /**< Function contains basic blocks that were inserted by searching the
                                             *   address space between the blocks discovered by analyzing the control flow.
                                             *   Blocks added by this algorithm do not take control flow into account, and
                                             *   therefore, the global control flow graph (CFG) may have edges into the
                                             *   middle of such blocks, or such blocks may have edges into the middle of
                                             *   other blocks, including inter-function edges.  Also, blocks added by this
                                             *   method might not represent true instructions, but rather data that was
                                             *   disassembled as instructions. */
            FUNC_THUNK       = 0x40000000,  /**< Function is a thunk.  Thunks are small pieces of code whose only purpose
                                             *   is to branch to another function.  Depending on how the disassembler and
                                             *   partitioner are run, a thunk can exist either as its own function or the
                                             *   thunk's instructions will be subsumed by the called function.  The
                                             *   partitioner only sets this flag for functions that are created due to
                                             *   the thunk recognition pass; other functions that don't have this bit set
                                             *   might also be thunks, and functions that have this bit set might not
                                             *   be a thunk.  The Partitioner::is_thunk() method will return true for
                                             *   functions whose content looks like a thunk. */
            FUNC_EXPORT      = 0x80000000,  /**< Exported function. These are the functions that appear in a PE export
                                             *   table. */
            FUNC_DEFAULT     = 0xefff80ff,  /**< Default value for Partitioner class. */

            /*========= Miscellaneous Reasons ===========================================================================
             * The first half of the range (1-127, inclusive) is used for algorithms defined by ROSE.  The second half is
             * availalble for users to use as they see fit. */
            FUNC_MISCMASK    = 0x000000ff,  /**< Miscellaneous.  These are all the other special purpose function detectors
                                             *   that are implemented in the Partitioner. Each one is identified by an
                                             *   eight-bit integer stored in the low order bits.  Only one such reason can
                                             *   be stored at a time.  These are not used to control which partitioning
                                             *   heuristics to use, but rather to indicate which one (of possibly many)
                                             *   that detected the function. */
            FUNC_INTERPADFUNC = 1,          /**< Detected by Partitioner::FindInterPadFunctions, which looks for unassigned
                                             *   space between two inter-function padding blocks and makes the first such
                                             *   address the beginning of one of these functions. */
            FUNC_PESCRAMBLER_DISPATCH = 2, /**<  Dispatcher function for code generated by pescrambler. */
            FUNC_CONFIGURED = 3,           /**<  Function is defined in a configuration file. */
            FUNC_CMDLINE = 4,              /**<  Function mentioned on the command-line. */
            FUNC_SCAN_RO_DATA = 5,         /**<  Address was found in read-only data area by scanning the data. */
            FUNC_INSN_RO_DATA = 6,         /**<  Address was found in read-only data referenced by an existing
                                            *    instruction. */
    };

    /** Constants for the "function_kind" property. */
    enum function_kind_enum {
        e_unknown  = 0,
        e_standard = 1,
        e_library  = 2,
        e_imported = 3,
        e_thunk     = 4,
        e_last
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(std::string const&);
    /** @} */
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 138 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_reason() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reason(unsigned const&);
    /** @} */
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_reasonComment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reasonComment(std::string const&);
    /** @} */
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 153 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmFunction::function_kind_enum const& get_function_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_function_kind(SgAsmFunction::function_kind_enum const&);
    /** @} */
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 159 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmFunction::MayReturn const& get_may_return() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_may_return(SgAsmFunction::MayReturn const&);
    /** @} */
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name_md5() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name_md5(std::string const&);
    /** @} */
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmStatementPtrList const& get_statementList() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmStatementPtrList& get_statementList();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_statementList(SgAsmStatementPtrList const&);
    /** @} */
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    // FIXME[Robb P Matzke 2017-02-13]: unused?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmStatementPtrList const& get_dest() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dest(SgAsmStatementPtrList const&);
    /** @} */
#line 177 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_entry_va() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_va(rose_addr_t const&);
    /** @} */
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgSymbolTable* const& get_symbol_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbol_table(SgSymbolTable* const&);
    /** @} */
#line 191 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    // FIXME[Robb P Matzke 2017-02-13]: what is this?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_cached_vertex() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_cached_vertex(size_t const&);
    /** @} */
#line 195 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 197 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int64_t const& get_stackDelta() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stackDelta(int64_t const&);
    /** @} */
#line 205 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 207 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_callingConvention() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_callingConvention(std::string const&);
    /** @} */
#line 214 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFunction.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Adds statement to end of statement list. */
    void append_statement(SgAsmStatement*);

    /** Erases statement from statement list.
     *
     *  If the specified statement is found in the list of statements then it is erased without being deleted. */
    void remove_statement(SgAsmStatement* statement);

    /** Function entry basic block.
     *
     *  Returns the basic block that represents the function primary entry point. Returns null for a function
     *  that contains no instructions. */
    SgAsmBlock* get_entry_block() const;

    /** Multi-line description of function reason keys from unparser.
     *
     *  Returns a string that describes what the one-letter function reasons mean in the unparser output. */
    static std::string reason_key(const std::string &prefix="");

    /** Returns a very short string describing the reason mask. */
    std::string reason_str(bool pad) const;

    /** Class method that converts a reason bit vector to a human-friendly string.
     *
     *  The second argument is the bit vector of SgAsmFunction::FunctionReason bits. */
    static std::string reason_str(bool pad, unsigned reason);

    /** Selection functor for SgAsmFunction::get_extent(). */
    class NodeSelector {
    public:
            virtual ~NodeSelector() {}
            virtual bool operator()(SgNode*) = 0;
    };

    /** Returns information about the function addresses.
     *
     *  Every non-empty function has a minimum (inclusive) and maximum (exclusive) address which are returned by reference,
     *  but not all functions own all the bytes within that range of addresses. Therefore, the exact bytes are returned by
     *  adding them to the optional ExtentMap argument.  This function returns the number of nodes (instructions and static
     *  data items) in the function.  If the function contains no nodes then @p extents is not modified and the low and
     *  high addresses are both set to zero.
     *
     *  If an @p selector functor is provided, then only nodes for which it returns true are considered part of the
     *  function.  This can be used for such things as filtering out data blocks that are marked as padding.  For example:
     *
     *  @code
     *  class NotPadding: public SgAsmFunction::NodeSelector {
     *  public:
     *      virtual bool operator()(SgNode *node) {
     *          SgAsmStaticData *data = isSgAsmStaticData(node);
     *          SgAsmBlock *block = SageInterface::getEnclosingNode<SgAsmBlock>(data);
     *          return !data || !block || block->get_reason()!=SgAsmBlock::BLK_PADDING;
     *      }
     *  } notPadding;
     *
     *  AddressIntervalSet extents;
     *  function->get_extent(&extents, NULL, NULL, &notPadding);
     *  @endcode
     *
     *  Here's another example that calculates the extent of only the padding data, based on the negation of the filter in
     *  the previous example:
     *
     *  @code
     *  class OnlyPadding: public NotPadding {
     *  public:
     *      virtual bool operator()(SgNode *node) {
     *          return !NotPadding::operator()(node);
     *      }
     *  } onlyPadding;
     *
     *  AddressIntervalSet extents;
     *  function->get_extent(&extents, NULL, NULL, &onlyPadding);
     *  @endcode */
    size_t get_extent(AddressIntervalSet *emap=NULL, rose_addr_t *lo_addr=NULL, rose_addr_t *hi_addr=NULL,
                      NodeSelector *selector=NULL);

    /** Computes the SHA1 message digest for the bytes of a function.
     *
     *  Returns true if the SHA1 is available, false if the message digest cannot be computed because the prerequisite
     *  gcrypt functions are not available. The optional @p selector argument can be used to limit the digest to only
     *  certain nodes of the function; by default, all instructions and static data are accumulated. */
    bool get_sha1(uint8_t digest[20]/*out*/, NodeSelector *selector=NULL);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmFunction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmFunction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmFunction(rose_addr_t const& address,
                  std::string const& name,
                  unsigned const& reason,
                  SgAsmFunction::function_kind_enum const& function_kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFunction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmSynthesizedDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmSynthesizedDeclaration = nonTerminalConstructor(
    "AsmSynthesizedDeclaration",
    *this,
    "AsmSynthesizedDeclaration",
    "AsmSynthesizedDeclarationTag",
    SubclassListBuilder()
        | AsmFunction
        | AsmSynthesizedDataStructureDeclaration
        | AsmSynthesizedFieldDeclaration
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmSynthesizedDeclaration.associatedGrammar != nullptr);
AsmSynthesizedDeclaration.setCppCondition("!defined(DOCUMENTATION)");
AsmSynthesizedDeclaration.isBoostSerializable(true);
AsmSynthesizedDeclaration.setAutomaticGenerationOfConstructor(false);
AsmSynthesizedDeclaration.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedDeclaration.h"
/** Base class for synthesized declarations.
 *
 *  A synthesized declaration is one created by ROSE which does not appear in the binary specimen. At one point we
 *  considered adding "synthesized" to all such intities, but later decided against it since most declarations are missing
 *  from binary specimens are are synthesized by ROSE, and would therefore lead to a lot of extra letters in many class
 *  names. */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmSynthesizedDeclaration.h"
class SgAsmSynthesizedDeclaration: public SgAsmStatement {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmSynthesizedDeclaration);
#if defined(SgAsmSynthesizedDeclaration_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmSynthesizedDeclaration();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmSynthesizedDeclaration();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmSynthesizedDeclaration(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmSynthesizedDeclaration_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFloatValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmFloatValueExpression);
IS_SERIALIZABLE(AsmFloatValueExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
/** Floating-point value.
 *
 *  The bits are stored in the super-class (SgAsmConstantExpression) and interpretted as various kinds of floating-point
 *  values. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
class SgAsmFloatValueExpression: public SgAsmConstantExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmFloatValueExpression);
#if defined(SgAsmFloatValueExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmConstantExpression);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_nativeValue);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_nativeValueIsValid);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
private:
    // This node stores its primary representation of the value in the p_bitVector of a parent class.  However, since we
    // often access the value as a native "double", and since converting to/from a bit vector is costly, we want to cache
    // the native double value whenever we compute it.  ROSETTA does not need to be aware of the cached value since it can
    // be recomputed from the bit vector, and in fact, ROSETTA can't handle cache data members because it doesn't
    // understand "mutable".
    //
    // However, Rosebud handles this just fine.
#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    mutable double p_nativeValue;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    mutable bool p_nativeValueIsValid;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatValueExpression.h"
public:
    /** Construct specified floating-point value.
     *
     *  Creates a new floating-point constant AST node having the specified native value and type. See also, the
     *  constructor that takes a bit vector as its first argument, which is useful in cases where the native representation
     *  of a floating point value does not match the target machine's representation.
     *
     *  On the other hand, the default constructor creates a new floating-point value of unspecified type initialized to positive
     *  zero.  We recommend using a constructor that takes a @ref SgAsmType argument instead. */
    SgAsmFloatValueExpression(double nativeValue, SgAsmType*);

    /** Construct specified floating-point value.
     *
     *  Creates a new floating-point constant AST node having the specified value and type.  See also, the constructor that
     *  takes a @c double argument for those cases when the native representation matches the target machine's
     *  representation. */
    SgAsmFloatValueExpression(const Sawyer::Container::BitVector&, SgAsmType*);

    /** Set AST node value to specified native value. */
    void set_nativeValue(double);

    /** Get value in native format. */
    double get_nativeValue() const;

    /** Update bit vector from native representation.
     *
     *  Resets the bit vector using the cached native representation.  The bit vector is considered to be the canonical
     *  value of this AST node. */
    void updateBitVector();

    /** Update cached native value from bit vector.
     *
     *  Resets the cached native value from the bit vector. The bit vector is considered to be the canonical value of this
     *  AST node, and the native format value is a cached representation that can be used in arithmetic. */
    void updateNativeValue() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmFloatValueExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmFloatValueExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFloatValueExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmFloatType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmFloatType);
IS_SERIALIZABLE(AsmFloatType);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmFloatType);
#if defined(SgAsmFloatType_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
#include <Sawyer/BitVector.h>
#include <Rose/BitFlags.h>
#endif // SgAsmFloatType_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
/** Floating point types. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
class SgAsmFloatType: public SgAsmScalarType {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "size_t", "significandOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "size_t", "significandNBits", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "size_t", "signBitOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "size_t", "exponentOffset", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "size_t", "exponentNBits", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "uint64_t", "exponentBias", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
    AsmFloatType.setDataPrototype(
        "unsigned", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmFloatType);
#if defined(SgAsmFloatType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmScalarType);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_significandOffset);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_significandNBits);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_signBitOffset);
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_exponentOffset);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_exponentNBits);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_exponentBias);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
public:
    /** Individual bit flags for this floating-point type. */
    enum Flag {
        GRADUAL_UNDERFLOW           = 0x00000001,   /**< De-normalized signifand when exponent field is clear. */
        IMPLICIT_BIT_CONVENTION     = 0x00000002    /**< Use IEEE 754 implicit bit convention for signicand. */
    };

    /** Collective bit flags for this floating-point type. */
    typedef Rose::BitFlags<Flag> Flags;

    /** Range of bits used for various purposes within the values of this type. */
    typedef Sawyer::Container::BitVector::BitRange BitRange;
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmFloatType.h"
public:
    /** Construct a new floating-point type. */
    SgAsmFloatType(ByteOrder::Endianness, size_t nBits,
                   const BitRange &significandBits, const BitRange exponentBits, size_t signBit,
                   uint64_t exponentBias, Flags flags);

    /** Property: Offset to significand least significant bit. */
    BitRange significandBits() const;

    /** Property: Number of bits in the exponent. */
    BitRange exponentBits() const;

    /** Property: Offset to significand sign bit. */
    size_t signBit() const;

    /** Property: Zero-point of exponent. */
    uint64_t exponentBias() const;

    /** Property: Bit vector of all boolean properties. */
    Flags flags() const;

    /** Default IEEE 754 flags.
     *
     *  These flags are the most common types and include the implicit bit convention for the significand and the
     *  gradual underflow capability. */
    static Flags ieeeFlags();

    /** Property: Whether type has gradual underflow.
     *
     *  If the type supports gradual underflow, then when the exponent field's bits are all clear then the integer part (a
     *  single bit implied or explicit depending on @ref implicitBitConvention) of the significand is zero instead of
     *  one. */
    bool gradualUnderflow() const;

    /** Property: Whether the type follows the IEEE 754 significand implicit bit convention.
     *
     *  If true, then the leading set bit of the significand is not stored but rather an implied. If the exponent field
     *  contains any non-zero bits then the integer part of the significand is one, otherwise when the exponent field
     *  is all clear the integer part is zero. */
    bool implicitBitConvention() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmFloatType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmFloatType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmFloatType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmScalarType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmScalarType = nonTerminalConstructor(
    "AsmScalarType",
    *this,
    "AsmScalarType",
    "AsmScalarTypeTag",
    SubclassListBuilder()
        | AsmFloatType
        | AsmIntegerType
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmScalarType.associatedGrammar != nullptr);
AsmScalarType.setCppCondition("!defined(DOCUMENTATION)");
AsmScalarType.isBoostSerializable(true);
AsmScalarType.setAutomaticGenerationOfConstructor(false);
AsmScalarType.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
/** Base class for scalar types. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
class SgAsmScalarType: public SgAsmType {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    AsmScalarType.setDataPrototype(
        "ByteOrder::Endianness", "minorOrder", "= ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    AsmScalarType.setDataPrototype(
        "ByteOrder::Endianness", "majorOrder", "= ByteOrder::ORDER_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    AsmScalarType.setDataPrototype(
        "size_t", "majorNBytes", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    AsmScalarType.setDataPrototype(
        "size_t", "nBits", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmScalarType);
#if defined(SgAsmScalarType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmType);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
        s & BOOST_SERIALIZATION_NVP(p_minorOrder);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
        s & BOOST_SERIALIZATION_NVP(p_majorOrder);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
        s & BOOST_SERIALIZATION_NVP(p_majorNBytes);
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
        s & BOOST_SERIALIZATION_NVP(p_nBits);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmScalarType.h"
protected:
    /** Construct a new scalar type.
     *
     *  Since scalar types are base classes, one normally does not construct just a scalar type but rather one of the base
     *  classes. */
    SgAsmScalarType(ByteOrder::Endianness, size_t nBits);

public:
    /** Property: Number of bits. */
    virtual size_t get_nBits() const override;

    /** Property: Minor byte order. This is the usual notion of byte order. */
    ByteOrder::Endianness get_minorOrder() const;

    /** Property: Major byte order for mixed-order types. */
    ByteOrder::Endianness get_majorOrder() const;

    /** Property: Stride of major byte order for mixed order types. */
    size_t get_majorNBytes() const;

    // Overrides documented in base class
    virtual void check() const override;
    virtual std::string toString() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmScalarType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmScalarType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmScalarType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmType = nonTerminalConstructor(
    "AsmType",
    *this,
    "AsmType",
    "AsmTypeTag",
    SubclassListBuilder()
        | AsmScalarType
        | AsmVectorType
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmType.associatedGrammar != nullptr);
AsmType.setCppCondition("!defined(DOCUMENTATION)");
AsmType.isBoostSerializable(true);
AsmType.setAutomaticGenerationOfConstructor(false);
AsmType.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmType.h"
/** Base class for binary types. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmType.h"
class SgAsmType: public SgAsmNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmType);
#if defined(SgAsmType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmType.h"
private:
    static Sawyer::Container::Map<std::string, SgAsmType*> p_typeRegistry;

public:
    /** Validate properties collectively.
     *
     *  This method collectively validates the properties of a type since validation is not always possible or convenient
     *  when the user modifies an individual property.  For instance, when changing the bit fields in a floating-point
     *  type, it would be very inconvenient to the user if those properties individually validated there settings because
     *  it would require the user to shuffle fields around in such a way that they never overlap. This way, the overlap
     *  validation can occur after the user is all done moving the fields. */
    virtual void check() const;

    /** Convert a type to a string.
     *
     *  The output is intended mostly for debugging since it contains more details than what would be typically useful. For
     *  instance, instead of the word "double", this will probably print all the details about where the various
     *  floating-point fields are located, how the exponent field works, etc. */
    virtual std::string toString() const {
        abort();                                    // ROSETTA limitation: intended pure virtual
        return NULL;                                // Windows limitation: return value required [Too, 2014-08-11]
    }

    /** Width of type in bits. */
    virtual size_t get_nBits() const {
        abort();                                    // ROSETTA limitation: intended pure virtual
        return (size_t)-1;                          // Windows limitation: return value required [Too, 2014-08-11]
    }

    /** Width of type in bytes. */
    virtual size_t get_nBytes() const;

    /** Registers a type with the type system.
     *
     *  This method registers the specified type by its @ref toString value so it can be found later.  If a type by the
     *  same name is already registered then the specified one is deleted.  The return value is the type that is ultimately
     *  in the registry (either one that existed their previously or the specified type). */
    template<class Type>                                    // Type is a subclass of SgAsmType
    static Type* registerOrDelete(Type *toInsert) {
        ASSERT_not_null(toInsert);
        std::string key = toInsert->toString();
        Type *retval = dynamic_cast<Type*>(p_typeRegistry.insertMaybe(key, toInsert));
        ASSERT_not_null(retval);
        if (retval!=toInsert)
            delete toInsert;
        return retval;
    }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExprListExp           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmExprListExp);
IS_SERIALIZABLE(AsmExprListExp);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"
/** List of expression nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"
class SgAsmExprListExp: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"
    AsmExprListExp.setDataPrototype(
        "SgAsmExpressionPtrList", "expressions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmExprListExp);
#if defined(SgAsmExprListExp_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"
        s & BOOST_SERIALIZATION_NVP(p_expressions);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpressionPtrList const& get_expressions() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpressionPtrList& get_expressions();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_expressions(SgAsmExpressionPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExprListExp.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmExprListExp();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmExprListExp();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExprListExp_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverSection);
IS_SERIALIZABLE(AsmElfSymverSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
/** The ELF symbol version table.
 *
 *  Often named ".gnu.version section", this section points to an @ref SgAsmElfSymverEntryPtrList containing a list of
 *  SgAsmElfSymverEntry objects. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
class SgAsmElfSymverSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
    AsmElfSymverSection.setDataPrototype(
        "SgAsmElfSymverEntryList*", "entries", "= createAndParent<SgAsmElfSymverEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverSection);
#if defined(SgAsmElfSymverSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverEntryList* const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverSection.h"
public:
    /** Construct section and link it into the AST. */
    explicit SgAsmElfSymverSection(SgAsmElfFileHeader*);

    /** Initializes section by parsing the file. */
    virtual SgAsmElfSymverSection* parse() override;

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write symver table sections back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverNeededSection);
IS_SERIALIZABLE(AsmElfSymverNeededSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
/** GNU symbol version requirements table.
 *
 *  This section is usually named ".gnu.version_r".  The format of this table is similar to the GNU Symbol Version
 *  Definitions Table, namey that the table object (@ref SgAsmElfSymverNeededSection) points to a list of entries (@ref
 *  SgAsmElfSymverNeededEntry), which of which point to a list of auxilliary information (@ref SgAsmElfSymverNeededAux). */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
class SgAsmElfSymverNeededSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
    AsmElfSymverNeededSection.setDataPrototype(
        "SgAsmElfSymverNeededEntryList*", "entries", "= createAndParent<SgAsmElfSymverNeededEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverNeededSection);
#if defined(SgAsmElfSymverNeededSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverNeededEntryList* const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededSection.h"
public:
    /** Constructor that links objec into AST.
     *
     *  This constructor adds this entry to the specified GNU Symbol Version Requirements Table. */
    SgAsmElfSymverNeededSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Parse a GNU Symbol Version Requirements Table.
     *
     *  The layout of this table is very similar to the layout of the GNU Symbol Version Definition Table and users should
     *  refer to @ref SgAsmElfSymverDefinedSection::parse for details.  Different data structures are used between the
     *  Definition and Requirements tables:
     *
     *  @li @ref SgAsmElfSymverNeededSection corresponds to SgAsmElfSymverDefinedSection.
     *  @li @ref SgAsmElfSymverNeededEntry corresponds to SgAsmElfSymverDefinedEntry.
     *  @li @ref SgAsmElfSymverNeededAux corresponds to SgAsmElfSymverDefinedAux. */
    virtual SgAsmElfSymverNeededSection* parse() override;

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write SymverNeeded section back to disk.
     *
     *  For more information about encoding, see @ref SgAsmElfSymverNeededSection::parse. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverNeededSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverNeededEntryList);
IS_SERIALIZABLE(AsmElfSymverNeededEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"
/** List of symbol version needed entries.
 *
 *  The only reason this node type exists is to hold the list of pointers. The list cannot be contained in the nodes that
 *  actually need it due to limitations of ROSETTA. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"
class SgAsmElfSymverNeededEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"
    AsmElfSymverNeededEntryList.setDataPrototype(
        "SgAsmElfSymverNeededEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverNeededEntryList);
#if defined(SgAsmElfSymverNeededEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverNeededEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverNeededEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverNeededEntry);
IS_SERIALIZABLE(AsmElfSymverNeededEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
/** One entry of the ELF symbol version needed table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
class SgAsmElfSymverNeededEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    AsmElfSymverNeededEntry.setDataPrototype(
        "size_t", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    AsmElfSymverNeededEntry.setDataPrototype(
        "SgAsmGenericString*", "file_name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    AsmElfSymverNeededEntry.setDataPrototype(
        "SgAsmElfSymverNeededAuxList*", "entries", "= createAndParent<SgAsmElfSymverNeededAuxList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverNeededEntry);
#if defined(SgAsmElfSymverNeededEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_version);
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_file_name);
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. Same for 32bit and 64bit. */
    struct ElfSymverNeededEntry_disk {
        uint16_t      vn_version;                   /**< version of this struct: This field shall be set to 1 */
        uint16_t      vn_cnt;                       /**< Number of vernaux entries @see SgAsmElfSymverNeededAux */
        uint32_t      vn_file;                      /**< Offset (in bytes) to strings table to file string */
        uint32_t      vn_aux;                       /**< Offset (in bytes) to start of array of vernaux entries */
        uint32_t      vn_next;                      /**< Offset (in bytes) to next verneed entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_version(size_t const&);
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_file_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_file_name(SgAsmGenericString* const&);
    /** @} */
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededAuxList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverNeededAuxList* const&);
    /** @} */
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that links object into the AST. */
    explicit SgAsmElfSymverNeededEntry(SgAsmElfSymverNeededSection*);

    /** Initialize object by parsing file. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*);

    /** Encode object to disk representation. */
    void *encode(ByteOrder::Endianness, SgAsmElfSymverNeededEntry::ElfSymverNeededEntry_disk*) const;

    /** Print debugging information. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverNeededEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededAuxList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverNeededAuxList);
IS_SERIALIZABLE(AsmElfSymverNeededAuxList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"
/** Hods a list of symbol version aux entries.
 *
 *  The only purpose of this node is to work around a limitation of ROSETTA that prevents this list from being contained
 *  directly in the class that needs it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"
class SgAsmElfSymverNeededAuxList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"
    AsmElfSymverNeededAuxList.setDataPrototype(
        "SgAsmElfSymverNeededAuxPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverNeededAuxList);
#if defined(SgAsmElfSymverNeededAuxList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededAuxPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverNeededAuxPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverNeededAuxPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAuxList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededAuxList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverNeededAuxList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededAuxList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverNeededAux           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverNeededAux);
IS_SERIALIZABLE(AsmElfSymverNeededAux);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
/** Auxiliary info for needed symbol version. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
class SgAsmElfSymverNeededAux: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    AsmElfSymverNeededAux.setDataPrototype(
        "uint32_t", "hash", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    AsmElfSymverNeededAux.setDataPrototype(
        "int", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    AsmElfSymverNeededAux.setDataPrototype(
        "size_t", "other", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    AsmElfSymverNeededAux.setDataPrototype(
        "SgAsmGenericString*", "name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverNeededAux);
#if defined(SgAsmElfSymverNeededAux_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
        s & BOOST_SERIALIZATION_NVP(p_hash);
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
        s & BOOST_SERIALIZATION_NVP(p_other);
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. Same for 32bit and 64bit. */
    struct ElfSymverNeededAux_disk {
        uint32_t      vna_hash;                     /**< Hash of version name */
        uint16_t      vna_flags;                    /**< Version information flag bitmask */
        uint16_t      vna_other;                    /**< Version index of this entry (bit 15 is special) */
        uint32_t      vna_name;                     /**< Offset (in bytes) to strings table to name string */
        uint32_t      vna_next;                     /**< Offset (in bytes) to next vernaux entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_hash() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hash(uint32_t const&);
    /** @} */
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(int const&);
    /** @} */
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_other() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_other(size_t const&);
    /** @} */
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(SgAsmGenericString* const&);
    /** @} */
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverNeededAux.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into AST.
     *
     *  This constructor adds this auxiliary information object to the specified entry of the specified GNU Symbol Version
     *  Requirements Table. */
    SgAsmElfSymverNeededAux(SgAsmElfSymverNeededEntry *entry, SgAsmElfSymverNeededSection *symver);

    /** Initialize this auxiliary record by parsing data from the file. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*);

    /** Encode this auxiliary record into a format that can be written to a file. */
    void *encode(ByteOrder::Endianness, SgAsmElfSymverNeededAux::ElfSymverNeededAux_disk*) const;

    /** Print debugging information.
     *
     *  Prints debugging information about this auxiliary record of an entry of the GNU Symbol Version Requirements
     *  Table. Note that this method is not normally called since @ref SgAsmElfSymverNeededEntry::dump prints the auxiliary
     *  information explicitly for a more compact listing. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverNeededAux();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverNeededAux();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverNeededAux_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverEntryList);
IS_SERIALIZABLE(AsmElfSymverEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"
/** List of entries from a symbol version table.
 *
 *  The only reason this node exists instead of storing the entries directly in the parent node that needs them is due to
 *  ROSETTA limitations. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"
class SgAsmElfSymverEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"
    AsmElfSymverEntryList.setDataPrototype(
        "SgAsmElfSymverEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverEntryList);
#if defined(SgAsmElfSymverEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverEntry);
IS_SERIALIZABLE(AsmElfSymverEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
/** Entry in an ELF symbol version table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
class SgAsmElfSymverEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
    AsmElfSymverEntry.setDataPrototype(
        "size_t", "value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverEntry);
#if defined(SgAsmElfSymverEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_value);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_value() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_value(size_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverEntry.h"
public:
    /** Constructor that links new entry into the AST. */
    explicit SgAsmElfSymverEntry(SgAsmElfSymverSection*);

    /** Prints some debugging info. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverDefinedSection);
IS_SERIALIZABLE(AsmElfSymverDefinedSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
/** The GNU symbol version definitions.
 *
 *  This section is usually named ".gnu.version_d".  The @ref SgAsmElfSymverDefinedSection points to a list of
 * entries (@ref SgAsmSymverDefinedEntry), which in turn point to a list of auxilliary members (@ref
 * SgAsmSymverDefinedAux). See @ref SgAsmSymverDefinedSection::parse for a good description of the disk format. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
class SgAsmElfSymverDefinedSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
    AsmElfSymverDefinedSection.setDataPrototype(
        "SgAsmElfSymverDefinedEntryList*", "entries", "= createAndParent<SgAsmElfSymverDefinedEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverDefinedSection);
#if defined(SgAsmElfSymverDefinedSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverDefinedEntryList* const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedSection.h"
public:
    /** Constructor linking object into AST. */
    SgAsmElfSymverDefinedSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initializes this ELF SymverDefined Section by parsing a file.
     *
     *  The structure is nominally the following (where n is from DT_VERDEFNUM - 1 in .dynamic)
     *
     *  @code
     *   [0]ElfSymverDefinedEntry_disk
     *        vd_next------------------------------------+
     *        vd_aux ---------------------------------+  |
     *        vd_cnt                                  |  |
     *      [0]       ElfSymverDefinedAux_disk <------+  |
     *                  vda_next -----------------+      |
     *      [1]       ElfSymverDefinedAux_disk <--+      |
     *         ...                                       |
     *      [vd_cnt-1]ElfSymverDefinedAux_disk           |
     *                  vda_next = 0 <== null term       |
     *   [1]ElfSymverDefinedEntry_disk <-----------------+
     *      ...
     *   [n]ElfSymverDefinedEntry_disk
     *        vd_next = 0
     *        vd_aux
     *        vd_cnt
     *      [0]       ElfSymverDefinedAux_disk
     *      [1]       ElfSymverDefinedAux_disk
     *         ...
     *      [vd_cnt-1]ElfSymverDefinedAux_disk
     *  @endcode
     *
     *  However, the spec doesn't specify any actual relationship to the layout of anything...so it could just as easily
     *  be:
     *
     *  @code
     *    [0]ElfSymverDefinedEntry_disk ---+---+
     *    [1]ElfSymverDefinedEntry_disk <--+   |
     *    ...                                  |
     *    [n]ElfSymverDefinedEntry_disk -------|---+
     *                                         |   |
     *    [0]ElfSymverDefinedAux_disk   <------+   |
     *    ...                                      |
     *    [x]ElfSymverDefinedAux_disk   <----------+
     *    [.]ElfSymverDefinedAux_disk
     *  @endcode
     *
     *  There is also nothing in particular that says Aux entries need to be next to each other.  So, the code handles the
     *  most rigidly compliant case, which is to use only the offsets and make no assumptions about layouts.
     *
     *  Also note the number of entries is specified in two ways -- via null termination on the "linked list", as well as
     *  the number from the .dynamic section [DT_VERDEFNUM].  For now, we'll support the null terminator, restricted by
     *  ensuring we don't exceed the size of the section (to keep from running away on a bad file).
     *
     *  We have a similar problem with the number of Aux's per Entry (vd_cnt versus vda_aux=0). However, in this case, we
     *  respect the min of the two (i.e. we assume cnt is right, but if vda_aux is zero earlier than expected, we stop).
     *  This is necessary because the spec allows two or more entries to point into (possibly different places) of a shared
     *  aux array.  This parser creates a new @ref SgAsmElfSymverDefinedAux object every time an element of the aux array
     *  is read from disk, ensuring that each @ref SgAsmElfSymverDefinedEntry points to its own copies.
     *
     *  All offsets are relative to the start of the struct they were specified in. I.e.,
     *
     *  @code
     *    Entry* entry=(0x0100);
     *    Aux* firstAux=(0x100 + entry->vd_aux)
     *    Aux* secondAux=(0x100 + entry->vd_aux + firstAux->vda_next)
     *
     *    Entry* secondEntry=(0x0100 + entry->vd_next);
     *  @endcode
     *
     *  Because of this rather complex structure, the section itself (@ref SgAsmElfSymverDefinedSection) manages all of the
     *  data related to structure (vd_next,vd_aux,vd_cnt, vda_next) -- the subclasses can simply ignore all of that.  The
     *  section also takes care of creating both *Entries and *Auxes and tying them together correctly. */
    virtual SgAsmElfSymverDefinedSection* parse() override;

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Write SymverDefined section back to disk.
     *
     *  For more information about encoding, see @ref parse. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverDefinedSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverDefinedEntryList);
IS_SERIALIZABLE(AsmElfSymverDefinedEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"
/** List of entries for the ELF symbol version definition table.
 *
 *  The only reason we have a dedicated AST node type for this information instead of storing it directly in the nodes that
 *  need it is due to limitations of ROSETTA. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"
class SgAsmElfSymverDefinedEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"
    AsmElfSymverDefinedEntryList.setDataPrototype(
        "SgAsmElfSymverDefinedEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverDefinedEntryList);
#if defined(SgAsmElfSymverDefinedEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverDefinedEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverDefinedEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverDefinedEntry);
IS_SERIALIZABLE(AsmElfSymverDefinedEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
/** One entry from an ELF symbol version definition table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
class SgAsmElfSymverDefinedEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    AsmElfSymverDefinedEntry.setDataPrototype(
        "size_t", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    AsmElfSymverDefinedEntry.setDataPrototype(
        "int", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    AsmElfSymverDefinedEntry.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    AsmElfSymverDefinedEntry.setDataPrototype(
        "uint32_t", "hash", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    AsmElfSymverDefinedEntry.setDataPrototype(
        "SgAsmElfSymverDefinedAuxList*", "entries", "= createAndParent<SgAsmElfSymverDefinedAuxList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverDefinedEntry);
#if defined(SgAsmElfSymverDefinedEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_version);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_index);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_hash);
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** Disk format. 32- and 64-bit formats are both the same. */
    struct ElfSymverDefinedEntry_disk {
        uint16_t      vd_version;                   /**< version of this struct: This field shall be set to 1 */
        uint16_t      vd_flags;                     /**< Version information flag bitmask */
        uint16_t      vd_ndx;                       /**< Version index of this entry */
        uint16_t      vd_cnt;                       /**< Number of verdaux entries @see SgAsmElfSymverDefinedAux */
        uint32_t      vd_hash;                      /**< Hash of version name */
        uint32_t      vd_aux;                       /**< Offset (in bytes) to start of array of verdaux entries */
        uint32_t      vd_next;                      /**< Offset (in bytes) to next verdef entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_version(size_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(int const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_index(size_t const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_hash() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hash(uint32_t const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedAuxList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverDefinedAuxList* const&);
    /** @} */
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking ojbec into the AST. */
    explicit SgAsmElfSymverDefinedEntry(SgAsmElfSymverDefinedSection *symver_defined);

    /** Initialize by parsing information from the file. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*);

    /** Convert to the disk format. */
    void *encode(ByteOrder::Endianness, SgAsmElfSymverDefinedEntry::ElfSymverDefinedEntry_disk*) const;

    /** Print some debugging info. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverDefinedEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedAuxList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverDefinedAuxList);
IS_SERIALIZABLE(AsmElfSymverDefinedAuxList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"
/** List of symbol version aux entries.
 *
 *  The only purpose of this node is to hold the list of pointers, which can't be contained in the classes that need the
 *  list due to limitations of ROSETTA. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"
class SgAsmElfSymverDefinedAuxList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"
    AsmElfSymverDefinedAuxList.setDataPrototype(
        "SgAsmElfSymverDefinedAuxPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverDefinedAuxList);
#if defined(SgAsmElfSymverDefinedAuxList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedAuxPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymverDefinedAuxPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSymverDefinedAuxPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAuxList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedAuxList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverDefinedAuxList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedAuxList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymverDefinedAux           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymverDefinedAux);
IS_SERIALIZABLE(AsmElfSymverDefinedAux);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
class SgAsmElfSymverDefinedAux: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
    AsmElfSymverDefinedAux.setDataPrototype(
        "SgAsmGenericString*", "name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymverDefinedAux);
#if defined(SgAsmElfSymverDefinedAux_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. The format is the same for 32bit and 64bit. */
    struct ElfSymverDefinedAux_disk {
        uint32_t      vda_name;                     /**< Offset (in bytes) to strings table to name string */
        uint32_t      vda_next;                     /**< Offset (in bytes) to next verdaux entry */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(SgAsmGenericString* const&);
    /** @} */
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymverDefinedAux.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into AST.
     *
     *  This constructor links this new Aux into the specified Entry of the specified Symbol Version Definition Table. */
    explicit SgAsmElfSymverDefinedAux(SgAsmElfSymverDefinedEntry *symver_def_entry, SgAsmElfSymverDefinedSection *symver_def_sec);

    /** Initialize this object with data parsed from a file. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*);

    /** Convert this object into the disk format record to be written back to the Symbol Version Definition Table. */
    void *encode(ByteOrder::Endianness, SgAsmElfSymverDefinedAux::ElfSymverDefinedAux_disk*) const;

    /** Print debugging information.
     *
     *  Shows information about the specified auxiliary data for an entry in the Symbol Version Definition Table. Note that
     *  in order to have a more compact output, @ref SgAsmElfSymverDefinedEntry::dump prints the @ref
     *  SgAsmElfSymverDefinedAux objects explicitly rather than calling this method. */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymverDefinedAux();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymverDefinedAux();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymverDefinedAux_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbolSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymbolSection);
IS_SERIALIZABLE(AsmElfSymbolSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
/** ELF file section containing symbols. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
class SgAsmElfSymbolSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
    AsmElfSymbolSection.setDataPrototype(
        "bool", "is_dynamic", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
    AsmElfSymbolSection.setDataPrototype(
        "SgAsmElfSymbolList*", "symbols", "= createAndParent<SgAsmElfSymbolList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymbolSection);
#if defined(SgAsmElfSymbolSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
        s & BOOST_SERIALIZATION_NVP(p_is_dynamic);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_is_dynamic() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_is_dynamic(bool const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymbolList* const& get_symbols() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgAsmElfSymbolList* const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolSection.h"
public:
    /** Non-parsing constructor */
    SgAsmElfSymbolSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initialize by parsing a file. */
    virtual SgAsmElfSymbolSection* parse() override;

    /** Update section pointers for locally-bound symbols.
     *
     *  Now that the section table has been read and all non-synthesized sections have been created, we can update
     *  pointers to other things.
     *
     *  The st_shndx is the index (ID) of the section to which the symbol is bound. Special values are:
     *
     *  @li 0x0000: no section (section table entry zero should be all zeros anyway)
     *  @li 0xff00-0xffff: reserved values, not an index
     *  @li 0xff00-0xff1f: processor specific values
     *  @li 0xfff1: symbol has absolute value not affected by relocation
     *  @li 0xfff2: symbol is fortran common or unallocated C extern */
    virtual void finish_parsing() override;

    /** Given a symbol, return its index in this symbol table. */
    size_t index_of(SgAsmElfSymbol*);

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *nentries) const override;

    /** Called prior to unparsing.
     *
     *  Updates symbol entries with name offsets. */
    virtual bool reallocate() override;

    /** Write symbol table sections back to disk. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymbolSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymbolSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbolSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymbolList);
IS_SERIALIZABLE(AsmElfSymbolList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"
class SgAsmElfSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"
    AsmElfSymbolList.setDataPrototype(
        "SgAsmElfSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymbolList);
#if defined(SgAsmElfSymbolList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymbolPtrList const& get_symbols() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSymbolPtrList& get_symbols();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgAsmElfSymbolPtrList const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbolList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymbolList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymbolList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbolList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSymbol);
IS_SERIALIZABLE(AsmElfSymbol);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
/** Represents a single ELF symbol.
 *
 *  Most of the properties of this node correspond directly with properties defined by the ELF specification. Their
 *  documentation is not replicated here -- refer to the specification. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
class SgAsmElfSymbol: public SgAsmGenericSymbol {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    AsmElfSymbol.setDataPrototype(
        "unsigned char", "st_info", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    AsmElfSymbol.setDataPrototype(
        "unsigned char", "st_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    AsmElfSymbol.setDataPrototype(
        "unsigned", "st_shndx", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    AsmElfSymbol.setDataPrototype(
        "rose_addr_t", "st_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    AsmElfSymbol.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSymbol);
#if defined(SgAsmElfSymbol_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSymbol);
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_info);
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_res1);
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_shndx);
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_size);
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_extra);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum ElfSymBinding {
        STB_LOCAL=0,
        STB_GLOBAL=1,
        STB_WEAK=2
    };

    enum ElfSymType {
        STT_NOTYPE      = 0,                    /**< Unspecified type */
        STT_OBJECT      = 1,                    /**< Data object */
        STT_FUNC        = 2,                    /**< Code object */
        STT_SECTION     = 3,                    /**< Associated with a section */
        STT_FILE        = 4,                    /**< Name of a file */
        STT_COMMON      = 5,                    /**< Common data object */
        STT_TLS         = 6,                    /**< Thread-local data object */
        STT_IFUNC       = 10                    /**< Indirect function. Function call w/out args results in reloc value. */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** 32-bit format of an ELF symbol. */
    struct Elf32SymbolEntry_disk {
        uint32_t      st_name;                      /**< Name offset into string table */
        uint32_t      st_value;                     /**< Value: absolute value, address, etc. depending on sym type */
        uint32_t      st_size;                      /**< Symbol size in bytes */
        unsigned char st_info;                      /**< Type and binding attributes */
        unsigned char st_res1;                      /**< Reserved; always zero */
        uint16_t      st_shndx;                     /**< Section index or special meaning */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SymbolEntry_disk {
        uint32_t      st_name;
        unsigned char st_info;
        unsigned char st_res1;
        uint16_t      st_shndx;
        uint64_t      st_value;
        uint64_t      st_size;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned char const& get_st_info() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_info(unsigned char const&);
    /** @} */
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned char const& get_st_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_res1(unsigned char const&);
    /** @} */
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_st_shndx() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_shndx(unsigned const&);
    /** @} */
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_st_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_size(rose_addr_t const&);
    /** @} */
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 90 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_extra() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_extra();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_extra(SgUnsignedCharList const&);
    /** @} */
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSymbol.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that adds the symbol to a symbol table. */
    explicit SgAsmElfSymbol(SgAsmElfSymbolSection*);

    /** Initialize symbol by parsing a symbol table entry.
     *
     *  An ELF String Section must be supplied in order to get the symbol name. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymbol::Elf32SymbolEntry_disk*);

    /** Initialize symbol by parsing a symbol table entry.
     *
     *  An ELF String Section must be supplied in order to get the symbol name. */
    void parse(ByteOrder::Endianness, const SgAsmElfSymbol::Elf64SymbolEntry_disk*);

    /** Encode a symbol into disk format.
     *
     * @{ */
    void *encode(ByteOrder::Endianness, SgAsmElfSymbol::Elf32SymbolEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfSymbol::Elf64SymbolEntry_disk*) const;
    /** @} */

    /** Print some debugging info.
     *
     *  The 'section' is an optional section pointer for the st_shndx member.
     *
     * @{ */
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const override;
    void dump(FILE*, const char *prefix, ssize_t idx, SgAsmGenericSection*) const;
    /** @} */

    /** Returns binding as an enum constant. */
    SgAsmElfSymbol::ElfSymBinding get_elf_binding() const;

    /** Returns type as an enum constant. */
    SgAsmElfSymbol::ElfSymType get_elf_type() const;

    /** Converts enum constant to string. */
    static std::string to_string(SgAsmElfSymbol::ElfSymBinding);

    /** Converts enum constant to string. */
    static std::string to_string(SgAsmElfSymbol::ElfSymType);

private:
    void parse_common();                            // initialization common to all parse() methods
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSymbol();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSymbol();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSymbol_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfStrtab);
IS_SERIALIZABLE(AsmElfStrtab);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStrtab.h"
/** ELF string table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStrtab.h"
class SgAsmElfStrtab: public SgAsmGenericStrtab {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfStrtab);
#if defined(SgAsmElfStrtab_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericStrtab);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStrtab.h"
public:
    /** Non-parsing constructor.
     *
     *  The table is created to be at least one byte long and having a NUL character as the first byte. */
    explicit SgAsmElfStrtab(class SgAsmElfSection *containing_section);

    /** Free StringStorage objects associated with this string table.
     *
     *  It may not be safe to blow them away yet since other objects may still have @ref SgAsmStoredStrings pointing to
     *  these storage objects. So instead, we will mark all this strtab's storage objects as no longer being associated
     *  with a string table. This allows the @ref SgAsmStoredString objects to still function properly and their
     *  destructors will free their storage. */
    void destructorHelper() override;

    /** Parses the string table.
     *
     *  All that actually happens at this point is we look to see if the table begins with an empty string. */
    virtual SgAsmElfStrtab *parse() override;

    /** Write string table back to disk.
     *
     *  Free space is zeroed out; holes are left as they are. */
    virtual void unparse(std::ostream&) const;

    /** Creates the storage item for the string at the specified offset.
     *
     *  If @p shared is true then attempt to re-use a previous storage object, otherwise always create a new one. Each
     *  storage object is considered a separate string, therefore when two strings share the same storage object, changing
     *  one string changes the other. */
    virtual SgAsmStringStorage *create_storage(rose_addr_t offset, bool shared) override;

    /** Returns the number of bytes required to store the string in the string table.
     *
     *  This is the length of the string plus one for the NUL terminator. */
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) override;

    /** Find offset for a string.
     *
     *  Tries to find a suitable offset for a string such that it overlaps with some other string already allocated. If the
     *  new string is the same as the end of some other string (new="main", existing="domain") then we just use an offset
     *  into that string since the space is already allocated for the existing string. If the new string ends with an
     *  existing string (new="domain", existing="main") and there's enough free space before the existing string (two bytes
     *  in this case) then we allocate some of that free space and use a suitable offset. In any case, upon return
     *  <code>storege->get_offset()</code> will return the allocated offset if successful, or
     *  @ref SgAsmGenericString::unallocated if we couldn't find an overlap. */
    virtual void allocate_overlap(SgAsmStringStorage*) override;

    /** Similar to create_storage() but uses a storage object that's already been allocated. */
    virtual void rebind(SgAsmStringStorage*, rose_addr_t) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfStrtab();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfStrtab();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfStrtab_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfStringSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfStringSection);
IS_SERIALIZABLE(AsmElfStringSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
/** ELF string table section.
 *
 *  A file section that holds string literals such as symbol names. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
class SgAsmElfStringSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
    AsmElfStringSection.setDataPrototype(
        "SgAsmElfStrtab*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfStringSection);
#if defined(SgAsmElfStringSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
        s & BOOST_SERIALIZATION_NVP(p_strtab);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfStrtab* const& get_strtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strtab(SgAsmElfStrtab* const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfStringSection.h"
public:
    /** Constructor that links new object into AST. */
    explicit SgAsmElfStringSection(SgAsmElfFileHeader*);

    /** Initialize object by parsing binary specimen. */
    virtual SgAsmElfStringSection *parse() override;

    /** Dump debugging information. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Adjust size of table.
     *
     * Augments superclass to make sure free list and such are adjusted properly. Any time the ELF String Section size is
     * changed we adjust the free list in the ELF String Table contained in this section. */
    virtual void set_size(rose_addr_t newsize) override;

    /** Reallocate space for the string section if necessary.
     *
     *  Note that reallocation is lazy here -- we don't shrink the section, we only enlarge it (if you want the section to
     *  shrink then call SgAsmGenericStrtab::reallocate(bool) with a true value rather than calling this
     *  function. SgAsmElfStringSection::reallocate is called in response to unparsing a file and gives the string table a
     *  chance to extend its container section if it needs to allocate more space for strings. */
    virtual bool reallocate() override;

    /** Unparse an ElfStringSection by unparsing the ElfStrtab */
    virtual void unparse(std::ostream&) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfStringSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfStringSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfStringSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSegmentTable);
IS_SERIALIZABLE(AsmElfSegmentTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTable.h"
/** Represents an ELF segment table.
 *
 * The ELF Segment Table is an ELF Section that has entries describing the various segments of the ELF file.  Each segment
 * is also an SgAsmElfSection and the entries of the ELF Segment Table are associated with the SgAsmElfSection they
 * describe.  The ELF Segment Table can be reconstructed by traversing the AST and finding the SgAsmElfSegmentTableEntry
 * nodes. */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTable.h"
class SgAsmElfSegmentTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSegmentTable);
#if defined(SgAsmElfSegmentTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTable.h"
public:
    /** Constuct segment table linked into the AST. */
    explicit SgAsmElfSegmentTable(SgAsmElfFileHeader*);

    /** Parses an ELF Segment (Program Header) Table.
     *
     *  Parses an ELF segment table and constructs and parses all segments reachable from the table. The section is
     *  extended as necessary based on the number of entries and teh size of each entry. */
    virtual SgAsmElfSegmentTable *parse() override;

    /** Attaches new segments to the segment table.
     *
     *  Attaches a previously unattached ELF Segment (@ref SgAsmElfSection) to the ELF Segment Table (@ref
     *  SgAsmElfSegmentTable). This method complements @ref SgAsmElfSection::init_from_segment_table. This method
     *  initializes the segment table from the segment while init_from_segment_table initializes the segment from the
     *  segment table.
     *
     *  ELF Segments are represented by @ref SgAsmElfSection objects since ELF Segments and ELF Sections overlap very much
     *  in their features and thus should share an interface. An @ref SgAsmElfSection can appear in the ELF Section Table
     *  and/or the ELF Segment Table and you can determine where it was located by calling @ref get_section_entry and
     *  @ref get_segment_entry.
     *
     *  Returns the new segment table entry linked into the AST. */
    SgAsmElfSegmentTableEntry *add_section(SgAsmElfSection*);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. */
    rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    /** Pre-unparsing updates */
    virtual bool reallocate() override;

    /** Write the segment table to disk. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSegmentTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTableEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSegmentTableEntryList);
IS_SERIALIZABLE(AsmElfSegmentTableEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"
class SgAsmElfSegmentTableEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"
    AsmElfSegmentTableEntryList.setDataPrototype(
        "SgAsmElfSegmentTableEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSegmentTableEntryList);
#if defined(SgAsmElfSegmentTableEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTableEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTableEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfSegmentTableEntryPtrList const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTableEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSegmentTableEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTableEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSegmentTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSegmentTableEntry);
IS_SERIALIZABLE(AsmElfSegmentTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
/** Represents one entry of a segment table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
class SgAsmElfSegmentTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "size_t", "index", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgAsmElfSegmentTableEntry::SegmentType", "type", "= SgAsmElfSegmentTableEntry::PT_LOAD",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgAsmElfSegmentTableEntry::SegmentFlags", "flags", "= SgAsmElfSegmentTableEntry::PF_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "vaddr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "paddr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "filesz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "memsz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "rose_addr_t", "align", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    AsmElfSegmentTableEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSegmentTableEntry);
#if defined(SgAsmElfSegmentTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_index);
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_type);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_vaddr);
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_paddr);
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_filesz);
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_memsz);
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_align);
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_extra);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Segment types (host order). All other values are reserved. */
    enum SegmentType {
        PT_NULL         = 0,                        /**< Ignored entry. Other values of entry are undefined. */
        PT_LOAD         = 1,                        /**< Loadable by mapping file contents into memory. */
        PT_DYNAMIC      = 2,                        /**< Dynamic linking information. */
        PT_INTERP       = 3,                        /**< Segment contains NUL-terminated path name of interpreter. */
        PT_NOTE         = 4,                        /**< Auxiliary information. */
        PT_SHLIB        = 5,                        /**< Reserved w/unspecified semantics. Such a file is nonconforming. */
        PT_PHDR         = 6,                        /**< Segment contains the segment table itself (program header array) */
        PT_TLS          = 7,                        /**< Thread local storage. */

        // OS- and Processor-specific ranges
        PT_LOOS         = 0x60000000,               /**< Values reserved for OS-specific semantics */
        PT_HIOS         = 0x6fffffff,
        PT_LOPROC       = 0x70000000,               /**< Values reserved for processor-specific semantics */
        PT_HIPROC       = 0x7fffffff,

        // OS-specific values for GNU/Linux
        PT_GNU_EH_FRAME = 0x6474e550,               /**< GCC .eh_frame_hdr segment */
        PT_GNU_STACK    = 0x6474e551,               /**< Indicates stack executability */
        PT_GNU_RELRO    = 0x6474e552,               /**< Read-only after relocation */
        PT_PAX_FLAGS    = 0x65041580,               /**< Indicates PaX flag markings */

        // OS-specific values for Sun
        PT_SUNWBSS      = 0x6ffffffa,               /**< Sun Specific segment */
        PT_SUNWSTACK    = 0x6ffffffb                /**< Stack segment */
    };

    /** Segment bit flags */
    enum SegmentFlags {
        PF_NONE         = 0,                        /**< Initial value in c'tor */
        PF_RESERVED     = 0x000ffff8,               /**< Reserved bits */
        PF_XPERM        = 0x00000001,               /**< Execute permission */
        PF_WPERM        = 0x00000002,               /**< Write permission */
        PF_RPERM        = 0x00000004,               /**< Read permission */
        PF_OS_MASK      = 0x0ff00000,               /**< os-specific bits */
        PF_PROC_MASK    = 0xf0000000                /**< Processor-specific bits */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** File format of an ELF Segment header.
     *
     * Byte order of members depends on e_ident value in file header. This code comes directly from "Executable and
     * Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool Interface Standards (TIS) and not from any
     * header file. The 64-bit structure is gleaned from the Linux elf(5) man page. Segment table entries (a.k.a., ELF
     * program headers) either describe process segments or give supplementary info which does not contribute to the
     * process image. */
    struct Elf32SegmentTableEntry_disk {
        uint32_t        p_type;                  /**< 0x00 kind of segment */
        uint32_t        p_offset;                /**< 0x04 file offset */
        uint32_t        p_vaddr;                 /**< 0x08 desired mapped address of segment */
        uint32_t        p_paddr;                 /**< 0x0c physical address where supported (unused by System V) */
        uint32_t        p_filesz;                /**< 0x20 bytes in file (may be zero or other value smaller than p_memsz) */
        uint32_t        p_memsz;                 /**< 0x24 number of bytes when mapped (may be zero) */
        uint32_t        p_flags;                 /**< 0x28 */
        uint32_t        p_align;                 /**< 0x2c alignment for file and memory (0,1=>none); power of two */
    }                                            /* 0x30 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SegmentTableEntry_disk {
        uint32_t        p_type;         /* 0x00 */
        uint32_t        p_flags;        /* 0x04 */
        uint64_t        p_offset;       /* 0x08 */
        uint64_t        p_vaddr;        /* 0x10 */
        uint64_t        p_paddr;        /* 0x18 */
        uint64_t        p_filesz;       /* 0x20 */
        uint64_t        p_memsz;        /* 0x28 */
        uint64_t        p_align;        /* 0x30 */
    }                                       /* 0x38 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_index() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_index(size_t const&);
    /** @} */
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTableEntry::SegmentType const& get_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_type(SgAsmElfSegmentTableEntry::SegmentType const&);
    /** @} */
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTableEntry::SegmentFlags const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(SgAsmElfSegmentTableEntry::SegmentFlags const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset(rose_addr_t const&);
    /** @} */
#line 111 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_vaddr() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vaddr(rose_addr_t const&);
    /** @} */
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 120 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_paddr() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_paddr(rose_addr_t const&);
    /** @} */
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 126 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_filesz() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_filesz(rose_addr_t const&);
    /** @} */
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_memsz() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_memsz(rose_addr_t const&);
    /** @} */
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 138 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_align() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_align(rose_addr_t const&);
    /** @} */
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_extra() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_extra();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_extra(SgUnsignedCharList const&);
    /** @} */
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSegmentTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Construct node from 32-bit file data. */
    SgAsmElfSegmentTableEntry(ByteOrder::Endianness sex,
                              const SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk *disk);

    /** Construct node from 64-bit file data. */
    SgAsmElfSegmentTableEntry(ByteOrder::Endianness sex,
                              const SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk *disk);

    /** Converts segment table entry back into disk structure.
     *
     * @{ */
    void *encode(ByteOrder::Endianness, SgAsmElfSegmentTableEntry::Elf32SegmentTableEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfSegmentTableEntry::Elf64SegmentTableEntry_disk*) const;
    /** @} */

    /** Update this segment table entry with newer information from the section */
    void update_from_section(SgAsmElfSection*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Convert segment type to string. */
    static std::string to_string(SgAsmElfSegmentTableEntry::SegmentType);

    /** Convert segment flags to string. */
    static std::string to_string(SgAsmElfSegmentTableEntry::SegmentFlags);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSegmentTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSegmentTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSegmentTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSectionTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSectionTable);
IS_SERIALIZABLE(AsmElfSectionTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTable.h"
/** Represents an ELF section table.
 *
 *  The ELF Section Table is itself a section.  The entries of the table are stored with the section they describe rather
 *  than storing them all in the SgAsmSectionTable node.  We can reconstruct the ELF Section Table since sections have
 *  unique ID numbers that are their original indices in the ELF Section Table. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTable.h"
class SgAsmElfSectionTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSectionTable);
#if defined(SgAsmElfSectionTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTable.h"
public:
    /** Constructor creates section table within the AST. */
    explicit SgAsmElfSectionTable(SgAsmElfFileHeader*);

    /** Parses an ELF Section Table.
     *
     *  Parses an ELF section table and constructs and parses all sections reachable from the table. The section is
     *  extended as necessary based on the number of entries and the size of each entry. Returns a pointer to this
     *  object. */
    virtual SgAsmElfSectionTable *parse() override;

    /** Attaches a previously unattached ELF Section to the section table.
     *
     *  If @p section is an ELF String Section (SgAsmElfStringSection) that contains an ELF String Table
     *  (SgAsmElfStringTable) and the ELF Section Table has no associated string table then the @p section will be used as
     *  the string table to hold the section names.
     *
     *  This method complements SgAsmElfSection::init_from_section_table. This method initializes the section table from
     *  the section while init_from_section_table() initializes the section from the section table.
     *
     *  Returns the new section table entry linked into the AST. */
    SgAsmElfSectionTableEntry *add_section(SgAsmElfSection*);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. */
    rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    /** Update prior to unparsing. */
    virtual bool reallocate() override;

    /** Write the section table section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSectionTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSectionTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSectionTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSectionTableEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfSectionTableEntry);
IS_SERIALIZABLE(AsmElfSectionTableEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
/** Represents one entry in an ELF section table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
class SgAsmElfSectionTableEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned", "sh_name", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "SgAsmElfSectionTableEntry::SectionType", "sh_type", "= SHT_PROGBITS",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned long", "sh_link", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "unsigned long", "sh_info", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "uint64_t", "sh_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_addr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_addralign", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "rose_addr_t", "sh_entsize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    AsmElfSectionTableEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSectionTableEntry);
#if defined(SgAsmElfSectionTableEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_name);
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_type);
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_link);
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_info);
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_flags);
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_addr);
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_offset);
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_size);
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_addralign);
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sh_entsize);
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_extra);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Section types (host order). All other values are reserved. */
    enum SectionType {
        SHT_NULL        = 0,                  /**< Section header is inactive */
        SHT_PROGBITS    = 1,                  /**< Info defined by the program; format and meaning determined by prog */
        SHT_SYMTAB      = 2,                  /**< Complete symbol table */
        SHT_STRTAB      = 3,                  /**< String table */
        SHT_RELA        = 4,                  /**< Relocation entries with explicit addends (e.g., Elf32_Rela types) */
        SHT_HASH        = 5,                  /**< Symbol hash table (used by dynamic linking) */
        SHT_DYNAMIC     = 6,                  /**< Information for dynamic linking */
        SHT_NOTE        = 7,                  /**< Information that marks the file in some way */
        SHT_NOBITS      = 8,                  /**< Like SHT_PROGBITS but occupies no file space */
        SHT_REL         = 9,                  /**< Relocation entries without explicit addends (e.g., Elf32_Rel types) */
        SHT_SHLIB       = 10,                 /**< Reserved, unspecified semantics; Present only in non-conforming files */
        SHT_DYNSYM      = 11,                 /**< Minimal set of dynamic linking symbols */

        SHT_LOOS        = 0x60000000,         /**< OS specific semantics */
        SHT_GNU_verdef  = 0x6ffffffd,         /**< Symbol Version Definitions [gnu extension] .gnu.version_d */
        SHT_GNU_verneed = 0x6ffffffe,         /**< Symbol Version Requirements [gnu extension] .gnu.version_r */
        SHT_GNU_versym  = 0x6fffffff,         /**< Symbol Version Table [gnu extension] .gnu.version */
        SHT_HIOS        = 0x6fffffff,         /**< End OS specific semantics */       /*NO_STRINGIFY*/

        SHT_LOPROC      = 0x70000000,         /* Processor specific semantics */
        SHT_HIPROC      = 0x7fffffff,
        SHT_LOUSER      = 0x80000000,         /* Application specific semantics */
        SHT_HIUSER      = 0xffffffff
    };

    /** Section Flags (host order).  All other values are reserved. */
    enum SectionFlags {
        SHF_NULL=                  0,        /**< Invalid section flag (added for rose) */
        SHF_WRITE=           (1 << 0),       /**< Writable */
        SHF_ALLOC=           (1 << 1),       /**< Occupies memory during execution */
        SHF_EXECINSTR=       (1 << 2),       /**< Executable */
        SHF_MERGE=           (1 << 4),       /**< Might be merged */
        SHF_STRINGS=         (1 << 5),       /**< Contains nul-terminated strings */
        SHF_INFO_LINK=       (1 << 6),       /**< 'sh_info' contains SHT index */
        SHF_LINK_ORDER=      (1 << 7),       /**< Preserve order after combining */
        SHF_OS_NONCONFORMING=(1 << 8),       /**< Non-standard OS specific handling required */
        SHF_GROUP=           (1 << 9),       /**< Section is member of a group.  */
        SHF_TLS=             (1 << 10),      /**< Section hold thread-local data.  */
        SHF_MASKOS=          0x0ff00000,     /**< OS-specific.  */
        SHF_MASKPROC=        0xf0000000      /**< Processor-specific */
    };

    /** File format of an ELF Section header.
     *
     *  Byte order of members depends on e_ident value in file header. This code
     * comes directly from "Executable and Linkable Format (ELF)", Portable Formats Specification, Version 1.1, Tool
     * Interface Standards (TIS) and not from any header file. The 64-bit structure is gleaned from the Linux elf(5) man
     * page. */
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct Elf32SectionTableEntry_disk {
        uint32_t        sh_name;             /* 0x00 Section name; index into section header string table */
        uint32_t        sh_type;             /* 0x04 Section contents and semantics (see SectionType enum) */
        uint32_t        sh_flags;            /* 0x08 Bit flags */
        uint32_t        sh_addr;             /* 0x0c Desired mapped address */
        uint32_t        sh_offset;           /* 0x10 Section location in file unless sh_type==SHT_NOBITS */
        uint32_t        sh_size;             /* 0x14 Section size in bytes */
        uint32_t        sh_link;             /* 0x18 Section ID of another section; meaning depends on section type */
        uint32_t        sh_info;             /* 0x1c Extra info depending on section type */
        uint32_t        sh_addralign;        /* 0x20 Mapped alignment (0 and 1=>byte aligned); sh_addr must be aligned*/
        uint32_t        sh_entsize;          /* 0x24 If non-zero, size in bytes of each array member in the section */
    }                                        /* 0x28 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64SectionTableEntry_disk {
        uint32_t        sh_name;             /* 0x00 see Elf32SectionTableEntry_disk */
        uint32_t        sh_type;             /* 0x04 */
        uint64_t        sh_flags;            /* 0x08 */
        uint64_t        sh_addr;             /* 0x10 */
        uint64_t        sh_offset;           /* 0x18 */
        uint64_t        sh_size;             /* 0x20 */
        uint32_t        sh_link;             /* 0x28 */
        uint32_t        sh_info;             /* 0x2c */
        uint64_t        sh_addralign;        /* 0x30 */
        uint64_t        sh_entsize;          /* 0x38 */
    }                                        /* 0x40 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_sh_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_name(unsigned const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSectionTableEntry::SectionType const& get_sh_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_type(SgAsmElfSectionTableEntry::SectionType const&);
    /** @} */
#line 111 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_sh_link() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_link(unsigned long const&);
    /** @} */
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_sh_info() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_info(unsigned long const&);
    /** @} */
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_sh_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_flags(uint64_t const&);
    /** @} */
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_sh_addr() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_addr(rose_addr_t const&);
    /** @} */
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_sh_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_offset(rose_addr_t const&);
    /** @} */
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_sh_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_size(rose_addr_t const&);
    /** @} */
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_sh_addralign() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_addralign(rose_addr_t const&);
    /** @} */
#line 153 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_sh_entsize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sh_entsize(rose_addr_t const&);
    /** @} */
#line 159 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_extra() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_extra();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_extra(SgUnsignedCharList const&);
    /** @} */
#line 165 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSectionTableEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Converts 32-bit disk representation to host representation. */
    SgAsmElfSectionTableEntry(ByteOrder::Endianness sex,
                              const SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk);

    /** Converts 64-bit disk representation to host representation. */
    SgAsmElfSectionTableEntry(ByteOrder::Endianness sex,
                              const SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk);

    /** Encode a section table entry into the disk structure.
     *
     * @{ */
    void *encode(ByteOrder::Endianness sex,
                 SgAsmElfSectionTableEntry::Elf32SectionTableEntry_disk *disk) const;
    void *encode(ByteOrder::Endianness sex,
                 SgAsmElfSectionTableEntry::Elf64SectionTableEntry_disk *disk) const;
    /** @} */

    /** Update this section table entry with newer information from the section. */
    void update_from_section(SgAsmElfSection*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    // Use Rose::stringify... function instead.
    static std::string to_string(SgAsmElfSectionTableEntry::SectionType);
    static std::string to_string(SgAsmElfSectionTableEntry::SectionFlags);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSectionTableEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSectionTableEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSectionTableEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfRelocSection);
IS_SERIALIZABLE(AsmElfRelocSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
/** Represents an ELF relocation section. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
class SgAsmElfRelocSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    AsmElfRelocSection.setDataPrototype(
        "bool", "uses_addend", "= true",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    AsmElfRelocSection.setDataPrototype(
        "SgAsmElfSection*", "target_section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    AsmElfRelocSection.setDataPrototype(
        "SgAsmElfRelocEntryList*", "entries", "= createAndParent<SgAsmElfRelocEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfRelocSection);
#if defined(SgAsmElfRelocSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
        s & BOOST_SERIALIZATION_NVP(p_uses_addend);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
        s & BOOST_SERIALIZATION_NVP(p_target_section);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_uses_addend() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_uses_addend(bool const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSection* const& get_target_section() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_target_section(SgAsmElfSection* const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfRelocEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfRelocEntryList* const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocSection.h"
public:
    SgAsmElfRelocSection(SgAsmElfFileHeader *fhdr, SgAsmElfSymbolSection *symsec,SgAsmElfSection* targetsec);

    using SgAsmElfSection::calculate_sizes;
    /** Parse an existing ELF Rela Section */
    virtual SgAsmElfRelocSection *parse() override;

    /** Return sizes for various parts of the table. See doc for SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    /** Pre-unparsing adjustments */
    virtual bool reallocate() override;

    /** Write section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfRelocSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfRelocSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfRelocEntryList);
IS_SERIALIZABLE(AsmElfRelocEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"
/** List of ELF relocation entries.
 *
 *  The only purpose of this node is to hold a list of the actual relocation entry nodes since ROSETTA limitations prevent
 *  that list from being contained in the nodes where it's needed. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"
class SgAsmElfRelocEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"
    AsmElfRelocEntryList.setDataPrototype(
        "SgAsmElfRelocEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfRelocEntryList);
#if defined(SgAsmElfRelocEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfRelocEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfRelocEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfRelocEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfRelocEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfRelocEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfRelocEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfRelocEntry);
IS_SERIALIZABLE(AsmElfRelocEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
/** One entry of an ELF relocation table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
class SgAsmElfRelocEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    AsmElfRelocEntry.setDataPrototype(
        "rose_addr_t", "r_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    AsmElfRelocEntry.setDataPrototype(
        "rose_addr_t", "r_addend", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    AsmElfRelocEntry.setDataPrototype(
        "unsigned long", "sym", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    AsmElfRelocEntry.setDataPrototype(
        "SgAsmElfRelocEntry::RelocType", "type", "= R_386_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    AsmElfRelocEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfRelocEntry);
#if defined(SgAsmElfRelocEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_r_offset);
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_r_addend);
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_sym);
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_type);
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_extra);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Relocation Type. In host order.  All other values are reserved. */
    enum RelocType{
        // Intel 80386 specific definitions.
        R_386_NONE         =0,  /**< No reloc */
        R_386_32           =1,  /**< Direct 32 bit  */
        R_386_PC32         =2,  /**< PC relative 32 bit */
        R_386_GOT32        =3,  /**< 32 bit GOT entry */
        R_386_PLT32        =4,  /**< 32 bit PLT address */
        R_386_COPY         =5,  /**< Copy symbol at runtime */
        R_386_GLOB_DAT     =6,  /**< Create GOT entry */
        R_386_JMP_SLOT     =7,  /**< Create PLT entry */
        R_386_RELATIVE     =8,  /**< Adjust by program base */
        R_386_GOTOFF       =9,  /**< 32 bit offset to GOT */
        R_386_GOTPC        =10, /**< 32 bit PC relative offset to GOT */
        R_386_32PLT        =11,
        R_386_TLS_TPOFF    =14, /**< Offset in static TLS block */
        R_386_TLS_IE       =15, /**< Address of GOT entry for static TLS block offset */
        R_386_TLS_GOTIE    =16, /**< GOT entry for static TLS block offset */
        R_386_TLS_LE       =17, /**< Offset relative to static TLS block */
        R_386_TLS_GD       =18, /**< Direct 32 bit for GNU version of general dynamic thread local data */
        R_386_TLS_LDM      =19, /**< Direct 32 bit for GNU version of local dynamic thread local data in LE code */
        R_386_16           =20,
        R_386_PC16         =21,
        R_386_8            =22,
        R_386_PC8          =23,
        R_386_TLS_GD_32    =24, /**< Direct 32 bit for general dynamic thread local data */
        R_386_TLS_GD_PUSH  =25, /**< Tag for pushl in GD TLS code */
        R_386_TLS_GD_CALL  =26, /**< Relocation for call to __tls_get_addr() */
        R_386_TLS_GD_POP   =27, /**< Tag for popl in GD TLS code */
        R_386_TLS_LDM_32   =28, /**< Direct 32 bit for local dynamic thread local data in LE code */
        R_386_TLS_LDM_PUSH =29, /**< Tag for pushl in LDM TLS code */
        R_386_TLS_LDM_CALL =30, /**< Relocation for call to __tls_get_addr() in LDM code */
        R_386_TLS_LDM_POP  =31, /**< Tag for popl in LDM TLS code */
        R_386_TLS_LDO_32   =32, /**< Offset relative to TLS block */
        R_386_TLS_IE_32    =33, /**< GOT entry for negated static TLS block offset */
        R_386_TLS_LE_32    =34, /**< Negated offset relative to static TLS block */
        R_386_TLS_DTPMOD32 =35, /**< ID of module containing symbol */
        R_386_TLS_DTPOFF32 =36, /**< Offset in TLS block */
        R_386_TLS_TPOFF32  =37, /**< Negated offset in static TLS block */

        // First Entry for X86-64
        R_X86_64_NONE     =100, /**<  No reloc */
        R_X86_64_64       =101, /**<  Direct 64 bit  */
        R_X86_64_PC32     =102, /**<  PC relative 32 bit signed */
        R_X86_64_GOT32    =103, /**<  32 bit GOT entry */
        R_X86_64_PLT32    =104, /**<  32 bit PLT address */
        R_X86_64_COPY     =105, /**<  Copy symbol at runtime */
        R_X86_64_GLOB_DAT =106, /**<  Create GOT entry */
        R_X86_64_JUMP_SLOT=107, /**<  Create PLT entry */
        R_X86_64_RELATIVE =108, /**<  Adjust by program base */
        R_X86_64_GOTPCREL =109, /**<  32 bit signed PC relative offset to GOT */
        R_X86_64_32       =110, /**<  Direct 32 bit zero extended */
        R_X86_64_32S      =111, /**<  Direct 32 bit sign extended */
        R_X86_64_16       =112, /**<  Direct 16 bit zero extended */
        R_X86_64_PC16     =113, /**<  16 bit sign extended pc relative */
        R_X86_64_8        =114, /**<  Direct 8 bit sign extended  */
        R_X86_64_PC8      =115, /**<  8 bit sign extended pc relative */
        R_X86_64_DTPMOD64 =116, /**<  ID of module containing symbol */
        R_X86_64_DTPOFF64 =117, /**<  Offset in module's TLS block */
        R_X86_64_TPOFF64  =118, /**<  Offset in initial TLS block */
        R_X86_64_TLSGD    =119, /**<  32 bit signed PC relative offset to two GOT entries for GD symbol */
        R_X86_64_TLSLD    =120, /**<  32 bit signed PC relative offset to two GOT entries for LD symbol */
        R_X86_64_DTPOFF32 =121, /**<  Offset in TLS block */
        R_X86_64_GOTTPOFF =122, /**<  32 bit signed PC relative offset to GOT entry for IE symbol */
        R_X86_64_TPOFF32  =123  /**<  Offset in initial TLS block */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    struct Elf32RelaEntry_disk {
        uint32_t        r_offset;
        uint32_t        r_info;
        uint32_t        r_addend;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64RelaEntry_disk {
        uint64_t        r_offset;
        uint64_t        r_info;
        uint64_t        r_addend;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf32RelEntry_disk {
        uint32_t        r_offset;
        uint32_t        r_info;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64RelEntry_disk {
        uint64_t        r_offset;
        uint64_t        r_info;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_r_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_r_offset(rose_addr_t const&);
    /** @} */
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_r_addend() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_r_addend(rose_addr_t const&);
    /** @} */
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_sym() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sym(unsigned long const&);
    /** @} */
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfRelocEntry::RelocType const& get_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_type(SgAsmElfRelocEntry::RelocType const&);
    /** @} */
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_extra() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_extra();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_extra(SgUnsignedCharList const&);
    /** @} */
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfRelocEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that adds the new entry to the relocation table. */
    SgAsmElfRelocEntry(SgAsmElfRelocSection*);

    /** Initialize object by parsing from file.
     *
     * @{ */
    void parse(ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf32RelaEntry_disk *disk);
    void parse(ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf64RelaEntry_disk *disk);
    void parse(ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf32RelEntry_disk *disk);
    void parse(ByteOrder::Endianness sex, const SgAsmElfRelocEntry::Elf64RelEntry_disk *disk);
    /** @} */

    /** Convert object to on-disk format.
     *
     * @{ */
    void *encode(ByteOrder::Endianness, SgAsmElfRelocEntry::Elf32RelaEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfRelocEntry::Elf64RelaEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfRelocEntry::Elf32RelEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfRelocEntry::Elf64RelEntry_disk*) const;
    /** @} */

    /** Print debugging information.
     *
     * @{ */
    void dump(FILE *f, const char *prefix, ssize_t idx, SgAsmElfSymbolSection *symtab) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const {
        dump(f, prefix, idx, NULL);
    }
    /** @} */

    /** Convert relocation to string for debugging. */
    std::string reloc_name() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfRelocEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfRelocEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfRelocEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfNoteSection);
IS_SERIALIZABLE(AsmElfNoteSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"
class SgAsmElfNoteSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"
    AsmElfNoteSection.setDataPrototype(
        "SgAsmElfNoteEntryList*", "entries", "= createAndParent<SgAsmElfNoteEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfNoteSection);
#if defined(SgAsmElfNoteSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfNoteEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfNoteEntryList* const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteSection.h"
public:
    /** Non-parsing constructor */
    explicit SgAsmElfNoteSection(SgAsmElfFileHeader*);

    virtual SgAsmElfNoteSection *parse() override;

    /** Pre-unparsing adjustments */
    virtual bool reallocate() override;

    /** Write data to note section */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfNoteSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfNoteSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfNoteEntryList);
IS_SERIALIZABLE(AsmElfNoteEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"
/** Node to hold list of ELF note entries.
 *
 *  This node's only purpose is to hold the list of pointers to note entries, which must be done like this because of
 *  limitations of ROSETTA. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"
class SgAsmElfNoteEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"
    AsmElfNoteEntryList.setDataPrototype(
        "SgAsmElfNoteEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfNoteEntryList);
#if defined(SgAsmElfNoteEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfNoteEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfNoteEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfNoteEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfNoteEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfNoteEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfNoteEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfNoteEntry);
IS_SERIALIZABLE(AsmElfNoteEntry);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
/** One entry of an ELF notes table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
class SgAsmElfNoteEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    AsmElfNoteEntry.setDataPrototype(
        "unsigned", "type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    AsmElfNoteEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    AsmElfNoteEntry.setDataPrototype(
        "SgUnsignedCharList", "payload", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfNoteEntry);
#if defined(SgAsmElfNoteEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_type);
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_payload);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_type(unsigned const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_payload() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_payload();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_payload(SgUnsignedCharList const&);
    /** @} */
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfNoteEntry.h"
public:
    /** Constructor adds the new note to the list of notes for the note section. */
    SgAsmElfNoteEntry(SgAsmElfNoteSection*);

    /** Property: Note name.
     *
     *  A string note name stored in an ELF string table in the binary specimen. Changing the name of a note also changes
     *  the contents of the string table.
     *
     * @{ */
    SgAsmGenericString *get_name() const;
    void set_name(SgAsmGenericString *name);
    /** @} */

    /** Initialize a note by parsing it from the specified location in the note section.
     *
     *  Return value is the offset to the beginning of the next note. */
    rose_addr_t parse(rose_addr_t starting_offset);

    /** Write a note at the specified offset to the section containing the note.
     *
     *  Returns the offset for the first byte past the end of the note. */
    rose_addr_t unparse(std::ostream &f, rose_addr_t starting_offset);

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Property: Note payload.
     *
     *  This is the data associated with the note. */
    void set_payload(const void*, size_t nbytes);

    /** Returns the number of bytes needed to store this note. */
    rose_addr_t calculate_size() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfNoteEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfNoteEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfNoteEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfFileHeader);
IS_SERIALIZABLE(AsmElfFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
/** Represents the file header of an ELF binary container.
 *
 *  The file header contains information that the operating system uses to find the various parts within the
 *  container. Most of the object properties are defined in the official ELF specification and their documentation is not
 *  replicated here.
 *
 *  ROSE does not require or use an ELF support library or headers and is thus able to parse ELF files on systems where ELF
 *  is not normally employed. */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
class SgAsmElfFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_file_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_data_encoding", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned char", "e_ident_file_version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "SgUnsignedCharList", "e_ident_padding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_machine", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_ehsize", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "phextrasz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_phnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "shextrasz", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_shnum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "unsigned long", "e_shstrndx", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "SgAsmElfSectionTable*", "section_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 190 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    AsmElfFileHeader.setDataPrototype(
        "SgAsmElfSegmentTable*", "segment_table", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfFileHeader);
#if defined(SgAsmElfFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ident_file_class);
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ident_data_encoding);
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ident_file_version);
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ident_padding);
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_type);
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_machine);
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_flags);
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ehsize);
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_phextrasz);
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_phnum);
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_shextrasz);
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_shnum);
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_shstrndx);
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_section_table);
#line 190 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_segment_table);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Enum for the @ref get_e_type "e_type" property. */
    enum ObjectType {
        ET_NONE         = 0                         /**< No file type */
        ,ET_REL          = 1                        /**< Relocatable file */
        ,ET_EXEC         = 2                        /**< Executable file */
        ,ET_DYN          = 3                        /**< Shared object file */
        ,ET_CORE         = 4                        /**< Core file */

        ,ET_LOOS         = 0xfe00                   /**< OS-specific range start */
        ,ET_HIOS         = 0xfeff                   /**< OS-specific range end */
        ,ET_LOPROC       = 0xff00                   /**< Processor-specific range start */
        ,ET_HIPROC       = 0xffff                   /**< Processor-specific range end */
    };

    // Some structures are used to represent certain things whose layout is very precise in binary files, thus we need to
    // make sure the compiler doesn't insert alignment padding between the struct members.  ROSE can be compiled on an
    // architecture that has different alignment constraints than the architecture that these structs describe. GNU
    // compilers have long used the attribute mechanism. Microsoft compilers on the other hand use pragmas. GCC versions
    // 4.0 and earlier do not recognize the Microsoft pragmas and issue compiler errors when one is encountered.
#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** File format of an ELF header.
     *
     *  Byte order of members depends on e_ident value. This code comes directly from "System V Application Binary
     *  Interface, Edition 4.1" and the FreeBSD elf(5) man page, and the "Executable and Linkable Format (ELF) Portable
     *  Formats Specifications, Version 1.2" and not from any header file. */
    struct Elf32FileHeader_disk {
        unsigned char       e_ident_magic[4];       /**< 0x7f, 'E', 'L', 'F' */
        unsigned char       e_ident_file_class;     /**< 1=>32-bit; 2=>64-bit; other is error */
        unsigned char       e_ident_data_encoding;  /**< 1=>LSB; 2=>MSB; other is error */
        unsigned char       e_ident_file_version;   /**< Format version number (same as e_version); must be 1 */
        unsigned char       e_ident_padding[9];     /**< Padding to byte 16; must be zero */
        uint16_t            e_type;                 /**< Object file type: relocatable, executable, lib, core */
        uint16_t            e_machine;              /**< Required architecture for an individual file */
        uint32_t            e_version;              /**< Object file version, currently zero or one */
        uint32_t            e_entry;                /**< Entry virtual address or zero if none */
        uint32_t            e_phoff;                /**< File offset of program header table or zero if none */
        uint32_t            e_shoff;                /**< File offset of section header table or zero if none */
        uint32_t            e_flags;                /**< Processor-specific flags (EF_* constants in docs) */
        uint16_t            e_ehsize;               /**< Size of ELF header in bytes */
        uint16_t            e_phentsize;            /**< Size of each entry in the program header table */
        uint16_t            e_phnum;                /**< Number of program headers, or PN_XNUM, or zero */
        uint16_t            e_shentsize;            /**< Size of each entry in the section header table */
        uint16_t            e_shnum;                /**< Number of section headers, or zero for extended entries */
        uint16_t            e_shstrndx;             /**< Index of name section, or SHN_UNDEF, or SHN_XINDEX */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64FileHeader_disk {
        unsigned char       e_ident_magic[4];
        unsigned char       e_ident_file_class;
        unsigned char       e_ident_data_encoding;
        unsigned char       e_ident_file_version;
        unsigned char       e_ident_padding[9];
        uint16_t            e_type;
        uint16_t            e_machine;
        uint32_t            e_version;
        uint64_t            e_entry;
        uint64_t            e_phoff;
        uint64_t            e_shoff;
        uint32_t            e_flags;
        uint16_t            e_ehsize;
        uint16_t            e_phentsize;
        uint16_t            e_phnum;
        uint16_t            e_shentsize;
        uint16_t            e_shnum;
        uint16_t            e_shstrndx;
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned char const& get_e_ident_file_class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ident_file_class(unsigned char const&);
    /** @} */
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned char const& get_e_ident_data_encoding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ident_data_encoding(unsigned char const&);
    /** @} */
#line 110 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned char const& get_e_ident_file_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ident_file_version(unsigned char const&);
    /** @} */
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_e_ident_padding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ident_padding(SgUnsignedCharList const&);
    /** @} */
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_type(unsigned long const&);
    /** @} */
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_machine() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_machine(unsigned long const&);
    /** @} */
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_flags(unsigned long const&);
    /** @} */
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_ehsize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ehsize(unsigned long const&);
    /** @} */
#line 146 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_phextrasz() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_phextrasz(unsigned long const&);
    /** @} */
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 154 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_phnum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_phnum(unsigned long const&);
    /** @} */
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_shextrasz() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_shextrasz(unsigned long const&);
    /** @} */
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 166 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_shnum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_shnum(unsigned long const&);
    /** @} */
#line 170 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_e_shstrndx() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_shstrndx(unsigned long const&);
    /** @} */
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 178 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSectionTable* const& get_section_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_table(SgAsmElfSectionTable* const&);
    /** @} */
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTable* const& get_segment_table() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_segment_table(SgAsmElfSegmentTable* const&);
    /** @} */
#line 191 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Construct a new ELF File Header with default values.
     *
     *  The new section is placed at file offset zero and the size is initially one byte (calling @ref parse will extend it
     *  as necessary). Setting the initial size of non-parsed sections to a positive value works better when adding
     *  sections to the end-of-file since the sections will all have different starting offsets and therefore @ref
     *  SgAsmGenericFile::shift_extend will know what order the sections should be in when they are eventually resized. */
    explicit SgAsmElfFileHeader(SgAsmGenericFile*);

    /** Maximum page size according to the ABI.
     *
     *  This is used by the loader when calculating the program base address. Since parts of the file are mapped into the
     *  process address space those parts must be aligned (both in the file and in memory) on the largest possible page
     *  boundary so that any smaller page boundary will also work correctly. */
    uint64_t max_page_size();

    /** Convert ELF "machine" identifier to generic instruction set architecture value. */
    static SgAsmExecutableFileFormat::InsSetArchitecture machine_to_isa(unsigned machine);

    /** Convert architecture value to an ELF "machine" value. */
    unsigned isa_to_machine(SgAsmExecutableFileFormat::InsSetArchitecture isa) const;

    /** Parse header from file.
     *
     *  Initialize this header with information parsed from the file and construct and parse everything that's reachable
     *  from the header. Since the size of the ELF File Header is determined by the contents of the ELF File Header as
     *  stored in the file, the size of the ELF File Header will be adjusted upward if necessary. */
    virtual SgAsmElfFileHeader *parse() override;

    /** Update prior to unparsing */
    virtual bool reallocate() override;

    /** Write ELF contents back to a file. */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Return true if the file looks like it might be an ELF file according to the magic number. */
    static bool is_ELF(SgAsmGenericFile*);

    /** Get the list of sections defined in the ELF Section Table */
    SgAsmGenericSectionPtrList get_sectab_sections();

    /** Get the list of sections defined in the ELF Segment Table */
    SgAsmGenericSectionPtrList get_segtab_sections();

    // Overrides documented in base class
    virtual const char *format_name() const override;

private:
    void *encode(ByteOrder::Endianness, SgAsmElfFileHeader::Elf32FileHeader_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfFileHeader::Elf64FileHeader_disk*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfEHFrameSection);
IS_SERIALIZABLE(AsmElfEHFrameSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
/** Represents an ELF EH frame section. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
class SgAsmElfEHFrameSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
    AsmElfEHFrameSection.setDataPrototype(
        "SgAsmElfEHFrameEntryCIList*", "ci_entries", "= createAndParent<SgAsmElfEHFrameEntryCIList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfEHFrameSection);
#if defined(SgAsmElfEHFrameSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
        s & BOOST_SERIALIZATION_NVP(p_ci_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryCIList* const& get_ci_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ci_entries(SgAsmElfEHFrameEntryCIList* const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameSection.h"
public:
    /** Non-parsing constructor. */
    explicit SgAsmElfEHFrameSection(SgAsmElfFileHeader*);

    /** Initialize by parsing a file. */
    virtual SgAsmElfEHFrameSection *parse() override;

    /** Return sizes for various parts of the table.
     *
     *  See documentation for @ref SgAsmElfSection::calculate_sizes. Since EH Frame Sections are run-length encoded, we
     *  need to actually unparse the section in order to determine its size. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    /** Write data to .eh_frame section */
    virtual void unparse(std::ostream&) const override;

    /** Unparses the section into the optional output stream and returns the number of bytes written.
     *
     *  If there is no output stream we still go through the actions but don't write anything. This is the only way to
     *  determine the amount of memory required to store the section since the section is run-length encoded. */
    rose_addr_t unparse(std::ostream*) const;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfEHFrameSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryFDList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfEHFrameEntryFDList);
IS_SERIALIZABLE(AsmElfEHFrameEntryFDList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"
/** List of ELF error handling frame descriptor entries.
 *
 *  The only purpose of this node is to hold the list of pointers to FD entries, and is necesssary due to limitations of
 *  ROSETTA. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"
class SgAsmElfEHFrameEntryFDList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"
    AsmElfEHFrameEntryFDList.setDataPrototype(
        "SgAsmElfEHFrameEntryFDPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfEHFrameEntryFDList);
#if defined(SgAsmElfEHFrameEntryFDList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryFDPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryFDPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfEHFrameEntryFDPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFDList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryFDList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryFDList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryFDList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryFD           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfEHFrameEntryFD);
IS_SERIALIZABLE(AsmElfEHFrameEntryFD);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
/** ELF error handling frame entry frame description entry. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
class SgAsmElfEHFrameEntryFD: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    AsmElfEHFrameEntryFD.setDataPrototype(
        "rose_rva_t", "begin_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    AsmElfEHFrameEntryFD.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    AsmElfEHFrameEntryFD.setDataPrototype(
        "SgUnsignedCharList", "augmentation_data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    AsmElfEHFrameEntryFD.setDataPrototype(
        "SgUnsignedCharList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfEHFrameEntryFD);
#if defined(SgAsmElfEHFrameEntryFD_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
        s & BOOST_SERIALIZATION_NVP(p_begin_rva);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
        s & BOOST_SERIALIZATION_NVP(p_size);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
        s & BOOST_SERIALIZATION_NVP(p_augmentation_data);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
        s & BOOST_SERIALIZATION_NVP(p_instructions);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_begin_rva() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_begin_rva();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_begin_rva(rose_rva_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_size(rose_addr_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_augmentation_data() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_augmentation_data();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_augmentation_data(SgUnsignedCharList const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_instructions() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_instructions();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_instructions(SgUnsignedCharList const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryFD.h"
public:
    /** Non-parsing constructor */
    explicit SgAsmElfEHFrameEntryFD(SgAsmElfEHFrameEntryCI*);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Unparse to string.
     *
     *  Unparses the frame description entry (FDE) into a string but do not include the leading length field(s) or the CIE
     *  back pointer. */
    std::string unparse(const SgAsmElfEHFrameSection*, SgAsmElfEHFrameEntryCI*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryFD();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryFD();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryFD_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryCIList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfEHFrameEntryCIList);
IS_SERIALIZABLE(AsmElfEHFrameEntryCIList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"
/** List of ELF EH frame CI entries.
 *
 *  See official ELF specification. The only reason this node exists is because of ROSETTA limitations which prevent the
 *  list from being stored directly in the class that needs it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"
class SgAsmElfEHFrameEntryCIList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"
    AsmElfEHFrameEntryCIList.setDataPrototype(
        "SgAsmElfEHFrameEntryCIPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfEHFrameEntryCIList);
#if defined(SgAsmElfEHFrameEntryCIList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryCIPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryCIPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfEHFrameEntryCIPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCIList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryCIList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryCIList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryCIList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfEHFrameEntryCI           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfEHFrameEntryCI);
IS_SERIALIZABLE(AsmElfEHFrameEntryCI);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
/** ELF error handling frame entry, common information entry.
 *
 *  Most of the properties of this class are documented in the official ELF specification. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
class SgAsmElfEHFrameEntryCI: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "version", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "std::string", "augmentation_string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "eh_data", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "code_alignment_factor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int64_t", "data_alignment_factor", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "uint64_t", "augmentation_data_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "lsda_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "prh_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "unsigned", "prh_arg", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "rose_addr_t", "prh_addr", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "int", "addr_encoding", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "bool", "sig_frame", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "SgUnsignedCharList", "instructions", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    AsmElfEHFrameEntryCI.setDataPrototype(
        "SgAsmElfEHFrameEntryFDList*", "fd_entries", "= createAndParent<SgAsmElfEHFrameEntryFDList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfEHFrameEntryCI);
#if defined(SgAsmElfEHFrameEntryCI_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_version);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_augmentation_string);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_eh_data);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_code_alignment_factor);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_data_alignment_factor);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_augmentation_data_length);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_lsda_encoding);
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_prh_encoding);
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_prh_arg);
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_prh_addr);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_addr_encoding);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_sig_frame);
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_instructions);
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
        s & BOOST_SERIALIZATION_NVP(p_fd_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_version(int const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_augmentation_string() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_augmentation_string(std::string const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_eh_data() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_eh_data(uint64_t const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_code_alignment_factor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_code_alignment_factor(uint64_t const&);
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int64_t const& get_data_alignment_factor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_data_alignment_factor(int64_t const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_augmentation_data_length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_augmentation_data_length(uint64_t const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_lsda_encoding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_lsda_encoding(int const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_prh_encoding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_prh_encoding(int const&);
    /** @} */
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_prh_arg() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_prh_arg(unsigned const&);
    /** @} */
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_prh_addr() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_prh_addr(rose_addr_t const&);
    /** @} */
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_addr_encoding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_addr_encoding(int const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_sig_frame() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sig_frame(bool const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_instructions() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_instructions();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_instructions(SgUnsignedCharList const&);
    /** @} */
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfEHFrameEntryFDList* const& get_fd_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_fd_entries(SgAsmElfEHFrameEntryFDList* const&);
    /** @} */
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfEHFrameEntryCI.h"
public:
    /** Non-parsing constructor */
    explicit SgAsmElfEHFrameEntryCI(SgAsmElfEHFrameSection *ehframe);

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Unparse an entry.
     *
     *  Unparse one Common Information Entry (CIE) without unparsing the Frame Description Entries (FDE) to which it
     *  points. The initial length fields are not included in the result string. */
    std::string unparse(const SgAsmElfEHFrameSection*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfEHFrameEntryCI();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfEHFrameEntryCI();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfEHFrameEntryCI_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfDynamicSection);
IS_SERIALIZABLE(AsmElfDynamicSection);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
/** ELF section containing dynamic linking information. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
class SgAsmElfDynamicSection: public SgAsmElfSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
    AsmElfDynamicSection.setDataPrototype(
        "SgAsmElfDynamicEntryList*", "entries", "= createAndParent<SgAsmElfDynamicEntryList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfDynamicSection);
#if defined(SgAsmElfDynamicSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmElfSection);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfDynamicEntryList* const& get_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfDynamicEntryList* const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicSection.h"
public:
    /** Constructor that links object into the AST. */
    SgAsmElfDynamicSection(SgAsmElfFileHeader *fhdr, SgAsmElfStringSection *strsec);

    /** Initialize object by parsing file. */
    virtual SgAsmElfDynamicSection* parse() override;

    /** Finish initializing the section entries. */
    virtual void finish_parsing() override;

    using SgAsmElfSection::calculate_sizes;
    /** Return sizes for various parts of the table. See documentation for @ref SgAsmElfSection::calculate_sizes. */
    virtual rose_addr_t calculate_sizes(size_t *total, size_t *required, size_t *optional, size_t *entcount) const override;

    /** Called prior to unparse to make things consistent. */
    virtual bool reallocate() override;

    /** Write the dynamic section back to disk */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfDynamicSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmElfSection = nonTerminalConstructor(
    "AsmElfSection",
    *this,
    "AsmElfSection",
    "AsmElfSectionTag",
    SubclassListBuilder()
        | AsmElfDynamicSection
        | AsmElfEHFrameSection
        | AsmElfNoteSection
        | AsmElfRelocSection
        | AsmElfStringSection
        | AsmElfSymbolSection
        | AsmElfSymverDefinedSection
        | AsmElfSymverNeededSection
        | AsmElfSymverSection
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmElfSection.associatedGrammar != nullptr);
AsmElfSection.setCppCondition("!defined(DOCUMENTATION)");
AsmElfSection.isBoostSerializable(true);
AsmElfSection.setAutomaticGenerationOfConstructor(false);
AsmElfSection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
/** Base class for ELF file sections. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
class SgAsmElfSection: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    AsmElfSection.setDataPrototype(
        "SgAsmElfSection*", "linked_section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    AsmElfSection.setDataPrototype(
        "SgAsmElfSectionTableEntry*", "section_entry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    AsmElfSection.setDataPrototype(
        "SgAsmElfSegmentTableEntry*", "segment_entry", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfSection);
#if defined(SgAsmElfSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
        s & BOOST_SERIALIZATION_NVP(p_linked_section);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
        s & BOOST_SERIALIZATION_NVP(p_section_entry);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
        s & BOOST_SERIALIZATION_NVP(p_segment_entry);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    SgAsmElfSection* get_linked_section() const;
    virtual void set_linked_section(SgAsmElfSection*);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSectionTableEntry* const& get_section_entry() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_section_entry(SgAsmElfSectionTableEntry* const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfSegmentTableEntry* const& get_segment_entry() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_segment_entry(SgAsmElfSegmentTableEntry* const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfSection.h"
public:
    /** Constructor for sections not yet in a table.
     *
     *  This constructs a section that is in neither the ELF Section Table nor the ELF Segment Table yet, but eventually
     *  will be. */
    explicit SgAsmElfSection(SgAsmGenericHeader*);

    /** Initializes the section from data parsed from the ELF Section Table.
     *
     *  This includes the section name, offset, size, memory mapping, and alignments. The @p id is the index into the
     *  section table. This function complements @ref SgAsmElfSectionTable::add_section in that this function initializes
     *  this section from the section table while @ref SgAsmElfSectionTable::add_section "add_section" initializes the
     *  section table from the section. */
    SgAsmElfSection *init_from_section_table(SgAsmElfSectionTableEntry*, SgAsmElfStringSection*, int id);

    /** Initializes the section from data parse from the ELF Segment Table.
     *
     *  This is similar to @ref init_from_section_table but for segments instead of sections. */
    SgAsmElfSection *init_from_segment_table(SgAsmElfSegmentTableEntry*, bool mmap_only=false);

    /** Returns info about the size of the entries based on information already available.
     *
     *  Any or all arguments may be null pointers if the caller is not interested in the value. Return values are:
     *
     *  @li @p entsize is the size of each entry, sum of required and optional parts. This comes from the sh_entsize member
     *  of this section's ELF Section Table Entry, adjusted upward to be large enough to hold the required part of each
     *  entry (see "required").
     *
     *  @li @p required is the size of the required (leading) part of each entry. The size of the required part is based
     *  on the ELF word size.
     *
     *  @li @p optional is the size of the optional (trailing) part of each entry. If the section has been parsed then
     *  the optional size will be calculated from the entry with the largest "extra" (aka, optional) data. Otherwise this
     *  is calculated as the difference between the @p entsize" and the @p required" sizes.
     *
     *  @li entcount is the total number of entries in this section. If the section has been parsed then this is the
     *  actual number of parsed entries, otherwise its the section size divided by the @p entsize.
     *
     *  Return value is the total size needed for the section. In all cases, it is the product of @p entsize and @p
     *  entcount. */
    rose_addr_t calculate_sizes(size_t r32size, size_t r64size, const std::vector<size_t> &optsizes,
                                size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    virtual void finish_parsing() {}

    /** Base implementation for calculating sizes.
     *
     *  Most subclasses will override this virtual function in order to return more useful values. This implementation
     *  returns the following values:
     *
     *  @li @p entsize is size stored in the ELF Section Table's sh_entsize member, or size of entire section if not a
     *  table.
     *
     *  @li @p required is the same as @p entsize.
     *
     *  @li @p optional is zero.
     *
     *  @li @p entcount is the number of entries, each of size entsize, that can fit in the section.
     *
     *  The return size is the product of @p entsize and @p entcount, which, if this section is a table (nonzero
     *  sh_entsize), could be smaller than the total size of the section. */
    virtual rose_addr_t calculate_sizes(size_t *entsize, size_t *required, size_t *optional, size_t *entcount) const;

    /** Called prior to unparse to make things consistent. */
    virtual bool reallocate() override;

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Make this section's name to be stored in the specified string table. */
    void allocate_name_to_storage(SgAsmElfStringSection*);

    /** Obtain ELF header.
     *
     *  This is just a convenience function so we don't need to constantly cast the return value from @ref get_header. */
    SgAsmElfFileHeader *get_elf_header() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicEntryList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfDynamicEntryList);
IS_SERIALIZABLE(AsmElfDynamicEntryList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"
/** List of dynamic linking section entries.
 *
 *  The only purpose of this node is to hold a list which, due to ROSETTA limitations, cannot be contained in the objects
 *  that actually need it. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"
class SgAsmElfDynamicEntryList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"
    AsmElfDynamicEntryList.setDataPrototype(
        "SgAsmElfDynamicEntryPtrList", "entries", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfDynamicEntryList);
#if defined(SgAsmElfDynamicEntryList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"
        s & BOOST_SERIALIZATION_NVP(p_entries);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfDynamicEntryPtrList const& get_entries() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfDynamicEntryPtrList& get_entries();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entries(SgAsmElfDynamicEntryPtrList const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntryList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicEntryList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfDynamicEntryList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicEntryList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmElfDynamicEntry           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmElfDynamicEntry);
IS_SERIALIZABLE(AsmElfDynamicEntry);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmElfDynamicEntry);
#if defined(SgAsmElfDynamicEntry_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
#include <ByteOrder.h>
#endif // SgAsmElfDynamicEntry_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
/** One entry from the dynamic linking table. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
class SgAsmElfDynamicEntry: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    AsmElfDynamicEntry.setDataPrototype(
        "SgAsmElfDynamicEntry::EntryType", "d_tag", "= SgAsmElfDynamicEntry::DT_NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    AsmElfDynamicEntry.setDataPrototype(
        "rose_rva_t", "d_val", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    AsmElfDynamicEntry.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    AsmElfDynamicEntry.setDataPrototype(
        "SgUnsignedCharList", "extra", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmElfDynamicEntry);
#if defined(SgAsmElfDynamicEntry_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_d_tag);
#line 122 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_d_val);
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
        s & BOOST_SERIALIZATION_NVP(p_extra);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    enum EntryType {                /* Type    Executable SharedObj Purpose */
        DT_NULL     = 0,        /* ignored mandatory  mandatory Marks end of dynamic array */
        DT_NEEDED   = 1,        /* value   optional   optional  Name of needed library */
        DT_PLTRELSZ = 2,        /* value   optional   optional  Size of reloc entries associated with PLT */
        DT_PLTGOT   = 3,        /* pointer optional   optional  PLT and/or GOT */
        DT_HASH     = 4,        /* pointer mandatory  mandatory Symbol hash table */
        DT_STRTAB   = 5,        /* pointer mandatory  mandatory String table for symbols, lib names, etc. */
        DT_SYMTAB   = 6,        /* pointer mandatory  mandatory Symbol table */
        DT_RELA     = 7,        /* pointer mandatory  optional  Relocation table */
        DT_RELASZ   = 8,        /* value   mandatory  optional  Size of RELA relocation table */
        DT_RELAENT  = 9,        /* value   mandatory  optional  Size of each RELA table entry */
        DT_STRSZ    = 10,       /* value   mandatory  mandatory Size of string table */
        DT_SYMENT   = 11,       /* value   mandatory  mandatory Size of symbol table entry */
        DT_INIT     = 12,       /* pointer optional   optional  Initialization function */
        DT_FINI     = 13,       /* pointer optional   optional  Termination function */
        DT_SONAME   = 14,       /* value   ignored    optional  Name of shared object */
        DT_RPATH    = 15,       /* value   optional   ignored   NUL-term library search path */
        DT_SYMBOLIC = 16,       /* ignored ignored    optional  Bool determines dynamic linker symbol resolution */
        DT_REL      = 17,       /* pointer mandatory  optional  Relocation table */
        DT_RELSZ    = 18,       /* value   mandatory  optional  Size of REL relocation table */
        DT_RELENT   = 19,       /* value   mandatory  optional  Size of each REL table entry */
        DT_PLTREL   = 20,       /* value   optional   optional  Reloc type for PLT; value is DT_RELA or DT_REL */
        DT_DEBUG    = 21,       /* pointer optional   ignored   Contents are not specified at ABI level */
        DT_TEXTREL  = 22,       /* ignored optional   optional  presence => relocs to nonwritable segments OK */
        DT_JMPREL   = 23,       /* pointer optional   optional  Addr of relocation entries for PLT */
        DT_BIND_NOW = 24,       /* ignored optional   optional  Shall dynlinker do relocs before xfering control?*/
        DT_INIT_ARRAY = 25,     /* pointer optional   ?         Array with addresses of init fct */
        DT_FINI_ARRAY = 26,     /* pointer optional   ?         Array with address of fini fct */
        DT_INIT_ARRAYSZ = 27,   /* value   optional   ?         Size in bytes of DT_INIT_ARRAY */
        DT_FINI_ARRAYSZ = 28,   /* value   optional   ?         Size in bytes of DT_FINI_ARRAY */
        DT_RUNPATH  = 29,       /* ?       optional   ?         Library search path (how diff from DT_RPATH?) */
        DT_FLAGS    = 30,       /* value   optional   ?         Bit flags */
        DT_PREINIT_ARRAY = 32,  /* pointer optional   ?         Array with addrs of preinit fct (aka DT_ENCODING)*/
        DT_PREINIT_ARRAYSZ = 33,/* value   optional   ?         size in bytes of DT_PREINIT_ARRAY */
        DT_NUM      = 34,       /* ?       ?          ?         "number used"? */

        DT_GNU_PRELINKED =0x6ffffdf5,/*value ?          ?         Prelinking time stamp */
        DT_GNU_CONFLICTSZ=0x6ffffdf6,/*value ?          ?         Size of conflict section */
        DT_GNU_LIBLISTSZ=0x6ffffdf7,/*value  ?          ?         Size of library list */
        DT_CHECKSUM = 0x6ffffdf8, /* value   ?          ?         ? */
        DT_PLTPADSZ = 0x6ffffdf9, /* value   ?          ?         ? */
        DT_MOVEENT  = 0x6ffffdfa, /* value   ?          ?         ? */
        DT_MOVESZ   = 0x6ffffdfb, /* value   ?          ?         ? */
        DT_FEATURE_1= 0x6ffffdfc, /* value   ?          ?         Feature selection (DTF_*) */
        DT_POSFLAG_1= 0x6ffffdfd, /* value   ?          ?         Flag for DT_* entries affecting next entry */
        DT_SYMINSZ  = 0x6ffffdfe, /* value   ?          ?         Size of syminfo table in bytes */
        DT_SYMINENT = 0x6ffffdff, /* value   ?          ?         Size of each syminfo table entry */

        DT_GNU_HASH = 0x6ffffef5, /* pointer ?          ?         GNU-style hash table */
        DT_TLSDESC_PLT=0x6ffffef6,/* pointer ?          ?         ? */
        DT_TLSDESC_GOT=0x6ffffef7,/* pointer ?          ?         ? */
        DT_GNU_CONFLICT=0x6ffffef8,/*pointer ?          ?         Start of conflict section */
        DT_GNU_LIBLIST=0x6ffffef9,/* pointer ?          ?         Library list */
        DT_CONFIG   = 0x6ffffefa, /* pointer ?          ?         Configuration information */
        DT_DEPAUDIT = 0x6ffffefb, /* pointer ?          ?         Dependency auditing */
        DT_AUDIT    = 0x6ffffefc, /* pointer ?          ?         Object auditing */
        DT_PLTPAD   = 0x6ffffefd, /* pointer ?          ?         PLT padding */
        DT_MOVETAB  = 0x6ffffefe, /* pointer ?          ?         Move table */
        DT_SYMINFO  = 0x6ffffeff, /* pointer ?          ?         Syminfo table */

        DT_VERSYM   = 0x6ffffff0, /* pointer ?          ?         ? */
        DT_RELACOUNT= 0x6ffffff9, /* value   ?          ?         ? */
        DT_RELCOUNT = 0x6ffffffa, /* value   ?          ?         ? */
        DT_FLAGS_1  = 0x6ffffffb, /* value   ?          ?         Sun state flags */
        DT_VERDEF   = 0x6ffffffc, /* pointer ?          ?         Sun version definition table */
        DT_VERDEFNUM= 0x6ffffffd, /* value   ?          ?         Sun number of version definitions */
        DT_VERNEED  = 0x6ffffffe, /* pointer ?          ?         Sun needed versions table */
        DT_VERNEEDNUM=0x6fffffff, /* value   ?          ?         Sun number of needed versions */

        DT_AUXILIARY= 0x7ffffffd, /* pointer ?          ?         Sun shared obj to load before self */
        DT_FILTER   = 0x7fffffff  /* pointer ?          ?         Shared object ot get values from */
    };

#ifdef _MSC_VER
# pragma pack (1)
#endif

    /** Disk format. */
    struct Elf32DynamicEntry_disk {
        uint32_t            d_tag;                  /**< Entry type, one of the DT_* constants */
        uint32_t            d_val;                  /**< Tag's value */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct Elf64DynamicEntry_disk {
        uint64_t            d_tag;                  /**< Entry type, one of the DT_* constants */
        uint64_t            d_val;                  /**< Tag's value */
    }
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmElfDynamicEntry::EntryType const& get_d_tag() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_d_tag(SgAsmElfDynamicEntry::EntryType const&);
    /** @} */
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t const& get_d_val() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    rose_rva_t& get_d_val();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_d_val(rose_rva_t const&);
    /** @} */
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericString* const& get_name() const;
    /** @} */
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    void set_name(SgAsmGenericString*);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 134 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_extra() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_extra();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_extra(SgUnsignedCharList const&);
    /** @} */
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmElfDynamicEntry.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor that links the object into the AST. */
    explicit SgAsmElfDynamicEntry(SgAsmElfDynamicSection *dynsec);

    /** Initialize object by parsing the file.
     *
     * @{ */
    void parse(ByteOrder::Endianness, const SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*);
    void parse(ByteOrder::Endianness, const SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*);
    /** @} */

    /** Convert object to disk representation.
     *
     * @{ */
    void *encode(ByteOrder::Endianness, SgAsmElfDynamicEntry::Elf32DynamicEntry_disk*) const;
    void *encode(ByteOrder::Endianness, SgAsmElfDynamicEntry::Elf64DynamicEntry_disk*) const;
    /** @} */

    /** Print some debugging info */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Convert Dynamic Entry Tag to a string */
    static std::string to_string(SgAsmElfDynamicEntry::EntryType);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmElfDynamicEntry();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmElfDynamicEntry();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmElfDynamicEntry_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfWithStmt           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfWithStmt);
IS_SERIALIZABLE(AsmDwarfWithStmt);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfWithStmt.h"
class SgAsmDwarfWithStmt: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfWithStmt);
#if defined(SgAsmDwarfWithStmt_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfWithStmt();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfWithStmt();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfWithStmt(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfWithStmt_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariantPart           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfVariantPart);
IS_SERIALIZABLE(AsmDwarfVariantPart);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfVariantPart.h"
class SgAsmDwarfVariantPart: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfVariantPart);
#if defined(SgAsmDwarfVariantPart_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariantPart();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfVariantPart();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfVariantPart(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariantPart_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfVariant);
IS_SERIALIZABLE(AsmDwarfVariant);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfVariant.h"
class SgAsmDwarfVariant: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfVariant);
#if defined(SgAsmDwarfVariant_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariant();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfVariant();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfVariant(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariant_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfVariable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfVariable);
IS_SERIALIZABLE(AsmDwarfVariable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfVariable.h"
class SgAsmDwarfVariable: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfVariable);
#if defined(SgAsmDwarfVariable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfVariable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfVariable();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfVariable(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfVariable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcStrictType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUpcStrictType);
IS_SERIALIZABLE(AsmDwarfUpcStrictType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUpcStrictType.h"
class SgAsmDwarfUpcStrictType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUpcStrictType);
#if defined(SgAsmDwarfUpcStrictType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcStrictType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUpcStrictType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUpcStrictType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcStrictType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcSharedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUpcSharedType);
IS_SERIALIZABLE(AsmDwarfUpcSharedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUpcSharedType.h"
class SgAsmDwarfUpcSharedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUpcSharedType);
#if defined(SgAsmDwarfUpcSharedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcSharedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUpcSharedType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUpcSharedType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcSharedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUpcRelaxedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUpcRelaxedType);
IS_SERIALIZABLE(AsmDwarfUpcRelaxedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUpcRelaxedType.h"
class SgAsmDwarfUpcRelaxedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUpcRelaxedType);
#if defined(SgAsmDwarfUpcRelaxedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUpcRelaxedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUpcRelaxedType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUpcRelaxedType(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUpcRelaxedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnspecifiedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUnspecifiedType);
IS_SERIALIZABLE(AsmDwarfUnspecifiedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnspecifiedType.h"
class SgAsmDwarfUnspecifiedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUnspecifiedType);
#if defined(SgAsmDwarfUnspecifiedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnspecifiedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUnspecifiedType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUnspecifiedType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnspecifiedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnspecifiedParameters           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUnspecifiedParameters);
IS_SERIALIZABLE(AsmDwarfUnspecifiedParameters);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnspecifiedParameters.h"
class SgAsmDwarfUnspecifiedParameters: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUnspecifiedParameters);
#if defined(SgAsmDwarfUnspecifiedParameters_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnspecifiedParameters();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUnspecifiedParameters();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUnspecifiedParameters(int const& nesting_level,
                                    uint64_t const& offset,
                                    uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnspecifiedParameters_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnknownConstruct           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUnknownConstruct);
IS_SERIALIZABLE(AsmDwarfUnknownConstruct);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnknownConstruct.h"
class SgAsmDwarfUnknownConstruct: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUnknownConstruct);
#if defined(SgAsmDwarfUnknownConstruct_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnknownConstruct();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUnknownConstruct();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUnknownConstruct(int const& nesting_level,
                               uint64_t const& offset,
                               uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnknownConstruct_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfUnionType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfUnionType);
IS_SERIALIZABLE(AsmDwarfUnionType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnionType.h"
class SgAsmDwarfUnionType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnionType.h"
    AsmDwarfUnionType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfUnionType);
#if defined(SgAsmDwarfUnionType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnionType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnionType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfUnionType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfUnionType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfUnionType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfUnionType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfUnionType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTypedef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfTypedef);
IS_SERIALIZABLE(AsmDwarfTypedef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfTypedef.h"
class SgAsmDwarfTypedef: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfTypedef);
#if defined(SgAsmDwarfTypedef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfTypedef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfTypedef();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfTypedef(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTypedef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTryBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfTryBlock);
IS_SERIALIZABLE(AsmDwarfTryBlock);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfTryBlock.h"
class SgAsmDwarfTryBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfTryBlock);
#if defined(SgAsmDwarfTryBlock_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfTryBlock();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfTryBlock();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfTryBlock(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTryBlock_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfThrownType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfThrownType);
IS_SERIALIZABLE(AsmDwarfThrownType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfThrownType.h"
class SgAsmDwarfThrownType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfThrownType);
#if defined(SgAsmDwarfThrownType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfThrownType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfThrownType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfThrownType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfThrownType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTemplateValueParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfTemplateValueParameter);
IS_SERIALIZABLE(AsmDwarfTemplateValueParameter);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfTemplateValueParameter.h"
class SgAsmDwarfTemplateValueParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfTemplateValueParameter);
#if defined(SgAsmDwarfTemplateValueParameter_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfTemplateValueParameter();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfTemplateValueParameter();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfTemplateValueParameter(int const& nesting_level,
                                     uint64_t const& offset,
                                     uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTemplateValueParameter_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfTemplateTypeParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfTemplateTypeParameter);
IS_SERIALIZABLE(AsmDwarfTemplateTypeParameter);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfTemplateTypeParameter.h"
class SgAsmDwarfTemplateTypeParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfTemplateTypeParameter);
#if defined(SgAsmDwarfTemplateTypeParameter_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfTemplateTypeParameter();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfTemplateTypeParameter();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfTemplateTypeParameter(int const& nesting_level,
                                    uint64_t const& offset,
                                    uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfTemplateTypeParameter_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubroutineType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfSubroutineType);
IS_SERIALIZABLE(AsmDwarfSubroutineType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubroutineType.h"
class SgAsmDwarfSubroutineType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubroutineType.h"
    AsmDwarfSubroutineType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfSubroutineType);
#if defined(SgAsmDwarfSubroutineType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubroutineType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubroutineType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubroutineType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubroutineType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfSubroutineType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfSubroutineType(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubroutineType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubrangeType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfSubrangeType);
IS_SERIALIZABLE(AsmDwarfSubrangeType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubrangeType.h"
class SgAsmDwarfSubrangeType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfSubrangeType);
#if defined(SgAsmDwarfSubrangeType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubrangeType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfSubrangeType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfSubrangeType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubrangeType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSubprogram           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfSubprogram);
IS_SERIALIZABLE(AsmDwarfSubprogram);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubprogram.h"
class SgAsmDwarfSubprogram: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubprogram.h"
    AsmDwarfSubprogram.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfSubprogram);
#if defined(SgAsmDwarfSubprogram_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubprogram.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubprogram.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSubprogram.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSubprogram();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfSubprogram();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfSubprogram(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSubprogram_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfStructureType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfStructureType);
IS_SERIALIZABLE(AsmDwarfStructureType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStructureType.h"
class SgAsmDwarfStructureType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStructureType.h"
    AsmDwarfStructureType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfStructureType);
#if defined(SgAsmDwarfStructureType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStructureType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStructureType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStructureType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfStructureType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfStructureType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfStructureType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfStructureType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfStringType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfStringType);
IS_SERIALIZABLE(AsmDwarfStringType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfStringType.h"
class SgAsmDwarfStringType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfStringType);
#if defined(SgAsmDwarfStringType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfStringType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfStringType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfStringType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfStringType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSharedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfSharedType);
IS_SERIALIZABLE(AsmDwarfSharedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSharedType.h"
class SgAsmDwarfSharedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfSharedType);
#if defined(SgAsmDwarfSharedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSharedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfSharedType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfSharedType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSharedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfSetType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfSetType);
IS_SERIALIZABLE(AsmDwarfSetType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfSetType.h"
class SgAsmDwarfSetType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfSetType);
#if defined(SgAsmDwarfSetType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfSetType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfSetType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfSetType(int const& nesting_level,
                      uint64_t const& offset,
                      uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfSetType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfRestrictType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfRestrictType);
IS_SERIALIZABLE(AsmDwarfRestrictType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfRestrictType.h"
class SgAsmDwarfRestrictType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfRestrictType);
#if defined(SgAsmDwarfRestrictType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfRestrictType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfRestrictType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfRestrictType(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfRestrictType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfReferenceType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfReferenceType);
IS_SERIALIZABLE(AsmDwarfReferenceType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfReferenceType.h"
class SgAsmDwarfReferenceType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfReferenceType);
#if defined(SgAsmDwarfReferenceType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfReferenceType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfReferenceType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfReferenceType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfReferenceType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPtrToMemberType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfPtrToMemberType);
IS_SERIALIZABLE(AsmDwarfPtrToMemberType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfPtrToMemberType.h"
class SgAsmDwarfPtrToMemberType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfPtrToMemberType);
#if defined(SgAsmDwarfPtrToMemberType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfPtrToMemberType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfPtrToMemberType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfPtrToMemberType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPtrToMemberType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPointerType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfPointerType);
IS_SERIALIZABLE(AsmDwarfPointerType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfPointerType.h"
class SgAsmDwarfPointerType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfPointerType);
#if defined(SgAsmDwarfPointerType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfPointerType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfPointerType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfPointerType(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPointerType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPartialUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfPartialUnit);
IS_SERIALIZABLE(AsmDwarfPartialUnit);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfPartialUnit.h"
class SgAsmDwarfPartialUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfPartialUnit);
#if defined(SgAsmDwarfPartialUnit_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfPartialUnit();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfPartialUnit();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfPartialUnit(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPartialUnit_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfPackedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfPackedType);
IS_SERIALIZABLE(AsmDwarfPackedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfPackedType.h"
class SgAsmDwarfPackedType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfPackedType);
#if defined(SgAsmDwarfPackedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfPackedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfPackedType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfPackedType(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfPackedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamespace           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfNamespace);
IS_SERIALIZABLE(AsmDwarfNamespace);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamespace.h"
class SgAsmDwarfNamespace: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamespace.h"
    AsmDwarfNamespace.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfNamespace);
#if defined(SgAsmDwarfNamespace_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamespace.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamespace.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamespace.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamespace();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfNamespace();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfNamespace(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamespace_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamelistItem           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfNamelistItem);
IS_SERIALIZABLE(AsmDwarfNamelistItem);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamelistItem.h"
class SgAsmDwarfNamelistItem: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfNamelistItem);
#if defined(SgAsmDwarfNamelistItem_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamelistItem();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfNamelistItem();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfNamelistItem(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamelistItem_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfNamelist           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfNamelist);
IS_SERIALIZABLE(AsmDwarfNamelist);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfNamelist.h"
class SgAsmDwarfNamelist: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfNamelist);
#if defined(SgAsmDwarfNamelist_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfNamelist();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfNamelist();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfNamelist(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfNamelist_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMutableType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfMutableType);
IS_SERIALIZABLE(AsmDwarfMutableType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMutableType.h"
class SgAsmDwarfMutableType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfMutableType);
#if defined(SgAsmDwarfMutableType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfMutableType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfMutableType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfMutableType(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMutableType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfModule);
IS_SERIALIZABLE(AsmDwarfModule);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfModule.h"
class SgAsmDwarfModule: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfModule);
#if defined(SgAsmDwarfModule_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfModule();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfModule();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfModule(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfModule_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMember           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfMember);
IS_SERIALIZABLE(AsmDwarfMember);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMember.h"
class SgAsmDwarfMember: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfMember);
#if defined(SgAsmDwarfMember_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfMember();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfMember();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfMember(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMember_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMacroList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfMacroList);
IS_SERIALIZABLE(AsmDwarfMacroList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacroList.h"
class SgAsmDwarfMacroList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacroList.h"
    AsmDwarfMacroList.setDataPrototype(
        "SgAsmDwarfMacroPtrList", "macro_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfMacroList);
#if defined(SgAsmDwarfMacroList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacroList.h"
        s & BOOST_SERIALIZATION_NVP(p_macro_list);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacroList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfMacroPtrList const& get_macro_list() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_macro_list(SgAsmDwarfMacroPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacroList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfMacroList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfMacroList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMacroList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfMacro           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfMacro);
IS_SERIALIZABLE(AsmDwarfMacro);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacro.h"
class SgAsmDwarfMacro: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacro.h"
    AsmDwarfMacro.setDataPrototype(
        "std::string", "macro_string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfMacro);
#if defined(SgAsmDwarfMacro_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacro.h"
        s & BOOST_SERIALIZATION_NVP(p_macro_string);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacro.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_macro_string() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_macro_string(std::string const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfMacro.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfMacro();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfMacro();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfMacro_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLineList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfLineList);
IS_SERIALIZABLE(AsmDwarfLineList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLineList.h"
class SgAsmDwarfLineList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLineList.h"
    AsmDwarfLineList.setDataPrototype(
        "SgAsmDwarfLinePtrList", "line_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfLineList);
#if defined(SgAsmDwarfLineList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLineList.h"
        s & BOOST_SERIALIZATION_NVP(p_line_list);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLineList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfLinePtrList const& get_line_list() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfLinePtrList& get_line_list();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_line_list(SgAsmDwarfLinePtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLineList.h"
#if 0
    // I [DQ] am having trouble making these proper data members so just use function to return them, so that they are
    // computed dynamically.
    AsmDwarfLineList.setDataPrototype("SgInstructionAddressSourcePositionMapPtrList", "instructionToSourceMap", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
    AsmDwarfLineList.setDataPrototype("SgSourcePositionInstructionAddressMapPtrList", "sourceToInstructionMap", "",
                                      NO_CONSTRUCTOR_PARAMETER, BUILD_LIST_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE);
#endif

public:
    // Once the maps are setup using a valid SgAsmDwarfCompilationUnit, NULL is an acceptable value.
    //! Support for building maps to and from instruction addresses to source positions (files, line numbers, column numbers).
    static DwarfInstructionSourceMapReturnType buildInstructionAddressSourcePositionMaps( SgAsmDwarfCompilationUnit* dwarf_cu = NULL );

    //! Output information about instruction address <--> source position
    void display( const std::string & label );

    static std::pair<uint64_t,uint64_t> instructionRange();
    static std::pair<LineColumnFilePosition,LineColumnFilePosition> sourceCodeRange( int file_id );

    static uint64_t sourceCodeToAddress ( FileIdLineColumnFilePosition sourcePosition );
    static FileIdLineColumnFilePosition addressToSourceCode ( uint64_t address );
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLineList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfLineList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLineList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLine           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfLine);
IS_SERIALIZABLE(AsmDwarfLine);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
class SgAsmDwarfLine: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
    AsmDwarfLine.setDataPrototype(
        "uint64_t", "address", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
    AsmDwarfLine.setDataPrototype(
        "int", "file_id", "= Sg_File_Info::NULL_FILE_ID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
    AsmDwarfLine.setDataPrototype(
        "int", "line", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
    AsmDwarfLine.setDataPrototype(
        "int", "column", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfLine);
#if defined(SgAsmDwarfLine_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
        s & BOOST_SERIALIZATION_NVP(p_address);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
        s & BOOST_SERIALIZATION_NVP(p_file_id);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
        s & BOOST_SERIALIZATION_NVP(p_line);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"
        s & BOOST_SERIALIZATION_NVP(p_column);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_address() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_address(uint64_t const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_file_id() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_file_id(int const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_line() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_line(int const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_column() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_column(int const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLine.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLine();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfLine();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfLine(uint64_t const& address,
                   int const& file_id,
                   int const& line,
                   int const& column);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLine_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLexicalBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfLexicalBlock);
IS_SERIALIZABLE(AsmDwarfLexicalBlock);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLexicalBlock.h"
class SgAsmDwarfLexicalBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLexicalBlock.h"
    AsmDwarfLexicalBlock.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfLexicalBlock);
#if defined(SgAsmDwarfLexicalBlock_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLexicalBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLexicalBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLexicalBlock.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLexicalBlock();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfLexicalBlock();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfLexicalBlock(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLexicalBlock_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfLabel           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfLabel);
IS_SERIALIZABLE(AsmDwarfLabel);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfLabel.h"
class SgAsmDwarfLabel: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfLabel);
#if defined(SgAsmDwarfLabel_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfLabel();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfLabel();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfLabel(int const& nesting_level,
                    uint64_t const& offset,
                    uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfLabel_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInterfaceType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfInterfaceType);
IS_SERIALIZABLE(AsmDwarfInterfaceType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInterfaceType.h"
class SgAsmDwarfInterfaceType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfInterfaceType);
#if defined(SgAsmDwarfInterfaceType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfInterfaceType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfInterfaceType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfInterfaceType(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInterfaceType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInlinedSubroutine           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfInlinedSubroutine);
IS_SERIALIZABLE(AsmDwarfInlinedSubroutine);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInlinedSubroutine.h"
class SgAsmDwarfInlinedSubroutine: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInlinedSubroutine.h"
    AsmDwarfInlinedSubroutine.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfInlinedSubroutine);
#if defined(SgAsmDwarfInlinedSubroutine_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInlinedSubroutine.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInlinedSubroutine.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInlinedSubroutine.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfInlinedSubroutine();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfInlinedSubroutine();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfInlinedSubroutine(int const& nesting_level,
                                uint64_t const& offset,
                                uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInlinedSubroutine_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInheritance           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfInheritance);
IS_SERIALIZABLE(AsmDwarfInheritance);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInheritance.h"
class SgAsmDwarfInheritance: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfInheritance);
#if defined(SgAsmDwarfInheritance_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfInheritance();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfInheritance();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfInheritance(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInheritance_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfImportedUnit);
IS_SERIALIZABLE(AsmDwarfImportedUnit);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfImportedUnit.h"
class SgAsmDwarfImportedUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfImportedUnit);
#if defined(SgAsmDwarfImportedUnit_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedUnit();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfImportedUnit();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfImportedUnit(int const& nesting_level,
                           uint64_t const& offset,
                           uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedUnit_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfImportedModule);
IS_SERIALIZABLE(AsmDwarfImportedModule);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfImportedModule.h"
class SgAsmDwarfImportedModule: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfImportedModule);
#if defined(SgAsmDwarfImportedModule_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedModule();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfImportedModule();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfImportedModule(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedModule_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfImportedDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfImportedDeclaration);
IS_SERIALIZABLE(AsmDwarfImportedDeclaration);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfImportedDeclaration.h"
class SgAsmDwarfImportedDeclaration: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfImportedDeclaration);
#if defined(SgAsmDwarfImportedDeclaration_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfImportedDeclaration();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfImportedDeclaration();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfImportedDeclaration(int const& nesting_level,
                                  uint64_t const& offset,
                                  uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfImportedDeclaration_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFunctionTemplate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfFunctionTemplate);
IS_SERIALIZABLE(AsmDwarfFunctionTemplate);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfFunctionTemplate.h"
class SgAsmDwarfFunctionTemplate: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfFunctionTemplate);
#if defined(SgAsmDwarfFunctionTemplate_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfFunctionTemplate();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfFunctionTemplate();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfFunctionTemplate(int const& nesting_level,
                               uint64_t const& offset,
                               uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFunctionTemplate_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFriend           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfFriend);
IS_SERIALIZABLE(AsmDwarfFriend);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfFriend.h"
class SgAsmDwarfFriend: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfFriend);
#if defined(SgAsmDwarfFriend_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfFriend();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfFriend();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfFriend(int const& nesting_level,
                     uint64_t const& offset,
                     uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFriend_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFormatLabel           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfFormatLabel);
IS_SERIALIZABLE(AsmDwarfFormatLabel);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfFormatLabel.h"
class SgAsmDwarfFormatLabel: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfFormatLabel);
#if defined(SgAsmDwarfFormatLabel_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfFormatLabel();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfFormatLabel();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfFormatLabel(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFormatLabel_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFormalParameter           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfFormalParameter);
IS_SERIALIZABLE(AsmDwarfFormalParameter);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfFormalParameter.h"
class SgAsmDwarfFormalParameter: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfFormalParameter);
#if defined(SgAsmDwarfFormalParameter_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfFormalParameter();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfFormalParameter();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfFormalParameter(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFormalParameter_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfFileType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfFileType);
IS_SERIALIZABLE(AsmDwarfFileType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfFileType.h"
class SgAsmDwarfFileType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfFileType);
#if defined(SgAsmDwarfFileType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfFileType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfFileType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfFileType(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfFileType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEnumerator           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfEnumerator);
IS_SERIALIZABLE(AsmDwarfEnumerator);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerator.h"
class SgAsmDwarfEnumerator: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfEnumerator);
#if defined(SgAsmDwarfEnumerator_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfEnumerator();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfEnumerator();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfEnumerator(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEnumerator_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEnumerationType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfEnumerationType);
IS_SERIALIZABLE(AsmDwarfEnumerationType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerationType.h"
class SgAsmDwarfEnumerationType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerationType.h"
    AsmDwarfEnumerationType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfEnumerationType);
#if defined(SgAsmDwarfEnumerationType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerationType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerationType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEnumerationType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfEnumerationType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfEnumerationType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfEnumerationType(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEnumerationType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfEntryPoint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfEntryPoint);
IS_SERIALIZABLE(AsmDwarfEntryPoint);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfEntryPoint.h"
class SgAsmDwarfEntryPoint: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfEntryPoint);
#if defined(SgAsmDwarfEntryPoint_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfEntryPoint();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfEntryPoint();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfEntryPoint(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfEntryPoint_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfDwarfProcedure           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfDwarfProcedure);
IS_SERIALIZABLE(AsmDwarfDwarfProcedure);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfDwarfProcedure.h"
class SgAsmDwarfDwarfProcedure: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfDwarfProcedure);
#if defined(SgAsmDwarfDwarfProcedure_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfDwarfProcedure();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfDwarfProcedure();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfDwarfProcedure(int const& nesting_level,
                             uint64_t const& offset,
                             uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfDwarfProcedure_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfConstType);
IS_SERIALIZABLE(AsmDwarfConstType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstType.h"
class SgAsmDwarfConstType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfConstType);
#if defined(SgAsmDwarfConstType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfConstType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfConstType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstructList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfConstructList);
IS_SERIALIZABLE(AsmDwarfConstructList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstructorList.h"
class SgAsmDwarfConstructList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstructorList.h"
    AsmDwarfConstructList.setDataPrototype(
        "SgAsmDwarfConstructPtrList", "list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfConstructList);
#if defined(SgAsmDwarfConstructList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstructorList.h"
        s & BOOST_SERIALIZATION_NVP(p_list);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstructorList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructPtrList const& get_list() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructPtrList& get_list();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_list(SgAsmDwarfConstructPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstructorList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstructList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfConstructList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstructList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfConstant);
IS_SERIALIZABLE(AsmDwarfConstant);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstant.h"
class SgAsmDwarfConstant: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfConstant);
#if defined(SgAsmDwarfConstant_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstant();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfConstant();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfConstant(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstant_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCondition           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCondition);
IS_SERIALIZABLE(AsmDwarfCondition);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCondition.h"
class SgAsmDwarfCondition: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCondition);
#if defined(SgAsmDwarfCondition_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCondition();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCondition();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfCondition(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCondition_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCompilationUnitList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCompilationUnitList);
IS_SERIALIZABLE(AsmDwarfCompilationUnitList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnitList.h"
class SgAsmDwarfCompilationUnitList: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnitList.h"
    AsmDwarfCompilationUnitList.setDataPrototype(
        "SgAsmDwarfCompilationUnitPtrList", "cu_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCompilationUnitList);
#if defined(SgAsmDwarfCompilationUnitList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnitList.h"
        s & BOOST_SERIALIZATION_NVP(p_cu_list);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnitList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfCompilationUnitPtrList const& get_cu_list() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfCompilationUnitPtrList& get_cu_list();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_cu_list(SgAsmDwarfCompilationUnitPtrList const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnitList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCompilationUnitList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCompilationUnitList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCompilationUnitList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCompilationUnit           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCompilationUnit);
IS_SERIALIZABLE(AsmDwarfCompilationUnit);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
class SgAsmDwarfCompilationUnit: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "std::string", "producer", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "std::string", "language", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "low_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "hi_pc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "int", "version_stamp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "abbrev_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "address_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "uint64_t", "offset_length", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfLineList*", "line_info", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfConstructList*", "language_constructs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
    AsmDwarfCompilationUnit.setDataPrototype(
        "SgAsmDwarfMacroList*", "macro_info", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCompilationUnit);
#if defined(SgAsmDwarfCompilationUnit_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_producer);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_language);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_low_pc);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_hi_pc);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_version_stamp);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_abbrev_offset);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_address_size);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_offset_length);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_line_info);
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_language_constructs);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
        s & BOOST_SERIALIZATION_NVP(p_macro_info);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_producer() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_producer(std::string const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_language() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_language(std::string const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_low_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_low_pc(uint64_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_hi_pc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hi_pc(uint64_t const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_version_stamp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_version_stamp(int const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_abbrev_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_abbrev_offset(uint64_t const&);
    /** @} */
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_address_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_address_size(uint64_t const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_offset_length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset_length(uint64_t const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfLineList* const& get_line_info() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_line_info(SgAsmDwarfLineList* const&);
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_language_constructs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_language_constructs(SgAsmDwarfConstructList* const&);
    /** @} */
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfMacroList* const& get_macro_info() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_macro_info(SgAsmDwarfMacroList* const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCompilationUnit.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCompilationUnit();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCompilationUnit();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfCompilationUnit(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCompilationUnit_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCommonInclusion           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCommonInclusion);
IS_SERIALIZABLE(AsmDwarfCommonInclusion);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonInclusion.h"
class SgAsmDwarfCommonInclusion: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCommonInclusion);
#if defined(SgAsmDwarfCommonInclusion_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCommonInclusion();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCommonInclusion();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfCommonInclusion(int const& nesting_level,
                              uint64_t const& offset,
                              uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCommonInclusion_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCommonBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCommonBlock);
IS_SERIALIZABLE(AsmDwarfCommonBlock);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonBlock.h"
class SgAsmDwarfCommonBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonBlock.h"
    AsmDwarfCommonBlock.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= NULL",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCommonBlock);
#if defined(SgAsmDwarfCommonBlock_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCommonBlock.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCommonBlock();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCommonBlock();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfCommonBlock(int const& nesting_level,
                          uint64_t const& offset,
                          uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCommonBlock_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfClassType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfClassType);
IS_SERIALIZABLE(AsmDwarfClassType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassType.h"
class SgAsmDwarfClassType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassType.h"
    AsmDwarfClassType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfClassType);
#if defined(SgAsmDwarfClassType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfClassType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfClassType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfClassType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfClassType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfClassTemplate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfClassTemplate);
IS_SERIALIZABLE(AsmDwarfClassTemplate);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfClassTemplate.h"
class SgAsmDwarfClassTemplate: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfClassTemplate);
#if defined(SgAsmDwarfClassTemplate_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfClassTemplate();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfClassTemplate();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfClassTemplate(int const& nesting_level,
                            uint64_t const& offset,
                            uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfClassTemplate_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfCatchBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfCatchBlock);
IS_SERIALIZABLE(AsmDwarfCatchBlock);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfCatchBlock.h"
class SgAsmDwarfCatchBlock: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfCatchBlock);
#if defined(SgAsmDwarfCatchBlock_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfCatchBlock();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfCatchBlock();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfCatchBlock(int const& nesting_level,
                         uint64_t const& offset,
                         uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfCatchBlock_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfBaseType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfBaseType);
IS_SERIALIZABLE(AsmDwarfBaseType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfBaseType.h"
class SgAsmDwarfBaseType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfBaseType);
#if defined(SgAsmDwarfBaseType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfBaseType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfBaseType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfBaseType(int const& nesting_level,
                       uint64_t const& offset,
                       uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfBaseType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfArrayType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfArrayType);
IS_SERIALIZABLE(AsmDwarfArrayType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfArrayType.h"
class SgAsmDwarfArrayType: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfArrayType.h"
    AsmDwarfArrayType.setDataPrototype(
        "SgAsmDwarfConstructList*", "body", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfArrayType);
#if defined(SgAsmDwarfArrayType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfArrayType.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfArrayType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfConstructList* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmDwarfConstructList* const&);
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfArrayType.h"
public:
    SgAsmDwarfConstructList* get_children() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfArrayType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfArrayType();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfArrayType(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfArrayType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfAccessDeclaration           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDwarfAccessDeclaration);
IS_SERIALIZABLE(AsmDwarfAccessDeclaration);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfAccessDeclaration.h"
class SgAsmDwarfAccessDeclaration: public SgAsmDwarfConstruct {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfAccessDeclaration);
#if defined(SgAsmDwarfAccessDeclaration_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfConstruct);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfAccessDeclaration();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfAccessDeclaration();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfAccessDeclaration(int const& nesting_level,
                                uint64_t const& offset,
                                uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfAccessDeclaration_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfConstruct           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmDwarfConstruct = nonTerminalConstructor(
    "AsmDwarfConstruct",
    *this,
    "AsmDwarfConstruct",
    "AsmDwarfConstructTag",
    SubclassListBuilder()
        | AsmDwarfAccessDeclaration
        | AsmDwarfArrayType
        | AsmDwarfBaseType
        | AsmDwarfCatchBlock
        | AsmDwarfClassTemplate
        | AsmDwarfClassType
        | AsmDwarfCommonBlock
        | AsmDwarfCommonInclusion
        | AsmDwarfCompilationUnit
        | AsmDwarfCondition
        | AsmDwarfConstant
        | AsmDwarfConstType
        | AsmDwarfDwarfProcedure
        | AsmDwarfEntryPoint
        | AsmDwarfEnumerationType
        | AsmDwarfEnumerator
        | AsmDwarfFileType
        | AsmDwarfFormalParameter
        | AsmDwarfFormatLabel
        | AsmDwarfFriend
        | AsmDwarfFunctionTemplate
        | AsmDwarfImportedDeclaration
        | AsmDwarfImportedModule
        | AsmDwarfImportedUnit
        | AsmDwarfInheritance
        | AsmDwarfInlinedSubroutine
        | AsmDwarfInterfaceType
        | AsmDwarfLabel
        | AsmDwarfLexicalBlock
        | AsmDwarfMember
        | AsmDwarfModule
        | AsmDwarfMutableType
        | AsmDwarfNamelist
        | AsmDwarfNamelistItem
        | AsmDwarfNamespace
        | AsmDwarfPackedType
        | AsmDwarfPartialUnit
        | AsmDwarfPointerType
        | AsmDwarfPtrToMemberType
        | AsmDwarfReferenceType
        | AsmDwarfRestrictType
        | AsmDwarfSetType
        | AsmDwarfSharedType
        | AsmDwarfStringType
        | AsmDwarfStructureType
        | AsmDwarfSubprogram
        | AsmDwarfSubrangeType
        | AsmDwarfSubroutineType
        | AsmDwarfTemplateTypeParameter
        | AsmDwarfTemplateValueParameter
        | AsmDwarfThrownType
        | AsmDwarfTryBlock
        | AsmDwarfTypedef
        | AsmDwarfUnionType
        | AsmDwarfUnknownConstruct
        | AsmDwarfUnspecifiedParameters
        | AsmDwarfUnspecifiedType
        | AsmDwarfUpcRelaxedType
        | AsmDwarfUpcSharedType
        | AsmDwarfUpcStrictType
        | AsmDwarfVariable
        | AsmDwarfVariant
        | AsmDwarfVariantPart
        | AsmDwarfWithStmt
        | AsmDwarfVolatileType
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmDwarfConstruct.associatedGrammar != nullptr);
AsmDwarfConstruct.setCppCondition("!defined(DOCUMENTATION)");
AsmDwarfConstruct.isBoostSerializable(true);
AsmDwarfConstruct.setAutomaticGenerationOfConstructor(false);
AsmDwarfConstruct.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
class SgAsmDwarfConstruct: public SgAsmDwarfInformation {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    AsmDwarfConstruct.setDataPrototype(
        "int", "nesting_level", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    AsmDwarfConstruct.setDataPrototype(
        "uint64_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    AsmDwarfConstruct.setDataPrototype(
        "uint64_t", "overall_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    AsmDwarfConstruct.setDataPrototype(
        "std::string", "name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    AsmDwarfConstruct.setDataPrototype(
        "SgAsmDwarfLine*", "source_position", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfConstruct);
#if defined(SgAsmDwarfConstruct_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmDwarfInformation);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
        s & BOOST_SERIALIZATION_NVP(p_nesting_level);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
        s & BOOST_SERIALIZATION_NVP(p_overall_offset);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
        s & BOOST_SERIALIZATION_NVP(p_source_position);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    // AsmDwarfConstruct.setFunctionPrototype("HEADER_ATTRIBUTE_SUPPORT", "../Grammar/Support.code");
    // AsmDwarfConstruct.setFunctionSource("SOURCE_ATTRIBUTE_SUPPORT", "../Grammar/Support.code");

    // For now we will store the nesting level (just to support debugging), then it will be removed.
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_nesting_level() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_nesting_level(int const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_offset(uint64_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_overall_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_overall_offset(uint64_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    // A lot of constructs have a name so put the name into the base class
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_name(std::string const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    // This is a data member that can be filled in via a separate analysis (we would have to read the line information before
    // hand).
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmDwarfLine* const& get_source_position() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_source_position(SgAsmDwarfLine* const&);
    /** @} */
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfConstruct.h"
    // [Robb Matzke 2023-03-22]: SgNode already has an attributeMechanism
    // [[using Rosebud: rosetta]]
    // AstAttributeMechanism* attributeMechanism = nullptr;

public:
    /** Factory pattern to build IR nodes based on the tag. */
    static SgAsmDwarfConstruct* createDwarfConstruct( int tag, int nesting_level, uint64_t offset, uint64_t overall_offset );

    virtual SgAsmDwarfConstructList* get_children();
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfConstruct();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfConstruct();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmDwarfConstruct(int const& nesting_level,
                        uint64_t const& offset,
                        uint64_t const& overall_offset);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfConstruct_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDwarfInformation           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmDwarfInformation = nonTerminalConstructor(
    "AsmDwarfInformation",
    *this,
    "AsmDwarfInformation",
    "AsmDwarfInformationTag",
    SubclassListBuilder()
        | AsmDwarfCompilationUnitList
        | AsmDwarfConstruct
        | AsmDwarfConstructList
        | AsmDwarfLine
        | AsmDwarfLineList
        | AsmDwarfMacro
        | AsmDwarfMacroList
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmDwarfInformation.associatedGrammar != nullptr);
AsmDwarfInformation.setCppCondition("!defined(DOCUMENTATION)");
AsmDwarfInformation.isBoostSerializable(true);
AsmDwarfInformation.setAutomaticGenerationOfConstructor(false);
AsmDwarfInformation.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDwarfInformation.h"
class SgAsmDwarfInformation: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDwarfInformation);
#if defined(SgAsmDwarfInformation_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDwarfInformation();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDwarfInformation();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDwarfInformation_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDOSFileHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDOSFileHeader);
IS_SERIALIZABLE(AsmDOSFileHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
/** Represents the file header for DOS executables.
 *
 *  Many of the properties for this node come directly from the DOS specification and have similar names to that documentation. Such
 *  properties are not documented in ROSE. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
class SgAsmDOSFileHeader: public SgAsmGenericHeader {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_last_page_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_total_pages", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_nrelocs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_header_paragraphs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_minalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_maxalloc", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_ss", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_sp", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_cksum", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_ip", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_cs", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "uint16_t", "e_overlay", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "rose_addr_t", "e_relocs_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "SgAsmGenericSection*", "relocs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    AsmDOSFileHeader.setDataPrototype(
        "SgAsmGenericSection*", "rm_section", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDOSFileHeader);
#if defined(SgAsmDOSFileHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericHeader);
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_last_page_size);
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_total_pages);
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_nrelocs);
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_header_paragraphs);
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_minalloc);
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_maxalloc);
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ss);
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_sp);
#line 106 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_cksum);
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_ip);
#line 118 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_cs);
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_overlay);
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_relocs_offset);
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_relocs);
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_rm_section);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    /** On-disk format of DOS file header. */
    struct DOSFileHeader_disk {
        unsigned char e_magic[2];                /**< 0x00 "MZ" */
        uint16_t      e_last_page_size;          /**< 0x02 bytes used on last page of file (1 page == 512 bytes);
                                                  *        zero implies if last page is full. */ //
        uint16_t      e_total_pages;             /**< 0x04 number of pages (inc. last possibly partial page) in file. */
        uint16_t      e_nrelocs;                 /**< 0x06 number of relocation entries stored after this header. */
        uint16_t      e_header_paragraphs;       /**< 0x08 header size in paragraphs (16-byte blocks) inc. relocations. */
        uint16_t      e_minalloc;                /**< 0x0a number of extra paragraphs needed, similar to BSS in Unix. */
        uint16_t      e_maxalloc;                /**< 0x0c max paragraphs to allocate for BSS. */
        uint16_t      e_ss;                      /**< 0x0e initial value of SS register relative to program load segment. */
        uint16_t      e_sp;                      /**< 0x10 initial value for SP register. */
        uint16_t      e_cksum;                   /**< 0x12 checksum; 16-bit sum of all words in file should be zero
                                                  *        (usually not filled in). */
        uint16_t      e_ip;                      /**< 0x14 initial value for IP register. */
        uint16_t      e_cs;                      /**< 0x16 initial value for CS register relative to program load segment. */
        uint16_t      e_relocs_offset;           /**< 0x18 file address of relocation table. */
        uint16_t      e_overlay;                 /**< 0x1a overlay number (zero indicates main program). */
        uint32_t      e_res1;                    /**< 0x1c unknown purpose. */
    }                                            /* 0x20 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

    struct DOSRelocEntry_disk {
        uint16_t      offset;                       /* 0x00 */
        uint16_t      segment;                      /* 0x02 */
    }                                               /* 0x04 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;

#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_last_page_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_last_page_size(uint16_t const&);
    /** @} */
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_total_pages() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_total_pages(uint16_t const&);
    /** @} */
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_nrelocs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_nrelocs(uint16_t const&);
    /** @} */
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 73 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_header_paragraphs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_header_paragraphs(uint16_t const&);
    /** @} */
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_minalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_minalloc(uint16_t const&);
    /** @} */
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_maxalloc() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_maxalloc(uint16_t const&);
    /** @} */
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 91 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_ss() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ss(uint16_t const&);
    /** @} */
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_sp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_sp(uint16_t const&);
    /** @} */
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_cksum() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_cksum(uint16_t const&);
    /** @} */
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_ip() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_ip(uint16_t const&);
    /** @} */
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_cs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_cs(uint16_t const&);
    /** @} */
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_e_overlay() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_overlay(uint16_t const&);
    /** @} */
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_relocs_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_relocs_offset(rose_addr_t const&);
    /** @} */
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res1(unsigned const&);
    /** @} */
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection* const& get_relocs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_relocs(SgAsmGenericSection* const&);
    /** @} */
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection* const& get_rm_section() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_rm_section(SgAsmGenericSection* const&);
    /** @} */
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSFileHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmDOSFileHeader(SgAsmGenericFile*);
    virtual SgAsmDOSFileHeader *parse() override {return parse(true);}
    SgAsmDOSFileHeader *parse(bool define_rm_section);
    virtual bool reallocate() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
    virtual const char *format_name() const override {return "DOS";}

    /** Parses the DOS real-mode text+data section and adds it to the AST.
     *
     *  If max_offset is non-zero then use that as the maximum offset of the real-mode section. If the DOS header indicates a zero
     *  sized section then return NULL. If the section exists or is zero size due to the max_offset then return the section. See
     *  also, update_from_rm_section(). */
    SgAsmGenericSection *parse_rm_section(rose_addr_t max_offset=0);

    /** Update DOS header with data from real-mode section.
     *
     *  The DOS real-mode data+text section is assumed to appear immediately after the DOS Extended Header, which appears
     *  immediately after the DOS File Header, which appears at the beginning of the file. These assumptions are not checked until
     *  SgAsmDOSFileHeader::unparse() is called. See also, @ref parse_rm_section. */
    void update_from_rm_section();

    /** Returns true if a cursory look at the file indicates that it could be a DOS executable file. */
    static bool is_DOS(SgAsmGenericFile*);

private:
    void *encode(SgAsmDOSFileHeader::DOSFileHeader_disk*) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDOSFileHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDOSFileHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDOSFileHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmGenericHeader = nonTerminalConstructor(
    "AsmGenericHeader",
    *this,
    "AsmGenericHeader",
    "AsmGenericHeaderTag",
    SubclassListBuilder()
        | AsmDOSFileHeader
        | AsmElfFileHeader
        | AsmJvmFileHeader
        | AsmLEFileHeader
        | AsmNEFileHeader
        | AsmPEFileHeader
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmGenericHeader.associatedGrammar != nullptr);
AsmGenericHeader.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericHeader.isBoostSerializable(true);
AsmGenericHeader.setAutomaticGenerationOfConstructor(false);
AsmGenericHeader.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
/** Base class for container file headers. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
class SgAsmGenericHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericFormat*", "exec_format", "= createAndParent<SgAsmGenericFormat>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgCharList", "magic", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericFormat::InsSetArchitecture", "isa", "= SgAsmGenericFormat::ISA_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "rose_addr_t", "base_va", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgRVAList", "entry_rvas", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericDLLList*", "dlls", "= createAndParent<SgAsmGenericDLLList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    AsmGenericHeader.setDataPrototype(
        "SgAsmGenericSectionList*", "sections", "= createAndParent<SgAsmGenericSectionList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericHeader);
#if defined(SgAsmGenericHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_exec_format);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_magic);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_isa);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_base_va);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_entry_rvas);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_dlls);
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_sections);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFormat* const& get_exec_format() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exec_format(SgAsmGenericFormat* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgCharList const& get_magic() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgCharList& get_magic();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_magic(SgCharList const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFormat::InsSetArchitecture const& get_isa() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_isa(SgAsmGenericFormat::InsSetArchitecture const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_base_va() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_base_va(rose_addr_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgRVAList const& get_entry_rvas() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgRVAList& get_entry_rvas();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entry_rvas(SgRVAList const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericDLLList* const& get_dlls() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dlls(SgAsmGenericDLLList* const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSectionList* const& get_sections() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_sections(SgAsmGenericSectionList* const&);
    /** @} */
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericHeader.h"
public:
    /** Constructor.
     *
     *  Headers (@ref SgAsmGenericHeader and derived classes) set the file/header relationship--a bidirectional link
     *  between this new header and the single file that contains this new header. This new header points to its file and
     *  the file contains a list that points to this new header. The header-to-file half of the link is deleted by the
     *  default destructor by virtue of being a simple pointer, but we also need to delete the other half of the link in
     *  the destructors. */
    explicit SgAsmGenericHeader(SgAsmGenericFile*);

    /** Allow all sections to reallocate themselves */
    virtual bool reallocate() override;

    /** Unparse headers and all they point to */
    virtual void unparse(std::ostream&) const override;

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;

    /** Returns the name of the file format. */
    virtual const char *format_name() const;

    /** Add a new DLL to the header DLL list */
    void add_dll(SgAsmGenericDLL *dll);

    /** Vector of dynamically loaded libraries. */
    std::vector<SgAsmGenericDLL*>& get_dlls() {
        ROSE_ASSERT(p_dlls != NULL);
        return p_dlls->get_dlls();
    }

    /** Returns the RVA of the first entry point.
     *
     *  The return value is relative to the header's base virtual address. If there are no entry points defined then
     *  returns a zero RVA. */
    rose_addr_t get_entry_rva() const;

    /** Append an RVA to the list of entry points. */
    void add_entry_rva(const rose_rva_t &rva) {
        p_entry_rvas.push_back(rva);
    }

    /* Convenience functions */
    ByteOrder::Endianness get_sex() const;
    size_t get_word_size() const;

    /** Adds a new section to the header.
     *
     *  This is called implicitly by the section constructor. */
    void add_section(SgAsmGenericSection*);

    /** Removes a secton from the header's section list. */
    void remove_section(SgAsmGenericSection*);

    /** Returns the list of sections that are memory mapped */
    SgAsmGenericSectionPtrList get_mapped_sections() const;

    /** Returns sections in this header that have the specified ID. */
    SgAsmGenericSectionPtrList get_sections_by_id(int id) const;

    /** Returns sections in this header that have the specified name.
     *
     *  If @p sep is a non-null string then ignore any part of name at and after @p sep. */
    SgAsmGenericSectionPtrList get_sections_by_name(std::string, char sep=0) const;

    /** Returns sectons in this header that contain all of the specified portion of the file. */
    SgAsmGenericSectionPtrList get_sections_by_offset(rose_addr_t offset, rose_addr_t size) const;

    /** Returns sections that have a preferred mapping that includes the specified relative virtual address. */
    SgAsmGenericSectionPtrList get_sections_by_rva(rose_addr_t rva) const;

    /** Returns sections having a preferred or actual mapping that includes the specified virtual address.
     *
     *  If @p use_preferred is set, then the condition is evaluated by looking at the section's preferred mapping,
     *  otherwise the actual mapping is used.  If an actual mapping is used, the specified virtual address must be part of
     *  the actual mapped section, not merely in the memory region that was also mapped to satisfy alignment
     *  constraints. */
    SgAsmGenericSectionPtrList get_sections_by_va(rose_addr_t va, bool use_preferred) const;

    /** Returns single section in this header that has the specified ID. */
    SgAsmGenericSection *get_section_by_id(int id, size_t *nfound=0) const;

    /** Returns single section in this header that has the specified name. */
    SgAsmGenericSection *get_section_by_name(const std::string&, char sep=0, size_t *nfound=0) const;

    /** Returns single section in this header that contains all of the specified portion of the file. */
    SgAsmGenericSection *get_section_by_offset(rose_addr_t offset, rose_addr_t size, size_t *nfound=0) const;

    /** Returns the single section having a preferred mapping that includes the specified relative virtual address.
     *
     *  If there are no sections or multiple sections satisfying this condition then a null pointer is returned. */
    SgAsmGenericSection *get_section_by_rva(rose_addr_t rva, size_t *nfound=0) const;

    /** Returns the section having a preferred or actual mapping that includes the specified virtual address.
     *
     *  If @p use_preferred is set, then the condition is evaluated by looking at the section's preferred mapping,
     *  otherwise the actual mapping is used. If an actual mapping is used, the specified virtual address must be part of
     *  the actual mapped section, not merely in the memory region that was also mapped to satisfy alignment constraints.
     *  If there are no sections or multiple sections satisfying this condition then a null pointer is returned. */
    SgAsmGenericSection *get_section_by_va(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;

    /** Like SgAsmGenericFile::get_best_section_by_va() except considers only sections defined in this header. */
    SgAsmGenericSection *get_best_section_by_va(rose_addr_t va, bool use_preferred, size_t *nfound=0) const;

protected:
    virtual void destructorHelper() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDOSExtendedHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDOSExtendedHeader);
IS_SERIALIZABLE(AsmDOSExtendedHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
/** DOS exteded header.
 *
 *  Most of the properties correspond to those defined in the PE/DOS specifications and that documentation is not repeated here. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
class SgAsmDOSExtendedHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res1", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_oemid", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_oeminfo", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res2", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res3", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res4", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res5", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "unsigned", "e_res6", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    AsmDOSExtendedHeader.setDataPrototype(
        "rose_addr_t", "e_lfanew", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDOSExtendedHeader);
#if defined(SgAsmDOSExtendedHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res1);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_oemid);
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_oeminfo);
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res2);
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res3);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res4);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res5);
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_res6);
#line 86 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_e_lfanew);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct DOSExtendedHeader_disk {
        uint32_t      e_res1;     /* 0x00 reserved */
        uint16_t      e_oemid;    /* 0x04 OEM Identifier */
        uint16_t      e_oeminfo;  /* 0x06 other OEM information; oemid specific */
        uint32_t      e_res2;     /* 0x08 reserved */
        uint32_t      e_res3;     /* 0x0c reserved */
        uint32_t      e_res4;     /* 0x10 reserved */
        uint32_t      e_res5;     /* 0x14 reserved */
        uint32_t      e_res6;     /* 0x18 reserved */
        uint32_t      e_lfanew;   /* 0x1c file offset of new exe (PE) header */
    }                                 /* 0x20 */
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res1() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res1(unsigned const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_oemid() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_oemid(unsigned const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_oeminfo() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_oeminfo(unsigned const&);
    /** @} */
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res2() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res2(unsigned const&);
    /** @} */
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res3() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res3(unsigned const&);
    /** @} */
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res4() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res4(unsigned const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res5() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res5(unsigned const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_e_res6() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_res6(unsigned const&);
    /** @} */
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_e_lfanew() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_e_lfanew(rose_addr_t const&);
    /** @} */
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDOSExtendedHeader.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    explicit SgAsmDOSExtendedHeader(SgAsmDOSFileHeader*);
    virtual SgAsmDOSExtendedHeader *parse() override;
    void *encode(SgAsmDOSExtendedHeader::DOSExtendedHeader_disk*) const;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDOSExtendedHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDOSExtendedHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDOSExtendedHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmDirectRegisterExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmDirectRegisterExpression);
IS_SERIALIZABLE(AsmDirectRegisterExpression);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDirectRegisterExpression.h"
/** Expression representing a machine register. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmDirectRegisterExpression.h"
class SgAsmDirectRegisterExpression: public SgAsmRegisterReferenceExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmDirectRegisterExpression);
#if defined(SgAsmDirectRegisterExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmRegisterReferenceExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmDirectRegisterExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmDirectRegisterExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmDirectRegisterExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmDirectRegisterExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmRegisterReferenceExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmRegisterReferenceExpression = nonTerminalConstructor(
    "AsmRegisterReferenceExpression",
    *this,
    "AsmRegisterReferenceExpression",
    "AsmRegisterReferenceExpressionTag",
    SubclassListBuilder()
        | AsmDirectRegisterExpression
        | AsmIndirectRegisterExpression
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmRegisterReferenceExpression.associatedGrammar != nullptr);
AsmRegisterReferenceExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmRegisterReferenceExpression.isBoostSerializable(true);
AsmRegisterReferenceExpression.setAutomaticGenerationOfConstructor(false);
AsmRegisterReferenceExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
/** Base class for references to a machine register. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
class SgAsmRegisterReferenceExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
    AsmRegisterReferenceExpression.setDataPrototype(
        "Rose::BinaryAnalysis::RegisterDescriptor", "descriptor", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
    AsmRegisterReferenceExpression.setDataPrototype(
        "int", "adjustment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmRegisterReferenceExpression);
#if defined(SgAsmRegisterReferenceExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_descriptor);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_adjustment);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::RegisterDescriptor const& get_descriptor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_descriptor(Rose::BinaryAnalysis::RegisterDescriptor const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_adjustment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_adjustment(int const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmRegisterReferenceExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmRegisterReferenceExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmRegisterReferenceExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmRegisterReferenceExpression(Rose::BinaryAnalysis::RegisterDescriptor const& descriptor);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmRegisterReferenceExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmControlFlagsExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmControlFlagsExpression);
IS_SERIALIZABLE(AsmControlFlagsExpression);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmControlFlagsExpression);
#if defined(SgAsmControlFlagsExpression_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmControlFlagsExpression_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"
class SgAsmControlFlagsExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"
    AsmControlFlagsExpression.setDataPrototype(
        "unsigned long", "bit_flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmControlFlagsExpression);
#if defined(SgAsmControlFlagsExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_bit_flags);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned long const& get_bit_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bit_flags(unsigned long const&);
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmControlFlowFlagsExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmControlFlagsExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmControlFlagsExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmControlFlagsExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmConstantExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmConstantExpression = nonTerminalConstructor(
    "AsmConstantExpression",
    *this,
    "AsmConstantExpression",
    "AsmConstantExpressionTag",
    SubclassListBuilder()
        | AsmFloatValueExpression
        | AsmIntegerValueExpression
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmConstantExpression.associatedGrammar != nullptr);
AsmConstantExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmConstantExpression.isBoostSerializable(true);
AsmConstantExpression.setAutomaticGenerationOfConstructor(false);
AsmConstantExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmConstantExpression);
#if defined(SgAsmConstantExpression_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
#include <Sawyer/BitVector.h>
#endif // SgAsmConstantExpression_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
/** Base class for constants.
 *
 *  Represents integer values, floating-point values, etc. This class holds the actual bits for the constant value.
 *  Subclasses provide the intepretation of those bits. */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
class SgAsmConstantExpression: public SgAsmValueExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
    AsmConstantExpression.setDataPrototype(
        "Sawyer::Container::BitVector", "bitVector", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmConstantExpression);
#if defined(SgAsmConstantExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmValueExpression);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_bitVector);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Sawyer::Container::BitVector const& get_bitVector() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    Sawyer::Container::BitVector& get_bitVector();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bitVector(Sawyer::Container::BitVector const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmConstantExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmConstantExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmConstantExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmConstantExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmValueExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmValueExpression = nonTerminalConstructor(
    "AsmValueExpression",
    *this,
    "AsmValueExpression",
    "AsmValueExpressionTag",
    SubclassListBuilder()
        | AsmConstantExpression
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmValueExpression.associatedGrammar != nullptr);
AsmValueExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmValueExpression.isBoostSerializable(true);
AsmValueExpression.setAutomaticGenerationOfConstructor(false);
AsmValueExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
/** Base class for values.
 *
 *  Assembly instruction (@ref SgAsmInstruction) operands are represented by @ref SgAsmExpression nodes in the AST. If the
 *  expression has a numeric value then an @ref SgAsmValueExpression is used.  Values of various types (integers and
 *  floating-point values of various sizes) are represented by subclasses of @ref SgAsmValueExpression.  Values that are
 *  addresses or references to data will have symbols in a function symbol table.  All other values are assumed to be
 *  literals and will not have associated symbols. */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
class SgAsmValueExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    AsmValueExpression.setDataPrototype(
        "SgAsmValueExpression*", "unfolded_expression_tree", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    AsmValueExpression.setDataPrototype(
        "unsigned short", "bit_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    AsmValueExpression.setDataPrototype(
        "unsigned short", "bit_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    AsmValueExpression.setDataPrototype(
        "SgSymbol*", "symbol", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmValueExpression);
#if defined(SgAsmValueExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_unfolded_expression_tree);
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_bit_offset);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_bit_size);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmValueExpression* const& get_unfolded_expression_tree() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_unfolded_expression_tree(SgAsmValueExpression* const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned short const& get_bit_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bit_offset(unsigned short const&);
    /** @} */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned short const& get_bit_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bit_size(unsigned short const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgSymbol* const& get_symbol() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbol(SgSymbol* const&);
    /** @} */
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmValueExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmValueExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmValueExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmValueExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCommonSubExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCommonSubExpression);
IS_SERIALIZABLE(AsmCommonSubExpression);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmCommonSubExpression);
#if defined(SgAsmCommonSubExpression_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"
// FIXME[Robb P Matzke 2016-10-31]: no idea what this is
#endif // SgAsmCommonSubExpression_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"
class SgAsmCommonSubExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"
    AsmCommonSubExpression.setDataPrototype(
        "SgAsmExpression*", "subexpression", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCommonSubExpression);
#if defined(SgAsmCommonSubExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_subexpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_subexpression() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_subexpression(SgAsmExpression* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCommonSubExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCommonSubExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCommonSubExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCommonSubExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbolTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCoffSymbolTable);
IS_SERIALIZABLE(AsmCoffSymbolTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
/** COFF symbol table.
 *
 *  This is a symbol table used by Microsoft PE format. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
class SgAsmCoffSymbolTable: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
    AsmCoffSymbolTable.setDataPrototype(
        "SgAsmGenericSection*", "strtab", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
    AsmCoffSymbolTable.setDataPrototype(
        "SgAsmCoffSymbolList*", "symbols", "= createAndParent<SgAsmCoffSymbolList>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCoffSymbolTable);
#if defined(SgAsmCoffSymbolTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
        s & BOOST_SERIALIZATION_NVP(p_strtab);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection* const& get_strtab() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strtab(SgAsmGenericSection* const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCoffSymbolList* const& get_symbols() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgAsmCoffSymbolList* const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolTable.h"
public:
    explicit SgAsmCoffSymbolTable(SgAsmPEFileHeader*);
    size_t get_nslots() const;
    virtual SgAsmCoffSymbolTable *parse() override;
    virtual void unparse(std::ostream&) const override;
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbolTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCoffSymbolTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbolTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbolList           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCoffSymbolList);
IS_SERIALIZABLE(AsmCoffSymbolList);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"
/** List of COFF symbols. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"
class SgAsmCoffSymbolList: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"
    AsmCoffSymbolList.setDataPrototype(
        "SgAsmCoffSymbolPtrList", "symbols", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCoffSymbolList);
#if defined(SgAsmCoffSymbolList_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"
        s & BOOST_SERIALIZATION_NVP(p_symbols);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCoffSymbolPtrList const& get_symbols() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmCoffSymbolPtrList& get_symbols();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_symbols(SgAsmCoffSymbolPtrList const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbolList.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbolList();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCoffSymbolList();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbolList_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCoffSymbol);
IS_SERIALIZABLE(AsmCoffSymbol);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
/** COFF symbol. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
class SgAsmCoffSymbol: public SgAsmGenericSymbol {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "std::string", "st_name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "rose_addr_t", "st_name_offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "int", "st_section_num", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_type", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_storage_class", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "unsigned", "st_num_aux_entries", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    AsmCoffSymbol.setDataPrototype(
        "SgUnsignedCharList", "aux_data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCoffSymbol);
#if defined(SgAsmCoffSymbol_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSymbol);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_name);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_name_offset);
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_section_num);
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_type);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_storage_class);
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_st_num_aux_entries);
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_aux_data);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
#ifdef _MSC_VER
# pragma pack (1)
#endif
    struct COFFSymbol_disk {
        union {
            char            st_name[8];
            struct {
                uint32_t    st_zero;
                uint32_t    st_offset;
            };
        };
        uint32_t            st_value;
        int16_t             st_section_num;
        uint16_t            st_type;
        unsigned char       st_storage_class;
        unsigned char       st_num_aux_entries;
    }
// DQ (3/7/2013): Adding support to restrict visability to SWIG.
#if !defined(SWIG) && !defined(_MSC_VER)
    __attribute__((packed))
#endif
    ;
#ifdef _MSC_VER
# pragma pack ()
#endif

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties and data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_st_name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_name(std::string const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_st_name_offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_name_offset(rose_addr_t const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_st_section_num() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_section_num(int const&);
    /** @} */
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_st_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_type(unsigned const&);
    /** @} */
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_st_storage_class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_storage_class(unsigned const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_st_num_aux_entries() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_st_num_aux_entries(unsigned const&);
    /** @} */
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_aux_data() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList& get_aux_data();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_aux_data(SgUnsignedCharList const&);
    /** @} */
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffSymbol.h"
public:
    static const unsigned int COFFSymbol_disk_size = 18;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    SgAsmCoffSymbol(SgAsmPEFileHeader *fhdr, SgAsmGenericSection *symtab, SgAsmGenericSection *strtab, size_t idx);
    void *encode(SgAsmCoffSymbol::COFFSymbol_disk*) const;
    virtual void dump(FILE *f, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCoffSymbol();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCoffSymbol();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffSymbol_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSymbol           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmGenericSymbol = nonTerminalConstructor(
    "AsmGenericSymbol",
    *this,
    "AsmGenericSymbol",
    "AsmGenericSymbolTag",
    SubclassListBuilder()
        | AsmCoffSymbol
        | AsmElfSymbol
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmGenericSymbol.associatedGrammar != nullptr);
AsmGenericSymbol.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericSymbol.isBoostSerializable(true);
AsmGenericSymbol.setAutomaticGenerationOfConstructor(false);
AsmGenericSymbol.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmGenericSymbol);
#if defined(SgAsmGenericSymbol_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
/* Base class for symbol tables. */
#endif // SgAsmGenericSymbol_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
class SgAsmGenericSymbol: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolDefState", "def_state", "= SgAsmGenericSymbol::SYM_UNDEFINED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolBinding", "binding", "= SgAsmGenericSymbol::SYM_NO_BINDING",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSymbol::SymbolType", "type", "= SgAsmGenericSymbol::SYM_NO_TYPE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "rose_addr_t", "value", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericSection*", "bound", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    AsmGenericSymbol.setDataPrototype(
        "SgAsmGenericString*", "name", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericSymbol);
#if defined(SgAsmGenericSymbol_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_def_state);
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_binding);
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_type);
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_value);
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_size);
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_bound);
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Symbol definition state. */
    enum SymbolDefState {
        SYM_UNDEFINED,          /**< Symbol has not been defined yet. */
        SYM_TENTATIVE,          /**< Does not have size/value yet. E.g., uninitialized C or Fortran common blks. */
        SYM_DEFINED             /**< Created and assigned storage. */
    };

    /** Symbol type. */
    enum SymbolType {
        SYM_NO_TYPE,            /**< No type or type is unknown. */
        SYM_DATA,               /**< Normal variable definitions. */
        SYM_FUNC,               /**< Function or other code. */
        SYM_SECTION,            /**< Section of a file. */
        SYM_FILE,               /**< Name of a file. */
        SYM_ARRAY,              /**< Array of some other type. */
        SYM_TLS,                /**< Thread-local storage. */
        SYM_REGISTER,           /**< CPU register value. See Sparc. */
        SYM_COMMON,             /**< Common block. */
        SYM_IFUNC               /**< Indirection function. */
    };

    /** Symbol binding. */
    enum SymbolBinding {
        SYM_NO_BINDING,         /**< Unknown binding. */
        SYM_LOCAL,              /**< Local binding. */
        SYM_GLOBAL,             /**< Global binding. */
        SYM_WEAK                /**< Weak binding. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSymbol::SymbolDefState const& get_def_state() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_def_state(SgAsmGenericSymbol::SymbolDefState const&);
    /** @} */
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSymbol::SymbolBinding const& get_binding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_binding(SgAsmGenericSymbol::SymbolBinding const&);
    /** @} */
#line 46 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSymbol::SymbolType const& get_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_type(SgAsmGenericSymbol::SymbolType const&);
    /** @} */
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_value() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_value(rose_addr_t const&);
    /** @} */
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_size(rose_addr_t const&);
    /** @} */
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection* const& get_bound() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_bound(SgAsmGenericSection* const&);
    /** @} */
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSymbol.h"
    SgAsmGenericString* get_name() const;
    void set_name(SgAsmGenericString*);
    /** @} */

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericSymbol();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericSymbol();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSymbol_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCoffStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCoffStrtab);
IS_SERIALIZABLE(AsmCoffStrtab);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffStrtab.h"
/** COFF symbol string table. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffStrtab.h"
class SgAsmCoffStrtab: public SgAsmGenericStrtab {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCoffStrtab);
#if defined(SgAsmCoffStrtab_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericStrtab);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCoffStrtab.h"
public:
    explicit SgAsmCoffStrtab(class SgAsmPESection *containing_section);
    void destructorHelper() override;
    virtual void unparse(std::ostream&) const;
    virtual SgAsmStringStorage *create_storage(rose_addr_t offset, bool shared) override;
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCoffStrtab();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCoffStrtab();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCoffStrtab_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericStrtab           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmGenericStrtab = nonTerminalConstructor(
    "AsmGenericStrtab",
    *this,
    "AsmGenericStrtab",
    "AsmGenericStrtabTag",
    SubclassListBuilder()
        | AsmCoffStrtab
        | AsmElfStrtab
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmGenericStrtab.associatedGrammar != nullptr);
AsmGenericStrtab.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericStrtab.isBoostSerializable(true);
AsmGenericStrtab.setAutomaticGenerationOfConstructor(false);
AsmGenericStrtab.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
/** Base class for string tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
class SgAsmGenericStrtab: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    AsmGenericStrtab.setDataPrototype(
        "SgAsmGenericSection*", "container", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    AsmGenericStrtab.setDataPrototype(
        "SgAsmGenericStrtab::referenced_t", "storage_list", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    AsmGenericStrtab.setDataPrototype(
        "AddressIntervalSet", "freelist", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    AsmGenericStrtab.setDataPrototype(
        "SgAsmStringStorage*", "dont_free", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    AsmGenericStrtab.setDataPrototype(
        "size_t", "num_freed", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericStrtab);
#if defined(SgAsmGenericStrtab_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
        s & BOOST_SERIALIZATION_NVP(p_container);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
        s & BOOST_SERIALIZATION_NVP(p_storage_list);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
        s & BOOST_SERIALIZATION_NVP(p_freelist);
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
        s & BOOST_SERIALIZATION_NVP(p_dont_free);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
        s & BOOST_SERIALIZATION_NVP(p_num_freed);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    typedef std::vector<class SgAsmStringStorage*> referenced_t;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection* const& get_container() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_container(SgAsmGenericSection* const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericStrtab::referenced_t const& get_storage_list() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_storage_list(SgAsmGenericStrtab::referenced_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    const AddressIntervalSet& get_freelist() const;
    AddressIntervalSet& get_freelist();
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmStringStorage* const& get_dont_free() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_dont_free(SgAsmStringStorage* const&);
    /** @} */
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_num_freed() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_num_freed(size_t const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericStrtab.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructs table inside file section. */
    explicit SgAsmGenericStrtab(SgAsmGenericSection *container);

    /** Parse a string table. */
    virtual SgAsmGenericStrtab* parse() {return this;}

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    /** Constructs an SgAsmStoredString from an offset into this string table. */
    SgAsmStoredString *create_string(rose_addr_t offset, bool shared);

    /** Free area of this string table that corresponds to the string currently stored.
     *
     *  Use this in preference to the offset/size version of free() when possible. */
    void free(SgAsmStringStorage*);

    /** Add a range of bytes to the free list after subtracting areas that are referenced by other strings.
     *
     *  For instance, an ELF string table can have "main" and "domain" sharing storage. If we free the "domain" string then
     *  only "do" should be added to the free list. */
    void free(rose_addr_t offset, rose_addr_t size); /*mark part of table as free*/

    /** Free all strings so they will be reallocated later.
     *
     *  This is more efficient than calling @ref free for each storage object. If @p blow_away_holes is true then any areas
     *  that are unreferenced in the string table will be marked as referenced and added to the free list. */
    void free_all_strings(bool blow_away_holes=false);

    virtual void allocate_overlap(SgAsmStringStorage*) {};

    /** Allocates storage for strings that have been modified but not allocated.
     *
     *  First try to fit unallocated strings into free space. Any that are left will cause the string table to be
     *  extended. Returns true if the reallocation would potentially affect some other section. If @p shrink is true then
     *  release address space that's no longer needed at the end of the table. */
    bool reallocate(bool shrink);

    //These should be pure virtual but ROSETTA apparently doesn't support that (RPM 2008-10-03)
    virtual SgAsmStringStorage *create_storage(rose_addr_t /*offset*/, bool /*shared*/) {abort(); return NULL;}
    virtual rose_addr_t get_storage_size(const SgAsmStringStorage*) {abort(); return 0;}
    virtual void rebind(SgAsmStringStorage*, rose_addr_t) {abort();}
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericStrtab();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericStrtab();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericStrtab_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCliHeader           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCliHeader);
IS_SERIALIZABLE(AsmCliHeader);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
/** CIL Managed Code section.
 *
 *  "CLI" means "common language infrastructure; "CIL" is "common intermediate language". */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
class SgAsmCliHeader: public SgAsmGenericSection {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint32_t", "cb", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint16_t", "majorRuntimeVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint16_t", "minorRuntimeVersion", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "metaData", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint32_t", "flags", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint32_t", "entryPointToken", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "resources", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "strongNameSignature", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "codeManagerTable", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "vTableFixups", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "exportAddressTableJumps", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "uint64_t", "managedNativeHeader", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    AsmCliHeader.setDataPrototype(
        "SgAsmCilMetadataRoot*", "metadataRoot", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCliHeader);
#if defined(SgAsmCliHeader_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericSection);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_cb);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_majorRuntimeVersion);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_minorRuntimeVersion);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_metaData);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_flags);
#line 38 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_entryPointToken);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_resources);
#line 50 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_strongNameSignature);
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_codeManagerTable);
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_vTableFixups);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_exportAddressTableJumps);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
        s & BOOST_SERIALIZATION_NVP(p_managedNativeHeader);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_cb() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_cb(uint32_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_majorRuntimeVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_majorRuntimeVersion(uint16_t const&);
    /** @} */
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_minorRuntimeVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_minorRuntimeVersion(uint16_t const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_metaData() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_metaData(uint64_t const&);
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_flags(uint32_t const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_entryPointToken() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_entryPointToken(uint32_t const&);
    /** @} */
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_resources() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_resources(uint64_t const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_strongNameSignature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_strongNameSignature(uint64_t const&);
    /** @} */
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_codeManagerTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_codeManagerTable(uint64_t const&);
    /** @} */
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_vTableFixups() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_vTableFixups(uint64_t const&);
    /** @} */
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_exportAddressTableJumps() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_exportAddressTableJumps(uint64_t const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_managedNativeHeader() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_managedNativeHeader(uint64_t const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    // FIXME[Robb Matzke 2023-03-20]: is no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMetadataRoot* const& get_metadataRoot() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_metadataRoot(SgAsmCilMetadataRoot* const&);
    /** @} */
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCliHeader.h"
 public:
    /** Initialize the object before parsing.
     *
     *  This is the preferred constructor to use before parsing.  It shall set its parent. */
    explicit SgAsmCliHeader(SgAsmPEFileHeader*);

    /** Initialize the object by parsing content from the PE file. */
    virtual SgAsmCliHeader* parse() override;

    /** Print some debugging information */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCliHeader();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCliHeader();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCliHeader_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericSection           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmGenericSection = nonTerminalConstructor(
    "AsmGenericSection",
    *this,
    "AsmGenericSection",
    "AsmGenericSectionTag",
    SubclassListBuilder()
        | AsmCliHeader
        | AsmCoffSymbolTable
        | AsmDOSExtendedHeader
        | AsmElfSection
        | AsmElfSectionTable
        | AsmElfSegmentTable
        | AsmGenericHeader
        | AsmJvmAttributeTable
        | AsmJvmConstantPool
        | AsmJvmFieldTable
        | AsmJvmMethodTable
        | AsmLEEntryTable
        | AsmLENameTable
        | AsmLEPageTable
        | AsmLERelocTable
        | AsmLESection
        | AsmLESectionTable
        | AsmNEEntryTable
        | AsmNEModuleTable
        | AsmNENameTable
        | AsmNERelocTable
        | AsmNESection
        | AsmNESectionTable
        | AsmNEStringTable
        | AsmPESection
        | AsmPESectionTable
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmGenericSection.associatedGrammar != nullptr);
AsmGenericSection.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericSection.isBoostSerializable(true);
AsmGenericSection.setAutomaticGenerationOfConstructor(false);
AsmGenericSection.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
/** Contiguous region of a file.
 *
 *  This class represents any contiguous region of a file that serves a particular purpose. Not only are ELF and PE Sections
 *  represented by @ref SgAsmGenericSection, but also such things as file headers, segment and section tables, etc. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
class SgAsmGenericSection: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericFile*", "file", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericHeader*", "header", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "offset", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "file_alignment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "SgFileContentList", "data", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericSection::SectionPurpose", "purpose", "= SgAsmGenericSection::SP_UNSPECIFIED",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "bool", "synthesized", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 90 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "int", "id", "= -1",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "SgAsmGenericString*", "name", "= createAndParent<SgAsmBasicString>(this)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 114 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "std::string", "short_name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mapped_preferred_rva", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mapped_size", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mapped_alignment", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 154 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "bool", "mapped_rperm", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "bool", "mapped_wperm", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 162 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "bool", "mapped_xperm", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "bool", "contains_code", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    AsmGenericSection.setDataPrototype(
        "rose_addr_t", "mapped_actual_va", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericSection);
#if defined(SgAsmGenericSection_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_file);
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_header);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_size);
#line 58 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_offset);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_file_alignment);
#line 74 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_data);
#line 78 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_purpose);
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_synthesized);
#line 90 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_id);
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_name);
#line 114 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_short_name);
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_preferred_rva);
#line 142 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_size);
#line 150 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_alignment);
#line 154 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_rperm);
#line 158 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_wperm);
#line 162 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_xperm);
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_contains_code);
#line 186 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
        s & BOOST_SERIALIZATION_NVP(p_mapped_actual_va);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Reason for section's existence.
     *
     *  This is a union of all the section purposes from the various supported file formats.  However, at this time we're
     *  only interested in a few kinds of sections and therefore most will fall into the SP_OTHER category. */
    enum SectionPurpose {
        SP_UNSPECIFIED,                 /**< File format did not specify a reason and none could be determined. */
        SP_PROGRAM,                     /**< Program-supplied data, code, etc. */
        SP_HEADER,                      /**< Section contains a header for the executable file format. */
        SP_SYMTAB,                      /**< Symbol table. */
        SP_OTHER                        /**< File-specified purpose other than any given in this enum. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericFile* const& get_file() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_file(SgAsmGenericFile* const&);
    /** @} */
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericHeader* const& get_header() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_header(SgAsmGenericHeader* const&);
    /** @} */
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    rose_addr_t get_size() const;
    virtual void set_size(rose_addr_t);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
 // Starting file offset of the section

    rose_addr_t get_offset() const;
    virtual void set_offset(rose_addr_t);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_file_alignment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_file_alignment(rose_addr_t const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgFileContentList const& get_data() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_data(SgFileContentList const&);
    /** @} */
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmGenericSection::SectionPurpose const& get_purpose() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_purpose(SgAsmGenericSection::SectionPurpose const&);
    /** @} */
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_synthesized() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_synthesized(bool const&);
    /** @} */
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& get_id() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_id(int const&);
    /** @} */
#line 91 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    SgAsmGenericString *get_name() const;
    void set_name(SgAsmGenericString *s);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    std::string get_short_name() const;
    void set_short_name(const std::string&);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    rose_addr_t get_mapped_preferred_rva() const;
    virtual void set_mapped_preferred_rva(rose_addr_t);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    rose_addr_t get_mapped_size() const;
    virtual void set_mapped_size(rose_addr_t);
    /** @} */
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_mapped_alignment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_alignment(rose_addr_t const&);
    /** @} */
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 153 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_mapped_rperm() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_rperm(bool const&);
    /** @} */
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_mapped_wperm() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_wperm(bool const&);
    /** @} */
#line 159 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_mapped_xperm() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_xperm(bool const&);
    /** @} */
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 165 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_contains_code() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_contains_code(bool const&);
    /** @} */
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_mapped_actual_va() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mapped_actual_va(rose_addr_t const&);
    /** @} */
#line 187 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericSection.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    /* This is an optional local, writable pool for the p_data member. Normally a section will point into the pool
     * for its SgAsmGenericFile which is memory-mapped (read-only) from the actual file being parsed. The default
     * unparsing action is to write the original data back to the file. By allowing a section to allocate its own
     * pool for p_data we create a very easy way to get data into the unparsed file (the alternative is to derive
     * a new class and override the unparse() method). */
    unsigned char *local_data_pool;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Constructor linking object into ASt.
     *
     *  Section constructors set the optional section header relationship--a bidirectional link between this new section
     *  and its optional, single header.  This new section points to its header and the header contains a list that points
     *  to this new section.  The section-to-header part of the link is deleted by the default destructor by virtue of
     *  being a simple pointer, but we also need to delete the other half of the link in the destructors. */
    SgAsmGenericSection(SgAsmGenericFile*, SgAsmGenericHeader*);

    /** Prints info about offsets into known sections. */
    static void dump_containing_sections(FILE*, const std::string &prefix, rose_rva_t, const SgAsmGenericSectionPtrList&);

    /** Saves a reference to the original file data for a section based on the section's current offset and size.
     *
     *  Once this happens, changing the offset or size of the file will not affect the original data. The original data can
     *  be extended, however, by calling @ref extend, which is typically done during parsing. */
    void grab_content();

    // DQ (10/20/2010): Moved this function's definition to the source file.
    virtual SgAsmGenericSection* parse();

    /** Print some debugging info. */
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;

    // Implemented in subclasses
    virtual bool reallocate() { return false; }

    /** Write a section back to the file.
     *
     *  This is the generic version that simply writes the content. Subclasses should override this. */
    virtual void unparse(std::ostream&) const;

    /** Write just the specified regions back to the file */
    void unparse(std::ostream&, const ExtentMap&) const;

    /** Write holes (unreferenced areas) back to the file */
    void unparse_holes(std::ostream&) const;

    /** Predicate determining whether this section is also a top-level file header.
     *
     *  Returns true (the associated @ref SgAsmGenericHeader pointer) if this section is a top-level file header, false
     *  (NULL) otherwise. */
    SgAsmGenericHeader *is_file_header();

    /** File offset for end of section. */
    rose_addr_t   get_end_offset() const;

    /** Extend a section by some number of bytes during the construction and/or parsing phase.
     *
     *  This is function is considered to be part of the parsing and construction of a section--it changes the part of the
     *  file that's considered the "original size" of the section. To adjust the size of a section after the executable
     *  file is parsed, see @ref SgAsmGenericFile::resize.  Sections are allowed to extend beyond the end of the file and
     *  the original data (the @ref get_data "data" property) is extended only up to the end of the file. */
    void extend(rose_addr_t nbytes);

    /** Write data to a file section.
     *
     *  @param f       Output steam to which to write
     *  @param offset  Byte offset relative to start of this section
     *  @param bufsize Size of @p buf in bytes
     *  @param buf     Buffer of bytes to be written
     *
     *  @returns Returns the section-relative byte offset for the first byte beyond what would have been written if all
     *  bytes of the buffer were written.
     *
     *  The buffer is allowed to extend past the end of the section as long as the part that extends beyond is all
     *  zeros. The zeros will not be written to the output file.  Furthermore, any trailing zeros that extend beyond the
     *  end of the file will not be written (end-of-file is determined by @ref SgAsmGenericFile::get_orig_size).
     *
     * @{ */
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, size_t bufsize, const void *buf) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const std::string &str) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, char c) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const SgFileContentList &buf) const;
    rose_addr_t   write(std::ostream &f, rose_addr_t offset, const SgUnsignedCharList &buf) const;
    /** @} */

    /** Write an unsigned little-endian 128-bit value.
     *
     *  Encode an unsigned value as LEB128 and return the next offset. */
    rose_addr_t   write_uleb128(unsigned char*, rose_addr_t offset, uint64_t) const;

    /** Write a signed little-endian 128-bit value.
     *
     *  Encode an signed value as LEB128 and return the next offset. */
    rose_addr_t   write_sleb128(unsigned char*, rose_addr_t offset, int64_t) const;

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data beginning at byte @p start_offset from the beginning of the file, placing the
     *  results in @p dst_buf and returning the number of bytes read. The return value could be smaller than @p size if the
     *  end-of-file is reached. If the return value is smaller than @p size then one of two things happen: if @p strict is
     *  set (the default) then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown; otherwise the @p dst_buf
     *  will be padded with zero bytes so that exactly @p size bytes of @p dst_buf are always initialized. */
    size_t read_content(rose_addr_t abs_offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads data from a file.
     *
     *  Reads up to @p size bytes of data beginning at byte @p start (absolute or relative virtual address) in the mapped
     *  address space and placing the results in @p dst_buf and returning the number of bytes read. The return value could
     *  be smaller than @p size if the reading encounters virtual addresses that are not mapped.  When an unmapped virtual
     *  address is encountered the reading stops (even if subsequent virtual addresses are defined) and one of two things
     *  happen: if @p strict is set (the default) then an @ref MemoryMap::NotMapped exception is thrown, otherwise the @p
     *  dst_buf is padded with zeros so that all @p size bytes are initialized. The @p map is used to map virtual addresses
     *  to file offsets; if @p map is NULL then the map defined in the underlying file is used.
     *
     * @{ */
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t start,  void *dst_buf,
                        rose_addr_t size, bool strict=true);
    size_t read_content(const Rose::BinaryAnalysis::MemoryMap::Ptr&, const rose_rva_t &start, void *dst_buf,
                        rose_addr_t size, bool strict=true);
    /** @} */

    /** Reads data from a file.
     *
     *  This behaves the same as @ref read_content except the starting offset is relative to the beginning of this section.
     *  Reading past the end of the section is not allowed and treated as a short read, and one of two things happen: if @p
     *  strict is set (the default) then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown, otherwise the
     *  result is zero padded so as to contain exactly @p size bytes. */
    size_t read_content_local(rose_addr_t rel_offset, void *dst_buf, rose_addr_t size, bool strict=true);

    /** Reads a string from the file.
     *
     *  The string begins at the specified virtual address and continues until the first NUL byte or until we reach an
     *  address that is not mapped. However, if @p strict is set (the default) and we reach an unmapped address then an
     *  @ref MemoryMap::NotMapped exception is thrown. The @p map defines the mapping from virtual addresses to file
     *  offsets; if @p map is NULL then the map defined in the underlying file is used. */
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr&, rose_addr_t va, bool strict=true);

    /** Reads a string from the file.
     *
     *  The string begins at the specified absolute or header-relative file offset and continues until the first NUL byte
     *  or end of file is reached. However, if @p strict is set (the default) and we reach the end-of-file then an @ref
     *  SgAsmExecutableFileFormat::ShortRead exception is thrown.
     *
     * @{ */
    std::string read_content_str(rose_addr_t abs_offset, bool strict=true);
    std::string read_content_str(const Rose::BinaryAnalysis::MemoryMap::Ptr &map, rose_rva_t rva, bool strict=true) {
        return read_content_str(map, rva.get_va(), strict);
    }
    /** @} */

    /** Reads a string from the file.
     *
     *  The string begins at the specified file offset relative to the start of this section and continues until the first
     *  NUL byte or the end of section is reached. However, if @p strict is set (the default) and we reach the
     *  end-of-section then an @ref SgAsmExecutableFileFormat::ShortRead exception is thrown. */
    std::string read_content_local_str(rose_addr_t rel_offset, bool strict=true);

    /** Reads content of a section and returns it as a container.
     *
     *  The returned container will always have exactly @p size byte.  If @p size bytes are not available in this section
     *  at the specified offset then the container will be zero padded. This method always behaves as a non-strict read. */
    SgUnsignedCharList read_content_local_ucl(rose_addr_t rel_offset, rose_addr_t size);

    /** Read a signed little-endian 128-bit value.
     *
     *  Extract a signed LEB128 value and adjust @p rel_offset according to how many bytes it occupied. If @p strict is set
     *  (the default) and the end of the section is reached then throw an @ref SgAsmExecutableFileFormat::ShortRead
     *  exception. Upon return, the @p rel_offset will be adjusted to point to the first byte after the LEB128 value. */
    int64_t read_content_local_sleb128(rose_addr_t *rel_offset, bool strict=true);

    /** Read an unsigned little-endian 128-bit value.
     *
     *  Extract an unsigned LEB128 value and adjust @p rel_offset according to how many bytes it occupied.  If @p strict is
     *  set (the default) and the end of the section is reached then throw an @ref SgAsmExecutableFileFormat::ShortRead
     *  exception. Upon return, the @p rel_offset will be adjusted to point to the first byte after the LEB128 value. */
    uint64_t read_content_local_uleb128(rose_addr_t *rel_offset, bool strict=true);

    /** Obtain a local, writable pool to hold content.
     *
     *  Sections typically point into the memory mapped, read-only file stored in the SgAsmGenericFile parent initialized
     *  by calling @ref grab_content (or indirectly by calling @ref parse).  This is also the same data which is, by
     *  default, written back out to the new file during @ref unparse.  Programs modify section content by either
     *  overriding the @ref unparse method or by modifying the @ref p_data "data" property. But in order to modify @ref
     *  p_data "data" we have to make sure that it's pointing to a read/write memory pool. This function replaces the
     *  read-only memory pool with a new one containing @p nbytes bytes of zeros. */
    unsigned char *writable_content(size_t nbytes);

    /** Returns a list of parts of a single section that have been referenced.
     *
     *  The offsets are relative to the start of the section. The tracking actually happens at the entire file level (see
     *  @ref SgAsmGenericFile::get_referenced_extents) and this function returns that same information but limits the
     *  results to this section, and returns section offsets rather than file offsets. */
    AddressIntervalSet get_referenced_extents() const;

    /** Returns a list of parts of a single section that have not been referenced.
     *
     *  The offsets are relative to the start of the section. The tracking actually happens at the entire file level
     *  (see @ref SgAsmGenericFile::get_unreferenced_extents) and this function returns that same information but
     *  limits the results to this section, and returns section offsets rather than file offsets. */
    AddressIntervalSet get_unreferenced_extents() const;

    /** Whether section desires to be mapped to memory.
     *
     *  This predicate is true iff this section has a non-zero mapped address and size. */
    bool is_mapped() const;

    /** Causes section to not be mapped to memory.
     *
     *  This method sets the mapped address and size to zero. */
    void clear_mapped();

    /** Base virtual address for a section.
     *
     *  Returns  zero if the section is not associated with a header.  This is just a convenience method to get the base
     *  virtual address of the file header that owns this section. */
    rose_addr_t get_base_va() const;

    /** Virtual address where section prefers to be mapped.
     *
     *  Returns (non-relative) virtual address if mapped, zero otherwise. See also, the @ref get_mapped_preferred_rva
     *  "mapped_preferred_rva" property. */
    rose_addr_t get_mapped_preferred_va() const;

    /** File offset for specified virtual address.
     *
     *  Returns the file offset associated with the virtual address of a mapped section. The @ref MemoryMap class is a
     *  better interface to this same information. */
    rose_addr_t get_va_offset(rose_addr_t va) const;

    /** File offset for specified relative virtual address.
     *
     *  Returns the file offset associated with the relative virtual address of a mapped section.  The @ref MemoryMap class
     *  is a better interface to this same information. */
    rose_addr_t get_rva_offset(rose_addr_t rva) const;

    /** Returns the file extent for the section.
     *
     *  The extent end points are determined by calling @ref get_offset and @ref get_size. */
    Extent get_file_extent() const;

    /** Returns the memory extent for a mapped section.
     *
     *  If the section is not mapped then offset and size will be zero. The return value is computed from the @ref
     *  get_mapped_preferred_rva "mapped_preferred_rva" and @ref get_mapped_size "mapped_size" properties. */
    Extent get_mapped_preferred_extent() const;

    /** Increase file offset and mapping address to satisfy alignment constraints.
     *
     *  This is typically done when initializing a new section. The constructor places the new section at the end of the
     *  file before it knows what the alignment constraints will be. The user should then set the alignment constraints
     *  (see @ref set_file_alignment "file_alignment" and @ref set_mapped_alignment "mapped_alignment" properties) and call
     *  this method.  This method must be called before any additional sections are appended to the file.
     *
     *  The file offset and memory mapping address are adjusted independently.
     *
     *  On the other hand, if additional sections are in the way, they must first be moved out of the way with the
     *  @ref SgAsmGenericFile::shift_extend method.
     *
     *  Returns true if the file offset and/or mapping address changed as a result of this call. */
    bool align();

protected:
    virtual void destructorHelper() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericSection();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericSection();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericSection_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilUint8Heap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilUint8Heap);
IS_SERIALIZABLE(AsmCilUint8Heap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"
/** Base class for CIL branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"
class SgAsmCilUint8Heap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"
    AsmCilUint8Heap.setDataPrototype(
        "std::vector<uint8_t>", "Stream", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilUint8Heap);
#if defined(SgAsmCilUint8Heap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"
        s & BOOST_SERIALIZATION_NVP(p_Stream);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<uint8_t> const& get_Stream() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<uint8_t>& get_Stream();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint8Heap.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilUint8Heap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilUint8Heap();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmCilUint8Heap(uint32_t const& Offset,
                      uint32_t const& Size,
                      std::string const& Name,
                      uint32_t const& NamePadding);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilUint8Heap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilUint32Heap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilUint32Heap);
IS_SERIALIZABLE(AsmCilUint32Heap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"
/** Base class for CIL branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"
class SgAsmCilUint32Heap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"
    AsmCilUint32Heap.setDataPrototype(
        "std::vector<uint32_t>", "Stream", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilUint32Heap);
#if defined(SgAsmCilUint32Heap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"
        s & BOOST_SERIALIZATION_NVP(p_Stream);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<uint32_t> const& get_Stream() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<uint32_t>& get_Stream();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilUint32Heap.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilUint32Heap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilUint32Heap();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmCilUint32Heap(uint32_t const& Offset,
                       uint32_t const& Size,
                       std::string const& Name,
                       uint32_t const& NamePadding);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilUint32Heap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeSpecTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeSpecTable);
IS_SERIALIZABLE(AsmCilTypeSpecTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"
/** CIL TypeSpec tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"
class SgAsmCilTypeSpecTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"
    AsmCilTypeSpecTable.setDataPrototype(
        "std::vector<SgAsmCilTypeSpec*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeSpecTable);
#if defined(SgAsmCilTypeSpecTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeSpec*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeSpec*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpecTable.h"
public:
    using CilMetadataType = SgAsmCilTypeSpec;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeSpecTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeSpecTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeSpecTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeSpec           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeSpec);
IS_SERIALIZABLE(AsmCilTypeSpec);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
/** CIL TypeSpec node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
class SgAsmCilTypeSpec: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
    AsmCilTypeSpec.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeSpec);
#if defined(SgAsmCilTypeSpec_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeSpec.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Signature_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeSpec();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeSpec();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeSpec_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeRefTable);
IS_SERIALIZABLE(AsmCilTypeRefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"
/** CIL TypeRef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"
class SgAsmCilTypeRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"
    AsmCilTypeRefTable.setDataPrototype(
        "std::vector<SgAsmCilTypeRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeRefTable);
#if defined(SgAsmCilTypeRefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeRef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeRef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRefTable.h"
public:
    using CilMetadataType = SgAsmCilTypeRef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeRefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeRefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeRefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeRef);
IS_SERIALIZABLE(AsmCilTypeRef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
/** CIL TypeRef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
class SgAsmCilTypeRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    AsmCilTypeRef.setDataPrototype(
        "uint16_t", "ResolutionScope", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    AsmCilTypeRef.setDataPrototype(
        "uint32_t", "TypeName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    AsmCilTypeRef.setDataPrototype(
        "uint32_t", "TypeNamespace", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeRef);
#if defined(SgAsmCilTypeRef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
        s & BOOST_SERIALIZATION_NVP(p_ResolutionScope);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_ResolutionScope() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ResolutionScope(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeName() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeName(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeNamespace() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeNamespace(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeRef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_ResolutionScope_object() const;
    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeRef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeRef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeRef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeDefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeDefTable);
IS_SERIALIZABLE(AsmCilTypeDefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"
/** CIL TypeDef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"
class SgAsmCilTypeDefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"
    AsmCilTypeDefTable.setDataPrototype(
        "std::vector<SgAsmCilTypeDef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeDefTable);
#if defined(SgAsmCilTypeDefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeDef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilTypeDef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypeDefTable.h"
public:
    using CilMetadataType = SgAsmCilTypeDef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeDefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeDefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeDefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilTypeDef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilTypeDef);
IS_SERIALIZABLE(AsmCilTypeDef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
/** CIL TypeDef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
class SgAsmCilTypeDef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "TypeName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "TypeNamespace", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "Extends", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "FieldList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    AsmCilTypeDef.setDataPrototype(
        "uint32_t", "MethodList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilTypeDef);
#if defined(SgAsmCilTypeDef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_Extends);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_FieldList);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodList);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeName() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeName(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeNamespace() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeNamespace(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Extends() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Extends(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_FieldList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FieldList(uint32_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_MethodList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodList(uint32_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilTypedef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
    const SgAsmCilMetadata* get_Extends_object() const;
    const SgAsmCilMetadata* get_FieldList_object() const;
    const SgAsmCilMetadata* get_MethodList_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilTypeDef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilTypeDef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilTypeDef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilStandAloneSigTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilStandAloneSigTable);
IS_SERIALIZABLE(AsmCilStandAloneSigTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"
/** CIL StandAloneSig tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"
class SgAsmCilStandAloneSigTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"
    AsmCilStandAloneSigTable.setDataPrototype(
        "std::vector<SgAsmCilStandAloneSig*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilStandAloneSigTable);
#if defined(SgAsmCilStandAloneSigTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilStandAloneSig*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilStandAloneSig*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSigTable.h"
public:
    using CilMetadataType = SgAsmCilStandAloneSig;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilStandAloneSigTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilStandAloneSigTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilStandAloneSigTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilStandAloneSig           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilStandAloneSig);
IS_SERIALIZABLE(AsmCilStandAloneSig);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
/** CIL StandAloneSig node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
class SgAsmCilStandAloneSig: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
    AsmCilStandAloneSig.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilStandAloneSig);
#if defined(SgAsmCilStandAloneSig_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilStandAloneSig.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Signature_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilStandAloneSig();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilStandAloneSig();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilStandAloneSig_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilPropertyTable);
IS_SERIALIZABLE(AsmCilPropertyTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"
/** CIL Property tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"
class SgAsmCilPropertyTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"
    AsmCilPropertyTable.setDataPrototype(
        "std::vector<SgAsmCilProperty*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilPropertyTable);
#if defined(SgAsmCilPropertyTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilProperty*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilProperty*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyTable.h"
public:
    using CilMetadataType = SgAsmCilProperty;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilPropertyTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilPropertyMapTable);
IS_SERIALIZABLE(AsmCilPropertyMapTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"
/** CIL PropertyMap tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"
class SgAsmCilPropertyMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"
    AsmCilPropertyMapTable.setDataPrototype(
        "std::vector<SgAsmCilPropertyMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilPropertyMapTable);
#if defined(SgAsmCilPropertyMapTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilPropertyMap*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilPropertyMap*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMapTable.h"
public:
    using CilMetadataType = SgAsmCilPropertyMap;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyMapTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilPropertyMapTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyMapTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilPropertyMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilPropertyMap);
IS_SERIALIZABLE(AsmCilPropertyMap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
/** CIL PropertyMap node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
class SgAsmCilPropertyMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
    AsmCilPropertyMap.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
    AsmCilPropertyMap.setDataPrototype(
        "uint32_t", "PropertyList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilPropertyMap);
#if defined(SgAsmCilPropertyMap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
        s & BOOST_SERIALIZATION_NVP(p_PropertyList);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_PropertyList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PropertyList(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilPropertyMap.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_PropertyList_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilPropertyMap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilPropertyMap();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilPropertyMap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilProperty           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilProperty);
IS_SERIALIZABLE(AsmCilProperty);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
/** CIL Property node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
class SgAsmCilProperty: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    AsmCilProperty.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    AsmCilProperty.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    AsmCilProperty.setDataPrototype(
        "uint32_t", "Type", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilProperty);
#if defined(SgAsmCilProperty_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
        s & BOOST_SERIALIZATION_NVP(p_Type);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Type(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilProperty.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Type_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilProperty();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilProperty();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilProperty_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilParamTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilParamTable);
IS_SERIALIZABLE(AsmCilParamTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"
/** CIL Param tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"
class SgAsmCilParamTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"
    AsmCilParamTable.setDataPrototype(
        "std::vector<SgAsmCilParam*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilParamTable);
#if defined(SgAsmCilParamTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilParam*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilParam*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParamTable.h"
public:
    using CilMetadataType = SgAsmCilParam;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilParamTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilParamTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilParamTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilParam           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilParam);
IS_SERIALIZABLE(AsmCilParam);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
/** CIL Param node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
class SgAsmCilParam: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    AsmCilParam.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    AsmCilParam.setDataPrototype(
        "uint16_t", "Sequence", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    AsmCilParam.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilParam);
#if defined(SgAsmCilParam_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Sequence);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Sequence() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Sequence(uint16_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilParam.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilParam();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilParam();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilParam_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNestedClassTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilNestedClassTable);
IS_SERIALIZABLE(AsmCilNestedClassTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"
/** CIL NestedClass tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"
class SgAsmCilNestedClassTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"
    AsmCilNestedClassTable.setDataPrototype(
        "std::vector<SgAsmCilNestedClass*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilNestedClassTable);
#if defined(SgAsmCilNestedClassTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilNestedClass*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilNestedClass*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClassTable.h"
public:
    using CilMetadataType = SgAsmCilNestedClass;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilNestedClassTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilNestedClassTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNestedClassTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNestedClass           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilNestedClass);
IS_SERIALIZABLE(AsmCilNestedClass);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
/** CIL NestedClass node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
class SgAsmCilNestedClass: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
    AsmCilNestedClass.setDataPrototype(
        "uint32_t", "NestedClass", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
    AsmCilNestedClass.setDataPrototype(
        "uint32_t", "EnclosingClass", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilNestedClass);
#if defined(SgAsmCilNestedClass_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
        s & BOOST_SERIALIZATION_NVP(p_NestedClass);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
        s & BOOST_SERIALIZATION_NVP(p_EnclosingClass);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_NestedClass() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NestedClass(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_EnclosingClass() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EnclosingClass(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNestedClass.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_NestedClass_object() const;
    const SgAsmCilMetadata* get_EnclosingClass_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilNestedClass();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilNestedClass();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNestedClass_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilModuleTable);
IS_SERIALIZABLE(AsmCilModuleTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"
/** CIL Module tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"
class SgAsmCilModuleTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"
    AsmCilModuleTable.setDataPrototype(
        "std::vector<SgAsmCilModule*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilModuleTable);
#if defined(SgAsmCilModuleTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilModule*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilModule*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleTable.h"
public:
    using CilMetadataType = SgAsmCilModule;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilModuleTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilModuleRefTable);
IS_SERIALIZABLE(AsmCilModuleRefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"
/** CIL ModuleRef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"
class SgAsmCilModuleRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"
    AsmCilModuleRefTable.setDataPrototype(
        "std::vector<SgAsmCilModuleRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilModuleRefTable);
#if defined(SgAsmCilModuleRefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilModuleRef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilModuleRef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRefTable.h"
public:
    using CilMetadataType = SgAsmCilModuleRef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleRefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilModuleRefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleRefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModuleRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilModuleRef);
IS_SERIALIZABLE(AsmCilModuleRef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
/** CIL ModuleRef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
class SgAsmCilModuleRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
    AsmCilModuleRef.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilModuleRef);
#if defined(SgAsmCilModuleRef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModuleRef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilModuleRef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilModuleRef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModuleRef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilModule           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilModule);
IS_SERIALIZABLE(AsmCilModule);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
/** CIL Module node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
class SgAsmCilModule: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    AsmCilModule.setDataPrototype(
        "uint16_t", "Generation", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    AsmCilModule.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    AsmCilModule.setDataPrototype(
        "uint32_t", "Mvid", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    AsmCilModule.setDataPrototype(
        "uint32_t", "Encld", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    AsmCilModule.setDataPrototype(
        "uint32_t", "EncBaseId", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilModule);
#if defined(SgAsmCilModule_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
        s & BOOST_SERIALIZATION_NVP(p_Generation);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
        s & BOOST_SERIALIZATION_NVP(p_Mvid);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
        s & BOOST_SERIALIZATION_NVP(p_Encld);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
        s & BOOST_SERIALIZATION_NVP(p_EncBaseId);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Generation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Generation(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Mvid() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Mvid(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Encld() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Encld(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_EncBaseId() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EncBaseId(uint32_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilModule.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const std::uint32_t* get_Mvid_guid() const;
    const std::uint32_t* get_Encld_guid() const;
    const std::uint32_t* get_EncBaseId_guid() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilModule();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilModule();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilModule_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSpecTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodSpecTable);
IS_SERIALIZABLE(AsmCilMethodSpecTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"
/** CIL MethodSpec tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"
class SgAsmCilMethodSpecTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"
    AsmCilMethodSpecTable.setDataPrototype(
        "std::vector<SgAsmCilMethodSpec*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodSpecTable);
#if defined(SgAsmCilMethodSpecTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodSpec*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodSpec*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpecTable.h"
public:
    using CilMetadataType = SgAsmCilMethodSpec;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSpecTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodSpecTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSpecTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSpec           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodSpec);
IS_SERIALIZABLE(AsmCilMethodSpec);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
/** CIL MethodSpec node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
class SgAsmCilMethodSpec: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
    AsmCilMethodSpec.setDataPrototype(
        "uint32_t", "Method", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
    AsmCilMethodSpec.setDataPrototype(
        "uint32_t", "Instantiation", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodSpec);
#if defined(SgAsmCilMethodSpec_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
        s & BOOST_SERIALIZATION_NVP(p_Method);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
        s & BOOST_SERIALIZATION_NVP(p_Instantiation);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Method() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Method(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Instantiation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Instantiation(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSpec.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Method_object() const;
    const std::uint8_t* get_Instantiation_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSpec();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodSpec();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSpec_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSemanticsTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodSemanticsTable);
IS_SERIALIZABLE(AsmCilMethodSemanticsTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"
/** CIL MethodSemantics tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"
class SgAsmCilMethodSemanticsTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"
    AsmCilMethodSemanticsTable.setDataPrototype(
        "std::vector<SgAsmCilMethodSemantics*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodSemanticsTable);
#if defined(SgAsmCilMethodSemanticsTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodSemantics*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodSemantics*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemanticsTable.h"
public:
    using CilMetadataType = SgAsmCilMethodSemantics;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSemanticsTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodSemanticsTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSemanticsTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodSemantics           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodSemantics);
IS_SERIALIZABLE(AsmCilMethodSemantics);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
/** CIL MethodSemantics node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
class SgAsmCilMethodSemantics: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    AsmCilMethodSemantics.setDataPrototype(
        "uint16_t", "Semantics", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    AsmCilMethodSemantics.setDataPrototype(
        "uint32_t", "Method", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    AsmCilMethodSemantics.setDataPrototype(
        "uint32_t", "Association", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodSemantics);
#if defined(SgAsmCilMethodSemantics_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
        s & BOOST_SERIALIZATION_NVP(p_Semantics);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
        s & BOOST_SERIALIZATION_NVP(p_Method);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
        s & BOOST_SERIALIZATION_NVP(p_Association);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Semantics() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Semantics(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Method() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Method(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Association() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Association(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodSemantics.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Method_object() const;
    const SgAsmCilMetadata* get_Association_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodSemantics();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodSemantics();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodSemantics_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodImplTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodImplTable);
IS_SERIALIZABLE(AsmCilMethodImplTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"
/** CIL MethodImpl tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"
class SgAsmCilMethodImplTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"
    AsmCilMethodImplTable.setDataPrototype(
        "std::vector<SgAsmCilMethodImpl*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodImplTable);
#if defined(SgAsmCilMethodImplTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodImpl*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodImpl*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImplTable.h"
public:
    using CilMetadataType = SgAsmCilMethodImpl;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodImplTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodImplTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodImplTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodImpl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodImpl);
IS_SERIALIZABLE(AsmCilMethodImpl);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
/** CIL MethodImpl node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
class SgAsmCilMethodImpl: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "Class", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "MethodBody", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    AsmCilMethodImpl.setDataPrototype(
        "uint32_t", "MethodDeclaration", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodImpl);
#if defined(SgAsmCilMethodImpl_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
        s & BOOST_SERIALIZATION_NVP(p_Class);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodBody);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodDeclaration);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Class(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_MethodBody() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodBody(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_MethodDeclaration() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodDeclaration(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodImpl.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Class_object() const;
    const SgAsmCilMetadata* get_MethodBody_object() const;
    const SgAsmCilMetadata* get_MethodDeclaration_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodImpl();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodImpl();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodImpl_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodDefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodDefTable);
IS_SERIALIZABLE(AsmCilMethodDefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"
/** CIL MethodDef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"
class SgAsmCilMethodDefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"
    AsmCilMethodDefTable.setDataPrototype(
        "std::vector<SgAsmCilMethodDef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodDefTable);
#if defined(SgAsmCilMethodDefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodDef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMethodDef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDefTable.h"
public:
    using CilMetadataType = SgAsmCilMethodDef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodDefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodDefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodDefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMethodDef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMethodDef);
IS_SERIALIZABLE(AsmCilMethodDef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
/** CIL MethodDef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
class SgAsmCilMethodDef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "RVA", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "ImplFlags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "ParamList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "SgAsmBlock*", "body", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "bool", "initLocals", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "uint32_t", "stackSize", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    AsmCilMethodDef.setDataPrototype(
        "bool", "hasMoreSections", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMethodDef);
#if defined(SgAsmCilMethodDef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_RVA);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_ImplFlags);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_ParamList);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_body);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_initLocals);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_stackSize);
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
        s & BOOST_SERIALIZATION_NVP(p_hasMoreSections);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_RVA() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_RVA(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ImplFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ImplFlags(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ParamList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ParamList(uint32_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmBlock* const& get_body() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_body(SgAsmBlock* const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_initLocals() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_initLocals(bool const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_stackSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stackSize(uint32_t const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_hasMoreSections() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_hasMoreSections(bool const&);
    /** @} */
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMethodDef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
    const SgAsmCilMetadata* get_ParamList_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMethodDef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMethodDef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMethodDef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadataRoot           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMetadataRoot);
IS_SERIALIZABLE(AsmCilMetadataRoot);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
/** CIL SgAsmCilMetadataRoot. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
class SgAsmCilMetadataRoot: public SgAsmCilNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "MajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "MinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Reserved0", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "Length", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "std::string", "Version", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint32_t", "VersionPadding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "uint16_t", "NumberOfStreams", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    AsmCilMetadataRoot.setDataPrototype(
        "std::vector<SgAsmCilDataStream*>", "Streams", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMetadataRoot);
#if defined(SgAsmCilMetadataRoot_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Reserved0);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Length);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Version);
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_VersionPadding);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_NumberOfStreams);
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
        s & BOOST_SERIALIZATION_NVP(p_Streams);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MajorVersion(uint16_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MinorVersion(uint16_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Reserved0() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Reserved0(uint32_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Length() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Length(uint32_t const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_Version() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Version(std::string const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_VersionPadding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_VersionPadding(uint32_t const&);
    /** @} */
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_NumberOfStreams() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NumberOfStreams(uint16_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    // FIXME[Robb Matzke 2023-03-22]: these were implemented elsewhere, but could be auto generated
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataRoot.h"
    const std::vector<SgAsmCilDataStream*>& get_Streams() const;
    std::vector<SgAsmCilDataStream*>& get_Streams();

private:
    /** indices to efficienty access the different heaps
     * @{ */
    mutable int8_t idxStringHeap = -1;
    mutable int8_t idxBlobHeap = -1;
    mutable int8_t idxUsHeap = -1;
    mutable int8_t idxGuidHeap = -1;
    mutable int8_t idxMetadataHeap = -1;
    /** }@ */

public:
    /** 4-byte indicating the start of the metadata root in the .text section.
     */
    static constexpr uint32_t MAGIC_SIGNATURE = 0x424A5342;

    /** Declares the parse function as called from the Cil section header object
     *  @pre isSgAsmCliHeader(this->get_parent()) != nullptr
     */
    void parse();

    /** Declares the parse function.
     *  @param buf the binary buffer
     *  @param index the start location of the metadata root object.
     *         buf[index] is the location of the magic number.
     */
    void parse(std::vector<uint8_t>& buf, size_t index);

    /** accessor functions to return specific heaps
     * @{ */
    SgAsmCilUint8Heap*    get_StringHeap() const;
    SgAsmCilUint8Heap*    get_BlobHeap() const;
    SgAsmCilUint8Heap*    get_UsHeap() const;
    SgAsmCilUint32Heap*   get_GuidHeap() const;
    SgAsmCilMetadataHeap* get_MetadataHeap() const;
    /** }@ */
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMetadataRoot();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMetadataRoot();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadataRoot_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadataHeap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMetadataHeap);
IS_SERIALIZABLE(AsmCilMetadataHeap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
/** CIL AsmCilMetadataHeap. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
class SgAsmCilMetadataHeap: public SgAsmCilDataStream {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint32_t", "ReservedAlwaysZero", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "MajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "MinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "HeapSizes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint8_t", "ReservedAlwaysOne", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "Valid", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "Sorted", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "std::vector<uint32_t>", "NumberOfRows", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "uint64_t", "DataSizeFlags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyTable*", "AssemblyTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyOSTable*", "AssemblyOSTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyProcessorTable*", "AssemblyProcessorTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefTable*", "AssemblyRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefOSTable*", "AssemblyRefOSTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilAssemblyRefProcessorTable*", "AssemblyRefProcessorTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilClassLayoutTable*", "ClassLayoutTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilConstantTable*", "ConstantTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilCustomAttributeTable*", "CustomAttributeTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilDeclSecurityTable*", "DeclSecurityTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilEventTable*", "EventTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilEventMapTable*", "EventMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilExportedTypeTable*", "ExportedTypeTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldTable*", "FieldTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldLayoutTable*", "FieldLayoutTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldMarshalTable*", "FieldMarshalTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFieldRVATable*", "FieldRVATable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 108 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilFileTable*", "FileTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilGenericParamTable*", "GenericParamTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilGenericParamConstraintTable*", "GenericParamConstraintTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 120 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilImplMapTable*", "ImplMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilInterfaceImplTable*", "InterfaceImplTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilManifestResourceTable*", "ManifestResourceTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMemberRefTable*", "MemberRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodDefTable*", "MethodDefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodImplTable*", "MethodImplTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodSemanticsTable*", "MethodSemanticsTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilMethodSpecTable*", "MethodSpecTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilModuleTable*", "ModuleTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilModuleRefTable*", "ModuleRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilNestedClassTable*", "NestedClassTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilParamTable*", "ParamTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 168 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilPropertyTable*", "PropertyTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilPropertyMapTable*", "PropertyMapTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilStandAloneSigTable*", "StandAloneSigTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 180 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeDefTable*", "TypeDefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeRefTable*", "TypeRefTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    AsmCilMetadataHeap.setDataPrototype(
        "SgAsmCilTypeSpecTable*", "TypeSpecTable", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMetadataHeap);
#if defined(SgAsmCilMetadataHeap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilDataStream);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysZero);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_HeapSizes);
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ReservedAlwaysOne);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_Valid);
#line 28 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_Sorted);
#line 32 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_NumberOfRows);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_DataSizeFlags);
#line 40 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyTable);
#line 44 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyOSTable);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyProcessorTable);
#line 52 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefTable);
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefOSTable);
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefProcessorTable);
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ClassLayoutTable);
#line 68 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ConstantTable);
#line 72 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_CustomAttributeTable);
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_DeclSecurityTable);
#line 80 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_EventTable);
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_EventMapTable);
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ExportedTypeTable);
#line 92 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_FieldTable);
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_FieldLayoutTable);
#line 100 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_FieldMarshalTable);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_FieldRVATable);
#line 108 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_FileTable);
#line 112 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_GenericParamTable);
#line 116 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_GenericParamConstraintTable);
#line 120 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ImplMapTable);
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_InterfaceImplTable);
#line 128 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ManifestResourceTable);
#line 132 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MemberRefTable);
#line 136 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodDefTable);
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodImplTable);
#line 144 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodSemanticsTable);
#line 148 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_MethodSpecTable);
#line 152 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ModuleTable);
#line 156 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ModuleRefTable);
#line 160 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_NestedClassTable);
#line 164 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_ParamTable);
#line 168 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_PropertyTable);
#line 172 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_PropertyMapTable);
#line 176 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_StandAloneSigTable);
#line 180 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeDefTable);
#line 184 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeRefTable);
#line 188 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeSpecTable);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ReservedAlwaysZero() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ReservedAlwaysZero(uint32_t const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_MajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MajorVersion(uint8_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_MinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MinorVersion(uint8_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_HeapSizes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_HeapSizes(uint8_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_ReservedAlwaysOne() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ReservedAlwaysOne(uint8_t const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_Valid() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Valid(uint64_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_Sorted() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Sorted(uint64_t const&);
    /** @} */
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<uint32_t> const& get_NumberOfRows() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NumberOfRows(std::vector<uint32_t> const&);
    /** @} */
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 35 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint64_t const& get_DataSizeFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_DataSizeFlags(uint64_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyTable* const& get_AssemblyTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyTable(SgAsmCilAssemblyTable* const&);
    /** @} */
#line 41 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyOSTable* const& get_AssemblyOSTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyOSTable(SgAsmCilAssemblyOSTable* const&);
    /** @} */
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyProcessorTable* const& get_AssemblyProcessorTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyProcessorTable(SgAsmCilAssemblyProcessorTable* const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyRefTable* const& get_AssemblyRefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyRefTable(SgAsmCilAssemblyRefTable* const&);
    /** @} */
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyRefOSTable* const& get_AssemblyRefOSTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyRefOSTable(SgAsmCilAssemblyRefOSTable* const&);
    /** @} */
#line 57 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilAssemblyRefProcessorTable* const& get_AssemblyRefProcessorTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyRefProcessorTable(SgAsmCilAssemblyRefProcessorTable* const&);
    /** @} */
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 63 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilClassLayoutTable* const& get_ClassLayoutTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ClassLayoutTable(SgAsmCilClassLayoutTable* const&);
    /** @} */
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilConstantTable* const& get_ConstantTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ConstantTable(SgAsmCilConstantTable* const&);
    /** @} */
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilCustomAttributeTable* const& get_CustomAttributeTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_CustomAttributeTable(SgAsmCilCustomAttributeTable* const&);
    /** @} */
#line 73 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 75 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilDeclSecurityTable* const& get_DeclSecurityTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_DeclSecurityTable(SgAsmCilDeclSecurityTable* const&);
    /** @} */
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 79 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilEventTable* const& get_EventTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventTable(SgAsmCilEventTable* const&);
    /** @} */
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 83 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilEventMapTable* const& get_EventMapTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventMapTable(SgAsmCilEventMapTable* const&);
    /** @} */
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 87 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilExportedTypeTable* const& get_ExportedTypeTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ExportedTypeTable(SgAsmCilExportedTypeTable* const&);
    /** @} */
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 91 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilFieldTable* const& get_FieldTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FieldTable(SgAsmCilFieldTable* const&);
    /** @} */
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 95 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilFieldLayoutTable* const& get_FieldLayoutTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FieldLayoutTable(SgAsmCilFieldLayoutTable* const&);
    /** @} */
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 99 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilFieldMarshalTable* const& get_FieldMarshalTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FieldMarshalTable(SgAsmCilFieldMarshalTable* const&);
    /** @} */
#line 101 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilFieldRVATable* const& get_FieldRVATable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FieldRVATable(SgAsmCilFieldRVATable* const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilFileTable* const& get_FileTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_FileTable(SgAsmCilFileTable* const&);
    /** @} */
#line 109 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 111 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilGenericParamTable* const& get_GenericParamTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_GenericParamTable(SgAsmCilGenericParamTable* const&);
    /** @} */
#line 113 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilGenericParamConstraintTable* const& get_GenericParamConstraintTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_GenericParamConstraintTable(SgAsmCilGenericParamConstraintTable* const&);
    /** @} */
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 119 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilImplMapTable* const& get_ImplMapTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ImplMapTable(SgAsmCilImplMapTable* const&);
    /** @} */
#line 121 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilInterfaceImplTable* const& get_InterfaceImplTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_InterfaceImplTable(SgAsmCilInterfaceImplTable* const&);
    /** @} */
#line 125 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 127 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilManifestResourceTable* const& get_ManifestResourceTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ManifestResourceTable(SgAsmCilManifestResourceTable* const&);
    /** @} */
#line 129 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMemberRefTable* const& get_MemberRefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MemberRefTable(SgAsmCilMemberRefTable* const&);
    /** @} */
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 135 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMethodDefTable* const& get_MethodDefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodDefTable(SgAsmCilMethodDefTable* const&);
    /** @} */
#line 137 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMethodImplTable* const& get_MethodImplTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodImplTable(SgAsmCilMethodImplTable* const&);
    /** @} */
#line 141 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 143 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMethodSemanticsTable* const& get_MethodSemanticsTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodSemanticsTable(SgAsmCilMethodSemanticsTable* const&);
    /** @} */
#line 145 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 147 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilMethodSpecTable* const& get_MethodSpecTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MethodSpecTable(SgAsmCilMethodSpecTable* const&);
    /** @} */
#line 149 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 151 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilModuleTable* const& get_ModuleTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ModuleTable(SgAsmCilModuleTable* const&);
    /** @} */
#line 153 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 155 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilModuleRefTable* const& get_ModuleRefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ModuleRefTable(SgAsmCilModuleRefTable* const&);
    /** @} */
#line 157 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 159 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilNestedClassTable* const& get_NestedClassTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NestedClassTable(SgAsmCilNestedClassTable* const&);
    /** @} */
#line 161 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 163 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilParamTable* const& get_ParamTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ParamTable(SgAsmCilParamTable* const&);
    /** @} */
#line 165 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 167 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilPropertyTable* const& get_PropertyTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PropertyTable(SgAsmCilPropertyTable* const&);
    /** @} */
#line 169 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 171 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilPropertyMapTable* const& get_PropertyMapTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PropertyMapTable(SgAsmCilPropertyMapTable* const&);
    /** @} */
#line 173 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 175 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilStandAloneSigTable* const& get_StandAloneSigTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_StandAloneSigTable(SgAsmCilStandAloneSigTable* const&);
    /** @} */
#line 177 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 179 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilTypeDefTable* const& get_TypeDefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeDefTable(SgAsmCilTypeDefTable* const&);
    /** @} */
#line 181 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 183 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilTypeRefTable* const& get_TypeRefTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeRefTable(SgAsmCilTypeRefTable* const&);
    /** @} */
#line 185 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 187 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmCilTypeSpecTable* const& get_TypeSpecTable() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeSpecTable(SgAsmCilTypeSpecTable* const&);
    /** @} */
#line 189 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadataHeap.h"
public:
    /// reference kinds in the metadata tables
    enum ReferenceKind
    {
      // heaps
      e_ref_string_heap           = 1 << 0,
      e_ref_guid_heap             = 1 << 1,
      e_ref_blob_heap             = 1 << 2,
      // single-table references
      e_ref_assembly_ref          = 1 << 3,
      e_ref_type_def              = 1 << 4,
      e_ref_event                 = 1 << 5,
      e_ref_field                 = 1 << 6,
      e_ref_generic_param         = 1 << 7,
      e_ref_module_ref            = 1 << 8,
      e_ref_method_def            = 1 << 9,
      e_ref_param                 = 1 << 10,
      e_ref_property              = 1 << 11,
      // multi-table references
      e_ref_has_constant          = 1 << 12,
      e_ref_has_custom_attribute  = 1 << 13,
      e_ref_has_decl_security     = 1 << 14,
      e_ref_has_field_marshall    = 1 << 15,
      e_ref_has_semantics         = 1 << 16,
      e_ref_method_def_or_ref     = 1 << 17,
      e_ref_type_def_or_ref       = 1 << 18,
      e_ref_implementation        = 1 << 19,
      e_ref_member_forwarded      = 1 << 20,
      e_ref_member_ref_parent     = 1 << 21,
      e_ref_type_or_method_def    = 1 << 22,
      e_ref_custom_attribute_type = 1 << 23,
      e_ref_resolution_scope      = 1 << 24,
      e_ref_last                  = 1 << 25,
    };

    enum TableKind : std::uint8_t
    {

      e_Assembly = 0x20,
      e_AssemblyOS = 0x22,
      e_AssemblyProcessor = 0x21,
      e_AssemblyRef = 0x23,
      e_AssemblyRefOS = 0x25,
      e_AssemblyRefProcessor = 0x24,
      e_ClassLayout = 0x0F,
      e_Constant = 0x0B,
      e_CustomAttribute = 0x0C,
      e_DeclSecurity = 0x0E,
      e_Event = 0x14,
      e_EventMap = 0x12,
      e_ExportedType = 0x27,
      e_Field = 0x04,
      e_FieldLayout = 0x10,
      e_FieldMarshal = 0x0D,
      e_FieldRVA = 0x1D,
      e_File = 0x26,
      e_GenericParam = 0x2A,
      e_GenericParamConstraint = 0x2C,
      e_ImplMap = 0x1C,
      e_InterfaceImpl = 0x09,
      e_ManifestResource = 0x28,
      e_MemberRef = 0x0A,
      e_MethodDef = 0x06,
      e_MethodImpl = 0x19,
      e_MethodSemantics = 0x18,
      e_MethodSpec = 0x2B,
      e_Module = 0x00,
      e_ModuleRef = 0x1A,
      e_NestedClass = 0x29,
      e_Param = 0x08,
      e_Property = 0x17,
      e_PropertyMap = 0x15,
      e_StandAloneSig = 0x11,
      e_TypeDef = 0x02,
      e_TypeRef = 0x01,
      e_TypeSpec = 0x1B,
      e_Unknown_table_kind = 0xFF
    };

    /** parses the metadata objects from the buffer. */
    void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) override;

    /** looks up the node associated with the coded index @ref idx in the metadata table
     *  associated with @ref tblcode.
     */
    SgAsmCilMetadata* get_MetadataNode(std::uint32_t idx, TableKind tblcode) const;

    /** looks up the node associated with the coded index @ref refcode in the metadata tables
     *  under the assumption that @refval is of kind @ref knd
     */
    SgAsmCilMetadata* get_CodedMetadataNode(std::uint32_t refcode, ReferenceKind knd) const;

    /** looks up the node associated with the coded index @ref refcode in the metadata tables
     *  under the assumption that @refval is of kind @ref knd
     */
    SgAsmCilMetadata* get_MetadataNode(std::uint32_t refcode, ReferenceKind knd) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMetadataHeap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMetadataHeap();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmCilMetadataHeap(uint32_t const& Offset,
                         uint32_t const& Size,
                         std::string const& Name,
                         uint32_t const& NamePadding);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadataHeap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMemberRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMemberRefTable);
IS_SERIALIZABLE(AsmCilMemberRefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"
/** CIL MemberRef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"
class SgAsmCilMemberRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"
    AsmCilMemberRefTable.setDataPrototype(
        "std::vector<SgAsmCilMemberRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMemberRefTable);
#if defined(SgAsmCilMemberRefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMemberRef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilMemberRef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRefTable.h"
public:
    using CilMetadataType = SgAsmCilMemberRef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMemberRefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMemberRefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMemberRefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMemberRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilMemberRef);
IS_SERIALIZABLE(AsmCilMemberRef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
/** CIL MemberRef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
class SgAsmCilMemberRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Class", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    AsmCilMemberRef.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMemberRef);
#if defined(SgAsmCilMemberRef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Class);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Class(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMemberRef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Class_object() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMemberRef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMemberRef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMemberRef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilManifestResourceTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilManifestResourceTable);
IS_SERIALIZABLE(AsmCilManifestResourceTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"
/** CIL ManifestResource tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"
class SgAsmCilManifestResourceTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"
    AsmCilManifestResourceTable.setDataPrototype(
        "std::vector<SgAsmCilManifestResource*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilManifestResourceTable);
#if defined(SgAsmCilManifestResourceTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilManifestResource*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilManifestResource*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResourceTable.h"
public:
    using CilMetadataType = SgAsmCilManifestResource;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilManifestResourceTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilManifestResourceTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilManifestResourceTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilManifestResource           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilManifestResource);
IS_SERIALIZABLE(AsmCilManifestResource);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
/** CIL ManifestResource node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
class SgAsmCilManifestResource: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    AsmCilManifestResource.setDataPrototype(
        "uint32_t", "Implementation", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilManifestResource);
#if defined(SgAsmCilManifestResource_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
        s & BOOST_SERIALIZATION_NVP(p_Offset);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
        s & BOOST_SERIALIZATION_NVP(p_Implementation);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Offset(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Implementation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Implementation(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilManifestResource.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const SgAsmCilMetadata* get_Implementation_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilManifestResource();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilManifestResource();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilManifestResource_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInterfaceImplTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilInterfaceImplTable);
IS_SERIALIZABLE(AsmCilInterfaceImplTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"
/** CIL InterfaceImpl tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"
class SgAsmCilInterfaceImplTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"
    AsmCilInterfaceImplTable.setDataPrototype(
        "std::vector<SgAsmCilInterfaceImpl*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilInterfaceImplTable);
#if defined(SgAsmCilInterfaceImplTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilInterfaceImpl*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilInterfaceImpl*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImplTable.h"
public:
    using CilMetadataType = SgAsmCilInterfaceImpl;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilInterfaceImplTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilInterfaceImplTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInterfaceImplTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInterfaceImpl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilInterfaceImpl);
IS_SERIALIZABLE(AsmCilInterfaceImpl);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
/** CIL InterfaceImpl node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
class SgAsmCilInterfaceImpl: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
    AsmCilInterfaceImpl.setDataPrototype(
        "uint32_t", "Class", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
    AsmCilInterfaceImpl.setDataPrototype(
        "uint32_t", "Interface", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilInterfaceImpl);
#if defined(SgAsmCilInterfaceImpl_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
        s & BOOST_SERIALIZATION_NVP(p_Class);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
        s & BOOST_SERIALIZATION_NVP(p_Interface);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Class() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Class(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Interface() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Interface(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInterfaceImpl.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Class_object() const;
    const SgAsmCilMetadata* get_Interface_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilInterfaceImpl();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilInterfaceImpl();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInterfaceImpl_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilInstruction);
IS_SERIALIZABLE(AsmCilInstruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmCilInstruction);
#if defined(SgAsmCilInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
#include <Rose/BinaryAnalysis/InstructionEnumsCil.h>
#endif // SgAsmCilInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
class SgAsmCilInstruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
    AsmCilInstruction.setDataPrototype(
        "Rose::BinaryAnalysis::CilInstructionKind", "kind", "= Rose::BinaryAnalysis::Cil_unknown_instruction",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilInstruction);
#if defined(SgAsmCilInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::CilInstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::CilInstructionKind const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilInstruction.h"
public:
    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*> &insns,
                                    rose_addr_t *target/*out*/, rose_addr_t *ret/*out*/) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&,
                                    rose_addr_t *target, rose_addr_t *ret) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*> &insns) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*> &insns) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*>&,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr()) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmCilInstruction(rose_addr_t const& address,
                        std::string const& mnemonic,
                        Rose::BinaryAnalysis::CilInstructionKind const& kind);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilImplMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilImplMapTable);
IS_SERIALIZABLE(AsmCilImplMapTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"
/** CIL ImplMap tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"
class SgAsmCilImplMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"
    AsmCilImplMapTable.setDataPrototype(
        "std::vector<SgAsmCilImplMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilImplMapTable);
#if defined(SgAsmCilImplMapTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilImplMap*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilImplMap*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMapTable.h"
public:
    using CilMetadataType = SgAsmCilImplMap;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilImplMapTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilImplMapTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilImplMapTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilImplMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilImplMap);
IS_SERIALIZABLE(AsmCilImplMap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
/** CIL ImplMap node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
class SgAsmCilImplMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    AsmCilImplMap.setDataPrototype(
        "uint16_t", "MappingFlags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "MemberForwarded", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "ImportName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    AsmCilImplMap.setDataPrototype(
        "uint32_t", "ImportScope", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilImplMap);
#if defined(SgAsmCilImplMap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
        s & BOOST_SERIALIZATION_NVP(p_MappingFlags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
        s & BOOST_SERIALIZATION_NVP(p_MemberForwarded);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
        s & BOOST_SERIALIZATION_NVP(p_ImportName);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
        s & BOOST_SERIALIZATION_NVP(p_ImportScope);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MappingFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MappingFlags(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_MemberForwarded() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MemberForwarded(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ImportName() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ImportName(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ImportScope() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ImportScope(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilImplMap.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_MemberForwarded_object() const;
    const std::uint8_t* get_ImportName_string() const;
    const SgAsmCilMetadata* get_ImportScope_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilImplMap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilImplMap();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilImplMap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilGenericParamTable);
IS_SERIALIZABLE(AsmCilGenericParamTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"
/** CIL GenericParam tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"
class SgAsmCilGenericParamTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"
    AsmCilGenericParamTable.setDataPrototype(
        "std::vector<SgAsmCilGenericParam*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilGenericParamTable);
#if defined(SgAsmCilGenericParamTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilGenericParam*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilGenericParam*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamTable.h"
public:
    using CilMetadataType = SgAsmCilGenericParam;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilGenericParamTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParam           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilGenericParam);
IS_SERIALIZABLE(AsmCilGenericParam);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
/** CIL GenericParam node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
class SgAsmCilGenericParam: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    AsmCilGenericParam.setDataPrototype(
        "uint16_t", "Number", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    AsmCilGenericParam.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    AsmCilGenericParam.setDataPrototype(
        "uint32_t", "Owner", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    AsmCilGenericParam.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilGenericParam);
#if defined(SgAsmCilGenericParam_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Number);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Owner);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Number() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Number(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Owner() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Owner(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParam.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Owner_object() const;
    const std::uint8_t* get_Name_string() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParam();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilGenericParam();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParam_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamConstraintTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilGenericParamConstraintTable);
IS_SERIALIZABLE(AsmCilGenericParamConstraintTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"
/** CIL GenericParamConstraint tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"
class SgAsmCilGenericParamConstraintTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"
    AsmCilGenericParamConstraintTable.setDataPrototype(
        "std::vector<SgAsmCilGenericParamConstraint*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilGenericParamConstraintTable);
#if defined(SgAsmCilGenericParamConstraintTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilGenericParamConstraint*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilGenericParamConstraint*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraintTable.h"
public:
    using CilMetadataType = SgAsmCilGenericParamConstraint;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamConstraintTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilGenericParamConstraintTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamConstraintTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilGenericParamConstraint           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilGenericParamConstraint);
IS_SERIALIZABLE(AsmCilGenericParamConstraint);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
/** CIL GenericParamConstraint node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
class SgAsmCilGenericParamConstraint: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
    AsmCilGenericParamConstraint.setDataPrototype(
        "uint32_t", "Owner", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
    AsmCilGenericParamConstraint.setDataPrototype(
        "uint32_t", "Constraint", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilGenericParamConstraint);
#if defined(SgAsmCilGenericParamConstraint_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
        s & BOOST_SERIALIZATION_NVP(p_Owner);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
        s & BOOST_SERIALIZATION_NVP(p_Constraint);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Owner() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Owner(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Constraint() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Constraint(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilGenericParamConstraint.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Owner_object() const;
    const SgAsmCilMetadata* get_Constraint_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilGenericParamConstraint();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilGenericParamConstraint();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilGenericParamConstraint_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFileTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFileTable);
IS_SERIALIZABLE(AsmCilFileTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"
/** CIL File tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"
class SgAsmCilFileTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"
    AsmCilFileTable.setDataPrototype(
        "std::vector<SgAsmCilFile*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFileTable);
#if defined(SgAsmCilFileTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFile*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFile*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFileTable.h"
public:
    using CilMetadataType = SgAsmCilFile;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFileTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFileTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFileTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFile           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFile);
IS_SERIALIZABLE(AsmCilFile);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
/** CIL File node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
class SgAsmCilFile: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    AsmCilFile.setDataPrototype(
        "uint32_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    AsmCilFile.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    AsmCilFile.setDataPrototype(
        "uint32_t", "HashValue", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFile);
#if defined(SgAsmCilFile_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
        s & BOOST_SERIALIZATION_NVP(p_HashValue);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_HashValue() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_HashValue(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFile.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_HashValue_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFile();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFile();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFile_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldTable);
IS_SERIALIZABLE(AsmCilFieldTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"
/** CIL Field tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"
class SgAsmCilFieldTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"
    AsmCilFieldTable.setDataPrototype(
        "std::vector<SgAsmCilField*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldTable);
#if defined(SgAsmCilFieldTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilField*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilField*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldTable.h"
public:
    using CilMetadataType = SgAsmCilField;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldRVATable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldRVATable);
IS_SERIALIZABLE(AsmCilFieldRVATable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"
/** CIL FieldRVA tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"
class SgAsmCilFieldRVATable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"
    AsmCilFieldRVATable.setDataPrototype(
        "std::vector<SgAsmCilFieldRVA*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldRVATable);
#if defined(SgAsmCilFieldRVATable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldRVA*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldRVA*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVATable.h"
public:
    using CilMetadataType = SgAsmCilFieldRVA;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldRVATable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldRVATable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldRVATable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldRVA           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldRVA);
IS_SERIALIZABLE(AsmCilFieldRVA);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
/** CIL FieldRVA node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
class SgAsmCilFieldRVA: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
    AsmCilFieldRVA.setDataPrototype(
        "uint32_t", "RVA", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
    AsmCilFieldRVA.setDataPrototype(
        "uint32_t", "Field", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldRVA);
#if defined(SgAsmCilFieldRVA_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
        s & BOOST_SERIALIZATION_NVP(p_RVA);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
        s & BOOST_SERIALIZATION_NVP(p_Field);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_RVA() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_RVA(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Field() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Field(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldRVA.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Field_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldRVA();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldRVA();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldRVA_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldMarshalTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldMarshalTable);
IS_SERIALIZABLE(AsmCilFieldMarshalTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"
/** CIL FieldMarshal tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"
class SgAsmCilFieldMarshalTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"
    AsmCilFieldMarshalTable.setDataPrototype(
        "std::vector<SgAsmCilFieldMarshal*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldMarshalTable);
#if defined(SgAsmCilFieldMarshalTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldMarshal*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldMarshal*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshalTable.h"
public:
    using CilMetadataType = SgAsmCilFieldMarshal;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldMarshalTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldMarshalTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldMarshalTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldMarshal           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldMarshal);
IS_SERIALIZABLE(AsmCilFieldMarshal);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
/** CIL FieldMarshal node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
class SgAsmCilFieldMarshal: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
    AsmCilFieldMarshal.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
    AsmCilFieldMarshal.setDataPrototype(
        "uint32_t", "NativeType", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldMarshal);
#if defined(SgAsmCilFieldMarshal_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
        s & BOOST_SERIALIZATION_NVP(p_NativeType);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_NativeType() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NativeType(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldMarshal.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_NativeType_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldMarshal();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldMarshal();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldMarshal_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldLayoutTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldLayoutTable);
IS_SERIALIZABLE(AsmCilFieldLayoutTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"
/** CIL FieldLayout tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"
class SgAsmCilFieldLayoutTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"
    AsmCilFieldLayoutTable.setDataPrototype(
        "std::vector<SgAsmCilFieldLayout*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldLayoutTable);
#if defined(SgAsmCilFieldLayoutTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldLayout*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilFieldLayout*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayoutTable.h"
public:
    using CilMetadataType = SgAsmCilFieldLayout;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldLayoutTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldLayoutTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldLayoutTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilFieldLayout           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilFieldLayout);
IS_SERIALIZABLE(AsmCilFieldLayout);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
/** CIL FieldLayout node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
class SgAsmCilFieldLayout: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
    AsmCilFieldLayout.setDataPrototype(
        "uint32_t", "Offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
    AsmCilFieldLayout.setDataPrototype(
        "uint32_t", "Field", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilFieldLayout);
#if defined(SgAsmCilFieldLayout_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
        s & BOOST_SERIALIZATION_NVP(p_Offset);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
        s & BOOST_SERIALIZATION_NVP(p_Field);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Offset(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Field() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Field(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilFieldLayout.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Field_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilFieldLayout();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilFieldLayout();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilFieldLayout_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilField           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilField);
IS_SERIALIZABLE(AsmCilField);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
/** CIL Field node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
class SgAsmCilField: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    AsmCilField.setDataPrototype(
        "uint16_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    AsmCilField.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    AsmCilField.setDataPrototype(
        "uint32_t", "Signature", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilField);
#if defined(SgAsmCilField_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
        s & BOOST_SERIALIZATION_NVP(p_Signature);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Signature() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Signature(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilField.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Signature_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilField();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilField();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilField_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilExportedTypeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilExportedTypeTable);
IS_SERIALIZABLE(AsmCilExportedTypeTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"
/** CIL ExportedType tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"
class SgAsmCilExportedTypeTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"
    AsmCilExportedTypeTable.setDataPrototype(
        "std::vector<SgAsmCilExportedType*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilExportedTypeTable);
#if defined(SgAsmCilExportedTypeTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilExportedType*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilExportedType*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedTypeTable.h"
public:
    using CilMetadataType = SgAsmCilExportedType;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilExportedTypeTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilExportedTypeTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilExportedTypeTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilExportedType           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilExportedType);
IS_SERIALIZABLE(AsmCilExportedType);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
/** CIL ExportedType node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
class SgAsmCilExportedType: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "EventFlags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeDefIdName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeName", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "TypeNamespace", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    AsmCilExportedType.setDataPrototype(
        "uint32_t", "Implementation", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilExportedType);
#if defined(SgAsmCilExportedType_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
        s & BOOST_SERIALIZATION_NVP(p_EventFlags);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeDefIdName);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeName);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
        s & BOOST_SERIALIZATION_NVP(p_TypeNamespace);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
        s & BOOST_SERIALIZATION_NVP(p_Implementation);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_EventFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventFlags(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeDefIdName() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeDefIdName(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeName() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeName(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_TypeNamespace() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_TypeNamespace(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Implementation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Implementation(uint32_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilExportedType.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_TypeName_string() const;
    const std::uint8_t* get_TypeNamespace_string() const;
    const SgAsmCilMetadata* get_Implementation_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilExportedType();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilExportedType();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilExportedType_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilEventTable);
IS_SERIALIZABLE(AsmCilEventTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"
/** CIL Event tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"
class SgAsmCilEventTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"
    AsmCilEventTable.setDataPrototype(
        "std::vector<SgAsmCilEvent*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilEventTable);
#if defined(SgAsmCilEventTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilEvent*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilEvent*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventTable.h"
public:
    using CilMetadataType = SgAsmCilEvent;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilEventTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilEventTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventMapTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilEventMapTable);
IS_SERIALIZABLE(AsmCilEventMapTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"
/** CIL EventMap tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"
class SgAsmCilEventMapTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"
    AsmCilEventMapTable.setDataPrototype(
        "std::vector<SgAsmCilEventMap*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilEventMapTable);
#if defined(SgAsmCilEventMapTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilEventMap*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilEventMap*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMapTable.h"
public:
    using CilMetadataType = SgAsmCilEventMap;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilEventMapTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilEventMapTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventMapTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEventMap           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilEventMap);
IS_SERIALIZABLE(AsmCilEventMap);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
/** CIL EventMap node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
class SgAsmCilEventMap: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
    AsmCilEventMap.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
    AsmCilEventMap.setDataPrototype(
        "uint32_t", "EventList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilEventMap);
#if defined(SgAsmCilEventMap_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
        s & BOOST_SERIALIZATION_NVP(p_EventList);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_EventList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventList(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEventMap.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_EventList_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilEventMap();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilEventMap();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEventMap_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilEvent           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilEvent);
IS_SERIALIZABLE(AsmCilEvent);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
/** CIL Event node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
class SgAsmCilEvent: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    AsmCilEvent.setDataPrototype(
        "uint16_t", "EventFlags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    AsmCilEvent.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    AsmCilEvent.setDataPrototype(
        "uint32_t", "EventType", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilEvent);
#if defined(SgAsmCilEvent_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
        s & BOOST_SERIALIZATION_NVP(p_EventFlags);
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
        s & BOOST_SERIALIZATION_NVP(p_EventType);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
public:
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_EventFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventFlags(uint16_t const&);
    /** @} */
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_EventType() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_EventType(uint32_t const&);
    /** @} */
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilEvent.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_Name_string() const;
    const SgAsmCilMetadata* get_EventType_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilEvent();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilEvent();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilEvent_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDeclSecurityTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilDeclSecurityTable);
IS_SERIALIZABLE(AsmCilDeclSecurityTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"
/** CIL DeclSecurity tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"
class SgAsmCilDeclSecurityTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"
    AsmCilDeclSecurityTable.setDataPrototype(
        "std::vector<SgAsmCilDeclSecurity*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilDeclSecurityTable);
#if defined(SgAsmCilDeclSecurityTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilDeclSecurity*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilDeclSecurity*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurityTable.h"
public:
    using CilMetadataType = SgAsmCilDeclSecurity;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilDeclSecurityTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilDeclSecurityTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDeclSecurityTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDeclSecurity           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilDeclSecurity);
IS_SERIALIZABLE(AsmCilDeclSecurity);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
/** CIL DeclSecurity node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
class SgAsmCilDeclSecurity: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    AsmCilDeclSecurity.setDataPrototype(
        "uint16_t", "Action", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    AsmCilDeclSecurity.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    AsmCilDeclSecurity.setDataPrototype(
        "uint32_t", "PermissionSet", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilDeclSecurity);
#if defined(SgAsmCilDeclSecurity_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
        s & BOOST_SERIALIZATION_NVP(p_Action);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
        s & BOOST_SERIALIZATION_NVP(p_PermissionSet);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_Action() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Action(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_PermissionSet() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PermissionSet(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDeclSecurity.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_PermissionSet_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilDeclSecurity();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilDeclSecurity();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDeclSecurity_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilDataStream           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmCilDataStream = nonTerminalConstructor(
    "AsmCilDataStream",
    *this,
    "AsmCilDataStream",
    "AsmCilDataStreamTag",
    SubclassListBuilder()
        | AsmCilMetadataHeap
        | AsmCilUint32Heap
        | AsmCilUint8Heap
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmCilDataStream.associatedGrammar != nullptr);
AsmCilDataStream.setCppCondition("!defined(DOCUMENTATION)");
AsmCilDataStream.isBoostSerializable(true);
AsmCilDataStream.setAutomaticGenerationOfConstructor(false);
AsmCilDataStream.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
/** Base class for CIL branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
class SgAsmCilDataStream: public SgAsmCilNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "Offset", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "Size", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    AsmCilDataStream.setDataPrototype(
        "std::string", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    AsmCilDataStream.setDataPrototype(
        "uint32_t", "NamePadding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilDataStream);
#if defined(SgAsmCilDataStream_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
        s & BOOST_SERIALIZATION_NVP(p_Offset);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
        s & BOOST_SERIALIZATION_NVP(p_Size);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
        s & BOOST_SERIALIZATION_NVP(p_NamePadding);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Offset() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Offset(uint32_t const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Size() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Size(uint32_t const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(std::string const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_NamePadding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_NamePadding(uint32_t const&);
    /** @} */
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilDataStream.h"
public:
    /** Define constant strings for the known stream types
     *  @{
     */
    static const std::string ID_STRING_HEAP;
    static const std::string ID_BLOB_HEAP;
    static const std::string ID_US_HEAP;
    static const std::string ID_GUID_HEAP;
    static const std::string ID_METADATA_HEAP;
    /** }@ */

    /**
     * Defines the parse function.
     * @param buf the binary buffer.
     * @param startOfMetaData the location in buf where the metadata root (CIL ECMA II.24.2.1)
     *        is located.
     * @details
     *   buf[startOfMetaData] is the location of the metadata root magic number.
     *   parse will add get_Offset to startOfMetaData to find the first byte of a
     *   stream.
     */
    virtual void parse(std::vector<uint8_t>& buf, size_t startOfMetaData) { /* FIXME: should be abstract */ }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilDataStream();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilDataStream();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmCilDataStream(uint32_t const& Offset,
                       uint32_t const& Size,
                       std::string const& Name,
                       uint32_t const& NamePadding);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilDataStream_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilCustomAttributeTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilCustomAttributeTable);
IS_SERIALIZABLE(AsmCilCustomAttributeTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttributeTable.h"
class SgAsmCilCustomAttributeTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttributeTable.h"
    AsmCilCustomAttributeTable.setDataPrototype(
        "std::vector<SgAsmCilCustomAttribute*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilCustomAttributeTable);
#if defined(SgAsmCilCustomAttributeTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttributeTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttributeTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilCustomAttribute*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilCustomAttribute*>& get_elements();
    /** @} */
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttributeTable.h"
public:
    using CilMetadataType = SgAsmCilCustomAttribute;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilCustomAttributeTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilCustomAttributeTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilCustomAttributeTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilCustomAttribute           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilCustomAttribute);
IS_SERIALIZABLE(AsmCilCustomAttribute);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
/** CIL CustomAttribute node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
class SgAsmCilCustomAttribute: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Type", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    AsmCilCustomAttribute.setDataPrototype(
        "uint32_t", "Value", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilCustomAttribute);
#if defined(SgAsmCilCustomAttribute_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_Type);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
        s & BOOST_SERIALIZATION_NVP(p_Value);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Type(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Value() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Value(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilCustomAttribute.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const SgAsmCilMetadata* get_Type_object() const;
    const std::uint8_t* get_Value_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilCustomAttribute();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilCustomAttribute();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilCustomAttribute_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilConstantTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilConstantTable);
IS_SERIALIZABLE(AsmCilConstantTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"
/** CIL Constant tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"
class SgAsmCilConstantTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"
    AsmCilConstantTable.setDataPrototype(
        "std::vector<SgAsmCilConstant*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilConstantTable);
#if defined(SgAsmCilConstantTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilConstant*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilConstant*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstantTable.h"
public:
    using CilMetadataType = SgAsmCilConstant;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilConstantTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilConstantTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilConstantTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilConstant           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilConstant);
IS_SERIALIZABLE(AsmCilConstant);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
/** CIL Constant node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
class SgAsmCilConstant: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    AsmCilConstant.setDataPrototype(
        "uint8_t", "Type", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    AsmCilConstant.setDataPrototype(
        "uint8_t", "Padding", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    AsmCilConstant.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    AsmCilConstant.setDataPrototype(
        "uint32_t", "Value", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilConstant);
#if defined(SgAsmCilConstant_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
        s & BOOST_SERIALIZATION_NVP(p_Type);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
        s & BOOST_SERIALIZATION_NVP(p_Padding);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
        s & BOOST_SERIALIZATION_NVP(p_Value);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_Type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Type(uint8_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint8_t const& get_Padding() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Padding(uint8_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Value() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Value(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilConstant.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
    const std::uint8_t* get_Value_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilConstant();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilConstant();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilConstant_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilClassLayoutTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilClassLayoutTable);
IS_SERIALIZABLE(AsmCilClassLayoutTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"
/** CIL ClassLayout tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"
class SgAsmCilClassLayoutTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"
    AsmCilClassLayoutTable.setDataPrototype(
        "std::vector<SgAsmCilClassLayout*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilClassLayoutTable);
#if defined(SgAsmCilClassLayoutTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilClassLayout*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilClassLayout*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayoutTable.h"
public:
    using CilMetadataType = SgAsmCilClassLayout;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilClassLayoutTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilClassLayoutTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilClassLayoutTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilClassLayout           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilClassLayout);
IS_SERIALIZABLE(AsmCilClassLayout);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
/** CIL ClassLayout node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
class SgAsmCilClassLayout: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    AsmCilClassLayout.setDataPrototype(
        "uint16_t", "PackingSize", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    AsmCilClassLayout.setDataPrototype(
        "uint32_t", "ClassSize", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    AsmCilClassLayout.setDataPrototype(
        "uint32_t", "Parent", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilClassLayout);
#if defined(SgAsmCilClassLayout_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
        s & BOOST_SERIALIZATION_NVP(p_PackingSize);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
        s & BOOST_SERIALIZATION_NVP(p_ClassSize);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
        s & BOOST_SERIALIZATION_NVP(p_Parent);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_PackingSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PackingSize(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_ClassSize() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_ClassSize(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Parent() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Parent(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilClassLayout.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_Parent_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilClassLayout();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilClassLayout();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilClassLayout_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyTable);
IS_SERIALIZABLE(AsmCilAssemblyTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"
/** CIL Assembly tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"
class SgAsmCilAssemblyTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"
    AsmCilAssemblyTable.setDataPrototype(
        "std::vector<SgAsmCilAssembly*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyTable);
#if defined(SgAsmCilAssemblyTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssembly*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssembly*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyTable.h"
public:
    using CilMetadataType = SgAsmCilAssembly;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRefTable);
IS_SERIALIZABLE(AsmCilAssemblyRefTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"
/** CIL AssemblyRef tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"
class SgAsmCilAssemblyRefTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"
    AsmCilAssemblyRefTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRef*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRefTable);
#if defined(SgAsmCilAssemblyRefTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRef*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRef*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefTable.h"
public:
    using CilMetadataType = SgAsmCilAssemblyRef;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRefTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefProcessorTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRefProcessorTable);
IS_SERIALIZABLE(AsmCilAssemblyRefProcessorTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"
/** CIL AssemblyRefProcessor tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"
class SgAsmCilAssemblyRefProcessorTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"
    AsmCilAssemblyRefProcessorTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRefProcessor*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRefProcessorTable);
#if defined(SgAsmCilAssemblyRefProcessorTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRefProcessor*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRefProcessor*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessorTable.h"
public:
    using CilMetadataType = SgAsmCilAssemblyRefProcessor;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefProcessorTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRefProcessorTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefProcessorTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefProcessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRefProcessor);
IS_SERIALIZABLE(AsmCilAssemblyRefProcessor);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
/** CIL AssemblyRefProcessor node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
class SgAsmCilAssemblyRefProcessor: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
    AsmCilAssemblyRefProcessor.setDataPrototype(
        "uint32_t", "Processor", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
    AsmCilAssemblyRefProcessor.setDataPrototype(
        "uint32_t", "AssemblyRef", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRefProcessor);
#if defined(SgAsmCilAssemblyRefProcessor_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
        s & BOOST_SERIALIZATION_NVP(p_Processor);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRef);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Processor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Processor(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_AssemblyRef() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyRef(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefProcessor.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_AssemblyRef_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefProcessor();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRefProcessor();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefProcessor_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefOSTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRefOSTable);
IS_SERIALIZABLE(AsmCilAssemblyRefOSTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"
/** CIL AssemblyRefOS tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"
class SgAsmCilAssemblyRefOSTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"
    AsmCilAssemblyRefOSTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyRefOS*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRefOSTable);
#if defined(SgAsmCilAssemblyRefOSTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRefOS*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyRefOS*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOSTable.h"
public:
    using CilMetadataType = SgAsmCilAssemblyRefOS;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefOSTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRefOSTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefOSTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRefOS           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRefOS);
IS_SERIALIZABLE(AsmCilAssemblyRefOS);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
/** CIL AssemblyRefOS node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
class SgAsmCilAssemblyRefOS: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSPlatformID", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSMajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "OSMinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    AsmCilAssemblyRefOS.setDataPrototype(
        "uint32_t", "AssemblyRefOS", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRefOS);
#if defined(SgAsmCilAssemblyRefOS_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSPlatformID);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSMajorVersion);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSMinorVersion);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
        s & BOOST_SERIALIZATION_NVP(p_AssemblyRefOS);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSPlatformID() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSPlatformID(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSMajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSMajorVersion(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSMinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSMinorVersion(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_AssemblyRefOS() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_AssemblyRefOS(uint32_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRefOS.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const SgAsmCilMetadata* get_AssemblyRefOS_object() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRefOS();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRefOS();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRefOS_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyRef           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyRef);
IS_SERIALIZABLE(AsmCilAssemblyRef);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
/** CIL AssemblyRef node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
class SgAsmCilAssemblyRef: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "MajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "MinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "BuildNumber", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint16_t", "RevisionNumber", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "PublicKeyOrToken", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "Culture", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    AsmCilAssemblyRef.setDataPrototype(
        "uint32_t", "HashValue", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyRef);
#if defined(SgAsmCilAssemblyRef_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_BuildNumber);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_RevisionNumber);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_PublicKeyOrToken);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_Culture);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
        s & BOOST_SERIALIZATION_NVP(p_HashValue);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MajorVersion(uint16_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MinorVersion(uint16_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_BuildNumber() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_BuildNumber(uint16_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_RevisionNumber() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_RevisionNumber(uint16_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint32_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_PublicKeyOrToken() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PublicKeyOrToken(uint32_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Culture() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Culture(uint32_t const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_HashValue() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_HashValue(uint32_t const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyRef.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_PublicKeyOrToken_blob() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Culture_string() const;
    const std::uint8_t* get_HashValue_blob() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyRef();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyRef();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyRef_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyProcessorTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyProcessorTable);
IS_SERIALIZABLE(AsmCilAssemblyProcessorTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"
/** CIL AssemblyProcessor tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"
class SgAsmCilAssemblyProcessorTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"
    AsmCilAssemblyProcessorTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyProcessor*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyProcessorTable);
#if defined(SgAsmCilAssemblyProcessorTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyProcessor*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyProcessor*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessorTable.h"
public:
    using CilMetadataType = SgAsmCilAssemblyProcessor;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyProcessorTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyProcessorTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyProcessorTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyProcessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyProcessor);
IS_SERIALIZABLE(AsmCilAssemblyProcessor);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
/** CIL AssemblyProcessor node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
class SgAsmCilAssemblyProcessor: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
    AsmCilAssemblyProcessor.setDataPrototype(
        "uint32_t", "Processor", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyProcessor);
#if defined(SgAsmCilAssemblyProcessor_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
        s & BOOST_SERIALIZATION_NVP(p_Processor);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Processor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Processor(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyProcessor.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyProcessor();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyProcessor();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyProcessor_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyOSTable           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyOSTable);
IS_SERIALIZABLE(AsmCilAssemblyOSTable);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"
/** CIL AssemblyOS tables. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"
class SgAsmCilAssemblyOSTable: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"
    AsmCilAssemblyOSTable.setDataPrototype(
        "std::vector<SgAsmCilAssemblyOS*>", "elements", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyOSTable);
#if defined(SgAsmCilAssemblyOSTable_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"
        s & BOOST_SERIALIZATION_NVP(p_elements);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyOS*> const& get_elements() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    std::vector<SgAsmCilAssemblyOS*>& get_elements();
    /** @} */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOSTable.h"
public:
    using CilMetadataType = SgAsmCilAssemblyOS;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyOSTable();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyOSTable();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyOSTable_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssemblyOS           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssemblyOS);
IS_SERIALIZABLE(AsmCilAssemblyOS);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
/** CIL AssemblyOS node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
class SgAsmCilAssemblyOS: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSPlatformID", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSMajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    AsmCilAssemblyOS.setDataPrototype(
        "uint32_t", "OSMinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssemblyOS);
#if defined(SgAsmCilAssemblyOS_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSPlatformID);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSMajorVersion);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
        s & BOOST_SERIALIZATION_NVP(p_OSMinorVersion);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSPlatformID() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSPlatformID(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSMajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSMajorVersion(uint32_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_OSMinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_OSMinorVersion(uint32_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssemblyOS.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssemblyOS();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssemblyOS();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssemblyOS_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilAssembly           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmCilAssembly);
IS_SERIALIZABLE(AsmCilAssembly);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
/** CIL Assembly node. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
class SgAsmCilAssembly: public SgAsmCilMetadata {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "HashAlgId", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "MajorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "MinorVersion", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "BuildNumber", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint16_t", "RevisionNumber", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Flags", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "PublicKey", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Name", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    AsmCilAssembly.setDataPrototype(
        "uint32_t", "Culture", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilAssembly);
#if defined(SgAsmCilAssembly_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilMetadata);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_HashAlgId);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_MajorVersion);
#line 18 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_MinorVersion);
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_BuildNumber);
#line 30 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_RevisionNumber);
#line 36 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_Flags);
#line 42 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_PublicKey);
#line 48 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_Name);
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
        s & BOOST_SERIALIZATION_NVP(p_Culture);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_HashAlgId() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_HashAlgId(uint32_t const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MajorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MajorVersion(uint16_t const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 15 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_MinorVersion() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_MinorVersion(uint16_t const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_BuildNumber() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_BuildNumber(uint16_t const&);
    /** @} */
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint16_t const& get_RevisionNumber() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_RevisionNumber(uint16_t const&);
    /** @} */
#line 31 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Flags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Flags(uint32_t const&);
    /** @} */
#line 37 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 39 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_PublicKey() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_PublicKey(uint32_t const&);
    /** @} */
#line 43 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 45 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Name() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Name(uint32_t const&);
    /** @} */
#line 49 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 51 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    uint32_t const& get_Culture() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_Culture(uint32_t const&);
    /** @} */
#line 55 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilAssembly.h"
public:
    void parse(std::vector<uint8_t>& buf, size_t& index, uint64_t uses4byteIndexing);

    const std::uint8_t* get_PublicKey_blob() const;
    const std::uint8_t* get_Name_string() const;
    const std::uint8_t* get_Culture_string() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilAssembly();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilAssembly();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilAssembly_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilMetadata           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmCilMetadata = nonTerminalConstructor(
    "AsmCilMetadata",
    *this,
    "AsmCilMetadata",
    "AsmCilMetadataTag",
    SubclassListBuilder()
        | AsmCilAssembly
        | AsmCilAssemblyOS
        | AsmCilAssemblyOSTable
        | AsmCilAssemblyProcessor
        | AsmCilAssemblyProcessorTable
        | AsmCilAssemblyRef
        | AsmCilAssemblyRefOS
        | AsmCilAssemblyRefOSTable
        | AsmCilAssemblyRefProcessor
        | AsmCilAssemblyRefProcessorTable
        | AsmCilAssemblyRefTable
        | AsmCilAssemblyTable
        | AsmCilClassLayout
        | AsmCilClassLayoutTable
        | AsmCilConstant
        | AsmCilConstantTable
        | AsmCilCustomAttribute
        | AsmCilCustomAttributeTable
        | AsmCilDeclSecurity
        | AsmCilDeclSecurityTable
        | AsmCilEvent
        | AsmCilEventMap
        | AsmCilEventMapTable
        | AsmCilEventTable
        | AsmCilExportedType
        | AsmCilExportedTypeTable
        | AsmCilField
        | AsmCilFieldLayout
        | AsmCilFieldLayoutTable
        | AsmCilFieldMarshal
        | AsmCilFieldMarshalTable
        | AsmCilFieldRVA
        | AsmCilFieldRVATable
        | AsmCilFieldTable
        | AsmCilFile
        | AsmCilFileTable
        | AsmCilGenericParamConstraint
        | AsmCilGenericParamConstraintTable
        | AsmCilGenericParam
        | AsmCilGenericParamTable
        | AsmCilImplMap
        | AsmCilImplMapTable
        | AsmCilInterfaceImpl
        | AsmCilInterfaceImplTable
        | AsmCilManifestResource
        | AsmCilManifestResourceTable
        | AsmCilMemberRef
        | AsmCilMemberRefTable
        | AsmCilMethodDef
        | AsmCilMethodDefTable
        | AsmCilMethodImpl
        | AsmCilMethodImplTable
        | AsmCilMethodSemantics
        | AsmCilMethodSemanticsTable
        | AsmCilMethodSpec
        | AsmCilMethodSpecTable
        | AsmCilModule
        | AsmCilModuleRef
        | AsmCilModuleRefTable
        | AsmCilModuleTable
        | AsmCilNestedClass
        | AsmCilNestedClassTable
        | AsmCilParam
        | AsmCilParamTable
        | AsmCilProperty
        | AsmCilPropertyMap
        | AsmCilPropertyMapTable
        | AsmCilPropertyTable
        | AsmCilStandAloneSig
        | AsmCilStandAloneSigTable
        | AsmCilTypeDef
        | AsmCilTypeDefTable
        | AsmCilTypeRef
        | AsmCilTypeRefTable
        | AsmCilTypeSpec
        | AsmCilTypeSpecTable
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmCilMetadata.associatedGrammar != nullptr);
AsmCilMetadata.setCppCondition("!defined(DOCUMENTATION)");
AsmCilMetadata.isBoostSerializable(true);
AsmCilMetadata.setAutomaticGenerationOfConstructor(false);
AsmCilMetadata.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadata.h"
/** Base class for CIL branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilMetadata.h"
class SgAsmCilMetadata: public SgAsmCilNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilMetadata);
#if defined(SgAsmCilMetadata_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmCilNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilMetadata();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilMetadata();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilMetadata_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmCilNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmCilNode = nonTerminalConstructor(
    "AsmCilNode",
    *this,
    "AsmCilNode",
    "AsmCilNodeTag",
    SubclassListBuilder()
        | AsmCilDataStream
        | AsmCilMetadata
        | AsmCilMetadataRoot
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmCilNode.associatedGrammar != nullptr);
AsmCilNode.setCppCondition("!defined(DOCUMENTATION)");
AsmCilNode.isBoostSerializable(true);
AsmCilNode.setAutomaticGenerationOfConstructor(false);
AsmCilNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNode.h"
/** Base class for CIL branch of binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmCilNode.h"
class SgAsmCilNode: public SgAsmNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmCilNode);
#if defined(SgAsmCilNode_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmCilNode();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmCilNode();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmCilNode_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmByteOrder           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmByteOrder);
IS_SERIALIZABLE(AsmByteOrder);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"
/** Byte order specification. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"
class SgAsmByteOrder: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmByteOrder);
#if defined(SgAsmByteOrder_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"
        s & BOOST_SERIALIZATION_NVP(byteOrder_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    ByteOrder::Endianness byteOrder_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    ByteOrder::Endianness const& byteOrder() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void byteOrder(ByteOrder::Endianness const&);
    /** @} */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmByteOrder.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmByteOrder();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmByteOrder();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmByteOrder(ByteOrder::Endianness const& byteOrder);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmByteOrder_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBlock           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBlock);
IS_SERIALIZABLE(AsmBlock);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
/** Instruction basic block.
 *
 *  A SgAsmBlock usually represents a sequence of instructions. It's also used for grouping other things such as
 *  functions. A SgAsmBlock represents a basic block if and only if it has at least one descendant of type @ref
 *  SgAsmInstruction and it has no descendants of type SgAsmBlock.
 *
 *  In the absence of interrupt handling, the instructions of a basic block are executed entirely.  In the absense of
 *  multi-threading, no other instructions intervene.
 *
 *  The instructions of a basic block need not be contiguous in virtual memory. They also do not need to be at increasing
 *  virtual addresses.
 *
 *  If the basic block has a parent pointer, then the closest @ref SgAsmFunction ancestor is the one to which this basic
 *  block belongs. In the @ref Rose::BinaryAnalysis::Partitioner2::Partitioner "Partitioner" API, a basic block can be
 *  owned by more than one function.
 *
 *  An AST may have multiple SgAsmBlock objects that represent the same basic block. This happens when a single block
 *  belongs to more than one function.
 *
 *  See also, @ref Rose::BinaryAnalysis::Partitioner2::BasicBlock, which represents a basic block outside the AST. */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
class SgAsmBlock: public SgAsmStatement {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 64 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "rose_addr_t", "id", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "unsigned", "reason", "= SgAsmBlock::BLK_NONE",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "SgAsmStatementPtrList", "statementList", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "SgAsmIntegerValuePtrList", "successors", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "bool", "successors_complete", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 114 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "SgAsmBlock*", "immediate_dominator", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "size_t", "cached_vertex", "= (size_t)(-1)",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "double", "code_likelihood", "= 0.0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    AsmBlock.setDataPrototype(
        "int64_t", "stackDeltaOut", "= SgAsmInstruction::INVALID_STACK_DELTA",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBlock);
#if defined(SgAsmBlock_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
#line 70 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_reason);
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_statementList);
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_successors);
#line 104 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_successors_complete);
#line 114 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_immediate_dominator);
#line 123 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_cached_vertex);
#line 130 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_code_likelihood);
#line 139 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
        s & BOOST_SERIALIZATION_NVP(p_stackDeltaOut);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Reasons why a basic block might have been assigned to a function. */
    enum Reason {
        // Please update SgAsmBlock::reason_str() if you change this enum!
        BLK_NONE        = 0x00000000,           /**< No particular reason.  Mostly just for initialization. */
        BLK_ENTRY_POINT = 0x00010000,           /**< Block is an entry point for the function. */
        BLK_PADDING     = 0x00020000,           /**< Block is used for padding. */
        BLK_FRAGMENT    = 0x00080000,           /**< This block created because it seems to belong to the function although
                                                 *   CFG traversal did not find it. */
        BLK_CFGHEAD     = 0x00100000,           /**< Block serves as an explicit starting point for CFG analysis. */
        BLK_USERDEF     = 0x00200000,           /**< User says block belongs to the function. */
        BLK_LEFTOVERS   = 0x00400000,           /**< Block is being assigned to a FUNC_LEFTOVERS function because it could
                                                 *   not be assigned to any other function. */
        BLK_JUMPTABLE   = 0x00800000,           /**< Table of code addresses used by indirect branches. */
        BLK_GRAPH1      = 0x01000000,           /**< Block was added by the main CFG analysis. */
        BLK_GRAPH2      = 0x02000000,           /**< Block was added by a second pass of CFG analysis. */
        BLK_GRAPH3      = 0x04000000,           /**< Block was added by a third pass of CFG analysis. */

        BLK_DEFAULT     = BLK_NONE,             //NO_STRINGIFY

        // ========= Miscellaneous Reasons ===========================================================================
        // The first half of the range (1-127, inclusive) is used for algorithms defined by ROSE.  The second half is
        // availalble for users to use as they see fit.
        BLK_MISCMASK    = 0x000000ff,           /**< Miscellaneous reasons go here. We can store only one such reason at
                                                 *   a time. */
        BLK_FINDDATA    = 0x00000001,           /**< Added by Partitioner::FindData, which attaches unassigned parts of the
                                                 *   disassembly address space to the preceding function. */
        BLK_POSTFUNC    = 0x00000002            /**< Added by Partitioner::FindPostFunctionInsns, which adds unassigned
                                                 *   instructions to the immediately preceding function. */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // FIXME[Robb Matzke 2023-03-18]: is the no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 61 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_id() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_id(rose_addr_t const&);
    /** @} */
#line 65 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& get_reason() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_reason(unsigned const&);
    /** @} */
#line 71 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    // statementList and successors should have been pointers to nodes that contain the list rather than being the lists
    // themselves because ROSETTA doesn't allow traversals on multiple list data members--we can traverse either one list or
    // the other, but not both.  It's too late to change how this part of the AST is structured because so much user code
    // already depends on it, therefore we can only traverse statementList and not successors. [Robb Matzke 2016-02-25]
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmStatementPtrList const& get_statementList() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmStatementPtrList& get_statementList();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_statementList(SgAsmStatementPtrList const&);
    /** @} */
#line 82 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    // statementList and successors should have been pointers to nodes that contain the list rather than being the lists
    // themselves because ROSETTA doesn't allow traversals on multiple list data members--we can traverse either one list or
    // the other, but not both.  It's too late to change how this part of the AST is structured because so much user code
    // already depends on it, therefore we can only traverse statementList and not successors. [Robb Matzke 2016-02-25]
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 88 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmIntegerValuePtrList const& get_successors() const;
#line 481 "src/Rosebud/RosettaGenerator.C"
    SgAsmIntegerValuePtrList& get_successors();
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_successors(SgAsmIntegerValuePtrList const&);
    /** @} */
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 96 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_successors_complete() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_successors_complete(bool const&);
    /** @} */
#line 105 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 107 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmBlock* const& get_immediate_dominator() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_immediate_dominator(SgAsmBlock* const&);
    /** @} */
#line 115 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 117 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    size_t const& get_cached_vertex() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_cached_vertex(size_t const&);
    /** @} */
#line 124 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
 // see BinaryAnalysis::ControlFlow
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 126 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    double const& get_code_likelihood() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_code_likelihood(double const&);
    /** @} */
#line 131 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 133 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int64_t const& get_stackDeltaOut() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stackDeltaOut(int64_t const&);
    /** @} */
#line 140 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBlock.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Add the specified statement to the end of the statement list.
     *
     *  This is is usually used to add the next instruction to the end of a basic block. */
    void append_statement(SgAsmStatement*);

    /** Erase the specified statement.
     *
     *  If the specified statement exists in the "statementList" property then it is erased but not deleted. */
    void remove_statement(SgAsmStatement*);

    // FIXME[Robb P Matzke 2017-02-13]: wrong name -- erases only statements, not all children
    /** Removes all statements from the block.
     *
     *  This makes the block empty, and not having a unique starting virtual address. It does not erase all children, just
     *  the statement children.  None of the statements that are erased are deleted. */
    void remove_children();

    /** Fall-through virtual address.
     *
     *  A block's fall-through address is the virtual address that follows the last byte of the block's last instruction.
     *  The block must have instructions (e.g., it cannot be a strict data block). */
    rose_addr_t get_fallthrough_va();

    /** Returns the function that owns this block.
     *
     *  This is just a convenience wrapper around @ref SageInterface::getEnclosingNode. */
    SgAsmFunction *get_enclosing_function() const;

    /** Determins if a block contains instructions.
     *
     *  Returns true if the block has instructions, false otherwise. We look only at the immediate descendants of this
     *  block.  See also, @ref SageInterface::querySubTree in order to get the list of all instructions or to consider all
     *  descendants. */
    bool has_instructions() const;

    /** Determine if a block contains instructions.
     *
     *  Returns true if the block has instructions, false otherwise. We look only at the immediate descendants of this
     *  block.  See also, @ref SageInterface::querySubTree in order to get the list of all instructions or to consider all
     *  descendants. */
    bool is_basic_block() const { return has_instructions(); }

    /** Returns true if basic block appears to be a function call.
     *
     *  If the target address is known and is a single value then it is stored in the @p target_va argument, otherwise we
     *  store the maximum 64-bit address.  If the return address for the function call is known then it is stored in the @p
     *  return_va argument, otherwise @p return_va will contain the maximum 64-bit address. The return address is usually
     *  the fall-through address of the basic block.
     *
     * Note: Use this function in preference to SgAsmInstruction::isFunctionCallSlow() because the latter is intended to be
     * used by the Partitioner before an AST is created and might not be as accurate. */
    bool is_function_call(rose_addr_t &target_va/*out*/, rose_addr_t &return_va/*out*/);

    /** Multi-line string describing the letters used for basic block reasons.
     *
     *  The letters are returned by the padding version of @ref reason_str and appear in unparser output. */
    static std::string reason_key(const std::string &prefix="");

    /** Returns reason string for this block.
     *
     *  The reason string is a very short string describing the reason that the block was created. */
    std::string reason_str(bool pad) const;

    /** Converts a reason bit vector to a human-friendly string.
     *
     *  The second argument is the bit vector of @ref SgAsmBlock::Reason bits.  Some of the positions in the padded return
     *  value are used for more than one bit.  For instance, the first character can be "L" for leftovers, "N" for padding,
     *  "E" for entry point, or "-" for none of the above. */
    static std::string reason_str(bool pad, unsigned reason);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBlock();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBlock();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmBlock(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBlock_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinarySubtract           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinarySubtract);
IS_SERIALIZABLE(AsmBinarySubtract);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinarySubtract.h"
/** Expression that subtracts the second operand from the first. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinarySubtract.h"
class SgAsmBinarySubtract: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinarySubtract);
#if defined(SgAsmBinarySubtract_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinarySubtract();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinarySubtract();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinarySubtract(SgAsmExpression* const& lhs,
                        SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinarySubtract_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryRor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryRor);
IS_SERIALIZABLE(AsmBinaryRor);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryRor.h"
/** Expression that performs a right rotate. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryRor.h"
class SgAsmBinaryRor: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryRor);
#if defined(SgAsmBinaryRor_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryRor();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryRor();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryRor(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryRor_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryPreupdate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryPreupdate);
IS_SERIALIZABLE(AsmBinaryPreupdate);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryPreupdate.h"
/** Expression that represents an update to a storage location.
 *
 *  The left-hand-side must be a register or memory location, and the right-hand-side is an expression that will be
 *  computed and stored at that location. Pre-updates happen before an instruction is evaluated. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryPreupdate.h"
class SgAsmBinaryPreupdate: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryPreupdate);
#if defined(SgAsmBinaryPreupdate_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryPreupdate();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryPreupdate();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryPreupdate(SgAsmExpression* const& lhs,
                         SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryPreupdate_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryPostupdate           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryPostupdate);
IS_SERIALIZABLE(AsmBinaryPostupdate);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryPostupdate.h"
/** Expression that represents an update to a storage location.
 *
 *  The left-hand-side must be a register or memory location, and the right-hand-side is an expression that will be
 *  computed and stored at that location. Post-updates happen after an instruction is evaluated. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryPostupdate.h"
class SgAsmBinaryPostupdate: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryPostupdate);
#if defined(SgAsmBinaryPostupdate_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryPostupdate();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryPostupdate();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryPostupdate(SgAsmExpression* const& lhs,
                          SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryPostupdate_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMultiply           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryMultiply);
IS_SERIALIZABLE(AsmBinaryMultiply);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMultiply.h"
/** Expression that multiplies two operands. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMultiply.h"
class SgAsmBinaryMultiply: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryMultiply);
#if defined(SgAsmBinaryMultiply_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryMultiply();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryMultiply();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryMultiply(SgAsmExpression* const& lhs,
                        SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMultiply_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMsl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryMsl);
IS_SERIALIZABLE(AsmBinaryMsl);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMsl.h"
/** Expression that performs a logical left shift operation filling low-order bits with one.
 *
 *  This is identical to the Lsl operation except instead of low-order bits being cleared they are set. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMsl.h"
class SgAsmBinaryMsl: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryMsl);
#if defined(SgAsmBinaryMsl_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryMsl();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryMsl();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryMsl(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMsl_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryMod           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryMod);
IS_SERIALIZABLE(AsmBinaryMod);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMod.h"
/** Expression that returns the remainder when dividing the first operand by the second. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryMod.h"
class SgAsmBinaryMod: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryMod);
#if defined(SgAsmBinaryMod_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryMod();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryMod();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryMod(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryMod_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryLsr           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryLsr);
IS_SERIALIZABLE(AsmBinaryLsr);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryLsr.h"
/** Expression that performs a logical, sign-bit non-preserving right shift. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryLsr.h"
class SgAsmBinaryLsr: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryLsr);
#if defined(SgAsmBinaryLsr_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryLsr();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryLsr();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryLsr(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryLsr_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryLsl           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryLsl);
IS_SERIALIZABLE(AsmBinaryLsl);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryLsl.h"
/** Expression that performs a logical left shift operation. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryLsl.h"
class SgAsmBinaryLsl: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryLsl);
#if defined(SgAsmBinaryLsl_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryLsl();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryLsl();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryLsl(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryLsl_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryDivide           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryDivide);
IS_SERIALIZABLE(AsmBinaryDivide);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryDivide.h"
/** Expression that divides the first operand by the second. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryDivide.h"
class SgAsmBinaryDivide: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryDivide);
#if defined(SgAsmBinaryDivide_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryDivide();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryDivide();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryDivide(SgAsmExpression* const& lhs,
                      SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryDivide_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryConcat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryConcat);
IS_SERIALIZABLE(AsmBinaryConcat);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryConcat.h"
/** Expression that concatenates two values to form a wider value. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryConcat.h"
class SgAsmBinaryConcat: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryConcat);
#if defined(SgAsmBinaryConcat_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryConcat();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryConcat();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryConcat(SgAsmExpression* const& lhs,
                      SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryConcat_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryAsr           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryAsr);
IS_SERIALIZABLE(AsmBinaryAsr);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryAsr.h"
/** Expression that performs an arithmetic, sign-bit preserving right shift. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryAsr.h"
class SgAsmBinaryAsr: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryAsr);
#if defined(SgAsmBinaryAsr_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryAsr();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryAsr();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryAsr(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryAsr_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryAdd           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBinaryAdd);
IS_SERIALIZABLE(AsmBinaryAdd);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryAdd.h"
/** Expression that adds two operands. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryAdd.h"
class SgAsmBinaryAdd: public SgAsmBinaryExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryAdd);
#if defined(SgAsmBinaryAdd_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmBinaryExpression);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryAdd();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryAdd();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryAdd(SgAsmExpression* const& lhs,
                   SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryAdd_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBinaryExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmBinaryExpression = nonTerminalConstructor(
    "AsmBinaryExpression",
    *this,
    "AsmBinaryExpression",
    "AsmBinaryExpressionTag",
    SubclassListBuilder()
        | AsmBinaryAdd
        | AsmBinaryAsr
        | AsmBinaryConcat
        | AsmBinaryDivide
        | AsmBinaryLsl
        | AsmBinaryLsr
        | AsmBinaryMod
        | AsmBinaryMsl
        | AsmBinaryMultiply
        | AsmBinaryPostupdate
        | AsmBinaryPreupdate
        | AsmBinaryRor
        | AsmBinarySubtract
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmBinaryExpression.associatedGrammar != nullptr);
AsmBinaryExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmBinaryExpression.isBoostSerializable(true);
AsmBinaryExpression.setAutomaticGenerationOfConstructor(false);
AsmBinaryExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
/** Base class for binary expressions. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
class SgAsmBinaryExpression: public SgAsmExpression {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
    AsmBinaryExpression.setDataPrototype(
        "SgAsmExpression*", "lhs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
    AsmBinaryExpression.setDataPrototype(
        "SgAsmExpression*", "rhs", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBinaryExpression);
#if defined(SgAsmBinaryExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_lhs);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_rhs);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_lhs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_lhs(SgAsmExpression* const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExpression* const& get_rhs() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_rhs(SgAsmExpression* const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBinaryExpression.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBinaryExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBinaryExpression();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmBinaryExpression(SgAsmExpression* const& lhs,
                          SgAsmExpression* const& rhs);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBinaryExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmBasicString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmBasicString);
IS_SERIALIZABLE(AsmBasicString);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"
/** String associated with a binary file.
 *
 *  Basic strings need not be stored in the binary specimen; they can be generated on the fly by the parser. See also, @ref
 *  SgAsmStoredString, which is present in the binary specimen. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"
class SgAsmBasicString: public SgAsmGenericString {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"
    AsmBasicString.setDataPrototype(
        "std::string", "string", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmBasicString);
#if defined(SgAsmBasicString_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmGenericString);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"
        s & BOOST_SERIALIZATION_NVP(p_string);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmBasicString.h"
    virtual std::string get_string(bool escape=false) const override;
    virtual void set_string(const std::string&) override;
    virtual void set_string(rose_addr_t) override;

public:
    /** Constructor that gives a value to the object.
     *
     * @{ */
    explicit SgAsmBasicString(const std::string&);
    explicit SgAsmBasicString(const char*);
    /** @} */

    // Overrides documented in base class
    virtual void dump(FILE*, const char *prefix, ssize_t idx) const override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmBasicString();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmBasicString();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmBasicString_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmGenericString           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmGenericString = nonTerminalConstructor(
    "AsmGenericString",
    *this,
    "AsmGenericString",
    "AsmGenericStringTag",
    SubclassListBuilder()
        | AsmBasicString
        | AsmStoredString
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmGenericString.associatedGrammar != nullptr);
AsmGenericString.setCppCondition("!defined(DOCUMENTATION)");
AsmGenericString.isBoostSerializable(true);
AsmGenericString.setAutomaticGenerationOfConstructor(false);
AsmGenericString.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericString.h"
/** Base class for strings related to binary specimens. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericString.h"
class SgAsmGenericString: public SgAsmExecutableFileFormat {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmGenericString);
#if defined(SgAsmGenericString_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExecutableFileFormat);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmGenericString.h"
public:
    /** Constant for addresses of unallocated strings. */
    static const rose_addr_t unallocated;

    /** Property: String value.
     *
     *  When retrieving the string, if @p escape is true then escape special charactes like the would be in C source code.
     *
     *  The base class implementation cannot be called and exists only due to ROSETTA limitations, otherwise we would have
     *  made them pure virtual.
     *
     * @{ */
    virtual std::string get_string(bool escape=false) const;
    virtual void set_string(const std::string &s);
    virtual void set_string(rose_addr_t);
    /** @} */

    virtual rose_addr_t get_offset() const {return unallocated;}

    virtual void dump(FILE*, const char *prefix, ssize_t idx) const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmGenericString();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmGenericString();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmGenericString_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExecutableFileFormat           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmExecutableFileFormat = nonTerminalConstructor(
    "AsmExecutableFileFormat",
    *this,
    "AsmExecutableFileFormat",
    "AsmExecutableFileFormatTag",
    SubclassListBuilder()
        | AsmCoffSymbolList
        | AsmDwarfInformation
        | AsmElfDynamicEntry
        | AsmElfDynamicEntryList
        | AsmElfEHFrameEntryCI
        | AsmElfEHFrameEntryCIList
        | AsmElfEHFrameEntryFD
        | AsmElfEHFrameEntryFDList
        | AsmElfNoteEntry
        | AsmElfNoteEntryList
        | AsmElfRelocEntry
        | AsmElfRelocEntryList
        | AsmElfSectionTableEntry
        | AsmElfSegmentTableEntry
        | AsmElfSegmentTableEntryList
        | AsmElfSymbolList
        | AsmElfSymverDefinedAux
        | AsmElfSymverDefinedAuxList
        | AsmElfSymverDefinedEntry
        | AsmElfSymverDefinedEntryList
        | AsmElfSymverEntry
        | AsmElfSymverEntryList
        | AsmElfSymverNeededAux
        | AsmElfSymverNeededAuxList
        | AsmElfSymverNeededEntry
        | AsmElfSymverNeededEntryList
        | AsmGenericDLL
        | AsmGenericDLLList
        | AsmGenericFile
        | AsmGenericFormat
        | AsmGenericHeaderList
        | AsmGenericSection
        | AsmGenericSectionList
        | AsmGenericString
        | AsmGenericStrtab
        | AsmGenericSymbol
        | AsmGenericSymbolList
        | AsmLEEntryPoint
        | AsmLEPageTableEntry
        | AsmLESectionTableEntry
        | AsmNEEntryPoint
        | AsmNERelocEntry
        | AsmNESectionTableEntry
        | AsmPEExportDirectory
        | AsmPEExportEntry
        | AsmPEExportEntryList
        | AsmPEImportDirectory
        | AsmPEImportDirectoryList
        | AsmPEImportItem
        | AsmPEImportItemList
        | AsmPERVASizePair
        | AsmPERVASizePairList
        | AsmPESectionTableEntry
        | AsmStringStorage
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmExecutableFileFormat.associatedGrammar != nullptr);
AsmExecutableFileFormat.setCppCondition("!defined(DOCUMENTATION)");
AsmExecutableFileFormat.isBoostSerializable(true);
AsmExecutableFileFormat.setAutomaticGenerationOfConstructor(false);
AsmExecutableFileFormat.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h"
/** Base class for many binary analysis nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h"
class SgAsmExecutableFileFormat: public SgAsmNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmExecutableFileFormat);
#if defined(SgAsmExecutableFileFormat_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExecutableFileFormat.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Exception for reading past the end of something.
     *
     *  This object is thrown when an attempt is made to read past the end of a file, section, header, segment, etc. */
    class ShortRead: public Rose::Exception {
    public:
        const SgAsmGenericSection *section;         /**< Section from which read occurred; null implies file-level write. */
        rose_addr_t offset;                         /**< Byte offset into section (or file). */
        rose_addr_t size;                           /**< Number of bytes of attempted read. */

        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size)
            : Rose::Exception("short read"), section(section), offset(offset), size(size) {}
        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ShortRead(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ~ShortRead() throw () {}
    };

    /** Exception for writing past the end of something.
     *
     *  This object is thrown when an attempt is made to write past the end of a file, section, header, segment, etc. */
    class ShortWrite: public Rose::Exception {
    public:
        const SgAsmGenericSection *section;         /**< Section to which write occurred; null implies file-level write. */
        rose_addr_t          offset;                /**< Byte offset into section (or file). */
        rose_addr_t          size;                  /**< Number of bytes of attempted write. */

        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size)
            : Rose::Exception(""), section(section), offset(offset), size(size) {}
        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const std::string &mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
        ShortWrite(const class SgAsmGenericSection *section, size_t offset, size_t size, const char *mesg)
            : Rose::Exception(mesg), section(section), offset(offset), size(size) {}
    };

    /** Exception for container syntax errors.
     *
     *  This object is thrown when the file contains an error that prevents ROSE from parsing it. */
    class FormatError: public Rose::Exception {
    public:
        FormatError(const std::string &mesg)
            : Rose::Exception(mesg) {}
        FormatError(const char *mesg)
            : Rose::Exception(mesg) {}
        ~FormatError() throw () {}
    };

    /** Information about the file in the filesystem. */
    typedef struct stat fileDetails;

    /** Architecture family. */
    enum ExecFamily {
        FAMILY_UNSPECIFIED,                         /**< Unspecified family. */
        FAMILY_DOS,                                 /**< Microsoft DOS format. */
        FAMILY_ELF,                                 /**< Unix Executable and Linking Format. */
        FAMILY_JVM,                                 /**< Java Virtual Machine (JVM) format. */
        FAMILY_LE,                                  /**< Microsft Linear Executable format. */
        FAMILY_LX,                                  /**< OS/2 LX (Windows 9x VxD device drivers, extension of LE). */
        FAMILY_NE,                                  /**< Microsoft New Executable Format. */
        FAMILY_PE                                   /**< Microsoft Portable Executable Format. */
    };

    /** Application binary interface. */
    enum ExecABI {
        ABI_UNSPECIFIED,                            /**< Not specified in file and could not be inferred */
        ABI_OTHER,                                  /**< Anything other than values below */
        ABI_86OPEN,                                 /**< 86Open Common IA32 */
        ABI_AIX,                                    /**< AIX */
        ABI_ARM,                                    /**< ARM architecture */
        ABI_FREEBSD,                                /**< FreeBSD */
        ABI_HPUX,                                   /**< HP/UX */
        ABI_IRIX,                                   /**< IRIX */
        ABI_HURD,                                   /**< GNU/Hurd */
        ABI_JVM,                                    /**< Java Virtual Machine (JVM). */
        ABI_LINUX,                                  /**< GNU/Linux */
        ABI_MODESTO,                                /**< Novell Modesto */
        ABI_MONTEREY,                               /**< Monterey project */
        ABI_MSDOS,                                  /**< Microsoft DOS */
        ABI_NT,                                     /**< Windows NT */
        ABI_NETBSD,                                 /**< NetBSD */
        ABI_OS2,                                    /**< OS/2 */
        ABI_SOLARIS,                                /**< Sun Solaris */
        ABI_SYSV,                                   /**< SysV R4 */
        ABI_TRU64,                                  /**< Compaq TRU64 UNIX */
        ABI_WIN386                                  /**< Microsoft Windows */
    };

    /** Instruction sets organized by families */
    enum InsSetArchitecture {
        ISA_UNSPECIFIED             = 0x0000,       /**< File does not specify an architecture */
        ISA_OTHER                   = 0xffff,       /**< Architecture is something other than below */
        ISA_FAMILY_MASK             = 0xff00,       /**< Mask to get family part of ISA */

        ISA_IA32_Family             = 0x0100,       /**< x86 IA-32 family of architectures; Intel, AMD, VIA, ... */
        ISA_IA32_286                = 0x0101,       /**< 80286 */
        ISA_IA32_386                = 0x0102,       /**< MMU with paging */
        ISA_IA32_486                = 0x0103,       /**< risc-like pipelining, integrated FPU, on-chip cache */
        ISA_IA32_Pentium            = 0x0104,       /**< superscalar, 64-bit databus, MMX */
        ISA_IA32_Cyrix6x86          = 0x0105,       /**< register renaming, speculative execution */
        ISA_IA32_AMDK5              = 0x0106,       /**< micro-op translation */
        ISA_IA32_PentiumPro         = 0x0107,       /**< PAE, integrated L2 cache */
        ISA_IA32_PentiumII          = 0x0108,       /**< L3-cache, 3D Now, SSE */
        ISA_IA32_Athlon             = 0x0109,       /**< superscalar FPU, wide design */
        ISA_IA32_Pentium4           = 0x010a,       /**< deeply pipelined, high frequency, SSE2, hyper-threading */
        ISA_IA32_PentiumM           = 0x010b,       /**< low power */

        ISA_X8664_Family            = 0x0200,       /**< x86-64 family of architectures: Intel, AMD, VIA, ... */
        ISA_X8664_Athlon64          = 0x0201,       /**< on-die memory controller, 40-bit phys address space */
        ISA_X8664_Prescott          = 0x0202,       /**< deeply pipelined, high frequency, SSE3 */
        ISA_X8664_IntelCore         = 0x0203,       /**< low power, multi-core, lower clock frequency */
        ISA_X8664_AMDPhenom         = 0x0204,       /**< quad core, 128-bit FPUs, SSE4a, native mem ctrl, on-die L3 cache */

        ISA_SPARC_Family            = 0x0300,       /**< SPARC family of architectures; Sun Microsystems */
        ISA_SPARC_V7                = 0x0301,
        ISA_SPARC_V8                = 0x0302,
        ISA_SPARC_V8E               = 0x0303,
        ISA_SPARC_V9                = 0x0304,
        ISA_SPARC_V9JPS1            = 0x0305,
        ISA_SPARC_V9UA              = 0x0306,
        ISA_SPARC_V9JPS2            = 0x0307,

        ISA_M68K_Family             = 0x0400,       /**< Motorala m68k family */
        ISA_M68K_68000              = 0x0401,       /**< generation one: 16/32 internal; 8-, 16-, 32-bit interface */
        ISA_M68K_68EC000            = 0x0402,
        ISA_M68K_68HC000            = 0x0403,
        ISA_M68K_68008              = 0x0404,
        ISA_M68K_68010              = 0x0405,
        ISA_M68K_68012              = 0x0406,
        ISA_M68K_68020              = 0x0407,       /**< generation two: fully 32-bit */
        ISA_M68K_68EC020            = 0x0408,
        ISA_M68K_68030              = 0x0409,
        ISA_M68K_68EC030            = 0x040a,
        ISA_M68K_68040              = 0x040b,       /**< generation three: pipelined */
        ISA_M68K_68EC040            = 0x040c,
        ISA_M68K_68LC040            = 0x040d,
        ISA_M68K_68060              = 0x040e,       /**< generation four: superscalar */
        ISA_M68K_ColdFire           = 0x040f,       /**< other */
        ISA_M68K_DragonBall         = 0x0410,       /**< other */

        ISA_M88K_Family             = 0x0500,       /**< Motorola m88k family (not very popular) */
        ISA_M88K_88100              = 0x0501,       /**< 32-bit, integrated FPU mated with 88200 MMU and cache controller */
        ISA_M88K_88110              = 0x0502,       /**< single package of 88100+88200 */
        ISA_M88K_88110MP            = 0x0503,       /**< on-chip comm for use in multi-processor systems */
        ISA_M88K_88120              = 0x0504,       /**< superscalar (never actually released) */

        ISA_MIPS_Family             = 0x0600,       /**< 32/64-bit RISC; MIPS Technologies, Inc. */
        ISA_MIPS_MarkI              = 0x0601,       /**< R2000, R3000 */
        ISA_MIPS_MarkII             = 0x0602,       /**< R6000 */
        ISA_MIPS_MarkIII            = 0x0603,       /**< R4000 */
        ISA_MIPS_R2000              = 0x0604,       /**< 32-bit, Big or little endian */
        ISA_MIPS_R3000              = 0x0605,       /**< virtual identical: Pacempi's R3400, IDT's R3500, Toshiba R3900 */
        ISA_MIPS_R4000              = 0x0606,       /**< 64-bit; others in the series had larger caches and bug fixes */
        ISA_MIPS_R4200              = 0x0607,       /**< low-cost version of R4000 */
        ISA_MIPS_R4300              = 0x0608,       /**< low-cost version of R4000 with 32-bit external bus */
        ISA_MIPS_R4600              = 0x0609,       /**< "Orion" by Qauntum Effect Devices (QED); larger caches */
        ISA_MIPS_R4650              = 0x060a,       /**< by QED */
        ISA_MIPS_R4700              = 0x060b,       /**< "Orion" by QED */
        ISA_MIPS_R5000              = 0x060c,       /**< by QED */
        ISA_MIPS_RM7000             = 0x060d,       /**< by PMC-Sierra; 256kB L2 and optional L3 */
        ISA_MIPS_R8000              = 0x060e,       /**< superscalar, fairly rare */
        ISA_MIPS_R10000             = 0x060f,       /**< R8000 on a single chip; 32kB caches; out-of-order */
        ISA_MIPS_R12000             = 0x0610,       /**< R10000 + higher clock rates */
        ISA_MIPS_R14000             = 0x0611,       /**< R12000 + support for DDR SRAM; 200MHz front side bus */
        ISA_MIPS_R16000             = 0x0612,       /**< R14000 + increased freq, more L1, smaller die */
        ISA_MIPS_R16000A            = 0x0613,
        ISA_MIPS_16                 = 0x0614,       /**< Unknown. Windows PE architecture 0x266 "MIPS16" */
        ISA_MIPS_FPU                = 0x0615,       /**< Unknown. Windows PE architecture 0x366 "MIPS with FPU" */
        ISA_MIPS_16FPU              = 0x0616,       /**< Unknown. Windows PE architecture 0x466 "MIPS16 with FPU" */

        ISA_I860_Family             = 0x0700,       /**< Intel i860 family; 1989-mid 90's; RISC VLIW */
        ISA_I860_860XR              = 0x0701,       /**< (code named N10) 25-40MHz */
        ISA_I860_860XP              = 0x0702,       /**< (code named N11) larger caches; 40-50MHz; same IS as XR */

        ISA_IA64_Family             = 0x0800,       /**< Intel 64-bit architecture */
        ISA_IA64_Itanium            = 0x0801,       /**< First generation */
        ISA_IA64_Itanium2           = 0x0802,       /**< Second generation starting Nov 2007 */

        // See http://en.wikipedia.org/wiki/ARM_architecture
        ISA_ARM_Family              = 0x0900,       /**< Acorn RISC Machine, Advanced RISC Machines, ARM Limited */
        ISA_ARM_ARM1                = 0x0901,       /**< ARM evaluation system */
        ISA_ARM_ARM2                = 0x0902,       /**< ARM2, ARM250 cores */
        ISA_ARM_ARM3                = 0x0903,       /**< ARM2a core */
        ISA_ARM_ARM6                = 0x0904,       /**< ARM60, ARM600, ARM610 cores */
        ISA_ARM_ARM7                = 0x0905,       /**< ARM{700,710,710a,7100,7500,7500FE} cores */
        ISA_ARM_ARM7TDMI            = 0x0906,       /**< ARM{7TDMI,7TDMI-S,710T,720T,740T,7EJ-S} cores */
        ISA_ARM_StrongARM           = 0x0907,       /**< SA-110, SA-1110 cores */
        ISA_ARM_ARM8                = 0x0908,       /**< ARM810 core */
        ISA_ARM_ARM9TDMI            = 0x0909,       /**< ARM{9TDMI,920T,922T,940T} cores */
        ISA_ARM_ARM9E               = 0x090a,       /**< ARM{946E-S,966E-S,968E-S,926EJ-S,966HS} cores */
        ISA_ARM_ARM10E              = 0x090b,       /**< ARM{1020E,1022E,1026EJ-S} cores */
        ISA_ARM_XScale              = 0x090c,       /**< 80200, IOP310, IOP315, 80219, IOP321, IOP33x, IOP34x, PXA210,
                                                     *   PXA250, PXA255, PXA26x, PXA27x, PXA800(E)F, Monahans, PXA900,
                                                     *   IXC1100, IXP2400, IXP2800, IXP2850, IXP2325, IXP2350, IXP42x,
                                                     *   IXP460, IXP465 cores */
        ISA_ARM_ARM11               = 0x090d,       /**< ARMv{6,6T2,6KZ,6K} cores */
        ISA_ARM_Cortex              = 0x090e,       /**< Cortex-{A8,A9,A9 MPCore,R4(F),M3,M1} cores */
        ISA_ARM_A64                 = 0x090f,       /**< ARM AArch64 A64 instruction set. */

        ISA_JVM                     = 0x0a00,       /**< Java Virtual Machine (JVM) instruction set. */

        // Others, not yet incorporated into this enum
        ISA_OTHER_Family            = 0xf000,

        ISA_ATT_WE_32100            = 0xf001,       /**< Sometimes simply "M32" */
        ISA_IBM_System_370          = 0xf002,
        ISA_HPPA                    = 0xf003,
        ISA_Fujitsu_VPP500          = 0xf004,
        ISA_Sun_v8plus              = 0xf005,
        ISA_PowerPC                 = 0xf006,
        ISA_PowerPC_64bit           = 0xf007,
        ISA_IBM_S390                = 0xf008,
        ISA_NEC_V800_series         = 0xf009,
        ISA_Fujitsu_FR20            = 0xf00a,
        ISA_TRW_RH_32               = 0xf00b,
        ISA_Motorola_RCE            = 0xf00c,
        ISA_Digital_Alpha_fake      = 0xf00e,
        ISA_Hitachi_SH              = 0xf00f,
        ISA_Siemens_Tricore         = 0xf010,
        ISA_Argonaut_RISC_Core      = 0xf011,
        ISA_Hitachi_H8_300          = 0xf012,
        ISA_Hitachi_H8_300H         = 0xf013,
        ISA_Hitachi_H8S             = 0xf014,
        ISA_Hitachi_H8_500          = 0xf015,
        ISA_Stanford_MIPS_X         = 0xf016,
        ISA_Motorola_M68HC12        = 0xf017,
        ISA_Fujitsu_MMA_Multimedia_Accelerator=0xf018,
        ISA_Siemens_PCP             = 0xf019,
        ISA_Sony_nCPU_embeeded_RISC = 0xf01a,
        ISA_Denso_NDR1_microprocessor=0xf01b,
        ISA_Motorola_Start_Core_processor=0xf01c,
        ISA_Toyota_ME16_processor   = 0xf01d,
        ISA_STMicroelectronic_ST100_processor=0xf01e,
        ISA_Advanced_Logic_Corp_Tinyj_emb_family=0xf01f,
        ISA_AMD_x86_64_architecture = 0xf020,
        ISA_Sony_DSP_Processor      = 0xf021,
        ISA_Siemens_FX66_microcontroller=0xf022,
        ISA_STMicroelectronics_ST9_plus_8_16_microcontroller=0xf023,
        ISA_STMicroelectronics_ST7_8bit_microcontroller=0xf024,
        ISA_Motorola_MC68HC16_microcontroller=0xf025,
        ISA_Motorola_MC68HC11_microcontroller=0xf026,
        ISA_Motorola_MC68HC08_microcontroller=0xf027,
        ISA_Motorola_MC68HC05_microcontroller=0xf028,
        ISA_Silicon_Graphics_SVx    = 0xf029,
        ISA_STMicroelectronics_ST19_8bit_microcontroller=0xf02a,
        ISA_Digital_VAX             = 0xf02b,
        ISA_Axis_Communications_32bit_embedded_processor=0xf02c,
        ISA_Infineon_Technologies_32bit_embedded_processor=0xf02d,
        ISA_Element_14_64bit_DSP_Processor=0xf02e,
        ISA_LSI_Logic_16bit_DSP_Processor=0xf02f,
        ISA_Donald_Knuths_educational_64bit_processor=0xf030,
        ISA_Harvard_University_machine_independent_object_files=0xf031,
        ISA_SiTera_Prism            = 0xf032,
        ISA_Atmel_AVR_8bit_microcontroller=0xf033,
        ISA_Fujitsu_FR30            = 0xf034,
        ISA_Mitsubishi_D10V         = 0xf035,
        ISA_Mitsubishi_D30V         = 0xf036,
        ISA_NEC_v850                = 0xf037,
        ISA_Mitsubishi_M32R         = 0xf038,
        ISA_Matsushita_MN10300      = 0xf039,
        ISA_Matsushita_MN10200      = 0xf03a,
        ISA_picoJava                = 0xf03b,
        ISA_OpenRISC_32bit_embedded_processor=0xf03c,
        ISA_ARC_Cores_Tangent_A5    = 0xf03d,
        ISA_Tensilica_Xtensa_Architecture=0xf03e,
        ISA_Digital_Alpha         = 0xf03f,
        ISA_Matsushita_AM33         = 0xf040,
        ISA_EFI_ByteCode            = 0xf041
    };

    /** General purpose of a binary executable file. */
    enum ExecPurpose {
        PURPOSE_UNSPECIFIED,                        /**< Purpose is not specified and could not be inferred */
        PURPOSE_OTHER,                              /**< A purpose other than any defined below */
        PURPOSE_EXECUTABLE,                         /**< Executable program */
        PURPOSE_LIBRARY,                            /**< Library (shared or relocatable) */
        PURPOSE_CORE_DUMP,                          /**< Post mortem image */
        PURPOSE_OS_SPECIFIC,                        /**< Some operating system specific purpose */
        PURPOSE_PROC_SPECIFIC                       /**< Some processor specific purpose */
    };

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Factory method that parses a binary file. */
    static SgAsmGenericFile *parseBinaryFormat(const char *name);

    /** Dump debugging information into a named text file.
     *
     *  Writes a new file from the IR node for a parsed executable file. Warning: This function might modify the AST by
     *  calling @ref reallocate, which makes sure all parts of the AST are consistent with respect to each other. */
    static void unparseBinaryFormat(const std::string &name, SgAsmGenericFile*);

    /** Dump debugging information to specified stream.
     *
     *  Unparses an executable file into the supplied output stream. Warning: This function might modify the AST by calling
     *  reallocate(), which makes sure all parts of the AST are consistent with respect to each other. */
    static void unparseBinaryFormat(std::ostream&, SgAsmGenericFile*);

    /** Diagnostic stream. */
    static Sawyer::Message::Facility mlog;

    /** Initialize diagnostic streams.
     *
     *  This is called automatically by @ref Rose::initializeLibrary. */
    static void initDiagnostics();

    /** Display binary data.
     *
     *  This function displays binary data in a fashion similar to the "hexdump -C" command in Unix: an address, numeric
     *  byte values, character byte values.  The format of the output is configurable through the HexdumpFormat
     *  argument. There are other versions that output containers of data.  The hexdump comes in three flavors: output to a
     *  C++ stream, output to a C FILE, and output to an std::string.  The FILE and string versions are implemented in
     *  terms of the stream version.
     *
     * @{ */
    static void hexdump(std::ostream&, rose_addr_t base_addr, const unsigned char *data, size_t data_sz,
                        const HexdumpFormat&);
    static void hexdump(std::ostream&, rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
                        bool multiline=true);
    static void hexdump(std::ostream&, rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
                        bool multiline=true);

    // Same, but returning a string instead.
    static std::string hexdump(rose_addr_t base_addr, const unsigned char *data, size_t data_sz, const HexdumpFormat&);
    static std::string hexdump(rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
                               bool multiline=true);
    static std::string hexdump(rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
                               bool multiline=true);

    // Same, but output to a FILE* instead.
    static void hexdump(FILE*, rose_addr_t base_addr, const unsigned char *data, size_t data_sz, const HexdumpFormat&);
    static void hexdump(FILE*, rose_addr_t base_addr, const std::string &prefix, const SgUnsignedCharList& data,
                        bool multiline=true);
    static void hexdump(FILE*, rose_addr_t base_addr, const std::string &prefix, const SgFileContentList& data,
                        bool multiline=true);
    /** @} */

    // These convert enums to strings. It is better to use the automatic enum stringification instead. They have names like
    // Rose::stringifySgAsmExecutableFileFormatInsnSetArchitecture, etc. */
    static std::string isa_family_to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string isa_to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string to_string(SgAsmExecutableFileFormat::InsSetArchitecture);
    static std::string to_string(SgAsmExecutableFileFormat::ExecFamily);
    static std::string to_string(SgAsmExecutableFileFormat::ExecABI);
    static std::string to_string(SgAsmExecutableFileFormat::ExecPurpose);
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmExecutableFileFormat();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmExecutableFileFormat();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExecutableFileFormat_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64SysMoveOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64SysMoveOperand);
IS_SERIALIZABLE(AsmAarch64SysMoveOperand);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64SysMoveOperand);
#if defined(SgAsmAarch64SysMoveOperand_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"
#ifdef ROSE_ENABLE_ASM_AARCH64
#endif
#endif // SgAsmAarch64SysMoveOperand_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"
/** Describes a system register for the ARM AArch64 A64 MRS and MSR instructions. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"
class SgAsmAarch64SysMoveOperand: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64SysMoveOperand);
#if defined(SgAsmAarch64SysMoveOperand_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"
        s & BOOST_SERIALIZATION_NVP(access_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    unsigned access_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& access() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void access(unsigned const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64SysMoveOperand.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64SysMoveOperand();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64SysMoveOperand();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch64SysMoveOperand(unsigned const& access);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64SysMoveOperand_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64PrefetchOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64PrefetchOperand);
IS_SERIALIZABLE(AsmAarch64PrefetchOperand);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64PrefetchOperand);
#if defined(SgAsmAarch64PrefetchOperand_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64PrefetchOperand_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"
/** Operand for an ARM AArch64 A64 prefetch instruction. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"
class SgAsmAarch64PrefetchOperand: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64PrefetchOperand);
#if defined(SgAsmAarch64PrefetchOperand_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"
        s & BOOST_SERIALIZATION_NVP(operation_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    Rose::BinaryAnalysis::Aarch64PrefetchOperation operation_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch64PrefetchOperation const& operation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void operation(Rose::BinaryAnalysis::Aarch64PrefetchOperation const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64PrefetchOperand.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64PrefetchOperand();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64PrefetchOperand();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch64PrefetchOperand(Rose::BinaryAnalysis::Aarch64PrefetchOperation const& operation);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64PrefetchOperand_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64Instruction);
IS_SERIALIZABLE(AsmAarch64Instruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64Instruction);
#if defined(SgAsmAarch64Instruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
#ifdef ROSE_ENABLE_ASM_AARCH64
#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64Instruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
/** Represents one ARM A64 machine instruction. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
class SgAsmAarch64Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    AsmAarch64Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch64InstructionKind", "kind", "= Rose::BinaryAnalysis::Aarch64InstructionKind::ARM64_INS_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    AsmAarch64Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch64InstructionCondition", "condition", "= Rose::BinaryAnalysis::Aarch64InstructionCondition::ARM64_CC_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 20 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    AsmAarch64Instruction.setDataPrototype(
        "bool", "updatesFlags", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64Instruction);
#if defined(SgAsmAarch64Instruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_condition);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch64InstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::Aarch64InstructionKind const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch64InstructionCondition const& get_condition() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_condition(Rose::BinaryAnalysis::Aarch64InstructionCondition const&);
    /** @} */
#line 16 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    // FIXME[Robb Matzke 2023-03-18]: is the no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_updatesFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_updatesFlags(bool const&);
    /** @} */
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64Instruction.h"
public:
    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&, rose_addr_t *target,
                                    rose_addr_t *return_va) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&, rose_addr_t *target,
                                    rose_addr_t *return_va) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64Instruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64Instruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmAarch64Instruction(rose_addr_t const& address,
                            std::string const& mnemonic,
                            Rose::BinaryAnalysis::Aarch64InstructionKind const& kind,
                            Rose::BinaryAnalysis::Aarch64InstructionCondition const& condition);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64Instruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64CImmediateOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64CImmediateOperand);
IS_SERIALIZABLE(AsmAarch64CImmediateOperand);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64CImmediateOperand);
#if defined(SgAsmAarch64CImmediateOperand_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"
#ifdef ROSE_ENABLE_ASM_AARCH64
#endif
#endif // SgAsmAarch64CImmediateOperand_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"
/** C-Immediate operand for SYS, AT, CFP, CPP, DC, DVP, IC, and TLBI instructions. */
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"
class SgAsmAarch64CImmediateOperand: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64CImmediateOperand);
#if defined(SgAsmAarch64CImmediateOperand_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"
        s & BOOST_SERIALIZATION_NVP(immediate_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    unsigned immediate_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    unsigned const& immediate() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void immediate(unsigned const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64ImmediateOperand.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64CImmediateOperand();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64CImmediateOperand();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch64CImmediateOperand(unsigned const& immediate);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64CImmediateOperand_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64BarrierOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64BarrierOperand);
IS_SERIALIZABLE(AsmAarch64BarrierOperand);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64BarrierOperand);
#if defined(SgAsmAarch64BarrierOperand_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64BarrierOperand_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"
/** Barriar operation operand for ISB, DMB, and DSB instructions. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"
class SgAsmAarch64BarrierOperand: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64BarrierOperand);
#if defined(SgAsmAarch64BarrierOperand_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 8 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"
        s & BOOST_SERIALIZATION_NVP(operation_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    Rose::BinaryAnalysis::Aarch64BarrierOperation operation_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch64BarrierOperation const& operation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void operation(Rose::BinaryAnalysis::Aarch64BarrierOperation const&);
    /** @} */
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64BarrierOperand.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64BarrierOperand();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64BarrierOperand();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch64BarrierOperand(Rose::BinaryAnalysis::Aarch64BarrierOperation const& operation);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64BarrierOperand_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch64AtOperand           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH64
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch64AtOperand);
IS_SERIALIZABLE(AsmAarch64AtOperand);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch64AtOperand);
#if defined(SgAsmAarch64AtOperand_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"
#ifdef ROSE_ENABLE_ASM_AARCH64

#include <Rose/BinaryAnalysis/InstructionEnumsAarch64.h>
#endif
#endif // SgAsmAarch64AtOperand_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"
/** Operand for an ARM AArch64 A64 AT instruction. */
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"
class SgAsmAarch64AtOperand: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch64AtOperand);
#if defined(SgAsmAarch64AtOperand_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"
        s & BOOST_SERIALIZATION_NVP(operation_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    Rose::BinaryAnalysis::Aarch64AtOperation operation_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch64AtOperation const& operation() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void operation(Rose::BinaryAnalysis::Aarch64AtOperation const&);
    /** @} */
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch64AtOperand.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch64AtOperand();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch64AtOperand();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch64AtOperand(Rose::BinaryAnalysis::Aarch64AtOperation const& operation);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch64AtOperand_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch32Instruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef ROSE_ENABLE_ASM_AARCH32
#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch32Instruction);
IS_SERIALIZABLE(AsmAarch32Instruction);

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmAarch32Instruction);
#if defined(SgAsmAarch32Instruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
#ifdef ROSE_ENABLE_ASM_AARCH32
#include <Rose/BinaryAnalysis/InstructionEnumsAarch32.h>
#endif
#endif // SgAsmAarch32Instruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
/** Represents one A32 or T32 machine instruction. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
class SgAsmAarch32Instruction: public SgAsmInstruction {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    AsmAarch32Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch32InstructionKind", "kind", "= Rose::BinaryAnalysis::Aarch32InstructionKind::ARM_INS_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    AsmAarch32Instruction.setDataPrototype(
        "Rose::BinaryAnalysis::Aarch32InstructionCondition", "condition", "= Rose::BinaryAnalysis::Aarch32InstructionCondition::ARM_CC_INVALID",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    AsmAarch32Instruction.setDataPrototype(
        "bool", "updatesFlags", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    AsmAarch32Instruction.setDataPrototype(
        "bool", "writesBack", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    AsmAarch32Instruction.setDataPrototype(
        "bool", "writesToIp", "= false",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch32Instruction);
#if defined(SgAsmAarch32Instruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmInstruction);
#line 11 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_kind);
#line 17 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_condition);
#line 22 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_updatesFlags);
#line 26 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_writesBack);
#line 33 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
        s & BOOST_SERIALIZATION_NVP(p_writesToIp);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
public:
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch32InstructionKind const& get_kind() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_kind(Rose::BinaryAnalysis::Aarch32InstructionKind const&);
    /** @} */
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    Rose::BinaryAnalysis::Aarch32InstructionCondition const& get_condition() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_condition(Rose::BinaryAnalysis::Aarch32InstructionCondition const&);
    /** @} */
#line 19 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 21 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_updatesFlags() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_updatesFlags(bool const&);
    /** @} */
#line 23 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 25 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_writesBack() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_writesBack(bool const&);
    /** @} */
#line 27 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 29 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    bool const& get_writesToIp() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_writesToIp(bool const&);
    /** @} */
#line 34 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Instruction.h"
public:
    // Overrides are documented in the base class
    virtual std::string description() const override;
    virtual bool terminatesBasicBlock() override;
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete) override;
    virtual bool isUnknown() const override;
    virtual unsigned get_anyKind() const override;
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&, rose_addr_t *target,
                                    rose_addr_t *return_va) override;
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&, rose_addr_t *target,
                                    rose_addr_t *return_va) override;
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&) override;
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&) override;
    virtual Sawyer::Optional<rose_addr_t> branchTarget() override;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch32Instruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch32Instruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmAarch32Instruction(rose_addr_t const& address,
                            std::string const& mnemonic,
                            Rose::BinaryAnalysis::Aarch32InstructionKind const& kind,
                            Rose::BinaryAnalysis::Aarch32InstructionCondition const& condition);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch32Instruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION
#endif


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmInstruction           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmInstruction = nonTerminalConstructor(
    "AsmInstruction",
    *this,
    "AsmInstruction",
    "AsmInstructionTag",
    SubclassListBuilder()
#ifdef ROSE_ENABLE_ASM_AARCH32
        | AsmAarch32Instruction
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64Instruction
#endif
        | AsmCilInstruction
        | AsmJvmInstruction
        | AsmM68kInstruction
        | AsmMipsInstruction
        | AsmNullInstruction
        | AsmPowerpcInstruction
        | AsmX86Instruction
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmInstruction.associatedGrammar != nullptr);
AsmInstruction.setCppCondition("!defined(DOCUMENTATION)");
AsmInstruction.isBoostSerializable(true);
AsmInstruction.setAutomaticGenerationOfConstructor(false);
AsmInstruction.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 622 "src/Rosebud/RosettaGenerator.C"
DECLARE_HEADERS(AsmInstruction);
#if defined(SgAsmInstruction_HEADERS) || defined(DOCUMENTATION)
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
#include <Rose/BinaryAnalysis/MemoryMap.h>
#endif // SgAsmInstruction_HEADERS

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
/** Base class for machine instructions.
 *
 *  @li Each instruction is represented by one or more instances of SgAsmInstruction.
 *
 *  @li An instruction obtained from a full AST will have a parent pointer. The instruction's first ancestor of type @ref
 *  SgAsmBlock is the basic block in which the instruction appears, and its first ancestor of type @ref SgAsmFunction is
 *  the function in which the instruction appears. There may be intervening AST nodes having other types.
 *
 *  @li An instruction obtained from a @ref Rose::BinaryAnalysis::Partitioner2::Partitioner "Partitioner" will not have a
 *  parent pointer. You can find ownership information using the Partitioner API.
 *
 *  @li An instruction's bytes will always be contiguous in the virtual address space from which the instruction was
 *  decoded, but might not be contiguous in the file (if any) where the instruction was stored. In fact, there's no
 *  guarantee that the instruction even exists entirely within one file.
 *
 *  @li Two distinct instructions (with different encodings) can start at the same virtual address if the specimen is
 *  self-modifying. Most ROSE analysis assumes that specimens are not self-modifying and uses the instruction's starting
 *  virtual address to uniquely identify the instruction.
 *
 *  @li Two distinct instructions (with different encodings) can occupy overlapping bytes in the virtual address space, and
 *  are guaranteed to have different starting addresses unless the specimen is self-modifying. */
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
class SgAsmInstruction: public SgAsmStatement {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "std::string", "mnemonic", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "SgUnsignedCharList", "raw_bytes", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "SgAsmOperandList*", "operandList", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "size_t", "cacheLockCount", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "SgAsmStatementPtrList", "sources", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 93 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "int64_t", "stackDeltaIn", "= SgAsmInstruction::INVALID_STACK_DELTA",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 102 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    AsmInstruction.setDataPrototype(
        "SgAsmExprListExp*", "semantics", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, DEF_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmInstruction);
#if defined(SgAsmInstruction_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmStatement);
#line 53 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_mnemonic);
#line 59 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_raw_bytes);
#line 66 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_operandList);
#line 76 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_cacheLockCount);
#line 84 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
        s & BOOST_SERIALIZATION_NVP(p_sources);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 24 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Local types
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    struct SemanticFailure {
        size_t n;
        SemanticFailure(): n(0) {}

#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
    private:
        friend class boost::serialization::access;
        template<class S>
        void serialize(S &s, const unsigned /*version*/) {
            s & BOOST_SERIALIZATION_NVP(n);
        }
#endif
};

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Properties
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 47 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_mnemonic() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_mnemonic(std::string const&);
    /** @} */
#line 54 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 56 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgUnsignedCharList const& get_raw_bytes() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_raw_bytes(SgUnsignedCharList const&);
    /** @} */
#line 60 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 62 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmOperandList* const& get_operandList() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_operandList(SgAsmOperandList* const&);
    /** @} */
#line 67 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 69 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 77 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    size_t cacheLockCount() const;
    void adjustCacheLockCount(int increment);

    // FIXME[Robb P Matzke 2017-02-13]: unused?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 81 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
    /** @} */
#line 85 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    void appendSources( SgAsmInstruction* instruction );

    // FIXME[Robb Matzke 2023-03-18]: is the no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 89 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int64_t const& get_stackDeltaIn() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_stackDeltaIn(int64_t const&);
    /** @} */
#line 94 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    // FIXME[Robb Matzke 2023-03-18]: is the no_serialize a bug?
#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 97 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmExprListExp* const& get_semantics() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_semantics(SgAsmExprListExp* const&);
    /** @} */
#line 103 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmInstruction.h"
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Non-property data members
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
private:
    SemanticFailure semanticFailure_;

    // Synchronized data members. All the following data members (as listed in binaryInstruction.C, not the ROSETTA-generated
    // code) should be procted by the mutex_. Additionally, the p_cacheLockCount data member is synchronized.
    mutable SAWYER_THREAD_TRAITS::Mutex mutex_;

public:
    /** Represents an invalid stack delta.
     *
     *  This value is used for the result of a stack delta analysis stored in the instruction AST if the stack delta
     *  analysis was not run or did not produce a numeric result. */
    static const int64_t INVALID_STACK_DELTA;

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Functions
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
public:
    /** Return a description of this instruction.
     *
     *  Descriptions are useful for generating comments in the disassembly listing to say what each instruction does when
     *  the audience is not well versed in that instruction set architecture.  The base implementation always returns an
     *  empty string. */
    virtual std::string description() const { return ""; }

    /** Number of operands. */
    size_t nOperands() const;

    /** Nth operand.
     *
     *  If the operand index is out of range, then null is returned. */
    SgAsmExpression* operand(size_t) const;

    /** Determines if this instruction normally terminates a basic block.
     *
     *  The analysis only looks at the individual instruction and therefore is not very sophisticated.  For instance, a
     *  conditional branch will always terminate a basic block by this method even if its condition is opaque.  The base
     *  class implementation always aborts; architecture-specific subclasses should override this to do something useful
     *  (pure virtual is not possible due to ROSETTA). */
    virtual bool terminatesBasicBlock();

    /** Returns true if the specified basic block looks like a function call.
     *
     *  This instruction object is only used to select the appropriate virtual method; the basic block to be analyzed is
     *  the first argument to the function.  If the basic block looks like a function call then this method returns true.
     *  If (and only if) the target address is known (i.e., the address of the called function) then @p target is set to
     *  this address (otherwise @p target is unmodified). If the return address is known or can be guessed, then return_va
     *  is initialized to the return address, which is normally the fall-through address of the last instruction; otherwise
     *  the return_va is unmodified.
     *
     *  The "fast" and "slow" versions differ only in what kind of anlysis they do.  The "fast" version typically looks
     *  only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.
     *
     * @{ */
    virtual bool isFunctionCallFast(const std::vector<SgAsmInstruction*>&, rose_addr_t *target, rose_addr_t *ret);
    virtual bool isFunctionCallSlow(const std::vector<SgAsmInstruction*>&, rose_addr_t *target, rose_addr_t *ret);
    /** @} */

    /** Returns true if the specified basic block looks like a function return.
     *
     *  This instruction object is only used to select the appropriate virtual method; the basic block to be analyzed is
     *  the first argument to the function.
     *
     *  The "fast" and "slow" versions differ only in what kind of anlysis they do.  The "fast" version typically looks
     *  only at instruction patterns while the slow version might incur more expense by looking at instruction semantics.
     *
     * @{ */
    virtual bool isFunctionReturnFast(const std::vector<SgAsmInstruction*>&);
    virtual bool isFunctionReturnSlow(const std::vector<SgAsmInstruction*>&);
    /** @} */

    /** Returns true if this instruction is the first instruction in a basic block.
     *
     *  This method looks only at the AST to make this determination. */
    bool isFirstInBlock();

    /** Returns true if this instruction is the last instruction in a basic block.
     *
     *  This method looks only at the AST to make this determination. */
    bool isLastInBlock();

    /** Obtains the virtual address for a branching instruction.
     *
     *  Returns the branch target address if this instruction is a branching instruction and the target is known; otherwise
     *  returns nothing. */
    virtual Sawyer::Optional<rose_addr_t> branchTarget();

    // FIXME[Robb Matzke 2021-03-02]: deprecated
    bool getBranchTarget(rose_addr_t *target /*out*/) ROSE_DEPRECATED("use branchTarget instead");

    /** Determines whether a single instruction has an effect.
     *
     *  An instruction has an effect if it does anything other than setting the instruction pointer to a concrete
     *  value. Instructions that have no effect are called "no-ops".  The x86 NOP instruction is an example of a no-op, but
     *  there are others also.
     *
     *  The following information about x86 no-ops is largely from Cory Cohen at CMU/SEI. In the discussion that follows,
     *  we are careful to distinguish between NOP (the mneumonic for instructions 90, and 0f1f) and "no-op" (any
     *  instruction whose only effect is to advance the instruction pointer).
     *
     * @code
     *  Opcode bytes         Intel assembly syntax
     *  -------------------- ----------------------
     *  90                   nop
     *
     *  89c0                 mov eax,eax            Intel's old recommended two-byte no-op was to
     *  89c9                 mov ecx,ecx            move a register to itself...  The second byte of these are mod/rm
     *  89d2                 mov edx,edx            bytes, and can generally be substituded wherever you see 0xc0 in
     *  89db                 mov ebx,ebx            subsequent examples.
     *  89e4                 mov esp,esp
     *  89ed                 mov ebp,ebp
     *  89f6                 mov esi,esi
     *  89ff                 mov edi,edi
     *
     *  88c0                 mov al,al              The above are also available in 8-bit form with a leading byte of 0x88
     *  6689c0               mov ax,ax              and with an operand size prefix (0x66).
     *
     *  66666689c0           mov ax,ax              The prefixes can be repeated. One source seemed to imply that up to
     *                                              three are reliably supported by the actual Intel processors. ROSE
     *                                              supports any number up to the maximum instruction size (varies by mode).
     *
     *  6688c0               mov al,al              The operand size prefix can even be nonsensical.
     *
     *  8ac0                 mov al,al              These are also presumabely no-ops.  As with most instructions, these
     *  8bc0                 mov eax,eax            will accept operand size prefixes as well.
     *
     *  f090                 lock nop               Most of these instructions will accept a lock prefix as well, which does
     *  f0f090               lock nop               not materially affect the result. As before, they can occur repeatedly,
     *  f066f090             lock nop               and even in wacky combinations.
     *  f066f06666f0f066f090 lock nop
     *
     *  f290                 repne nop              Cory Cohen strongly suspects that the other instruction prefixes are
     *  f390                 rep nop                ignored as well, although to be complete, we might want to conduct a
     *  2690                 es nop                 few tests into the behavior of common processors.
     *  2e90                 cs nop
     *  3690                 ss nop
     *  3e90                 ds nop
     *  6490                 fs nop
     *  6590                 gs nop
     *  6790                 nop
     *
     *  8d00                 lea eax,[eax]          Intel's old recommendation for larger no-ops was to use the LEA
     *  8d09                 lea ecx,[ecx]          instruction in various dereferencing modes.
     *  8d12                 lea edx,[edx]
     *  8d1b                 lea ebx,[ebx]
     *  8d36                 lea esi,[esi]
     *  8d3f                 lea edi,[edi]
     *
     *  8d4000               lea eax,[eax+0x0]
     *  8d4900               lea ecx,[ecx+0x0]
     *  8d5200               lea edx,[edx+0x0]
     *  8d5b00               lea ebx,[ebx+0x0]
     *  8d7600               lea esi,[esi+0x0]
     *  8d7f00               lea edi,[edi+0x0]
     *
     *  8d8000000000         lea eax,[eax+0x0]      This last block is really the [reg*0x1+0x0] dereferencing mode.
     *  8d8900000000         lea ecx,[ecx+0x0]
     *  8d9200000000         lea edx,[edx+0x0]
     *  8d9b00000000         lea ebx,[ebx+0x0]
     *  8db600000000         lea esi,[esi+0x0]
     *  8dbf00000000         lea edi,[edi+0x0]
     *
     *  8d0420               lea eax,[eax]          Then there's funky equivalents involving SIB bytes.
     *  8d0c21               lea ecx,[ecx]
     *  8d1422               lea edx,[edx]
     *  8d1c23               lea ebx,[ebx]
     *  8d2424               lea esp,[esp]
     *  8d3426               lea esi,[esi]
     *  8d3c27               lea edi,[edi]
     *
     *  8d442000             lea eax,[eax+0x0]
     *  8d4c2100             lea ecx,[ecx+0x0]
     *  8d542200             lea edx,[edx+0x0]
     *  8d5c2300             lea ebx,[ebx+0x0]
     *  8d642400             lea esp,[esp+0x0]
     *  8d742600             lea esi,[esi+0x0]
     *  8d7c2700             lea edi,[edi+0x0]
     *
     *  8d842000000000       lea eax,[eax+0x0]
     *  8d8c2100000000       lea ecx,[ecx+0x0]
     *  8d942200000000       lea edx,[edx+0x0]
     *  8d9c2300000000       lea ebx,[ebx+0x0]
     *  8da42400000000       lea esp,[esp+0x0]
     *  8db42600000000       lea esi,[esi+0x0]
     *  8dbc2700000000       lea edi,[edi+0x0]
     *
     *  8d2c2d00000000       lea ebp,[ebp+0x0]      The EBP variants don't exactly follow the pattern above.
     *  8d6c2500             lea ebp,[ebp+0x0]
     *  8dac2500000000       lea ebp,[ebp+0x0]
     *
     *  0f1f00               nop [eax]              P4+ adds the 0f1f instruction. Each of these can be prefixed with the
     *  0f1f4000             nop [eax+0x0]          0x66 operand size prefix. In fact, Intel recommends doing this now
     *  0f1f440000           nop [eax+0x0]          for the optimally efficient 6- and 9-byte sequences.
     *  0f1f8000000000       nop [eax+0x0]
     *  0f1f840000000000     nop [eax+0x0]
     *
     *  0f0dxx               nop [xxx]              The latest version of the manual implies that this sequence is also
     *                                              reserved for NOP, although I can find almost no references to it except
     *                                              in the latest instruction manual on page A-13 of volume 2B. It's also
     *                                              mentioned on x86asm.net. [CORY 2010-04]
     *
     *  d9d0                 fnop                   These aren't really no-ops on the chip, but are no-ops from the
     *  9b                   wait                   program's perspective. Most of these instructions are related to
     *  0f08                 invd                   improving cache efficiency and performance, but otherwise do not
     *  0f09                 wbinvd                 affect the program behavior.
     *  0f01c9               mwait
     *  0f0138               invlpg [eax]
     *  0f01bf00000000       invlpg [edi+0x0]       and more...
     *  0f18 /0              prefetchnta [xxx]
     *  0f18 /1              prefetch0 [xxx]
     *  0f18 /2              prefetch1 [xxx]
     *  0f18 /3              prefetch2 [xxx]
     *  0fae /5              lfence [xxx]
     *  0fae /6              mfence [xxx]
     *  0fae /7              sfence [xxx]
     *
     *  0f18xx through 0f1exx                       This opcode rante is officially undefined but is probably reserved
     *                                              for no-ops as well.  Any instructions encountered in this range are
     *                                              probably consequences of bad code and should be ingored.
     *
     *  JMP, Jcc, PUSH/RET, etc.                    Branches are considered no-ops if they can be proven to always branch
     *                                              to the fall-through address.
     * @endcode
     */
    virtual bool hasEffect();

    /** Determine if an instruction sequence has an effect.
     *
     *  A sequence of instructions has an effect if it does something other than setting the instruction pointer to a
     *  concrete value.
     *
     *  This is mostly a wrapper around the @ref Rose::BinaryAnalysis::NoOperation "NoOperation" analysis. The @p
     *  allow_branch and @p relax_stack_semantics are no longer supported but perhaps will be added eventually to the
     *  NoOperation analysis. */
    virtual bool hasEffect(const std::vector<SgAsmInstruction*>&, bool allow_branch=false,
                           bool relax_stack_semantics=false);

    /** Determines what subsequences of an instruction sequence have no cumulative effect.
     *
     *  The return value is a vector of pairs where each pair is the starting index and length of subsequence.  The
     *  algorithm we use is to compute the machine state after each instruction and then look for pairs of states that are
     *  identical except for the instruction pointer.
     *
     *  This is mostly a wrapper around the @ref Rose::BinaryAnalysis::NoOperation "NoOperation" analysis. The @p
     *  allow_branch and @p relax_stack_semantics are no longer supported but perhaps will be added eventually to the
     *  NoOperation analysis. */
    virtual std::vector<std::pair<size_t,size_t> >
    findNoopSubsequences(const std::vector<SgAsmInstruction*>& insns, bool allow_branch=false,
                         bool relax_stack_semantics=false);

    /** Control flow successors for a single instruction.
     *
     *  The return value does not consider neighboring instructions, and therefore is quite naive.  It returns only the
     *  information it can glean from this single instruction.  If the returned set of virtual instructions is fully known
     *  then the @p complete argument will be set to true, otherwise false.  The base class implementation always
     *  aborts()--it must be defined in an architecture-specific subclass (pure virtual is not possible due to ROSETTA). */
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(bool &complete); /*subclasses must redefine*/

    /** Control flow successors for a basic block.
     *
     *  The @p basicBlock argument is a vector of instructions that is assumed to be a basic block that is entered only at
     *  the first instruction and exits only at the last instruction.  A memory map can supply initial values for the
     *  analysis' memory state.  The return value is a set of control flow successor virtual addresses, and the @p complete
     *  argument return value indicates whether the returned set is known to be complete (aside from interrupts, faults,
     *  etc).  The base class implementation just calls the single-instruction version, so architecture-specific subclasses
     *  might want to override this to do something more sophisticated. */
    virtual Rose::BinaryAnalysis::AddressSet getSuccessors(const std::vector<SgAsmInstruction*> &basicBlock,
                                                           bool &complete,
                                                           const Rose::BinaryAnalysis::MemoryMap::Ptr &initial_memory =
                                                           Rose::BinaryAnalysis::MemoryMap::Ptr());

    /** Returns the size of an instruction in bytes.
     *
     *  This is only a convenience function that returns the size of the instruction's raw byte vector.  If an instruction
     *  or its arguments are modified, then the size returned by this function might not reflect the true size of the
     *  modified instruction if it were to be reassembled. */
    virtual size_t get_size() const;

    /** Returns true if this instruction is the special "unknown" instruction.
     *
     *  Each instruction architecture in ROSE defines an "unknown" instruction to be used when the disassembler is unable
     *  to create a real instruction.  This can happen, for instance, if the bit pattern does not represent a valid
     *  instruction for the architecture. */
    virtual bool isUnknown() const;

    /** Returns instruction kind for any architecture.
     *
     *  Instruction kinds are specific to the architecture so it doesn't make sense to compare an instruction kind from x86
     *  with an instruction kind from m68k.  However, this virtual function exists so that we don't need to implement
     *  switch statements every time we want to compare two instructions from the same architecture.  For instance, instead
     *  of code like this:
     *
     * @code
     *  bool areSame(SgAsmInstruction *a, SgAsmInstruction *b) {
     *      if (a->variantT() != b->variantT())
     *          return false;
     *      if (SgAsmM68kInstruction *aa = isSgAsmM68kInstruction(a)) {
     *          SgAsmM68kInstruction *bb = isSgAsmM68kInstruction(b);
     *          return aa->get_kind() == bb->get_kind();
     *      }
     *      if (SgAsmMipsInstruction *aa = isSgAsmMipsInstruction(a)) {
     *          SgAsmMipsInstruction *bb = isSgAsmMipsInstruction(b);
     *          return aa->get_kind() == bb->get_kind();
     *      }
     *      ...
     *      ... // and many others
     *      ...
     *      ASSERT_not_reachable("architecture is not implemented yet");
     *  }
     * @endcode
     *
     *  we can write future-proof code:
     *
     * @code
     *  bool areSame(SgAsmInstruction *a, SgAsmInstruction *b) {
     *      return a->variantT()==b->variantT() && a->get_anyKind()==b->get_anyKind();
     *  }
     * @endcode */
    virtual unsigned get_anyKind() const;

    /** Converts the instruction to a string.
     *
     *  The return value is an address, colon, mnemonic, and arguments. Only one space is used between the parts. */
    virtual std::string toString() const;

    /** Explicit constants.
     *
     *  Return the set of integer constants that appear explicitly in the instruction's operands. These are called
     *  "immediates" for some architectures such as X86. */
    virtual std::set<rose_addr_t> explicitConstants() const;

    /** Property: Whether instruction semantics failed at this location.
     *
     *  This property is incremented by various analyses that evaluate instructions semantically when semantics fails
     *  in a way that is not recoverable.  Some analyses can work around failed semantics by operating in a degraded
     *  mode, and it is up to the analysis whether to increment this property.
     *
     *  Thread safety: This method is thread safe.
     *
     * @{ */
    size_t semanticFailure() const;
    void semanticFailure(size_t);
    void incrementSemanticFailure();
    /** @} */

    /** Rewrite certain addressing modes for operands.
     *
     *  The addressing mode: <code>REG1 + REG2 * SIZE + OFFSET</code> is changed from <code>(+ (+ REG1 (* REG2 SIZE))
     *  OFFSET)</code> to <code>(+ (+ REG1 OFFSET) (* REG2 SIZE))</code>, which during instruction semantic executions causes
     *  the base register and offset to be added first to obtain the starting address of an array, and then an additional offset
     *  added to obtain the address of the desired element of that array.
     *
     *  Returns true if anything changed, false otherwise. */
    bool normalizeOperands();
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmInstruction();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmInstruction();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    SgAsmInstruction(rose_addr_t const& address,
                     std::string const& mnemonic);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmInstruction_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmStatement           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmStatement = nonTerminalConstructor(
    "AsmStatement",
    *this,
    "AsmStatement",
    "AsmStatementTag",
    SubclassListBuilder()
        | AsmBlock
        | AsmInstruction
        | AsmStaticData
        | AsmSynthesizedDeclaration
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmStatement.associatedGrammar != nullptr);
AsmStatement.setCppCondition("!defined(DOCUMENTATION)");
AsmStatement.isBoostSerializable(true);
AsmStatement.setAutomaticGenerationOfConstructor(false);
AsmStatement.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
/** Base class for statement-like subclasses.
 *
 *  This is a base class for those binary analysis entities, such as instructions and basic blocks, that have a starting
 *  address in the virtual address space. */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
class SgAsmStatement: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
    AsmStatement.setDataPrototype(
        "rose_addr_t", "address", "= 0",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
    AsmStatement.setDataPrototype(
        "std::string", "comment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmStatement);
#if defined(SgAsmStatement_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
        s & BOOST_SERIALIZATION_NVP(p_address);
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
        s & BOOST_SERIALIZATION_NVP(p_comment);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    rose_addr_t const& get_address() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_address(rose_addr_t const&);
    /** @} */
#line 10 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_comment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_comment(std::string const&);
    /** @} */
#line 14 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmStatement.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmStatement();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmStatement();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmStatement(rose_addr_t const& address);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmStatement_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmAarch32Coprocessor           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 581 "src/Rosebud/RosettaGenerator.C"
DECLARE_LEAF_CLASS(AsmAarch32Coprocessor);
IS_SERIALIZABLE(AsmAarch32Coprocessor);

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"
/** Operand referencing a Co-processor. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"
class SgAsmAarch32Coprocessor: public SgAsmExpression {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmAarch32Coprocessor);
#if defined(SgAsmAarch32Coprocessor_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmExpression);
#line 4 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"
        s & BOOST_SERIALIZATION_NVP(coprocessor_);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"

#line 465 "src/Rosebud/RosettaGenerator.C"
private:
    int coprocessor_;

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    int const& coprocessor() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void coprocessor(int const&);
    /** @} */
#line 5 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmAarch32Coprocessor.h"

#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmAarch32Coprocessor();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmAarch32Coprocessor();

#line 290 "src/Rosebud/RosettaGenerator.C"
public:
    /** Constructor. */
    explicit SgAsmAarch32Coprocessor(int const& coprocessor);

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmAarch32Coprocessor_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmExpression           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmExpression = nonTerminalConstructor(
    "AsmExpression",
    *this,
    "AsmExpression",
    "AsmExpressionTag",
    SubclassListBuilder()
        | AsmAarch32Coprocessor
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64AtOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64BarrierOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64CImmediateOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64PrefetchOperand
#endif
#ifdef ROSE_ENABLE_ASM_AARCH64
        | AsmAarch64SysMoveOperand
#endif
        | AsmBinaryExpression
        | AsmByteOrder
        | AsmCommonSubExpression
        | AsmControlFlagsExpression
        | AsmExprListExp
        | AsmMemoryReferenceExpression
        | AsmRegisterNames
        | AsmRegisterReferenceExpression
        | AsmRiscOperation
        | AsmStackExpression
        | AsmUnaryExpression
        | AsmValueExpression
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmExpression.associatedGrammar != nullptr);
AsmExpression.setCppCondition("!defined(DOCUMENTATION)");
AsmExpression.isBoostSerializable(true);
AsmExpression.setAutomaticGenerationOfConstructor(false);
AsmExpression.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
/** Base class for expressions. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
class SgAsmExpression: public SgAsmNode {
#endif // DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
    AsmExpression.setDataPrototype(
        "SgAsmType*", "type", "= nullptr",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 453 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
    AsmExpression.setDataPrototype(
        "std::string", "comment", "",
        NO_CONSTRUCTOR_PARAMETER, NO_ACCESS_FUNCTIONS, NO_TRAVERSAL, NO_DELETE, COPY_DATA);
#line 462 "src/Rosebud/RosettaGenerator.C"
#endif // !DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmExpression);
#if defined(SgAsmExpression_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgAsmNode);
#line 6 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_type);
#line 12 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
        s & BOOST_SERIALIZATION_NVP(p_comment);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 3 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    SgAsmType* const& get_type() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_type(SgAsmType* const&);
    /** @} */
#line 7 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"

#line 471 "src/Rosebud/RosettaGenerator.C"
public:
#line 9 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
    /** Property: Instruction kind.
     *
     *  Returns an enum constant describing the x86 instruction. These enum constants correspond roughly 1:1 with
     *  instruction mnemonics. Each architecture has its own set of enum constants. See also, getAnyKind. 
     *  
     *  @{ */
#line 479 "src/Rosebud/RosettaGenerator.C"
    std::string const& get_comment() const;
#line 502 "src/Rosebud/RosettaGenerator.C"
    void set_comment(std::string const&);
    /** @} */
#line 13 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmExpression.h"
public:
    /** Property: Width of expression in bits.
     *
     *  Returns the width of the expression in bits according to its data type. The "type" property must be non-null. */
    size_t get_nBits() const;

    /** Return a constant if possible.
     *
     *  If this expression is an integer expression with a constant that fits in a 64-bit unsigned type, then return it,
     *  otherwise return nothing. */
    Sawyer::Optional<uint64_t> asUnsigned() const;

    /** Return a signed constant if possible.
     *
     *  If this expression is an integer expression with a constant that fits in a 64-bit signed type, then return it,
     *  otherwise return nothing. */
    Sawyer::Optional<int64_t> asSigned() const;
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmExpression();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmExpression();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmExpression_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION


#line 605 "src/Rosebud/RosettaGenerator.C"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// SgAsmNode           -- MACHINE GENERATED; DO NOT MODIFY --
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#line 568 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
#line 541 "src/Rosebud/RosettaGenerator.C"
AstNodeClass& AsmNode = nonTerminalConstructor(
    "AsmNode",
    *this,
    "AsmNode",
    "AsmNodeTag",
    SubclassListBuilder()
        | AsmCilNode
        | AsmExecutableFileFormat
        | AsmExpression
        | AsmGenericFileList
        | AsmInstructionList
        | AsmInterpretation
        | AsmInterpretationList
        | AsmJvmNode
        | AsmOperandList
        | AsmStatement
        | AsmType
    , true);
#line 561 "src/Rosebud/RosettaGenerator.C"
assert(AsmNode.associatedGrammar != nullptr);
AsmNode.setCppCondition("!defined(DOCUMENTATION)");
AsmNode.isBoostSerializable(true);
AsmNode.setAutomaticGenerationOfConstructor(false);
AsmNode.setAutomaticGenerationOfDestructor(false);
#endif // !DOCUMENTATION

#line 211 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
#line 1 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNode.h"
/** Base class for all binary analysis IR nodes. */
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNode.h"
class SgAsmNode: public SgNode {
#endif // DOCUMENTATION

#line 525 "src/Rosebud/RosettaGenerator.C"
    DECLARE_OTHERS(AsmNode);
#if defined(SgAsmNode_OTHERS) || defined(DOCUMENTATION)

#line 17 "src/Rosebud/BoostSerializer.C"
    //----------------------- Boost serialization -----------------------
#ifdef ROSE_HAVE_BOOST_SERIALIZATION_LIB
private:
    friend class boost::serialization::access;

    template<class S>
    void serialize(S &s, const unsigned /*version*/) {
#line 27 "src/Rosebud/BoostSerializer.C"
        s & BOOST_SERIALIZATION_BASE_OBJECT_NVP(SgNode);
#line 38 "src/Rosebud/BoostSerializer.C"
    }
#endif // ROSE_HAVE_BOOST_SERIALIZATION
#line 2 "/home/matzke/rose-wip/rose/src/AstNodes/BinaryAnalysis/SgAsmNode.h"
protected:
    // Rosebud generates call to destructorHelper in every destructor implementation. This gives the user a chance to do something
    // special. Any implementations should be prepared to handle multiple invocations on the same object, and should not access any
    // data members in any derived class. Standard C++ rules about calling virtual functions in destructors apply here.
    virtual void destructorHelper() {}

public:
    /** Allocate and return a new node after setting its parent.
     *
     *  ROSE's AST has this annoying, error-prone process for adding a node to the tree. One has to not only add the downward edge
     *  from parent to child, but also explicitly add the upward edge from child to parent. This two-step process makes it difficult
     *  to create child nodes and link them into the parent while the parent is being constructed. This function attempts to make
     *  this easier by doing everything in one step.
     *
     *  Use it like this:
     *
     * @code
     *  Parent::Parent(int foo, int bar)
     *      : p_child(createAndParent<Child>(this), p_foo(foo), p_bar(bar) {}
     * @endcode */
    template<class T>
    static typename std::enable_if<std::is_base_of<SgNode, T>::value, T*>::type
    createAndParent(SgNode *parent) {
        auto node = new T;
        node->set_parent(parent);
        return node;
    }
#line 239 "src/Rosebud/RosettaGenerator.C"
public:
    /** Destructor. */
    virtual ~SgAsmNode();

#line 267 "src/Rosebud/RosettaGenerator.C"
public:
    /** Default constructor. */
    SgAsmNode();

#line 379 "src/Rosebud/RosettaGenerator.C"
protected:
    /** Initialize all properties that have explicit initial values.
     *
     *  This function is mostly for use in user-defined constructors where the user desires to initialize
     *  all the properties but does not know the names of the data members that store the property values.
     *  This function initializes the properties that have explicit initializations within this class, but
     *  does not recursively initialize base classes. */
    void initializeProperties();
#endif // SgAsmNode_OTHERS
#line 228 "src/Rosebud/RosettaGenerator.C"
#ifdef DOCUMENTATION
};
#endif // DOCUMENTATION

#line 155 "src/Rosebud/RosettaGenerator.C"
#ifndef DOCUMENTATION
} // Grammar::setUpBinaryInstruction
#endif // !DOCUMENTATION
#line 141 "src/Rosebud/RosettaGenerator.C"
#endif // ROSE_ENABLE_BINARY_ANALYSIS
