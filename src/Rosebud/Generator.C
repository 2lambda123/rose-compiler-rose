#include <Rosebud/Generator.h>

#include <Rosebud/NoneGenerator.h>
#include <Rosebud/RosettaGenerator.h>
#include <Rosebud/SawyerGenerator.h>
#include <Rosebud/YamlGenerator.h>

#include <boost/range/adaptor/reversed.hpp>
#include <sstream>

namespace Rosebud {

std::vector<Generator::Ptr>
Generator::registry_;

void
Generator::initRegistry() {
    static bool initialized = false;
    if (!initialized) {
        registry_.push_back(YamlGenerator::instance());
        registry_.push_back(RosettaGenerator::instance());
        registry_.push_back(SawyerGenerator::instance());
        registry_.push_back(NoneGenerator::instance());
        initialized = true;
    }
}

void
Generator::registerGenerator(const Ptr &generator) {
    ASSERT_not_null(generator);
    initRegistry();
    registry_.push_back(generator);
}

const std::vector<Generator::Ptr>&
Generator::registeredGenerators() {
    initRegistry();
    return registry_;
}

Generator::Ptr
Generator::lookup(const std::string &name) {
    initRegistry();
    for (const Ptr &generator: boost::adaptors::reverse(registry_)) {
        if (generator->name() == name)
            return generator;
    }
    return {};
}

void
Generator::addAllToParser(Sawyer::CommandLine::Parser &parser) {
    for (const Ptr &generator: registry_)
        generator->adjustParser(parser);
}

std::string
Generator::propertyDataMemberName(const Ast::Property::Ptr &p) const {
    ASSERT_not_null(p);
    if (p->dataMemberName) {
        return *p->dataMemberName;
    } else {
        return p->name + "_";
    }
}

std::vector<std::string>
Generator::propertyAccessorNames(const Ast::Property::Ptr &p) const {
    ASSERT_not_null(p);
    if (p->accessorNames) {
        return *p->accessorNames;
    } else {
        return {p->name};
    }
}

std::vector<std::string>
Generator::propertyMutatorNames(const Ast::Property::Ptr &p) const {
    ASSERT_not_null(p);
    if (p->mutatorNames) {
        return *p->mutatorNames;
    } else {
        return {p->name};
    }
}

const std::vector<std::string>&
Generator::commandLine() const {
    return commandLine_;
}

void
Generator::commandLine(const std::vector<std::string> &cmdline) {
    commandLine_ = cmdline;
}

std::string
Generator::generatedByRosebud(const std::string &prefix) {
    std::ostringstream ss;

    ss <<prefix <<"\n"
       <<prefix <<" This file was generated by Rosebud\n";

    if (!commandLine().empty()) {
        const std::string initialIndent = "    ";
        const std::string additionalIndent = initialIndent + "    ";
        size_t at = prefix.size() + initialIndent.size();
        ss <<prefix <<initialIndent;
        for (size_t i = 0; i <commandLine().size(); ++i) {
            const std::string arg = bourneEscape(commandLine()[i]);
            if (i > 0 && at + 1 + arg.size() > 132 /*arbitrary*/) {
                ss <<"\n" <<prefix <<additionalIndent;
                at = prefix.size() + additionalIndent.size();
            }
            at += 1 + arg.size();
            ss <<" " <<arg;
        }
        ss <<"\n";
    }
    ss <<prefix <<"\n";

    ss <<prefix <<" See documentation for the ::Rosebud namespace for information about the input language and how to best run\n"
       <<prefix <<" the commands to (re)generate this file. See `rosebud --help` for documentation about command-line switches.\n"
       <<prefix <<"\n"
       <<prefix <<" The ::Rosebud namespace might be documented at one of these places:\n"
       <<prefix <<"     https://rpm.is/rose\n"
       <<prefix <<"     http://rosecompiler.org/ROSE_HTML_Reference/index.html\n"
       <<prefix <<"\n";

    return ss.str();
}

} // namespace
