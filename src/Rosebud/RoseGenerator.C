#include <Rosebud/RoseGenerator.h>

#include <Sawyer/GraphTraversal.h>

#include <boost/algorithm/string/predicate.hpp>

#include <fstream>
#include <regex>
#include <string>
#include <vector>

using namespace Sawyer::Message::Common;

namespace Rosebud {

void
RoseGenerator::adjustParser(Sawyer::CommandLine::Parser &parser) {
    using namespace Sawyer::CommandLine;

    SwitchGroup sg("ROSE backend (--backend=rose)");
    sg.name("rose");
    sg.doc("This backend generates code directly without sending it through ROSETTA. It's goal is to generate a more modern style "
           "of tree data structures where node memory is managed and parent pointers are automatic.\n\n"

           "The following command-line switches are understood by this backend:");

    sg.insert(Switch("generated")
              .argument("directory", anyParser(generatedDir))
              .doc("Name of the directory that will contain the generated C++ files."));

    parser.with(sg);
}

void
RoseGenerator::generate(const Ast::Project::Ptr &project) {
    ASSERT_not_null(project);

    Hierarchy h = classHierarchy(project->allClassesFileOrder());
    const Classes classes = topDown(h);

    adjustAst(classes);
    genBasicTypes(project);
    for (const auto &c: classes)
        genClass(c, h);
}

std::string
RoseGenerator::ctorInitializerExpression(const Ast::Property::Ptr &p, const std::string &init) {
    ASSERT_not_null(p);
    if (isTreeEdge(p)) {
        return init.empty() ? "*this" : "*this, " + init;
    } else {
        return init;
    }
}

std::string
RoseGenerator::valueType(const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);
    return Base::valueType(p) + (isTreeEdge(p) ? "::ChildPtr" : "");
}

bool
RoseGenerator::isTreeEdge(const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);
    static std::regex re("((Rose::)?Tree::)?Edge<.*>");
    return std::regex_match(dataMemberType(p), re);
}

void
RoseGenerator::genImplOpen(std::ostream &impl, const Ast::Class::Ptr &c) {
    ASSERT_not_null(c);
    impl <<THIS_LOCATION <<machineGenerated()
         <<"//\n"
         <<"// This file was generated by Rosebud.\n"
         <<"//\n"
         <<"#include <" <<(generatedDir / toPath(c->name, ".h")).string() <<">\n";
}

void
RoseGenerator::genImplClose(std::ostream &impl, const Ast::Class::Ptr &c) {
    ASSERT_not_null(c);
    impl <<"\n"
         <<THIS_LOCATION <<machineGenerated();
}

void
RoseGenerator::genHeaderOpen(std::ostream &header, const Ast::Class::Ptr &c) {
    ASSERT_not_null(c);
    header <<THIS_LOCATION <<machineGenerated()
           <<"//\n"
           <<"// This file was generated by Rosebud.\n"
           <<"//\n"
           <<"#ifndef ROSE_" <<toCppSymbol(c->name) <<"_H\n"
           <<"#define ROSE_" <<toCppSymbol(c->name) <<"_H\n";
}

void
RoseGenerator::genHeaderClose(std::ostream &header, const Ast::Class::Ptr &c) {
    ASSERT_not_null(c);
    header <<"\n"
           <<THIS_LOCATION <<"#endif // ROSE_" <<toCppSymbol(c->name) <<"_H\n"
           <<machineGenerated();
}

void
RoseGenerator::genHeaderIncludes(std::ostream &header, const Ast::Class::Ptr &c, const Hierarchy &h) {
    ASSERT_not_null(c);

    header <<"\n"
           <<THIS_LOCATION <<"#include <featureTests.h>\n"
           <<"#include <" <<(generatedDir/"BasicTypes.h").string() <<">\n";

    // If the base class is one we're generating, then use the header we generated. Otherwise use just the class header.
    for (const auto &base: c->inheritance) {
        const boost::filesystem::path include = h.findVertexKey(base.second) == h.vertices().end() ?
                                                toPath(base.second, ".h") :
                                                generatedDir / toPath(base.second, ".h");
        header <<THIS_LOCATION <<locationDirective(c, c->startToken)
               <<"#include <" <<include.string() <<">\n";
    }
}

void
RoseGenerator::genPropertyDataMember(std::ostream &header, const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);
    header <<THIS_LOCATION <<locationDirective(p, p->startToken)
           <<"private:\n"
           <<"    " <<dataMemberType(p) <<" " <<propertyDataMemberName(p) <<";\n";
}

void
RoseGenerator::genPropertyAccessors(std::ostream &header, std::ostream &impl, const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);

    for (const std::string &accessorName: propertyAccessorNames(p)) {
        const std::string type = dataMemberType(p);
        const std::string refType = removeVolatileMutable(type) + "&";
        const std::string constRefType = constRef(removeVolatileMutable(type));
        const auto c = p->findAncestor<Ast::Class>();
        const bool isLarge = isTreeEdge(p) || p->findAttribute("Rosebud::large");
        ASSERT_not_null(c);

        // Declarations
        header <<THIS_LOCATION <<locationDirective(p, p->startToken)
               <<"public:\n"
               <<"    " <<constRefType <<" " <<accessorName <<"() const;\n";
        if (isLarge) {
            header <<THIS_LOCATION <<locationDirective(p, p->startToken)
                   <<"public:\n"
                   <<"    " <<refType <<" " <<accessorName <<"();\n";
        }

        // Implementations
        impl <<"\n"
             <<THIS_LOCATION <<locationDirective(p, p->startToken)
             <<constRefType <<"\n"
             <<c->name <<"::" <<accessorName <<"() const {\n"
             <<"    return " <<propertyDataMemberName(p) <<";\n"
             <<"}\n";
        if (isLarge) {
            impl <<"\n"
                 <<THIS_LOCATION <<locationDirective(p, p->startToken)
                 <<refType <<"\n"
                 <<c->name <<"::" <<accessorName <<"() {\n"
                 <<"    return " <<propertyDataMemberName(p) <<";\n"
                 <<"}\n";
        }
    }
}

void
RoseGenerator::genPropertyMutators(std::ostream &header, std::ostream &impl, const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);

    for (const std::string &mutatorName: propertyMutatorNames(p)) {
        const std::string type = valueType(p);
        const std::string constRefType = constRef(removeVolatileMutable(type));
        const auto c = p->findAncestor<Ast::Class>();
        ASSERT_not_null(c);

        // Declarations
        header <<THIS_LOCATION <<locationDirective(p, p->startToken)
               <<"public:\n"
               <<"    void " <<mutatorName <<"(" <<constRefType <<");\n";

        // Implementations
        impl <<"\n"
             <<THIS_LOCATION <<locationDirective(p, p->startToken)
             <<"void\n"
             <<c->name <<"::" <<mutatorName <<"(" <<constRefType <<" x) {\n"
             <<"    this->" <<propertyDataMemberName(p) <<" = x;\n"
             <<"}\n";
    }
}

void
RoseGenerator::genProperty(std::ostream &header, std::ostream &impl, const Ast::Property::Ptr &p) {
    ASSERT_not_null(p);

    // Emit text prior to the property
    if (!p->priorText.empty()) {
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(p, p->priorTextToken);
    }

    // Fix up the doxygen comment so it can apply to more than one class member. If the doxygen comment doesn't end with "@{" then
    // we need to add that.
    static auto doc = [&p]() -> std::pair<std::string, std::string> {
        std::string begin = p->doc;
        std::string end;
        if (!begin.empty()) {
            if (begin.find("@{") == std::string::npos) {
                begin = appendToDoxygen(begin, "\n@{");
                end = "    /** @} */\n";
            }
            if (!boost::ends_with(begin, "\n"))
                begin += "\n";
        }
        return {begin, end};
    }();

    // Emit documentation
    if (!doc.first.empty())
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(p, p->docToken) <<doc.first;

    genPropertyDataMember(header, p);
    genPropertyAccessors(header, impl, p);
    genPropertyMutators(header, impl, p);

    // Close documentation
    header <<doc.second;
};

void
RoseGenerator::genDefaultConstructor(std::ostream &header, std::ostream &impl, const Ast::Class::Ptr &c) {
    ASSERT_not_null(c);
    Base::genDefaultConstructor(header, impl, c, Access::PROTECTED);

    if (!c->findAttribute("Rosebud::abstract")) {
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->startToken)
               <<"public:\n"
               <<"    /** Allocating constructor. */\n"
               <<"    static Ptr instance();\n";

        impl <<"\n"
             <<THIS_LOCATION <<locationDirective(c, c->startToken)
             <<c->name <<"::Ptr\n"
             <<c->name <<"::instance() {\n"
             <<"    return Ptr(new " <<c->name <<");\n"
             <<"}\n";
    }
}

void
RoseGenerator::genArgsConstructor(std::ostream &header, std::ostream &impl, const Ast::Class::Ptr &c, const Hierarchy &h) {
    ASSERT_not_null(c);
    Base::genArgsConstructor(header, impl, c, h, Access::PROTECTED);

    if (!c->findAttribute("Rosebud::abstract")) {
        const std::vector<Ast::Property::Ptr> args = allConstructorArguments(c, h);

        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->startToken)
               <<"public:\n"
               <<"    /** Allocating constructor. */\n"
               <<"    static Ptr instance(";
        for (size_t i = 0; i <args.size(); ++i) {
            header <<(0 == i ? "" : ",\n                        ")
                   <<constRef(removeVolatileMutable(valueType(args[i]))) <<" " <<args[i]->name;
        }
        header <<");\n";

        impl <<"\n"
             <<THIS_LOCATION <<locationDirective(c, c->startToken)
             <<c->name <<"::Ptr\n"
             <<c->name <<"::instance(";
        const auto indent = ",\n" + std::string(c->name.size() + 11, ' ');
        for (size_t i = 0; i <args.size(); ++i) {
            impl <<(0 == i ? "" : indent)
                 <<constRef(removeVolatileMutable(valueType(args[i]))) <<" " <<args[i]->name;
        }
        impl <<") {\n"
             <<"    return Ptr(new " <<c->name <<"(";
        for (size_t i = 0; i < args.size(); ++i)
            impl <<(0 == i ? "" : ", ") <<args[i]->name;
        impl <<"));\n"
             <<"}\n";
    }
}

void
RoseGenerator::genTraversals(std::ostream &header, std::ostream &impl, const Ast::Class::Ptr &c, const Hierarchy &h) {
    ASSERT_not_null(c);

    const std::string base = firstPublicBaseClass(c);
    std::vector<Ast::Property::Ptr> children;
    for (const auto &p: c->properties) {
        if (isTreeEdge(p()))
            children.push_back(p());
    }

    header <<"\n"
           <<THIS_LOCATION <<locationDirective(c, c->startToken)
           <<"protected:\n"
           <<"    virtual ChildDescriptor findChild(size_t) const override;\n";

    impl <<"\n"
         <<THIS_LOCATION <<locationDirective(c, c->startToken)
         <<c->name <<"::ChildDescriptor\n"
         <<c->name <<"::findChild(size_t i) const {\n";
    std::string baseBias = "0";
    if (!base.empty()) {
        impl <<"    const ChildDescriptor child = " <<base <<"::findChild(i);\n"
             <<"    if (child.i == i && !child.name.empty())\n"
             <<"        return child;\n";
        baseBias = "child.i";
    }
    impl <<"    switch (i - " <<baseBias <<") {\n";
    for (size_t i = 0; i < children.size(); ++i) {
        const std::string dataMember = propertyDataMemberName(children[i]);
        impl <<"        case " <<i <<":\n"
             <<"            return ChildDescriptor{i, \"" <<children[i]->name <<"\", " <<dataMember <<"()};\n";
    }
    impl <<"        default:\n"
         <<"            return ChildDescriptor{" <<children.size() <<" + " <<baseBias <<", \"\", nullptr};\n"
         <<"    }\n"
         <<"}\n";
}

void
RoseGenerator::genClass(const Ast::Class::Ptr &c, const Hierarchy &h) {
    ASSERT_not_null(c);
    auto file = c->findAncestor<Ast::File>();
    ASSERT_not_null(file);

    const boost::filesystem::path headerName = generatedDir / toPath(c->name, ".h");
    const boost::filesystem::path implName = generatedDir / toPath(c->name, ".C");
    std::ofstream header(headerName.c_str());
    std::ofstream impl(implName.c_str());
    if (!header) {
        message(ERROR, "cannot open file for writing: \"" + headerName.string() + "\"");
        return;
    }
    if (!impl) {
        message(ERROR, "cannot open file for writing: \"" + implName.string() + "\"");
        return;
    }

    // Emit stuff before the beginning of the class
    genImplOpen(impl, c);
    genHeaderOpen(header, c);
    genHeaderIncludes(header, c, h);
    if (!c->priorText.empty()) {
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->priorTextToken)
               <<c->priorText <<"\n";
    }
    c->cppStack->emitOpen(impl);

    // Class documentation
    if (!c->doc.empty()) {
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->docToken)
               <<c->doc;
    }

    // Class opening line: "class NAME [: BASES] {"
    header <<"\n"
           <<locationDirective(c, c->nameToken)
           <<"class " <<c->name;
    for (auto base = c->inheritance.begin(); base != c->inheritance.end(); ++base)
        header <<(base == c->inheritance.begin() ? ": " : ", ") <<base->first <<" " <<base->second;
    header <<" {\n";

    // Emit generated types at the start of the class
    header <<THIS_LOCATION <<locationDirective(c, c->startToken)
           <<"public:\n"
           <<"    /** Shared-ownership pointer. */\n"
           <<"    using Ptr = " <<c->name <<"Ptr;\n";

    // Class definition body between the "{" and "};"
    for (const auto &p: c->properties)
        genProperty(header, impl, p());

    // User-defined stuff at the end of the class before the closing "}"
    if (!c->endText.empty())
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->endTextToken)
               <<c->endText;

    // Constructors and destructors. We place these at the end of the class because they might depend on types declared earlier in
    // the class.
    genDestructor(header, impl, c);
    genDefaultConstructor(header, impl, c);
    genArgsConstructor(header, impl, c, h);
    genInitProperties(header, impl, c);
    genTraversals(header, impl, c, h);

    // Emit stuff after the class.
    header <<"};\n";
    if (!file->endText.empty())
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(file, file->endTextToken)
               <<file->endText <<"\n";
    genHeaderClose(header, c);
    impl <<"\n";
    c->cppStack->emitClose(impl);
    genImplClose(impl, c);
}

void
RoseGenerator::genBasicTypes(const Ast::Project::Ptr &project) {
    ASSERT_not_null(project);

    const auto headerName = generatedDir / "BasicTypes.h";
    std::ofstream header(headerName.c_str());
    if (!header) {
        message(ERROR, "cannot open file for writing: \"" + headerName.string() + "\"");
        return;
    }

    const std::string onceSymbol = "ROSE_" + toCppSymbol((generatedDir / "BasicTypes").string()) + "_H";
    header <<THIS_LOCATION <<machineGenerated()
           <<"//\n"
           <<"// This file was generated by Rosebud\n"
           <<"//\n"
           <<"#ifndef " <<onceSymbol <<"\n"
           <<"#define " <<onceSymbol <<"\n"
           <<"\n"
           <<"#include <memory>\n"
           <<"\n";

    Classes classes = project->allClassesFileOrder();
    std::sort(classes.begin(), classes.end(), [](const Ast::Class::Ptr &a, const Ast::Class::Ptr &b) {
        return a->name < b->name;
    });

    for (const auto &c: classes) {
        header <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->startToken)
               <<"class " <<c->name <<";\n"
               <<"\n"
               <<THIS_LOCATION <<locationDirective(c, c->startToken)
               <<"/** Shared-ownership pointer to @ref " <<c->name <<"*/\n"
               <<"using " <<c->name <<"Ptr = std::shared_ptr<" <<c->name <<">;\n";
    }

    header <<"\n"
           <<THIS_LOCATION <<"#endif // " <<onceSymbol <<"\n"
           <<machineGenerated();
}

void
RoseGenerator::adjustAst(const Classes &classes) {
#if 0 // [Robb Matzke 2023-04-05]
    ASSERT_not_null(project);

    static std::regex treeEdgeRe("TreeEdge<.*>");

    for (const auto &c: classes) {
        for (const auto &p: *c->properties()) {
            if (isTreeEdge(p())) {


            }
        }
    }
#endif
}

} // namespace
