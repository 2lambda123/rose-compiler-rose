
#ifndef DEFAULT_FUNCTION_GENERATOR_HH
#define DEFAULT_FUNCTION_GENERATOR_HH

#include "rose.h"

enum defaultEnumFunctionType {
  e_unknown =0,
  e_constructor=1,
  e_destructor=2,
  e_copy_constructor=3,
  e_assignment_operator=4,
  e_last_type 
};

//-----------------------------------------------------------------------------
//  generateDefaultFunctionDeclaration() will call generateDefaultFunctionDefinition() when necessary
class DefaultFunctionGenerator: public SgSimpleProcessing
{
 public:
  void visit (SgNode* astNode);
  int pass;
 private:
  /** \brief   Returns a method declaration within a class of the same
   *           type as a specified method.  If the method declaration
   *           does not exist, create it and the method definition.
   *  \param   memberFunctionDeclaration  A method declaration.  If method
   *           is NULL lookup the default constructor.
   *  \param   classDefinition  a SgNode representing a class definition.
   *  \returns A SgMemberFunctionDeclaration from classDefinition that
   *           has the "same type" as method.
   *
   *  Note:  By "same type" we mean the following:
   *  If method is a default constructor, return the default constructor defined
   *  within classDefinition, else NULL.
   *  If method is a copy constructor, return the copy constructor defined
   *  within classDefinition, else NULL.
   *  If method is a destructor, return the destructor defined
   *  within classDefinition, else NULL.
   *  If method is operator=, return the operator= defined
   *  within classDefinition, else NULL.
   *  Otherwise, if method has type signature s and name n, return the
   *  method defined within classDefinition having type signature s and name n.
   */
  SgMemberFunctionDeclaration *
  getMethodInClass(SgMemberFunctionDeclaration *method,
		   SgClassDefinition *classDefinition);
  
  /** \brief  Makes explicit any implicit invocations of copy constructors,
   *          default constructors, operator=, or destructors within
   *          functionDefinition.
   *  \param  functionDefinition  A SgFunctionDefinition representing
   *          a function definition.
   *
   *  Assumes functionDefinition is the definition of a method.
   *  If the method is a constructor, destructor, or operator=, 
   *  other copy or default constructors, destructors, or operator=
   *  methods may be implicitly invoked from it.  Please see
   *  the discussion at the top of this file.
   *
   *  Let the method's "flavor" describe whether it is a 
   *  constructor, destructor, or operator=.  generateImplicitInvocations
   *  finds any _explicit_ invocations within the method of a
   *  method of the same flavor invoked on one of its base classes.
   *  It then iterates over each of base class and records
   *  which of these had a method (of the same flavor) invoked upon it.
   *  Those which did not will have their method implicitly invoked.
   *  The task of generateImplicitInvocations is to make these
   *  implicit invocations explicit by creating the necessary
   *  AST nodes.
   *
   *  For each base class which has not been invoked, we look up 
   *  the method of the correct flavor in that base class and create
   *  an invocation of it.  If that method does not exist, it would
   *  be automatically generated by the backend compiler.  Therefore,
   *  we generate the method definition here.
   *  
   *  NB:  The generated order of invocation is probably not correct.
   *  I imagine C++ dictates the order in which constructors, destructors,
   *  etc. are invoked on base classes.  Instead, I just iterate
   *  over the base classes and invoke methods in that order (modulo
   *  those base classes which have already been invoked).  At the
   *  bare minimum the ordering of implicit invocations should probably
   *  be interleaved with existing explicit invocations (in some way).
   *
   *  NB:  Assuming that a base class is only registered once in
   *  get_inheritances, we should only invoke a constructor, destructor, etc.
   *  once per base class.  Is this the correct behavior with respect
   *  to multiple inheritance?  How about multiple inheritance when the
   *  base class is virtual.
   */
  void generateImplicitInvocations(SgFunctionDefinition *functionDefinition);

  SgClassDefinition* get_ClassDeclarationFromNewOp(SgConstructorInitializer * ctorInitNode);
  SgMemberFunctionDeclaration* generateDefaultFunctionDeclaration(defaultEnumFunctionType enumFunctionType, SgClassDefinition* classDef1);
  void generateDefaultFunctionDefinition(defaultEnumFunctionType enumFunctionType, SgMemberFunctionDeclaration * func);
  SgMemberFunctionDeclaration * findDefaultFunctionDeclaration(defaultEnumFunctionType enumFunctionType, \
							       SgClassDefinition* classDef1);
  SgName generateDefaultFunctionName(defaultEnumFunctionType enumFunctionType, SgClassDefinition *parentClassDef);
  SgMemberFunctionType *generateDefaultFunctionType(defaultEnumFunctionType enumFunctionType, SgClassDefinition *parentClassDef);
  void generateDefaultFunctionCall(SgMemberFunctionDeclaration *func, SgClassDefinition *parentClassDef, SgExpression *receiver, SgExpression *arg, SgBasicBlock *basicBlock);
  void generateDefaultConstructorCall(SgMemberFunctionDeclaration *func, SgClassDefinition *parentClassDef, SgExpression *arg, SgCtorInitializerList *ctorInitializerList);
  void normalizeCtorInitializer(SgConstructorInitializer *ctorInit);
  SgInitializer *normalizeInitializer(SgInitializer *origInit, SgType *objType);
  SgConstructorInitializer *normalizeAssignInitializer(SgAssignInitializer *assignInit);
  SgFunctionCallExp *translateAssignmentToOperatorEqCall(SgExpression *lhs, SgExpression *rhs, SgClassDefinition *clsDef);
  SgMemberFunctionDeclaration * findOrGenerateDefaultFunctionDeclaration(defaultEnumFunctionType enumFunctionType, \
							       SgClassDefinition* classDef1);

};

void defaultFunctionGenerator(SgProject *prj);

#endif /* DEFAULT_FUNCTION_GENERATOR_HH */
