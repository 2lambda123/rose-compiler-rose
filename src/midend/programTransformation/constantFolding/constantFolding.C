// DQ (4/8/2006):
// This implements constant folding using both a conventional
// constant folding algorithm and also the work that has already 
// been done within EDG on the part of the AST generated by the front-end.
//     1) Constant folded expression trees saved in the AST are eliminated
//        simplifying optimizations and a number of analysis operations.
//     2) New constant values expression added after the front-end
//        processing are folded.  This simplifies transformaions introduced
//        after front-end processing. 
// The constant folding is implemented first to eliminate the front-end 
// constant valued expression trees that have been saved into the AST. 
// This is doen because the PRE had at least one bug specific to nested 
// application of itself on the saved constant folded expression trees.
// So eliminating them fixes this problem at least for now.

#include "rose.h"
#include "constantFolding.h"

using namespace ConstantFolding;

void
ConstantFolding::constantFoldingOptimization(SgNode* n, bool internalTestingAgainstFrontend)
   {
  // This is the main function interface for constant folding
     ConstantFoldingTraversal t;
     ConstantFoldingInheritedAttribute ih;

  // Set internal ability to do error checking against any constant expression trees stored in the AST.
     ih.internalTestingAgainstFrontend = internalTestingAgainstFrontend;

     t.traverse(n,ih);
   }

void
ConstantFolding::constantUnFoldingTest(SgNode* n)
   {
  // This is the main function interface for constant un-folding tests.
  // Since the constant folding we have only checks the results computed by EDG 
  // where there are no transformation, we have to generate a transformation to have
  // something to constant fold.  This transformation generates constant expressions 
  // from constants to use in testing the constant folding where EDG would not have 
  // generated the constant folding.  

  // Note that if we save the AST before hand (AST File IO)
  // We could then test the AST to see if the constant folding generated
  // the same AST.  The concept of same AST (equality) would have to be 
  // specified precisely.

     ConstantUnFoldingTraversal t;

  // Test this by turning constants into rather long and ugly constant expressions!
     t.traverse(n);

  // Now fold the constant expressions that we just generated
  // constantFoldingOptimization(n);

  // Need a way to verify that it all worked (other than visually)!
   }

ConstantFoldingInheritedAttribute
ConstantFoldingTraversal::evaluateInheritedAttribute ( SgNode* astNode, ConstantFoldingInheritedAttribute inheritedAttribute )
   {
  // Compute the inheritedAttribute.  Since the modification of the AST must be done 
  // bottom up, this is the most we can do here (since the evaluation of inherited 
  // attributes happens top down).
     if (inheritedAttribute.isConstantFoldedValue == true)
        {
          inheritedAttribute.isConstantFoldedValue = false;
          inheritedAttribute.isPartOfFoldedExpression = true;
        }
       else
        {
       // Check for constant folded value
          SgValueExp* originalExpression = isSgValueExp(astNode);
          if (originalExpression != NULL && originalExpression->get_originalExpressionTree() != NULL)
             {
               if (inheritedAttribute.internalTestingAgainstFrontend == true)
                  {
                 // If we are testing the constant folding then refold the values constant expression trees 
                 // stored in the AST and check the result against what EDG computed.

                 // To test the constant folding skip marking the constant as folded and test if we fold the 
                 // constant expression correctly
                    inheritedAttribute.isConstantFoldedValue = false;
                  }
                 else
                  {
                 // This is a resulting value generated from constant folding in the front-end (EDG)
                    inheritedAttribute.isConstantFoldedValue = true;

                 // We can just remove a subtree that we have not yet traversed, is this perfectly safe?
                 // I think it is safe since it is a child and not a sibling! However, this does not delete 
                 // the existing constant folded trees, it just disconnects them from the AST.
#if PRINT_DEVELOPER_WARNINGS
                    printf ("Deleting the original expression tree within ConstantFoldingTraversal::evaluateInheritedAttribute ... (likely memory leak) \n");
#endif
                    originalExpression->set_originalExpressionTree(NULL);
                  }
             }
        }

     return inheritedAttribute;
   }

// Macro to permit use of shorter name
#define TRANSFORMATION_FILE_INFO Sg_File_Info::generateDefaultFileInfoForTransformationNode()

ConstantFoldingSynthesizedAttribute
ConstantFoldingTraversal::evaluateSynthesizedAttribute (
     SgNode* astNode,
     ConstantFoldingInheritedAttribute inheritedAttribute,
     SubTreeSynthesizedAttributes synthesizedAttributeList )
   {
     ConstantFoldingSynthesizedAttribute returnAttribute;
#if 0
     printf ("astNode = %p = %s: synthesizedAttributeList.size() = %ld \n",astNode,astNode->class_name().c_str(),synthesizedAttributeList.size());
     for (SubTreeSynthesizedAttributes::iterator i = synthesizedAttributeList.begin(); i != synthesizedAttributeList.end(); i++)
        {
          printf ("     synthesizedAttributeList i->newValueExp = %p \n",i->newValueExp);
        }
#endif

  // Use the inheritedAttribute to simplify the logic
     if (inheritedAttribute.isConstantFoldedValue == false)
        {
       // Here is where the front-end mechanism leaves off and we pickup the job to do the constant folding of 
       // anything not handled by the front-end.  This applies to constant expression trees built as part of 
       // transformations.  This should help cleanup a lot of automatically generated code.

       // And of course this section is not yet implemented yet!

          SgExpression* expr = isSgExpression(astNode);
          if ( expr != NULL )
             {
               if (inheritedAttribute.internalTestingAgainstFrontend == true)
                  {
                 // If this is a SgValueExp it might be that a const expression tree is hidden inside of it.
                 // This would have been done in the front-end processing. To check our constant folding we have 
                 // to look in the SgValueExp for the originalExpressionTree and copy the generated SgIntVal from
                 // there (actually where we are just checking, so we only verify that we get the same value).
                    SgValueExp* valueExpression = isSgValueExp(expr);
                    if (valueExpression != NULL)
                       {
                      // If we have a value expression then there could be many types of value IR nodes
                         switch(valueExpression->variantT())
                            {
                              case V_SgIntVal:
                                 {
                                   SgIntVal* integerValue = isSgIntVal(valueExpression);
                                   int originalValue = integerValue->get_value();

                                // Check if we have a constant folded value computed at a child node (synthesized attribute).
                                   SgValueExp* constantValueExp = synthesizedAttributeList[SgValueExp_originalExpressionTree].newValueExp;
                                   if (constantValueExp != NULL)
                                      {
                                     // I think there it is not required to be a SgIntVal IR node since many constant expressions could return "int"
                                     // So I think we have to check again, not ceratin if this much checking is really required.
                                        SgIntVal* intValue = isSgIntVal(constantValueExp);
                                        ROSE_ASSERT(intValue != NULL);  // see if we can assert this!
                                        if (intValue != NULL)
                                           {
                                             int constantFoldedValue = intValue->get_value();
                                             printf ("Error checking: constantFoldedValue = %d originalValue (computed by frontend) = %d \n",constantFoldedValue,originalValue);
                                             ROSE_ASSERT(constantFoldedValue == originalValue);

#if PRINT_DEVELOPER_WARNINGS
                                             printf ("Deleting the original expression tree within ConstantFoldingTraversal::evaluateSynthesizedAttribute ... (likely memory leak) \n");
#endif
                                          // This does not delete the existing constant folded trees, it just disconnects them from the AST.
                                             valueExpression->set_originalExpressionTree(NULL);
                                           }
                                      }
                                 }

                              default:
                                 {
                                 }
                            }
                       }
                  }

            // Found an expression see if it is a binary or unary operator
            // (else we can ignore it in constant folding, I think).
               SgBinaryOp* binaryOperator = isSgBinaryOp(expr);
               if (binaryOperator != NULL)
                  {
                    ROSE_ASSERT(synthesizedAttributeList.size() == 2);

                 // Process any SubTreeSynthesizedAttributes so any values there can be reused (propogated up in the AST)
                 // If we are not testing agains values from the constant expression trees saved by ROSE in the AST, then 
                 // this is where we would expect to find the values propogated up from and constant operands or values 
                 // folded from constant expressions.
                    SgExpression* lhsSynthesizedValue = synthesizedAttributeList[SgBinaryOp_lhs_operand_i].newValueExp;
                    SgExpression* rhsSynthesizedValue = synthesizedAttributeList[SgBinaryOp_rhs_operand_i].newValueExp;

                 // printf ("Propogated values: lhsSynthesizedValue = %p rhsSynthesizedValue = %p \n",lhsSynthesizedValue,rhsSynthesizedValue);

                 // Replace the lhs and/or rhs if generated at a child node in the AST traversal
                 // Note that this overwrites the existing pointer and is likely a memory leak!
                    if (lhsSynthesizedValue != NULL)
                         binaryOperator->set_lhs_operand(lhsSynthesizedValue);
                    if (rhsSynthesizedValue != NULL)
                       binaryOperator->set_rhs_operand(rhsSynthesizedValue);

                 // Get the child nodes (existing or new reset values)
                    SgExpression* lhsOperand = binaryOperator->get_lhs_operand();
                    SgExpression* rhsOperand = binaryOperator->get_rhs_operand();

                 // Check if these are value expressions (constants appropriate for constant folding)
                    SgValueExp* lhsValue = isSgValueExp(lhsOperand);
                    SgValueExp* rhsValue = isSgValueExp(rhsOperand);
                    if (lhsValue != NULL && rhsValue != NULL)
                       {
                      // Now we have to see what kind of binary operator this is (since there are a lot
                      // of binary operators there could be a lot of cases, is there a better design?)
                         switch (binaryOperator->variantT())
                            {
                              case V_SgAddOp:
                                 {
                                // Now we have to look at the type (since there are a lot of types this could be
                                // a lot of cases)
                                   SgType* type = binaryOperator->get_type();
                                   switch(type->variantT())
                                      {
                                     // implement at least one case for now
                                        case V_SgTypeInt:
                                           {
                                             SgIntVal* lhsIntValue = isSgIntVal(lhsValue);
                                             SgIntVal* rhsIntValue = isSgIntVal(rhsValue);
                                             if (lhsIntValue != NULL && rhsIntValue != NULL)
                                                {
                                                  int lhsInteger  = lhsIntValue->get_value();
                                                  int rhsInteger  = rhsIntValue->get_value();
                                                  int foldedValue = lhsInteger + rhsInteger;

                                                  returnAttribute.newValueExp = new SgIntVal(TRANSFORMATION_FILE_INFO,foldedValue);

                                                  printf ("Found a constant expression %d + %d --> folding to value = %d \n",lhsInteger,rhsInteger,foldedValue);
                                                }
                                             break;
                                           }

                                        default:
                                           {
                                          // Not a handled type
                                           }
                                      }
                                   break;
                                 }

                              case V_SgAssignOp:  // values are not lhs operands
                              default:
                                 {
                                // There are a lot of expressions where constant folding does not apply
                                 }
                            }
                       }
                  }

            // Constant folding makes sense on unary operators, but this case is not implemented yet!
               SgUnaryOp* unaryOperator = isSgUnaryOp(expr);
               if (unaryOperator != NULL)
                  {
                    SgExpression* operand = unaryOperator->get_operand();
                    SgValueExp* value = isSgValueExp(operand);
                    if (value != NULL)
                       {
                         switch (unaryOperator->variantT())
                            {
                              case V_SgUnaryAddOp:
                              case V_SgMinusOp:
                              case V_SgCastExp:
                                 {
                                   break;
                                 }

                              default:
                                 {
                                // There are a lot of expressions where constant folding does not apply
                                 }
                            }
                       }
                  }
             }
        }

  // printf ("Returning returnAttribute.newValueExp = %p \n",returnAttribute.newValueExp);

     return returnAttribute;
   }




ConstantUnFoldingSynthesizedAttribute
ConstantUnFoldingTraversal::evaluateSynthesizedAttribute (
     SgNode* astNode,
     SubTreeSynthesizedAttributes synthesizedAttributeList )
   {
     ConstantUnFoldingSynthesizedAttribute returnAttribute;

  // This code will expand out a constant into a constant expression (this is done to test the constant folding) 
     SgValueExp* valueExp = isSgValueExp(astNode);
     if ( valueExp != NULL )
        {
          SgType* type = valueExp->get_type();
          switch(type->variantT())
             {
               case V_SgTypeInt:
                  {
                 // Since a number of value expressions could evaluate to int we don't want to assume 
                 // that this is always a SgIntVal, so we have to test.
                    SgIntVal* intValueExp = isSgIntVal(valueExp);
                    if (intValueExp != NULL)
                       {
                         int value = intValueExp->get_value();
                         SgIntVal* lhsIntValue  = new SgIntVal(TRANSFORMATION_FILE_INFO,1);
                         SgIntVal* rhsIntValue  = new SgIntVal(TRANSFORMATION_FILE_INFO,value-1);
                         returnAttribute.newExp = new SgAddOp(TRANSFORMATION_FILE_INFO,lhsIntValue,rhsIntValue);
                         printf ("Found constant = %d and built a constant expression (%d+%d) \n",
                              value,lhsIntValue->get_value(),rhsIntValue->get_value());
                       }
                      else
                       {
                         printf ("Found an integer type value expression which was not a SgIntVal: valueExp = %p = %s \n",valueExp,valueExp->class_name().c_str());
                       }
                    break;
                  }

               default:
                  {
                 // There are a lot of expressions where constant folding does not get tested using this test
                  }
             }
        }

  // This will turn binary operators containing value expresssions into binary operators with 
  // binary operators as subexpressions.
     SgBinaryOp* binaryOperator = isSgBinaryOp(astNode);
     if (binaryOperator != NULL)
        {
       // Process any SubTreeSynthesizedAttributes so any values there can be reused (propogated up in the AST)
       // If we are not testing agains values from the constant expression trees saved by ROSE in the AST, then 
       // this is where we would expect to find the values propogated up from and constant operands or values 
       // folded from constant expressions.
          SgExpression* lhsSynthesizedValue = synthesizedAttributeList[SgBinaryOp_lhs_operand_i].newExp;
          SgExpression* rhsSynthesizedValue = synthesizedAttributeList[SgBinaryOp_rhs_operand_i].newExp;

       // Replace the lhs and/or rhs if generated at a child node in the AST traversal
       // Note that this overwrites the existing pointer and is likely a memory leak!
          if (lhsSynthesizedValue != NULL)
               binaryOperator->set_lhs_operand(lhsSynthesizedValue);
          if (rhsSynthesizedValue != NULL)
               binaryOperator->set_rhs_operand(rhsSynthesizedValue);
        }

     return returnAttribute;
   }




