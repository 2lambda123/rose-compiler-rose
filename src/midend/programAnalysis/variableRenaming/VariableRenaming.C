/**
 * Category: SSA Analysis
 * VariableRenaming Declaration
 * Created by frye5 in Jun2010
 */

#include "sage3basic.h"
#include "VariableRenaming.h"
#include "sageInterface.h"
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <queue>
#include <fstream>
#include <stack>
#include <boost/foreach.hpp>
#define foreach BOOST_FOREACH

using namespace std;

//Initializations of the static attribute tags
std::string VariableRenaming::varKeyTag = "rename_KeyTag";
SgInitializedName* VariableRenaming::thisDecl = NULL;

//Printing functions
std::string VariableRenaming::keyToString(varName vec)
{
    std::string name = "";
    foreach(varName::value_type& iter, vec)
    {
        if(iter != vec.front())
        {
            name += ":";
        }
        name += iter->get_name().getString();
    }

    return name;
}

void VariableRenaming::printDefs(SgNode* node)
{
    if(!DEBUG_MODE)
        return;

    std::cout << "Def Table for [" << node->class_name() << ":" << node <<"]:" << std::endl;

    foreach(tableEntry::value_type& entry, defTable[node])
    {
        std::cout << "    Defs for [" << keyToString(entry.first) << "]:" << std::endl;
        foreach(nodeVec::value_type& iter, entry.second)
        {
            std::cout << "        -[" << iter->class_name() << ":" << iter << "]" << std::endl;
        }
    }
}

void VariableRenaming::printDefs(std::map< std::vector<SgInitializedName*>, std::vector<SgNode*> >& table)
{
    if(!DEBUG_MODE)
        return;

    std::cout << "Def Table:" << std::endl;

    foreach(tableEntry::value_type& entry,table)
    {
        std::cout << "    Defs for [" << keyToString(entry.first) << "]:" << std::endl;
        foreach(nodeVec::value_type& iter, entry.second)
        {
            std::cout << "        -[" << iter->class_name() << ":" << iter << "]" << std::endl;
        }
    }
}

void VariableRenaming::printUses(SgNode* node)
{
    if(!DEBUG_MODE)
        return;

    std::cout << "Use Table for [" << node->class_name() << ":" << node <<"]:" << std::endl;

    foreach(tableEntry::value_type& entry,useTable[node])
    {
        std::cout << "    Uses for [" << keyToString(entry.first) << "]:" << std::endl;
        foreach(nodeVec::value_type& iter, entry.second)
        {
            std::cout << "        -[" << iter->class_name() << ":" << iter << "]" << std::endl;
        }
    }
}

void VariableRenaming::printUses(std::map< std::vector<SgInitializedName*>, std::vector<SgNode*> >& table)
{
    if(!DEBUG_MODE)
        return;

    std::cout << "Use Table:" << std::endl;

    foreach(tableEntry::value_type& entry,table)
    {
        std::cout << "    Uses for [" << keyToString(entry.first) << "]:" << std::endl;
        foreach(nodeVec::value_type& iter, entry.second)
        {
            std::cout << "        -[" << iter->class_name() << ":" << iter << "]" << std::endl;
        }
    }
}

void VariableRenaming::printRenameTable()
{
    if(!DEBUG_MODE)
        return;

    std::cout << "Rename Table:" << std::endl;

    //Iterate the rename Table
    foreach(numNodeRenameTable::value_type& entry, numRenameTable)
    {
        std::cout << "     Names for [" << keyToString(entry.first) << "]:" << std::endl;

        //Print out the renamings in order.
        int i = 1;
        while(getNodeForRenameNumber(entry.first, i) != NULL)
        {
            std::cout << "       " << i << ": " << getNodeForRenameNumber(entry.first, i) << std::endl;
            i++;
        }
    }
}

VarUniqueName* VariableRenaming::getUniqueName(SgNode* node)
{
    if(!node->attributeExists(VariableRenaming::varKeyTag))
    {
        return NULL;
    }
    VarUniqueName* uName = dynamic_cast<VarUniqueName*>(node->getAttribute(VariableRenaming::varKeyTag));
    return uName;
}


bool VariableRenaming::isFromLibrary(SgInitializedName* initName)
{
  Sg_File_Info* fi = initName->get_file_info();
  if (fi->isCompilerGenerated())
    return true;
  string filename = fi->get_filenameString();
  if ((filename.find("/include/") != std::string::npos))
      return true;

  return false;
}



//Function to perform the VariableRenaming and annotate the AST
void VariableRenaming::run()
{
    //if(DEBUG_MODE)
        //cout << "Performing Variable location traversal." << endl;

    //VariableRenaming::VarLocatorTraversal varTraverse(this);
    //varTraverse.traverse(this->project,VariableRenaming::VarLocatorInheritedAttr(VariableRenaming::VarLocatorInheritedAttr::Global,this->project));

    if(DEBUG_MODE)
        cout << "Locating global variables." << endl;

    findGlobalVars();

    if(DEBUG_MODE)
        cout << "Performing UniqueNameTraversal..." << endl;

    UniqueNameTraversal *uniqueTrav = new UniqueNameTraversal();
    std::vector<SgFunctionDefinition*> funcs = SageInterface::querySubTree<SgFunctionDefinition>(project, V_SgFunctionDefinition);
    std::vector<SgFunctionDefinition*>::iterator iter = funcs.begin();
    for(;iter != funcs.end(); ++iter)
    {
        SgFunctionDeclaration* func = (*iter)->get_declaration();
        ROSE_ASSERT(func);
        uniqueTrav->traverse(func);
    }

    cout << "Finished UniqueNameTrav..." << endl;

    VariableRenaming::VarDefUseTraversal *defUseTrav = new VariableRenaming::VarDefUseTraversal(this);
    for(iter = funcs.begin();iter != funcs.end(); ++iter)
    {
        SgFunctionDeclaration* func = (*iter)->get_declaration();
        ROSE_ASSERT(func);
        cout << "Running defUseTrav on function: " << func->get_name().getString() << endl;
        defUseTrav->traverse(func);
    }

    cout << "Finished DefUseTraversal." << endl;
    cout << "Performing DefUse." << endl;

    for(iter = funcs.begin();iter != funcs.end(); ++iter)
    {
        SgFunctionDefinition* func = (*iter);
        ROSE_ASSERT(func);
        cout << "Running DefUse on function: " << func->get_declaration()->get_name().getString() << endl;
        runDefUse(func);
    }

    return;
}

void VariableRenaming::findGlobalVars()
{
    initNameVec vars = SageInterface::querySubTree<SgInitializedName>(project, V_SgInitializedName);
    foreach(initNameVec::value_type& iter, vars)
    {
        //Ignore library/compiler generated variables.
        if(isFromLibrary(iter))
            continue;

        //Check if we are in global scope.
        SgNode* scope = iter->get_scope();
        if(isSgGlobal(scope))
        {
            //Add the variable to the global scope and name it.
            VarUniqueName *uName = new VarUniqueName(iter);
            iter->setAttribute(VariableRenaming::varKeyTag, uName);
            //Add to the global var list
            globalVarList.push_back(uName->getKey());
        }
    }
}

void VariableRenaming::toDOT(const std::string fileName)
{
    ROSE_ASSERT(fileName != "");

    typedef std::vector<SgSourceFile*> fileVec;
    fileVec files = SageInterface::querySubTree<SgSourceFile>(project, V_SgSourceFile);

    //print all the functions in each file
    foreach(fileVec::value_type& file, files)
    {
        ofstream outFile((StringUtility::stripPathFromFileName(file->getFileName())
                            + "_" + fileName).c_str());

        if(!outFile.good())
        {
            if(DEBUG_MODE)
                cout << "Error printing DOT." << endl;

            return;
        }

        //Print the CFG of the function
        printToDOT(file, outFile);
    }
}

void VariableRenaming::toFilteredDOT(const std::string fileName)
{
    ROSE_ASSERT(fileName != "");

    typedef std::vector<SgSourceFile*> fileVec;
    fileVec files = SageInterface::querySubTree<SgSourceFile>(project, V_SgSourceFile);

    //print all the functions in each file
    foreach(fileVec::value_type& file, files)
    {
        ofstream outFile((StringUtility::stripPathFromFileName(file->getFileName())
                            + "_filtered_" + fileName).c_str());

        if(!outFile.good())
        {
            if(DEBUG_MODE)
                cout << "Error printing DOT." << endl;

            return;
        }

        //Print the CFG of the function
        printToFilteredDOT(file, outFile);
    }
}

void VariableRenaming::printToDOT(SgSourceFile* source, std::ofstream &outFile)
{
    if(!outFile.good())
    {
        if(DEBUG_MODE)
            cout << "Error: Bad ofstream in printToDOT()" << endl;
        return;
    }

    typedef CFGNode cfgNode;
    typedef CFGEdge cfgEdge;

    typedef std::vector<SgFunctionDefinition*> funcDefVec;
    funcDefVec funcs = SageInterface::querySubTree<SgFunctionDefinition>(source, V_SgFunctionDefinition);

    //Start the graph
    outFile << "digraph SSAGraph {\n";

    //Iterate all the functions and print them in the same file.
    foreach(funcDefVec::value_type& func, funcs)
    {
        vector<cfgNode> visited;
        stack<cfgNode> traverse;
        cfgNode current = cfgNode(func->cfgForBeginning());

        traverse.push(current);

        while(!traverse.empty())
        {
            current = traverse.top();

            //If not visited
            if(std::count(visited.begin(),visited.end(),current) == 0)
            {
                //Visit the node and print it
                std::string id = current.id();
                std::string nodeColor = "black";

                bool uniqueName = current.getNode()->attributeExists(VariableRenaming::varKeyTag);

                if (isSgStatement(current.getNode()))
                    nodeColor = "blue";
                else if (isSgExpression(current.getNode()))
                    nodeColor = "green";
                else if (isSgInitializedName(current.getNode()))
                    nodeColor = "red";

                std::string name = "";
                if(uniqueName)
                {
                    if(DEBUG_MODE)
                        cout << "Getting Unique Name attribute." << endl;
                    VarUniqueName *attr = getUniqueName(current.getNode());
                    ROSE_ASSERT(attr);

                    name = attr->getNameString();
                }

                //Print the defs to a string
                std::stringstream defUse;
                typedef std::map< std::vector<SgInitializedName*>, std::vector <SgNode*> > tableEntry;
                typedef std::vector<SgNode*> valT;
                foreach(tableEntry::value_type& entry, defTable[current.getNode()])
                {
                    defUse << "Def [" << keyToString(entry.first) << "] :\\n";
                    foreach(valT::value_type& val, entry.second)
                    {
                        defUse << getRenameNumberForNode(entry.first, val) << ": " << val << "\\n";
                    }
                }
                //Print the uses to a string
                foreach(tableEntry::value_type& entry, useTable[current.getNode()])
                {
                    defUse << "Use [" << keyToString(entry.first) << "] :\\n";
                    foreach(valT::value_type& val, entry.second)
                    {
                        defUse << getRenameNumberForNode(entry.first, val) << ": " << val << "\\n";
                    }
                }

                //Copy out the string and trim off the last '\n'
                std::string defUseStr = defUse.str().substr(0,defUse.str().size()-2);


                //Print this node
                outFile << id << " [label=\"<"  << escapeString(current.getNode()->class_name()) << ">:" << current.getNode()
                        //Now we add the unique name information
                        << ((name != "")? "\\n" : "") << name
                        << ((defUseStr != "")? "\\n" : "") << defUseStr
                        << "\", color=\"" << nodeColor << "\", style=\""
                        << (current.isInteresting()? "solid" : "dotted") << "\"];\n";

                //Now print the out edges
                std::vector<cfgEdge> outEdges = current.outEdges();

                foreach(std::vector<cfgEdge>::value_type& edge, outEdges)
                {
                    outFile << edge.source().id() << " -> " << edge.target().id()
                            << " [label=\"" << escapeString(edge.toString())
                            << "\"];\n";
                }
            }

            visited.push_back(current);

            std::vector<cfgEdge> outEdges = current.outEdges();
            foreach(std::vector<cfgEdge>::value_type& edge, outEdges)
            {
                //If we haven't seen the target of this node yet, process the node
                if(std::count(visited.begin(),visited.end(),edge.target()) == 0)
                {
                    traverse.push(edge.target());
                    break;
                }
            }

            //If there are no new out edges to explore
            if(traverse.top() == current)
            {
                std::vector<cfgEdge> inEdges = current.inEdges();
                foreach(std::vector<cfgEdge>::value_type& edge, inEdges)
                {
                    //If we haven't seen the target of this node yet, process the node
                    if(std::count(visited.begin(),visited.end(),edge.target()) == 0)
                    {
                        traverse.push(edge.source());
                        break;
                    }
                }
            }

            //No out or in edges left to print, pop this node
            if(traverse.top() == current)
            {
                traverse.pop();
            }
        }
    }

    //End the graph
    outFile << "}\n";
}

void VariableRenaming::printToFilteredDOT(SgSourceFile* source, std::ofstream& outFile)
{
    if(!outFile.good())
    {
        if(DEBUG_MODE)
            cout << "Error: Bad ofstream in printToDOT()" << endl;
        return;
    }

    typedef FilteredCFGNode<IsDefUseFilter> cfgNode;
    typedef FilteredCFGEdge<IsDefUseFilter> cfgEdge;

    typedef std::vector<SgFunctionDefinition*> funcDefVec;
    funcDefVec funcs = SageInterface::querySubTree<SgFunctionDefinition>(source, V_SgFunctionDefinition);

    //Start the graph
    outFile << "digraph SSAGraph {\n";

    //Iterate all the functions and print them in the same file.
    foreach(funcDefVec::value_type& func, funcs)
    {
        vector<cfgNode> visited;
        stack<cfgNode> traverse;
        cfgNode current = cfgNode(func->cfgForBeginning());

        traverse.push(current);

        while(!traverse.empty())
        {
            current = traverse.top();

            //If not visited
            if(std::count(visited.begin(),visited.end(),current) == 0)
            {
                //Visit the node and print it
                std::string id = current.id();
                std::string nodeColor = "black";

                bool uniqueName = current.getNode()->attributeExists(VariableRenaming::varKeyTag);

                if (isSgStatement(current.getNode()))
                    nodeColor = "blue";
                else if (isSgExpression(current.getNode()))
                    nodeColor = "green";
                else if (isSgInitializedName(current.getNode()))
                    nodeColor = "red";

                std::string name = "";
                if(uniqueName)
                {
                    if(DEBUG_MODE)
                        cout << "Getting Unique Name attribute." << endl;
                    VarUniqueName *attr = getUniqueName(current.getNode());
                    ROSE_ASSERT(attr);

                    name = attr->getNameString();
                }

                //Print the defs to a string
                std::stringstream defUse;
                typedef std::map< std::vector<SgInitializedName*>, std::vector <SgNode*> > tableEntry;
                typedef std::vector<SgNode*> valT;
                foreach(tableEntry::value_type& entry, defTable[current.getNode()])
                {
                    defUse << "Def [" << keyToString(entry.first) << "] :\\n";
                    foreach(valT::value_type& val, entry.second)
                    {
                        defUse << getRenameNumberForNode(entry.first, val) << ": " << val << "\\n";
                    }
                }
                //Print the uses to a string
                foreach(tableEntry::value_type& entry, useTable[current.getNode()])
                {
                    defUse << "Use [" << keyToString(entry.first) << "] :\\n";
                    foreach(valT::value_type& val, entry.second)
                    {
                        defUse << getRenameNumberForNode(entry.first, val) << ": " << val << "\\n";
                    }
                }

                //Copy out the string and trim off the last '\n'
                std::string defUseStr = defUse.str().substr(0,defUse.str().size()-2);


                //Print this node
                outFile << id << " [label=\"<"  << escapeString(current.getNode()->class_name()) << ">:" << current.getNode()
                        //Now we add the unique name information
                        << ((name != "")? "\\n" : "") << name
                        << ((defUseStr != "")? "\\n" : "") << defUseStr
                        << "\", color=\"" << nodeColor << "\", style=\""
                        << (current.isInteresting()? "solid" : "dotted") << "\"];\n";

                //Now print the out edges
                std::vector<cfgEdge> outEdges = current.outEdges();

                foreach(std::vector<cfgEdge>::value_type& edge, outEdges)
                {
                    outFile << edge.source().id() << " -> " << edge.target().id()
                            << " [label=\"" << escapeString(edge.toString())
                            << "\"];\n";
                }
            }

            visited.push_back(current);

            std::vector<cfgEdge> outEdges = current.outEdges();
            foreach(std::vector<cfgEdge>::value_type& edge, outEdges)
            {
                //If we haven't seen the target of this node yet, process the node
                if(std::count(visited.begin(),visited.end(),edge.target()) == 0)
                {
                    traverse.push(edge.target());
                    break;
                }
            }

            //If there are no new out edges to explore
            if(traverse.top() == current)
            {
                std::vector<cfgEdge> inEdges = current.inEdges();
                foreach(std::vector<cfgEdge>::value_type& edge, inEdges)
                {
                    //If we haven't seen the target of this node yet, process the node
                    if(std::count(visited.begin(),visited.end(),edge.target()) == 0)
                    {
                        traverse.push(edge.source());
                        break;
                    }
                }
            }

            //No out or in edges left to print, pop this node
            if(traverse.top() == current)
            {
                traverse.pop();
            }
        }
    }
   
    //End the graph
    outFile << "}\n";
}

VariableRenaming::VarRefSynthAttr VariableRenaming::UniqueNameTraversal::evaluateSynthesizedAttribute(SgNode* node, SynthesizedAttributesList attrs)
{
    //First we check if this is an initName
    if(isSgInitializedName(node))
    {
        SgInitializedName* name = isSgInitializedName(node);

        //We want to assign this node its unique name, as well as adding it to the defs.
        VarUniqueName* uName = new VarUniqueName(name);
        name->setAttribute(VariableRenaming::varKeyTag, uName);

        return VariableRenaming::VarRefSynthAttr(name);
    }
    //Next, see if it is a varRef
    else if(isSgVarRefExp(node))
    {
        SgVarRefExp* var = isSgVarRefExp(node);

        if(attrs.size() != 0)
        {
            cout << "Error: Found VarRef with children." << endl;
            ROSE_ASSERT(false);
        }

        //We want to assign this node its unique name, as well as adding it to the defs.
        VarUniqueName* uName = new VarUniqueName(var->get_symbol()->get_declaration());
        var->setAttribute(VariableRenaming::varKeyTag, uName);

        return VariableRenaming::VarRefSynthAttr(var);
    }
    //We check if it is a 'this' expression, since we want to be able to version 'this' as well.
    //We don't have an SgInitializedName for 'this', so we use a flag in the unique names
    else if(isSgThisExp(node))
    {
        SgThisExp* thisExp = isSgThisExp(node);

        if(attrs.size() != 0)
        {
            cout << "Error: Found ThisExp with children." << endl;
            ROSE_ASSERT(false);
        }

        return VariableRenaming::VarRefSynthAttr(thisExp);
    }
    //Now we check if we have reached a Dot Expression, where we have to merge names.
    else if(isSgDotExp(node))
    {
        if(attrs.size() != 2)
        {
            cout << "Error: Found dot operator without exactly 2 children." << endl;
            ROSE_ASSERT(false);
        }

        //We want to update the naming for the RHS child
        //Check if the LHS has at least one varRef
        if(attrs[0].getRefs().size() > 0)
        {
            //Get the unique name from the highest varRef in the LHS, since this will have the most
            //fully qualified UniqueName.
            VarUniqueName* lhsName = dynamic_cast<VarUniqueName*>(attrs[0].getRefs()[attrs[0].getRefs().size() - 1]->getAttribute(VariableRenaming::varKeyTag));
            ROSE_ASSERT(lhsName);

            //Check if the RHS has a single varRef
            if(attrs[1].getRefs().size() == 1)
            {
                SgVarRefExp* varRef = isSgVarRefExp(attrs[1].getRefs()[0]);

                if(varRef)
                {
                    //Create the uniqueName from the uniqueName of the lhs prepended to the rhs uniqueName
                    VarUniqueName* uName = new VarUniqueName(lhsName->getKey(), varRef->get_symbol()->get_declaration());
                    uName->setUsesThis(lhsName->getUsesThis());
                    varRef->setAttribute(VariableRenaming::varKeyTag,uName);

                    //Return the combination of the LHS and RHS varRefs
                    return VariableRenaming::VarRefSynthAttr(attrs[0].getRefs(), varRef);
                }
                else
                {
                    //RHS could be a function call.
                    return VariableRenaming::VarRefSynthAttr(varRef);
                }
            }
            else
            {
                //RHS could be a function call.
                return attrs[0];
            }   
        }
        else
        {
            cout << "Error: LHS of dot has no varRefs." << endl;
            ROSE_ASSERT(false);
        }
    }
    //Now we check if we have reached an ArrowExpression, we have to merge names.
    else if(isSgArrowExp(node))
    {
        if(attrs.size() != 2)
        {
            cout << "Error: Found arrow operator without exactly 2 children." << endl;
            ROSE_ASSERT(false);
        }

        //We want to update the naming for the RHS child
        //Check if the LHS has at least one varRef
        if(attrs[0].getRefs().size() > 0)
        {
            bool thisExp = false;
            //Check if our LHS varRef is the 'this' expression
            if(isSgThisExp(attrs[0].getRefs()[attrs[0].getRefs().size() - 1]))
            {
                thisExp = true;
            }
            
            //Get the unique name from the highest varRef in the LHS, since this will have the most
            //fully qualified UniqueName.
            VarUniqueName* lhsName;
            if(!thisExp)
            {
                lhsName = dynamic_cast<VarUniqueName*>(attrs[0].getRefs()[attrs[0].getRefs().size() - 1]->getAttribute(VariableRenaming::varKeyTag));
                ROSE_ASSERT(lhsName);
            }
            
            //Check if the RHS has a single varRef
            if(attrs[1].getRefs().size() == 1)
            {
                SgVarRefExp* varRef = isSgVarRefExp(attrs[1].getRefs()[0]);

                if(varRef)
                {
                    if(!thisExp)
                    {
                        //Create the uniqueName from the uniqueName of the lhs prepended to the rhs uniqueName
                        VarUniqueName* uName = new VarUniqueName(lhsName->getKey(), varRef->get_symbol()->get_declaration());
                        uName->setUsesThis(lhsName->getUsesThis());
                        varRef->setAttribute(VariableRenaming::varKeyTag,uName);
                    }
                    else
                    {
                        //Create the UniqueName from the current varRef, and stores that it uses 'this'
                        VarUniqueName* uName = new VarUniqueName(varRef->get_symbol()->get_declaration());
                        uName->setUsesThis(true);
                        varRef->setAttribute(VariableRenaming::varKeyTag,uName);
                    }

                    //Return the combination of the LHS and RHS varRefs
                    return VariableRenaming::VarRefSynthAttr(attrs[0].getRefs(), varRef);
                }
                else
                {
                    //RHS could be a function call
                    return VariableRenaming::VarRefSynthAttr(varRef);
                }
            }
            else
            {
                //RHS could be a function call, and wouldn't have any varRefs.
                return VariableRenaming::VarRefSynthAttr();
            }
        }
        else
        {
            cout << "Error: LHS of arrow has no varRefs." << endl;
            ROSE_ASSERT(false);
        }
    }
    //Now we hit the default case. We should return a merged list.
    else
    {
        std::vector<SgNode*> names;
        for(unsigned int i = 0; i < attrs.size(); i++)
        {
            names.insert(names.end(), attrs[i].getRefs().begin(), attrs[i].getRefs().end());
        }

        return VariableRenaming::VarRefSynthAttr(names);
    }
}

VariableRenaming::VarDefUseSynthAttr VariableRenaming::VarDefUseTraversal::evaluateSynthesizedAttribute(SgNode* node, SynthesizedAttributesList attrs)
{
    cout << "---------<" << node->class_name() << ">-------" << node << endl;
    //We want to propogate the def/use information up from the varRefs to the higher expressions.
    //Initially, we only store defs in the table, since we have to determine where each
    //use obtains its value(s)
    if(isSgInitializedName(node))
    {
        SgInitializedName* name = isSgInitializedName(node);
        ROSE_ASSERT(name);

        VarUniqueName * uName = varRename->getUniqueName(name);
        ROSE_ASSERT(uName);

        //Add this as a def. [node][uniqueName]
        varRename->getDefTable()[name][uName->getKey()].push_back(name);

        if(varRename->getDebug())
        {
            cout << "Defined " << uName->getNameString() << endl;
        }

        //An SgInitializedName should count as a def, since it is the initial definition.
        return VariableRenaming::VarDefUseSynthAttr(name, NULL);
    }
    //Catch all variable references
    else if(isSgVarRefExp(node))
    {
        SgVarRefExp* varRef = isSgVarRefExp(node);
        ROSE_ASSERT(varRef);

        //Get the unique name of the def.
        VarUniqueName * uName = varRename->getUniqueName(varRef);
        ROSE_ASSERT(uName);

        //Add this as a use. We will correct the reference later.
        varRename->getUseTable()[varRef][uName->getKey()].push_back(varRef);

        if(varRename->getDebug())
        {
            cout << "Found use for " << uName->getNameString() << " at " << varRef->cfgForBeginning().toStringForDebugging() << endl;
        }

        //A VarRef is always a use, it only becomes defined by the parent assignment.
        return VariableRenaming::VarDefUseSynthAttr(NULL, varRef);
    }
    //Catch all types of Binary Operations
    else if(isSgBinaryOp(node))
    {
        SgBinaryOp* op = isSgBinaryOp(node);

        if(attrs.size() == 2)
        {
            //If we have an assigning operation, we want to list everything on the LHS as being defined
            //Otherwise, everything is being used.
            VariantT type = op->variantT();
            switch(type)
            {
                //Catch all the types of Ops that define the LHS
                case V_SgAndAssignOp:
                case V_SgAssignOp:
                case V_SgDivAssignOp:
                case V_SgIorAssignOp:
                case V_SgLshiftAssignOp:
                case V_SgMinusAssignOp:
                case V_SgModAssignOp:
                case V_SgMultAssignOp:
                case V_SgPlusAssignOp:
                case V_SgPointerAssignOp:
                case V_SgRshiftAssignOp:
                case V_SgXorAssignOp:
                {
                    //We want to set all the varRefs from the LHS as being defined here.
                    std::vector<SgNode*> defs;
                    defs.assign(attrs[0].getDefs().begin(), attrs[0].getDefs().end());
                    defs.assign(attrs[0].getUses().begin(), attrs[0].getUses().end());

                    //We want to set all the varRefs from the RHS as being used here
                    std::vector<SgNode*> uses;
                    uses.assign(attrs[1].getDefs().begin(), attrs[1].getDefs().end());
                    uses.assign(attrs[1].getUses().begin(), attrs[1].getUses().end());

                    //Set all the defs as being defined here.
                    foreach(nodeVec::value_type& iter, defs)
                    {
                        //Get the unique name of the def.
                        VarUniqueName * uName = varRename->getUniqueName(iter);
                        ROSE_ASSERT(uName);

                        //Add the varRef as a definition at the current node of the ref's uniqueName
                        varRename->getDefTable()[op][uName->getKey()].push_back(node);

                        if(varRename->getDebug())
                        {
                            cout << "Found def for " << uName->getNameString() << " at " << op->cfgForBeginning().toStringForDebugging() << endl;
                        }
                    }

                    //Set all the uses as being used here.
                    foreach(nodeVec::value_type& iter, uses)
                    {
                        //Get the unique name of the def.
                        VarUniqueName * uName = varRename->getUniqueName(iter);
                        ROSE_ASSERT(uName);

                        //Add the varRef as a use at the current node of the ref's uniqueName
                        //We will correct the reference later.
                        varRename->getUseTable()[op][uName->getKey()].push_back(iter);

                        if(varRename->getDebug())
                        {
                            cout << "Found use for " << uName->getNameString() << " at " << op->cfgForBeginning().toStringForDebugging() << endl;
                        }
                    }

                    //Cut off the uses here. We will only pass up the defs.
                    return VariableRenaming::VarDefUseSynthAttr(defs, NULL);
                }
                //Otherwise cover all the non-defining Ops
                default:
                {
                    //We want to set all the varRefs as being used here
                    std::vector<SgNode*> uses;
                    uses.assign(attrs[1].getDefs().begin(), attrs[1].getDefs().end());
                    uses.assign(attrs[1].getUses().begin(), attrs[1].getUses().end());
                    uses.assign(attrs[0].getDefs().begin(), attrs[0].getDefs().end());
                    uses.assign(attrs[0].getUses().begin(), attrs[0].getUses().end());

                    //Set all the uses as being used here.
                    foreach(nodeVec::value_type& iter, uses)
                    {
                        //Get the unique name of the def.
                        VarUniqueName * uName = varRename->getUniqueName(iter);
                        ROSE_ASSERT(uName);

                        //Add the varRef as a use at the current node of the ref's uniqueName
                        //We will correct the reference later.
                        varRename->getUseTable()[op][uName->getKey()].push_back(iter);

                        if(varRename->getDebug())
                        {
                            cout << "Found use for " << uName->getNameString() << " at " << op->cfgForBeginning().toStringForDebugging() << endl;
                        }
                    }

                    //Return all the uses.
                    return VariableRenaming::VarDefUseSynthAttr(NULL, uses);
                }
            }
        }
        else
        {
            cout << "Error: BinaryOp without exactly 2 children." << endl;
            ROSE_ASSERT(false);
        }

    }
    //Catch all unary oprtations here.
    else if(isSgUnaryOp(node))
    {
        SgUnaryOp* op = isSgUnaryOp(node);

        //If we have an assigning operation, we want to list everything as being defined
        //Otherwise, everything is being used.
        VariantT type = op->variantT();
        switch(type)
        {
            //Defines the variable
            case V_SgMinusMinusOp:
            case V_SgPlusPlusOp:
            {
                std::vector<SgNode*> defs;
                defs.assign(attrs[0].getDefs().begin(), attrs[0].getDefs().end());
                defs.assign(attrs[0].getUses().begin(), attrs[0].getUses().end());

                //Set all the defs as being defined here.
                foreach(nodeVec::value_type& iter, defs)
                {
                    //Get the unique name of the def.
                    VarUniqueName * uName = varRename->getUniqueName(iter);
                    ROSE_ASSERT(uName);

                    //Add the varRef as a definition at the current node of the ref's uniqueName
                    varRename->getDefTable()[op][uName->getKey()].push_back(node);

                    if(varRename->getDebug())
                    {
                        cout << "Found def for " << uName->getNameString() << " at " << op->cfgForBeginning().toStringForDebugging() << endl;
                    }
                }

                //Return the defs from this node.
                return VariableRenaming::VarDefUseSynthAttr(defs, NULL);
            }
            default:
            {
                //For all non-defining Unary Ops, add all of them as uses
                //We want to set all the varRefs as being used here
                std::vector<SgNode*> uses;

                //Guard agains unary ops that have no children (exception rethrow statement)
                if(attrs.size() > 0)
                {
                    uses.assign(attrs[0].getDefs().begin(), attrs[0].getDefs().end());
                    uses.assign(attrs[0].getUses().begin(), attrs[0].getUses().end());
                }

                //Set all the uses as being used here.
                foreach(nodeVec::value_type& iter, uses)
                {
                    //Get the unique name of the def.
                    VarUniqueName * uName = varRename->getUniqueName(iter);
                    ROSE_ASSERT(uName);

                    //Add the varRef as a use at the current node of the ref's uniqueName
                    //We will correct the reference later.
                    varRename->getUseTable()[op][uName->getKey()].push_back(iter);

                    if(varRename->getDebug())
                    {
                        cout << "Found use for " << uName->getNameString() << " at " << op->cfgForBeginning().toStringForDebugging() << endl;
                    }
                }

                //Return the combined defs and uses.
                return VariableRenaming::VarDefUseSynthAttr(NULL, uses);
            }
        }
    }
    else if(isSgStatement(node))
    {
        //Don't propogate uses and defs up to the statement level
        return VariableRenaming::VarDefUseSynthAttr();
    }

    //For the default case, we merge the defs and uses of every attribute and pass them upwards
    std::vector<SgNode*> defs;
    std::vector<SgNode*> uses;
    for(unsigned int i = 0; i < attrs.size(); i++)
    {
        cout << "Merging attr[" << i << "]" << endl;
        defs.insert(defs.end(), attrs[i].getDefs().begin(), attrs[i].getDefs().end());
        uses.insert(uses.end(), attrs[i].getUses().begin(), attrs[i].getUses().end());
    }

    //Set all the defs as being defined here.
    foreach(nodeVec::value_type& iter, defs)
    {
        //Get the unique name of the def.
        VarUniqueName * uName = varRename->getUniqueName(iter);
        ROSE_ASSERT(uName);

        //Add the varRef as a definition at the current node of the ref's uniqueName
        varRename->getDefTable()[node][uName->getKey()].push_back(node);

        if(varRename->getDebug())
        {
            cout << "Found def for " << uName->getNameString() << " at " << node->cfgForBeginning().toStringForDebugging() << endl;
        }
    }

    //Set all the uses as being used here.
    foreach(nodeVec::value_type& iter, uses)
    {
        //Get the unique name of the def.
        VarUniqueName * uName = varRename->getUniqueName(iter);
        ROSE_ASSERT(uName);

        //Add the varRef as a use at the current node of the ref's uniqueName
        //We will correct the reference later.
        varRename->getUseTable()[node][uName->getKey()].push_back(iter);

        if(varRename->getDebug())
        {
            cout << "Found use for " << uName->getNameString() << " at " << node->cfgForBeginning().toStringForDebugging() << endl;
        }
    }

    

    return VariableRenaming::VarDefUseSynthAttr(defs, uses);
}

void VariableRenaming::runDefUse(SgFunctionDefinition* func)
{
    //Keep track of visited nodes
    vector<SgNode*> visited;

    typedef FilteredCFGNode<IsDefUseFilter> cfgNode;
    typedef FilteredCFGEdge<IsDefUseFilter> cfgEdge;
    typedef std::vector<cfgNode> nodeVec;
    typedef std::vector<cfgEdge> edgeVec;
    
    nodeVec worklist;

    cfgNode current = cfgNode(func->cfgForBeginning());
    worklist.push_back(current);

    while(!worklist.empty())
    {
        //Get the node to work on
        current = worklist.front();
        worklist.erase(worklist.begin());

        //We don't want to do def_use on the ending CFGNode of the function definition
        //so if we see it, continue.

        if(current == cfgNode(func->cfgForEnd()))
        {
            if(DEBUG_MODE)
                cout << "Skipped defUse on End of function definition." << endl;
            continue;
        }

        bool copied = false;
        bool changed = defUse(current, &copied);

        //Get the outgoing edges
        edgeVec outEdges = current.outEdges();

        //For every edge, add it to the worklist if it is not seen or something has changed
        foreach(edgeVec::value_type& edge, outEdges)
        {
            cfgNode nextNode = edge.target();

            //Only insert the node in the worklist if it isn't there already.
            if(std::find(worklist.begin(), worklist.end(), nextNode) == worklist.end())
            {
                if(changed || copied)
                {
                    //Add the node to the worklist
                    worklist.push_back(nextNode);
                    if(DEBUG_MODE)
                        cout << "Defs Changed: Added " << nextNode.getNode()->class_name() << nextNode.getNode() << " to the worklist." << endl;
                }
                //If the next node has not yet been visited
                else if(std::find(visited.begin(), visited.end(), nextNode.getNode()) == visited.end())
                {
                    //Add it to the worklist
                    worklist.push_back(nextNode);
                    if(DEBUG_MODE)
                        cout << "Next unvisited: Added " << nextNode.getNode()->class_name() << nextNode.getNode() << " to the worklist." << endl;
                }
            }
            
        }

        //Mark the current node as seen
        visited.push_back(current.getNode());

        if(DEBUG_MODE)
            cout << "-------------------------" << endl;
    }
}

bool VariableRenaming::defUse(FilteredCFGNode<IsDefUseFilter> node, bool *copied)
{
    SgNode* current = node.getNode();

    //Handle each type of node
    if(DEBUG_MODE)
        cout << "Performing DefUse on " << current->class_name() << ":" << current << endl;

    bool defChanged = false;
    bool useChanged = false;
    defChanged = mergeDefs(node);
    useChanged = resolveUses(node);

    if(DEBUG_MODE)
        cout << "Defs were " << ((defChanged)?"changed.":"same.") << endl;
    
    return defChanged;
}

bool VariableRenaming::mergeDefs(cfgNode curNode)
{
    SgNode* node = curNode.getNode();

    bool changed = false;

    if(DEBUG_MODE)
    {
        cout << "merging defs..." << endl;
        printDefs(node);
    }

    //We have the definitions stored as follows:
    //defTable contans the definitions as propogated by the CFG analysis
    //originalDefTable contains the original definitions that are part of the
    //given statement.

    //When we want to propogate the defs from the previous node(s) to this one,
    //We perform a few steps. This is dependent on the number of incoming edges.

    /*1 Edge: When we have linear control flow, we do the following:
    *        1. Copy the definitions from the previous node wholesale to a staging table.
    *        2. Copy in the original definitions from the current node, overwriting those
    *           from the previous node.
    *        3. Compare the staging and current tables, and only overwrite if needed.
    */

    /*2+ Edges: When we have branched control flow, we do the following:
     *       1. Copy the definitions from the previous node(s) wholesale to a staging table.
     *          Be careful to not insert duplicates.
     *       2. Copy in the original definitions from the current node, overwriting those
     *          from the previous node(s).
     *       3. Compare the staging and current tables, and only overwrite if needed.
     */

    //To test for changes, we perform a deep copy of the original table entry and compare it
    //to the final version.

    tableEntry propDefs;
    //Retrieve the defs coming from previous cfgNodes
    aggregatePreviousDefs(curNode, propDefs);
    
    //Replace every entry in staging table that has definition in original defs
    foreach(tableEntry::value_type& entry, originalDefTable[node])
    {
        //Replace the entry for this variable with the definitions at this node.
        propDefs[entry.first] = entry.second;
    }

    if(DEBUG_MODE_EXTRA)
    {
        cout << "Local Defs replaced in propDefs ";
        printDefs(propDefs);
    }

    //Now do a comparison to see if we should copy
    if(propDefs != defTable[node])
    {
        defTable[node] = propDefs;
        changed = true;
    }
    else
    {
        changed = false;
    }

    if(DEBUG_MODE)
    {
        cout << "Defs after Merge..." << endl;
        printDefs(node);
    }

    //Now, before we return, we want to check that any defs from the originalDefTable
    //are properly renumbered

    //First, iterate the originalDefTable
    foreach(tableEntry::value_type& entry, originalDefTable[node])
    {
        //Now, iterate the definition vector for this node
        foreach(nodeVec::value_type& defNode, entry.second)
        {
            //Assign a number to each new definition. The function will prevent duplicates
            addRenameNumberForNode(entry.first, defNode);
        }
    }

    printRenameTable();

    return changed;
}

void VariableRenaming::aggregatePreviousDefs(cfgNode curNode, tableEntry& results)
{
    SgNode* node = curNode.getNode();
    
    //Get the previous edges in the CFG for this node
    cfgEdgeVec inEdges = curNode.inEdges();

    if(inEdges.size() == 1)
    {
        SgNode* prev = inEdges[0].source().getNode();

        if(DEBUG_MODE)
        {
            cout << "Merging defs from " << prev->class_name() << prev << " to " << node->class_name() << node << endl;
            printDefs(prev);
        }

        //Copy the previous node defs to the staging table
        results = defTable[prev];
    }
    else if(inEdges.size() > 1)
    {
        //Iterate all of the incoming edges
        for(unsigned int i = 0; i < inEdges.size(); i++)
        {
            SgNode* prev = inEdges[i].source().getNode();

            if(DEBUG_MODE)
            {
                cout << "Merging defs from " << prev->class_name() << prev << endl;
                printDefs(prev);
            }

            //Perform the union of all the infoming definitions.
            foreach(tableEntry::value_type& entry, defTable[prev])
            {
                //Insert the definitions for this node at the end of the list
                results[entry.first].insert(results[entry.first].end(), entry.second.begin(), entry.second.end());
            }
        }
    }

    //Sort every vector in propDefs and remove duplicates
    foreach(tableEntry::value_type& entry, results)
    {
        std::sort(entry.second.begin(), entry.second.end());
        //Create new sequence of unique elements and remove duplicate ones
        entry.second.resize(std::unique(entry.second.begin(), entry.second.end()) - entry.second.begin());
    }

    if(DEBUG_MODE_EXTRA)
    {
        cout << "Merged propDefs ";
        printDefs(results);
    }

    return;
}

bool VariableRenaming::resolveUses(FilteredCFGNode<IsDefUseFilter> curNode)
{
    SgNode* node = curNode.getNode();
    
    bool changed = false;

    //We want to resolve the uses at the current node
    //We need to look to the defs at the current node, and match them
    //with the uses


    if(DEBUG_MODE)
        cout << "Resolving uses at " << node->class_name() << node << endl;

    //Iterate every use at the current node
    foreach(tableEntry::value_type& entry, useTable[node])
    {
        //Check the defs that are active at the current node to find the reaching definition
        //We want to check if there is a definition entry for this use at the current node
        if(defTable[node].find(entry.first) != defTable[node].end())
        {
            //There is a definition entry. Now we want to see if the use is already up to date
            if(useTable[node][entry.first] != defTable[node][entry.first])
            {
                //The use was not up to date, so we update it
                changed = true;
                //Overwrite the use with this definition location(s).
                useTable[node][entry.first] = defTable[node][entry.first];
            }            
        }
        else
        {
            cout << "Error: Use at node does not have propogated def at same node." << endl;
            ROSE_ASSERT(false);
        }
    }

    tableEntry results;
    //Get the previous defs
    aggregatePreviousDefs(curNode, results);

    //However, if there is a def at the current node, we want to use the previous
    //def as the use for this node.

    //Iterate every use at the current node
    foreach(tableEntry::value_type& entry, useTable[node])
    {
        //If any of these uses are for a variable defined at this node, we will
        //set the flag and correct it later.
        if(originalDefTable[node].count(entry.first) != 0)
        {
            useTable[node][entry.first] = results[entry.first];

            if(DEBUG_MODE)
                cout << "Fixed use of local def." << endl;
        }
    }

    return changed;
}

int VariableRenaming::getRenameNumberForNode(const varName& var, SgNode* node)
{
    ROSE_ASSERT(node);

    //Try and get the number for the node
    if(nodeRenameTable[var].count(node) == 1)
    {
        return nodeRenameTable[var][node];
    }
    //Node not in table
    else
    {
        return -1;
    }
}

SgNode* VariableRenaming::getNodeForRenameNumber(const varName& var, int num)
{
    ROSE_ASSERT(num > 0);

    //Try and get the node for the number
    if(numRenameTable[var].count(num) == 1)
    {
        return numRenameTable[var][num];
    }
    //Number not in table
    else
    {
        return NULL;
    }
}

int VariableRenaming::addRenameNumberForNode(const varName& var, SgNode* node)
{
    ROSE_ASSERT(node);

    //Check if the var/node combination is already in the table.
    if(nodeRenameTable[var].count(node) == 1)
    {
        return nodeRenameTable[var][node];
    }

    //Not in the table, so we now need to add it.
    int nextNum = nodeRenameTable[var].size() + 1;

    nodeRenameTable[var][node] = nextNum;
    numRenameTable[var][nextNum] = node;

    if(DEBUG_MODE)
        cout << "Renaming Added:[" << keyToString(var) << "]:" << nextNum << " - " << node << endl;

    return nextNum;
}
