#include <sage3basic.h>

void
SgCastExp::post_construction_initialization()
   {
   }

// DQ (6/14/2005): Modified to make enum name consistant with elsewhere in ROSE (Sage III)
// $CLASSNAME::Sg_e_cast_type
SgCastExp::cast_type_enum
SgCastExp::cast_type() const
   {
     return p_cast_type;
   }

// DQ (1/17/2008): Added set_type function since this is one of a few IR nodes that require
// the type to be held explicitly, for all other IR nodes the type is computed dynamicly.
void
SgCastExp::set_type( SgType* type )
   {
     p_expression_type = type;
   }

SgType*
SgCastExp::get_type() const
   {
  // DQ (1/16/2006): In this function we want to return the stored p_expression_type.
  // This IR node has to store the type explicitly since there is no other way to
  // recover what the cast is TO (since the operand stored what the cast in FROM).

     ROSE_ASSERT(p_expression_type != NULL);
     return p_expression_type;
   }

bool
SgCastExp::cast_looses_precision()
   {
  // DQ (10/24/2014): Added support to determine when cast should be allowable.
  // This is used in the SageInterace support for evaluation of constant expressions.

     bool result = false;
     if (isSgTypeDouble(p_expression_type) != NULL && isSgTypeFloat(p_expression_type) != NULL)
        {
          SgExpression* operand = this->get_operand();
          ROSE_ASSERT(operand != NULL);

          SgType* operantType = operand->get_type();
          ROSE_ASSERT(operantType != NULL);

          if (isSgTypeInt(operantType) != NULL         || isSgTypeLong(operantType) != NULL         || isSgTypeShort(operantType) != NULL         || isSgTypeChar(operantType) != NULL ||
              isSgTypeUnsignedInt(operantType) != NULL || isSgTypeUnsignedLong(operantType) != NULL || isSgTypeUnsignedShort(operantType) != NULL || isSgTypeUnsignedChar(operantType) != NULL ||
              isSgTypeSignedInt(operantType) != NULL   || isSgTypeSignedLong(operantType) != NULL   || isSgTypeSignedShort(operantType) != NULL   || isSgTypeSignedChar(operantType) != NULL)
             {
               result = true;
             }
        }

     return result;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgCastExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgCastExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgCastExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgCastExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgCastExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgCastExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

std::string
SgCastExp::cast_type_to_string ( enum cast_type_enum cast_type )
   {
     std::string s;

     switch (cast_type)
       {
         case e_unknown: s = "e_unknown"; break;
         case e_default: s = "e_default"; break;
         case e_C_style_cast: s = "e_C_style_cast"; break;
         case e_const_cast: s = "e_const_cast"; break;
         case e_static_cast: s = "e_static_cast"; break;
         case e_dynamic_cast: s = "e_dynamic_cast"; break;
         case e_reinterpret_cast: s = "e_reinterpret_cast"; break;
         case e_safe_cast: s = "e_safe_cast"; break;
         case e_ada_type_qualification: s = "e_ada_type_qualification"; break;
         case e_last_cast: s = "e_last_cast"; break;

         default:
              printf ("ERROR: default reached in switch: cast_type = %d \n",cast_type);
       }

     return s;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgCastExp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgCastExp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgCastExp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgCastExp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgCastExp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgCastExp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }
