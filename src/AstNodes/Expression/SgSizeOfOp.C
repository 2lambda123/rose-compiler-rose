#include <sage3basic.h>

SgType*
SgSizeOfOp::get_type() const
   {
  // This function returns an unsigned integer representing the size of type
  // (the unsigned int should match size_t, which may or may not be defined).

     ROSE_ASSERT(p_operand_expr != NULL || p_operand_type != NULL);

#if 0
     printf ("In SgSizeOfOp::get_type() \n");
#endif

     SgType* returnType = SgTypeUnsignedInt::createType();

     ROSE_ASSERT(returnType != NULL);
     return returnType;
   }

// Liao, 11/17/2009
int
SgSizeOfOp::replace_expression (SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if (get_operand_expr() == o)
        {
          set_operand_expr(n);
          return 1;
        }
       else
        {
          printf ("Warning: inside of SgSizeOfOp::replace_expression original SgExpression unidentified \n");
          return 0;
        }
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgSizeOfOp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgSizeOfOp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgSizeOfOp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgSizeOfOp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgSizeOfOp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgSizeOfOp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgSizeOfOp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgSizeOfOp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgSizeOfOp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgSizeOfOp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgSizeOfOp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgSizeOfOp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }
