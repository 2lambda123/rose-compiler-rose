#include <sage3basic.h>

void
SgNewExp::post_construction_initialization()
   {
     if(p_constructor_args)
        {
          p_constructor_args->set_parent(this);
          p_constructor_args->set_need_paren(true);
        }

     if(p_builtin_args)
        {
          p_builtin_args->set_parent(this);
        }

     if(p_placement_args)
          p_placement_args->set_parent(this);
   }


SgExpression*
SgNewExp::get_next(int& n) const
   {
  // SgExpression *tmp = NULL;
     if(n==0)
        {
          n++;
          if(get_placement_args()) return get_placement_args();
            else
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }
        }
       else
          if(n==1)
             {
               n++;
               if(get_constructor_args())
                    return get_constructor_args();
                 else
                    return get_builtin_args();
             }

     return NULL;
   }

int
SgNewExp::replace_expression(SgExpression *o, SgExpression *n)
   {
  // DQ (12/17/2006): This function should have the semantics that it will represent a
  // structural change to the AST, thus it is free to set the parent of the new expression.

     ROSE_ASSERT(o != NULL);
     ROSE_ASSERT(n != NULL);

     if(get_placement_args()==o)
        {
          set_placement_args(isSgExprListExp(n));
          n->set_parent(this);
          return 1;
        }
       else
        {
          if(get_constructor_args()==o)
             {
               set_constructor_args(isSgConstructorInitializer(n));
               n->set_parent(this);
               return 1;
             }
            else
             {
               if(get_builtin_args()==o)
                  {
                    set_builtin_args(n);
                    n->set_parent(this);
                    return 1;
                  }
                 else
                  {
                    return 0;
                  }
             }
        }
   }

SgType*
SgNewExp::get_type() const
   {
  // The p_constructor_args really just identifies the constructor being called,
  // from which we can get the type to be returned from the new operator!
  // If there is no constructor then this might be a primative type or perhaps
  // a class or struct without an explicit constructor.

  // Since where the p_constructor_args->get_declaration() == NULL (often for primative types)
  // we need the explicitly stored p_expression_type pointer anyway so we can just make it the
  // return type for all cases.
     ROSE_ASSERT(p_specified_type != NULL);
     SgType* returnType = SgPointerType::createType(p_specified_type);

     ROSE_ASSERT(returnType != NULL);

     return returnType;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgNewExp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgNewExp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgNewExp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgNewExp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgNewExp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgNewExp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }


// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgNewExp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgNewExp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgNewExp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgNewExp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgNewExp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgNewExp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }
