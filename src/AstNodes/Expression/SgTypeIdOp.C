#include <sage3basic.h>

SgType*
SgTypeIdOp::get_type() const
   {
#if 0
     printf ("In $CLASSNAME::get_type() \n");
#endif

    // get_type on SgTypeIdOp must always retuen a const referene to "std::type_info"

     SgType* returnType = NULL;
     // If we call get_type() on a node that is not fully build then this will break.
     SgGlobal* globalScope = SageInterface::getGlobalScope(this);
     ROSE_ASSERT(globalScope && "globalScope is NULL");

     SgNamespaceSymbol* stdNamespaceSymbol = globalScope->lookup_namespace_symbol(SgName("std"));
     ROSE_ASSERT(stdNamespaceSymbol && "lookup_namespace_symbol did not found std symbol");

     SgNamespaceDeclarationStatement *  namespaceDeclarationStatement   = stdNamespaceSymbol->get_declaration ();
     SgNamespaceDefinitionStatement * namespaceDefinitionStatement = namespaceDeclarationStatement->get_definition();
     ROSE_ASSERT(namespaceDefinitionStatement && "get_definition() retured NULL");

     SgClassSymbol * typeInfoClassSymbol = namespaceDefinitionStatement->lookup_class_symbol(SgName("type_info"));
     ROSE_ASSERT(typeInfoClassSymbol && "lookup_class_symbol did not found type_info symbol");

     //returnType = SageInterface::deepCopy(typeInfoClassSymbol->get_type());
     returnType = typeInfoClassSymbol->get_type();
     ROSE_ASSERT(isSgClassType(returnType));


     SgModifierType* constType =  SageBuilder::buildConstType(returnType);
     ROSE_ASSERT (constType);
     SgReferenceType * constRefType = SageBuilder::buildReferenceType(constType);
     return constRefType;
   }

// DQ (6/11/2015): Moved these six access functions, they should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTypeIdOp::get_name_qualification_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_length;
   }

void
SgTypeIdOp::set_name_qualification_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_length = name_qualification_length;
   }

bool
SgTypeIdOp::get_type_elaboration_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_required;
   }

void
SgTypeIdOp::set_type_elaboration_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_required = type_elaboration_required;
   }

bool
SgTypeIdOp::get_global_qualification_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_required;
   }

void
SgTypeIdOp::set_global_qualification_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_required = global_qualification_required;
   }

// DQ (4/15/2019): These six access functions should not be generated by ROSETTA
// so that we could avoid them setting the isModified flag which is a problem in the
// name qualification support for C++ (interfering with the token-based unparsing).
int
SgTypeIdOp::get_name_qualification_for_pointer_to_member_class_length () const
   {
     ROSE_ASSERT (this != NULL);
     return p_name_qualification_for_pointer_to_member_class_length;
   }

void
SgTypeIdOp::set_name_qualification_for_pointer_to_member_class_length ( int name_qualification_length )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_name_qualification_for_pointer_to_member_class_length = name_qualification_length;
   }

bool
SgTypeIdOp::get_type_elaboration_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_type_elaboration_for_pointer_to_member_class_required;
   }

void
SgTypeIdOp::set_type_elaboration_for_pointer_to_member_class_required ( bool type_elaboration_required )
   {
     ROSE_ASSERT (this != NULL);
  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_type_elaboration_for_pointer_to_member_class_required = type_elaboration_required;
   }

bool
SgTypeIdOp::get_global_qualification_for_pointer_to_member_class_required () const
   {
     ROSE_ASSERT (this != NULL);
     return p_global_qualification_for_pointer_to_member_class_required;
   }

void
SgTypeIdOp::set_global_qualification_for_pointer_to_member_class_required ( bool global_qualification_required )
   {
     ROSE_ASSERT (this != NULL);

  // This can't be called by the name qualification API (see test2015_26.C).
  // set_isModified(true);

     p_global_qualification_for_pointer_to_member_class_required = global_qualification_required;
   }
