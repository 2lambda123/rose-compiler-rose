// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh//"
// # 1 "<built-in>"
// # 1 "<command-line>"
// # 1 "/usr/include/stdc-predef.h" 1 3 4
// # 1 "<command-line>" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc"
// # 16 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_config.h" 1
// # 29 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 41 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
// # 1 "/usr/include/stdio.h" 1 3 4
// # 27 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/features.h" 1 3 4
// # 375 "/usr/include/features.h" 3 4
// # 1 "/usr/include/sys/cdefs.h" 1 3 4
// # 392 "/usr/include/sys/cdefs.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 393 "/usr/include/sys/cdefs.h" 2 3 4
// # 376 "/usr/include/features.h" 2 3 4
// # 399 "/usr/include/features.h" 3 4
// # 1 "/usr/include/gnu/stubs.h" 1 3 4
// # 10 "/usr/include/gnu/stubs.h" 3 4
// # 1 "/usr/include/gnu/stubs-64.h" 1 3 4
// # 11 "/usr/include/gnu/stubs.h" 2 3 4
// # 400 "/usr/include/features.h" 2 3 4
// # 28 "/usr/include/stdio.h" 2 3 4

extern "C" {



// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 212 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 3 4
typedef long unsigned int size_t;
// # 34 "/usr/include/stdio.h" 2 3 4

// # 1 "/usr/include/bits/types.h" 1 3 4
// # 27 "/usr/include/bits/types.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
// # 130 "/usr/include/bits/types.h" 3 4
// # 1 "/usr/include/bits/typesizes.h" 1 3 4
// # 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
// # 36 "/usr/include/stdio.h" 2 3 4
// # 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





// # 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
// # 74 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/libio.h" 1 3 4
// # 32 "/usr/include/libio.h" 3 4
// # 1 "/usr/include/_G_config.h" 1 3 4
// # 15 "/usr/include/_G_config.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 16 "/usr/include/_G_config.h" 2 3 4




// # 1 "/usr/include/wchar.h" 1 3 4
// # 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
// # 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
// # 33 "/usr/include/libio.h" 2 3 4
// # 50 "/usr/include/libio.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdarg.h" 1 3 4
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
// # 51 "/usr/include/libio.h" 2 3 4
// # 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
// # 155 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
// # 178 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
// # 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
// # 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
// # 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};





struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
// # 339 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);




typedef __io_read_fn cookie_read_function_t;
typedef __io_write_fn cookie_write_function_t;
typedef __io_seek_fn cookie_seek_function_t;
typedef __io_close_fn cookie_close_function_t;


typedef struct
{
  __io_read_fn *read;
  __io_write_fn *write;
  __io_seek_fn *seek;
  __io_close_fn *close;
} _IO_cookie_io_functions_t;
typedef _IO_cookie_io_functions_t cookie_io_functions_t;

struct _IO_cookie_file;


extern void _IO_cookie_init (struct _IO_cookie_file *__cfile, int __read_write,
        void *__cookie, _IO_cookie_io_functions_t __fns);




extern "C" {


extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
// # 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) throw ();
extern int _IO_ferror (_IO_FILE *__fp) throw ();

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) throw ();
extern void _IO_funlockfile (_IO_FILE *) throw ();
extern int _IO_ftrylockfile (_IO_FILE *) throw ();
// # 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) throw ();
// # 527 "/usr/include/libio.h" 3 4
}
// # 75 "/usr/include/stdio.h" 2 3 4




typedef __gnuc_va_list va_list;
// # 92 "/usr/include/stdio.h" 3 4
typedef __off64_t off_t;




typedef __off64_t off64_t;




typedef __ssize_t ssize_t;









typedef _G_fpos64_t fpos_t;



typedef _G_fpos64_t fpos64_t;
// # 164 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/bits/stdio_lim.h" 1 3 4
// # 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) throw ();

extern int rename (const char *__old, const char *__new) throw ();




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) throw ();



// # 198 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void) __asm__ ("" "tmpfile64") ;






extern FILE *tmpfile64 (void) ;



extern char *tmpnam (char *__s) throw () ;





extern char *tmpnam_r (char *__s) throw () ;
// # 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     throw () __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

// # 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
// # 262 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);




// # 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename, const char *__restrict __modes) __asm__ ("" "fopen64")

  ;
extern FILE *freopen (const char *__restrict __filename, const char *__restrict __modes, FILE *__restrict __stream) __asm__ ("" "freopen64")


  ;







extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes) ;
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) ;




extern FILE *fdopen (int __fd, const char *__modes) throw () ;





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     _IO_cookie_io_functions_t __io_funcs) throw () ;




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  throw () ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) throw () ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) throw ();



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) throw ();





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) throw ();


extern void setlinebuf (FILE *__stream) throw ();








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) throw ();





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) throw ();





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 3, 0)));






extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__printf__, 2, 0))) ;
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3))) ;




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) throw ();
// # 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     throw () __attribute__ ((__format__ (__scanf__, 2, 0)));
// # 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

// # 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
// # 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

// # 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
// # 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


// # 649 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) ;
// # 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

// # 726 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
// # 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

// # 781 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off64_t __off, int __whence) __asm__ ("" "fseeko64")

                  ;
extern __off64_t ftello (FILE *__stream) __asm__ ("" "ftello64");








// # 806 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos) __asm__ ("" "fgetpos64")
                                          ;
extern int fsetpos (FILE *__stream, const fpos_t *__pos) __asm__ ("" "fsetpos64")
                                                          ;








extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) ;
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);




extern void clearerr (FILE *__stream) throw ();

extern int feof (FILE *__stream) throw () ;

extern int ferror (FILE *__stream) throw () ;




extern void clearerr_unlocked (FILE *__stream) throw ();
extern int feof_unlocked (FILE *__stream) throw () ;
extern int ferror_unlocked (FILE *__stream) throw () ;








extern void perror (const char *__s);






// # 1 "/usr/include/bits/sys_errlist.h" 1 3 4
// # 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];


extern int _sys_nerr;
extern const char *const _sys_errlist[];
// # 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) throw () ;




extern int fileno_unlocked (FILE *__stream) throw () ;
// # 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) throw ();





extern char *cuserid (char *__s);




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     throw () __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     throw () __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) throw ();



extern int ftrylockfile (FILE *__stream) throw () ;


extern void funlockfile (FILE *__stream) throw ();
// # 934 "/usr/include/stdio.h" 3 4
// # 1 "/usr/include/bits/stdio.h" 1 3 4
// # 35 "/usr/include/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) feof_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) ferror_unlocked (FILE *__stream) throw ()
{
  return (((__stream)->_flags & 0x20) != 0);
}
// # 935 "/usr/include/stdio.h" 2 3 4
// # 943 "/usr/include/stdio.h" 3 4
}
// # 42 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdarg.h" 1 3 4
// # 43 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/usr/include/stdlib.h" 1 3 4
// # 32 "/usr/include/stdlib.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 33 "/usr/include/stdlib.h" 2 3 4

extern "C" {






// # 1 "/usr/include/bits/waitflags.h" 1 3 4
// # 42 "/usr/include/stdlib.h" 2 3 4
// # 1 "/usr/include/bits/waitstatus.h" 1 3 4
// # 64 "/usr/include/bits/waitstatus.h" 3 4
// # 1 "/usr/include/endian.h" 1 3 4
// # 36 "/usr/include/endian.h" 3 4
// # 1 "/usr/include/bits/endian.h" 1 3 4
// # 37 "/usr/include/endian.h" 2 3 4
// # 60 "/usr/include/endian.h" 3 4
// # 1 "/usr/include/bits/byteswap.h" 1 3 4
// # 28 "/usr/include/bits/byteswap.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 29 "/usr/include/bits/byteswap.h" 2 3 4






// # 1 "/usr/include/bits/byteswap-16.h" 1 3 4
// # 36 "/usr/include/bits/byteswap.h" 2 3 4
// # 44 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
// # 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
// # 61 "/usr/include/endian.h" 2 3 4
// # 65 "/usr/include/bits/waitstatus.h" 2 3 4

union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
// # 43 "/usr/include/stdlib.h" 2 3 4
// # 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


// # 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) throw () ;




extern double atof (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) throw () __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     throw () __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     throw () __attribute__ ((__nonnull__ (1)));

// # 235 "/usr/include/stdlib.h" 3 4
// # 1 "/usr/include/xlocale.h" 1 3 4
// # 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
// # 236 "/usr/include/stdlib.h" 2 3 4



extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     __locale_t __loc) throw () __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         __locale_t __loc)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) atoi (const char *__nptr) throw ()
{
  return (int) strtol (__nptr, (char **) __null, 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__leaf__)) atol (const char *__nptr) throw ()
{
  return strtol (__nptr, (char **) __null, 10);
}




__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__leaf__)) atoll (const char *__nptr) throw ()
{
  return strtoll (__nptr, (char **) __null, 10);
}

// # 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) throw () ;


extern long int a64l (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




// # 1 "/usr/include/sys/types.h" 1 3 4
// # 27 "/usr/include/sys/types.h" 3 4
extern "C" {





typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;





typedef __ino64_t ino_t;




typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
// # 98 "/usr/include/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
// # 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
// # 132 "/usr/include/sys/types.h" 3 4
// # 1 "/usr/include/time.h" 1 3 4
// # 57 "/usr/include/time.h" 3 4


typedef __clock_t clock_t;



// # 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



// # 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
// # 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
// # 133 "/usr/include/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
// # 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
// # 219 "/usr/include/sys/types.h" 3 4
// # 1 "/usr/include/sys/select.h" 1 3 4
// # 30 "/usr/include/sys/select.h" 3 4
// # 1 "/usr/include/bits/select.h" 1 3 4
// # 22 "/usr/include/bits/select.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 23 "/usr/include/bits/select.h" 2 3 4
// # 31 "/usr/include/sys/select.h" 2 3 4


// # 1 "/usr/include/bits/sigset.h" 1 3 4
// # 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
// # 34 "/usr/include/sys/select.h" 2 3 4



typedef __sigset_t sigset_t;





// # 1 "/usr/include/time.h" 1 3 4
// # 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };
// # 44 "/usr/include/sys/select.h" 2 3 4

// # 1 "/usr/include/bits/time.h" 1 3 4
// # 30 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
// # 46 "/usr/include/sys/select.h" 2 3 4
// # 54 "/usr/include/sys/select.h" 3 4
typedef long int __fd_mask;
// # 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
// # 96 "/usr/include/sys/select.h" 3 4
extern "C" {
// # 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
// # 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
// # 131 "/usr/include/sys/select.h" 3 4
}
// # 220 "/usr/include/sys/types.h" 2 3 4


// # 1 "/usr/include/sys/sysmacros.h" 1 3 4
// # 29 "/usr/include/sys/sysmacros.h" 3 4
extern "C" {

__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     throw () __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     throw () __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_major (unsigned long long int __dev) throw ()
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int
__attribute__ ((__leaf__)) gnu_dev_minor (unsigned long long int __dev) throw ()
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor) throw ()
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}

}
// # 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;
// # 248 "/usr/include/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt_t;



typedef __fsblkcnt64_t fsblkcnt_t;



typedef __fsfilcnt64_t fsfilcnt_t;





typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





// # 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
// # 21 "/usr/include/bits/pthreadtypes.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
// # 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;





typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
// # 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
// # 115 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
// # 202 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
// # 271 "/usr/include/sys/types.h" 2 3 4


}
// # 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) throw ();


extern void srandom (unsigned int __seed) throw ();





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) throw () __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) throw () __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     throw () __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) throw ();

extern void srand (unsigned int __seed) throw ();




extern int rand_r (unsigned int *__seed) throw ();







extern double drand48 (void) throw ();
extern double erand48 (unsigned short int __xsubi[3]) throw () __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) throw ();
extern long int nrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) throw ();
extern long int jrand48 (unsigned short int __xsubi[3])
     throw () __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) throw ();
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     throw () __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) throw () __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) throw () __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     throw () __attribute__ ((__nonnull__ (1, 2)));









extern void *malloc (size_t __size) throw () __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     throw () __attribute__ ((__malloc__)) ;










extern void *realloc (void *__ptr, size_t __size)
     throw () __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) throw ();




extern void cfree (void *__ptr) throw ();



// # 1 "/usr/include/alloca.h" 1 3 4
// # 24 "/usr/include/alloca.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 25 "/usr/include/alloca.h" 2 3 4

extern "C" {





extern void *alloca (size_t __size) throw ();





}
// # 492 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) throw () __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     throw () __attribute__ ((__nonnull__ (1))) ;




extern void *aligned_alloc (size_t __alignment, size_t __size)
     throw () __attribute__ ((__malloc__, __alloc_size__ (2)));




extern void abort (void) throw () __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) throw () __attribute__ ((__nonnull__ (1)));




extern "C++" int at_quick_exit (void (*__func) (void))
     throw () __asm ("at_quick_exit") __attribute__ ((__nonnull__ (1)));









extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     throw () __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) throw () __attribute__ ((__noreturn__));





extern void quick_exit (int __status) throw () __attribute__ ((__noreturn__));







extern void _Exit (int __status) throw () __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) throw () __attribute__ ((__nonnull__ (1))) ;





extern char *secure_getenv (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int putenv (char *__string) throw () __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     throw () __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) throw () __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) throw ();
// # 605 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) throw () __attribute__ ((__nonnull__ (1)));
// # 622 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __asm__ ("" "mkstemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) ;
// # 644 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __asm__ ("" "mkstemps64")
                     __attribute__ ((__nonnull__ (1))) ;





extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) ;
// # 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) throw () __attribute__ ((__nonnull__ (1))) ;
// # 676 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __asm__ ("" "mkostemp64")
     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) ;
// # 697 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags) __asm__ ("" "mkostemps64")

     __attribute__ ((__nonnull__ (1))) ;





extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) ;









extern int system (const char *__command) ;






extern char *canonicalize_file_name (const char *__name)
     throw () __attribute__ ((__nonnull__ (1))) ;
// # 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) throw () ;






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);





extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) throw () __attribute__ ((__const__)) ;
extern long int labs (long int __x) throw () __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     throw () __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     throw () __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     throw () __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     throw () __attribute__ ((__const__)) ;

// # 807 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) throw () __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     throw () __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     throw () __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) throw () __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (const char *__s, size_t __n) throw () ;


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) throw () ;


extern int wctomb (char *__s, wchar_t __wchar) throw () ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) throw ();

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     throw ();








extern int rpmatch (const char *__response) throw () __attribute__ ((__nonnull__ (1))) ;
// # 895 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     throw () __attribute__ ((__nonnull__ (1, 2, 3))) ;





extern void setkey (const char *__key) throw () __attribute__ ((__nonnull__ (1)));







extern int posix_openpt (int __oflag) ;







extern int grantpt (int __fd) throw ();



extern int unlockpt (int __fd) throw ();




extern char *ptsname (int __fd) throw () ;






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     throw () __attribute__ ((__nonnull__ (1)));


// # 1 "/usr/include/bits/stdlib-float.h" 1 3 4
// # 24 "/usr/include/bits/stdlib-float.h" 3 4

extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__leaf__)) atof (const char *__nptr) throw ()
{
  return strtod (__nptr, (char **) __null);
}

// # 952 "/usr/include/stdlib.h" 2 3 4
// # 964 "/usr/include/stdlib.h" 3 4
}
// # 44 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 147 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 3 4
typedef long int ptrdiff_t;
// # 45 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/usr/include/math.h" 1 3 4
// # 29 "/usr/include/math.h" 3 4
extern "C" {



// # 1 "/usr/include/bits/huge_val.h" 1 3 4
// # 34 "/usr/include/math.h" 2 3 4

// # 1 "/usr/include/bits/huge_valf.h" 1 3 4
// # 36 "/usr/include/math.h" 2 3 4
// # 1 "/usr/include/bits/huge_vall.h" 1 3 4
// # 37 "/usr/include/math.h" 2 3 4


// # 1 "/usr/include/bits/inf.h" 1 3 4
// # 40 "/usr/include/math.h" 2 3 4


// # 1 "/usr/include/bits/nan.h" 1 3 4
// # 43 "/usr/include/math.h" 2 3 4



// # 1 "/usr/include/bits/mathdef.h" 1 3 4
// # 28 "/usr/include/bits/mathdef.h" 3 4
typedef float float_t;
typedef double double_t;
// # 47 "/usr/include/math.h" 2 3 4
// # 70 "/usr/include/math.h" 3 4
// # 1 "/usr/include/bits/mathcalls.h" 1 3 4
// # 52 "/usr/include/bits/mathcalls.h" 3 4


extern double acos (double __x) throw (); extern double __acos (double __x) throw ();

extern double asin (double __x) throw (); extern double __asin (double __x) throw ();

extern double atan (double __x) throw (); extern double __atan (double __x) throw ();

extern double atan2 (double __y, double __x) throw (); extern double __atan2 (double __y, double __x) throw ();


extern double cos (double __x) throw (); extern double __cos (double __x) throw ();

extern double sin (double __x) throw (); extern double __sin (double __x) throw ();

extern double tan (double __x) throw (); extern double __tan (double __x) throw ();




extern double cosh (double __x) throw (); extern double __cosh (double __x) throw ();

extern double sinh (double __x) throw (); extern double __sinh (double __x) throw ();

extern double tanh (double __x) throw (); extern double __tanh (double __x) throw ();




extern void sincos (double __x, double *__sinx, double *__cosx) throw (); extern void __sincos (double __x, double *__sinx, double *__cosx) throw ()
                                                           ;





extern double acosh (double __x) throw (); extern double __acosh (double __x) throw ();

extern double asinh (double __x) throw (); extern double __asinh (double __x) throw ();

extern double atanh (double __x) throw (); extern double __atanh (double __x) throw ();







extern double exp (double __x) throw (); extern double __exp (double __x) throw ();


extern double frexp (double __x, int *__exponent) throw (); extern double __frexp (double __x, int *__exponent) throw ();


extern double ldexp (double __x, int __exponent) throw (); extern double __ldexp (double __x, int __exponent) throw ();


extern double log (double __x) throw (); extern double __log (double __x) throw ();


extern double log10 (double __x) throw (); extern double __log10 (double __x) throw ();


extern double modf (double __x, double *__iptr) throw (); extern double __modf (double __x, double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern double exp10 (double __x) throw (); extern double __exp10 (double __x) throw ();

extern double pow10 (double __x) throw (); extern double __pow10 (double __x) throw ();





extern double expm1 (double __x) throw (); extern double __expm1 (double __x) throw ();


extern double log1p (double __x) throw (); extern double __log1p (double __x) throw ();


extern double logb (double __x) throw (); extern double __logb (double __x) throw ();






extern double exp2 (double __x) throw (); extern double __exp2 (double __x) throw ();


extern double log2 (double __x) throw (); extern double __log2 (double __x) throw ();








extern double pow (double __x, double __y) throw (); extern double __pow (double __x, double __y) throw ();


extern double sqrt (double __x) throw (); extern double __sqrt (double __x) throw ();





extern double hypot (double __x, double __y) throw (); extern double __hypot (double __x, double __y) throw ();






extern double cbrt (double __x) throw (); extern double __cbrt (double __x) throw ();








extern double ceil (double __x) throw () __attribute__ ((__const__)); extern double __ceil (double __x) throw () __attribute__ ((__const__));


extern double fabs (double __x) throw () __attribute__ ((__const__)); extern double __fabs (double __x) throw () __attribute__ ((__const__));


extern double floor (double __x) throw () __attribute__ ((__const__)); extern double __floor (double __x) throw () __attribute__ ((__const__));


extern double fmod (double __x, double __y) throw (); extern double __fmod (double __x, double __y) throw ();




extern int __isinf (double __value) throw () __attribute__ ((__const__));


extern int __finite (double __value) throw () __attribute__ ((__const__));





extern int isinf (double __value) throw () __attribute__ ((__const__));


extern int finite (double __value) throw () __attribute__ ((__const__));


extern double drem (double __x, double __y) throw (); extern double __drem (double __x, double __y) throw ();



extern double significand (double __x) throw (); extern double __significand (double __x) throw ();





extern double copysign (double __x, double __y) throw () __attribute__ ((__const__)); extern double __copysign (double __x, double __y) throw () __attribute__ ((__const__));






extern double nan (const char *__tagb) throw () __attribute__ ((__const__)); extern double __nan (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnan (double __value) throw () __attribute__ ((__const__));



extern int isnan (double __value) throw () __attribute__ ((__const__));


extern double j0 (double) throw (); extern double __j0 (double) throw ();
extern double j1 (double) throw (); extern double __j1 (double) throw ();
extern double jn (int, double) throw (); extern double __jn (int, double) throw ();
extern double y0 (double) throw (); extern double __y0 (double) throw ();
extern double y1 (double) throw (); extern double __y1 (double) throw ();
extern double yn (int, double) throw (); extern double __yn (int, double) throw ();






extern double erf (double) throw (); extern double __erf (double) throw ();
extern double erfc (double) throw (); extern double __erfc (double) throw ();
extern double lgamma (double) throw (); extern double __lgamma (double) throw ();






extern double tgamma (double) throw (); extern double __tgamma (double) throw ();





extern double gamma (double) throw (); extern double __gamma (double) throw ();






extern double lgamma_r (double, int *__signgamp) throw (); extern double __lgamma_r (double, int *__signgamp) throw ();







extern double rint (double __x) throw (); extern double __rint (double __x) throw ();


extern double nextafter (double __x, double __y) throw () __attribute__ ((__const__)); extern double __nextafter (double __x, double __y) throw () __attribute__ ((__const__));

extern double nexttoward (double __x, long double __y) throw () __attribute__ ((__const__)); extern double __nexttoward (double __x, long double __y) throw () __attribute__ ((__const__));



extern double remainder (double __x, double __y) throw (); extern double __remainder (double __x, double __y) throw ();



extern double scalbn (double __x, int __n) throw (); extern double __scalbn (double __x, int __n) throw ();



extern int ilogb (double __x) throw (); extern int __ilogb (double __x) throw ();




extern double scalbln (double __x, long int __n) throw (); extern double __scalbln (double __x, long int __n) throw ();



extern double nearbyint (double __x) throw (); extern double __nearbyint (double __x) throw ();



extern double round (double __x) throw () __attribute__ ((__const__)); extern double __round (double __x) throw () __attribute__ ((__const__));



extern double trunc (double __x) throw () __attribute__ ((__const__)); extern double __trunc (double __x) throw () __attribute__ ((__const__));




extern double remquo (double __x, double __y, int *__quo) throw (); extern double __remquo (double __x, double __y, int *__quo) throw ();






extern long int lrint (double __x) throw (); extern long int __lrint (double __x) throw ();
extern long long int llrint (double __x) throw (); extern long long int __llrint (double __x) throw ();



extern long int lround (double __x) throw (); extern long int __lround (double __x) throw ();
extern long long int llround (double __x) throw (); extern long long int __llround (double __x) throw ();



extern double fdim (double __x, double __y) throw (); extern double __fdim (double __x, double __y) throw ();


extern double fmax (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmax (double __x, double __y) throw () __attribute__ ((__const__));


extern double fmin (double __x, double __y) throw () __attribute__ ((__const__)); extern double __fmin (double __x, double __y) throw () __attribute__ ((__const__));



extern int __fpclassify (double __value) throw ()
     __attribute__ ((__const__));


extern int __signbit (double __value) throw ()
     __attribute__ ((__const__));



extern double fma (double __x, double __y, double __z) throw (); extern double __fma (double __x, double __y, double __z) throw ();








extern double scalb (double __x, double __n) throw (); extern double __scalb (double __x, double __n) throw ();
// # 71 "/usr/include/math.h" 2 3 4
// # 89 "/usr/include/math.h" 3 4
// # 1 "/usr/include/bits/mathcalls.h" 1 3 4
// # 52 "/usr/include/bits/mathcalls.h" 3 4


extern float acosf (float __x) throw (); extern float __acosf (float __x) throw ();

extern float asinf (float __x) throw (); extern float __asinf (float __x) throw ();

extern float atanf (float __x) throw (); extern float __atanf (float __x) throw ();

extern float atan2f (float __y, float __x) throw (); extern float __atan2f (float __y, float __x) throw ();


extern float cosf (float __x) throw (); extern float __cosf (float __x) throw ();

extern float sinf (float __x) throw (); extern float __sinf (float __x) throw ();

extern float tanf (float __x) throw (); extern float __tanf (float __x) throw ();




extern float coshf (float __x) throw (); extern float __coshf (float __x) throw ();

extern float sinhf (float __x) throw (); extern float __sinhf (float __x) throw ();

extern float tanhf (float __x) throw (); extern float __tanhf (float __x) throw ();




extern void sincosf (float __x, float *__sinx, float *__cosx) throw (); extern void __sincosf (float __x, float *__sinx, float *__cosx) throw ()
                                                           ;





extern float acoshf (float __x) throw (); extern float __acoshf (float __x) throw ();

extern float asinhf (float __x) throw (); extern float __asinhf (float __x) throw ();

extern float atanhf (float __x) throw (); extern float __atanhf (float __x) throw ();







extern float expf (float __x) throw (); extern float __expf (float __x) throw ();


extern float frexpf (float __x, int *__exponent) throw (); extern float __frexpf (float __x, int *__exponent) throw ();


extern float ldexpf (float __x, int __exponent) throw (); extern float __ldexpf (float __x, int __exponent) throw ();


extern float logf (float __x) throw (); extern float __logf (float __x) throw ();


extern float log10f (float __x) throw (); extern float __log10f (float __x) throw ();


extern float modff (float __x, float *__iptr) throw (); extern float __modff (float __x, float *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern float exp10f (float __x) throw (); extern float __exp10f (float __x) throw ();

extern float pow10f (float __x) throw (); extern float __pow10f (float __x) throw ();





extern float expm1f (float __x) throw (); extern float __expm1f (float __x) throw ();


extern float log1pf (float __x) throw (); extern float __log1pf (float __x) throw ();


extern float logbf (float __x) throw (); extern float __logbf (float __x) throw ();






extern float exp2f (float __x) throw (); extern float __exp2f (float __x) throw ();


extern float log2f (float __x) throw (); extern float __log2f (float __x) throw ();








extern float powf (float __x, float __y) throw (); extern float __powf (float __x, float __y) throw ();


extern float sqrtf (float __x) throw (); extern float __sqrtf (float __x) throw ();





extern float hypotf (float __x, float __y) throw (); extern float __hypotf (float __x, float __y) throw ();






extern float cbrtf (float __x) throw (); extern float __cbrtf (float __x) throw ();








extern float ceilf (float __x) throw () __attribute__ ((__const__)); extern float __ceilf (float __x) throw () __attribute__ ((__const__));


extern float fabsf (float __x) throw () __attribute__ ((__const__)); extern float __fabsf (float __x) throw () __attribute__ ((__const__));


extern float floorf (float __x) throw () __attribute__ ((__const__)); extern float __floorf (float __x) throw () __attribute__ ((__const__));


extern float fmodf (float __x, float __y) throw (); extern float __fmodf (float __x, float __y) throw ();




extern int __isinff (float __value) throw () __attribute__ ((__const__));


extern int __finitef (float __value) throw () __attribute__ ((__const__));





extern int isinff (float __value) throw () __attribute__ ((__const__));


extern int finitef (float __value) throw () __attribute__ ((__const__));


extern float dremf (float __x, float __y) throw (); extern float __dremf (float __x, float __y) throw ();



extern float significandf (float __x) throw (); extern float __significandf (float __x) throw ();





extern float copysignf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __copysignf (float __x, float __y) throw () __attribute__ ((__const__));






extern float nanf (const char *__tagb) throw () __attribute__ ((__const__)); extern float __nanf (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanf (float __value) throw () __attribute__ ((__const__));



extern int isnanf (float __value) throw () __attribute__ ((__const__));


extern float j0f (float) throw (); extern float __j0f (float) throw ();
extern float j1f (float) throw (); extern float __j1f (float) throw ();
extern float jnf (int, float) throw (); extern float __jnf (int, float) throw ();
extern float y0f (float) throw (); extern float __y0f (float) throw ();
extern float y1f (float) throw (); extern float __y1f (float) throw ();
extern float ynf (int, float) throw (); extern float __ynf (int, float) throw ();






extern float erff (float) throw (); extern float __erff (float) throw ();
extern float erfcf (float) throw (); extern float __erfcf (float) throw ();
extern float lgammaf (float) throw (); extern float __lgammaf (float) throw ();






extern float tgammaf (float) throw (); extern float __tgammaf (float) throw ();





extern float gammaf (float) throw (); extern float __gammaf (float) throw ();






extern float lgammaf_r (float, int *__signgamp) throw (); extern float __lgammaf_r (float, int *__signgamp) throw ();







extern float rintf (float __x) throw (); extern float __rintf (float __x) throw ();


extern float nextafterf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __nextafterf (float __x, float __y) throw () __attribute__ ((__const__));

extern float nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__)); extern float __nexttowardf (float __x, long double __y) throw () __attribute__ ((__const__));



extern float remainderf (float __x, float __y) throw (); extern float __remainderf (float __x, float __y) throw ();



extern float scalbnf (float __x, int __n) throw (); extern float __scalbnf (float __x, int __n) throw ();



extern int ilogbf (float __x) throw (); extern int __ilogbf (float __x) throw ();




extern float scalblnf (float __x, long int __n) throw (); extern float __scalblnf (float __x, long int __n) throw ();



extern float nearbyintf (float __x) throw (); extern float __nearbyintf (float __x) throw ();



extern float roundf (float __x) throw () __attribute__ ((__const__)); extern float __roundf (float __x) throw () __attribute__ ((__const__));



extern float truncf (float __x) throw () __attribute__ ((__const__)); extern float __truncf (float __x) throw () __attribute__ ((__const__));




extern float remquof (float __x, float __y, int *__quo) throw (); extern float __remquof (float __x, float __y, int *__quo) throw ();






extern long int lrintf (float __x) throw (); extern long int __lrintf (float __x) throw ();
extern long long int llrintf (float __x) throw (); extern long long int __llrintf (float __x) throw ();



extern long int lroundf (float __x) throw (); extern long int __lroundf (float __x) throw ();
extern long long int llroundf (float __x) throw (); extern long long int __llroundf (float __x) throw ();



extern float fdimf (float __x, float __y) throw (); extern float __fdimf (float __x, float __y) throw ();


extern float fmaxf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fmaxf (float __x, float __y) throw () __attribute__ ((__const__));


extern float fminf (float __x, float __y) throw () __attribute__ ((__const__)); extern float __fminf (float __x, float __y) throw () __attribute__ ((__const__));



extern int __fpclassifyf (float __value) throw ()
     __attribute__ ((__const__));


extern int __signbitf (float __value) throw ()
     __attribute__ ((__const__));



extern float fmaf (float __x, float __y, float __z) throw (); extern float __fmaf (float __x, float __y, float __z) throw ();








extern float scalbf (float __x, float __n) throw (); extern float __scalbf (float __x, float __n) throw ();
// # 90 "/usr/include/math.h" 2 3 4
// # 133 "/usr/include/math.h" 3 4
// # 1 "/usr/include/bits/mathcalls.h" 1 3 4
// # 52 "/usr/include/bits/mathcalls.h" 3 4


extern long double acosl (long double __x) throw (); extern long double __acosl (long double __x) throw ();

extern long double asinl (long double __x) throw (); extern long double __asinl (long double __x) throw ();

extern long double atanl (long double __x) throw (); extern long double __atanl (long double __x) throw ();

extern long double atan2l (long double __y, long double __x) throw (); extern long double __atan2l (long double __y, long double __x) throw ();


extern long double cosl (long double __x) throw (); extern long double __cosl (long double __x) throw ();

extern long double sinl (long double __x) throw (); extern long double __sinl (long double __x) throw ();

extern long double tanl (long double __x) throw (); extern long double __tanl (long double __x) throw ();




extern long double coshl (long double __x) throw (); extern long double __coshl (long double __x) throw ();

extern long double sinhl (long double __x) throw (); extern long double __sinhl (long double __x) throw ();

extern long double tanhl (long double __x) throw (); extern long double __tanhl (long double __x) throw ();




extern void sincosl (long double __x, long double *__sinx, long double *__cosx) throw (); extern void __sincosl (long double __x, long double *__sinx, long double *__cosx) throw ()
                                                           ;





extern long double acoshl (long double __x) throw (); extern long double __acoshl (long double __x) throw ();

extern long double asinhl (long double __x) throw (); extern long double __asinhl (long double __x) throw ();

extern long double atanhl (long double __x) throw (); extern long double __atanhl (long double __x) throw ();







extern long double expl (long double __x) throw (); extern long double __expl (long double __x) throw ();


extern long double frexpl (long double __x, int *__exponent) throw (); extern long double __frexpl (long double __x, int *__exponent) throw ();


extern long double ldexpl (long double __x, int __exponent) throw (); extern long double __ldexpl (long double __x, int __exponent) throw ();


extern long double logl (long double __x) throw (); extern long double __logl (long double __x) throw ();


extern long double log10l (long double __x) throw (); extern long double __log10l (long double __x) throw ();


extern long double modfl (long double __x, long double *__iptr) throw (); extern long double __modfl (long double __x, long double *__iptr) throw ()
     __attribute__ ((__nonnull__ (2)));




extern long double exp10l (long double __x) throw (); extern long double __exp10l (long double __x) throw ();

extern long double pow10l (long double __x) throw (); extern long double __pow10l (long double __x) throw ();





extern long double expm1l (long double __x) throw (); extern long double __expm1l (long double __x) throw ();


extern long double log1pl (long double __x) throw (); extern long double __log1pl (long double __x) throw ();


extern long double logbl (long double __x) throw (); extern long double __logbl (long double __x) throw ();






extern long double exp2l (long double __x) throw (); extern long double __exp2l (long double __x) throw ();


extern long double log2l (long double __x) throw (); extern long double __log2l (long double __x) throw ();








extern long double powl (long double __x, long double __y) throw (); extern long double __powl (long double __x, long double __y) throw ();


extern long double sqrtl (long double __x) throw (); extern long double __sqrtl (long double __x) throw ();





extern long double hypotl (long double __x, long double __y) throw (); extern long double __hypotl (long double __x, long double __y) throw ();






extern long double cbrtl (long double __x) throw (); extern long double __cbrtl (long double __x) throw ();








extern long double ceill (long double __x) throw () __attribute__ ((__const__)); extern long double __ceill (long double __x) throw () __attribute__ ((__const__));


extern long double fabsl (long double __x) throw () __attribute__ ((__const__)); extern long double __fabsl (long double __x) throw () __attribute__ ((__const__));


extern long double floorl (long double __x) throw () __attribute__ ((__const__)); extern long double __floorl (long double __x) throw () __attribute__ ((__const__));


extern long double fmodl (long double __x, long double __y) throw (); extern long double __fmodl (long double __x, long double __y) throw ();




extern int __isinfl (long double __value) throw () __attribute__ ((__const__));


extern int __finitel (long double __value) throw () __attribute__ ((__const__));





extern int isinfl (long double __value) throw () __attribute__ ((__const__));


extern int finitel (long double __value) throw () __attribute__ ((__const__));


extern long double dreml (long double __x, long double __y) throw (); extern long double __dreml (long double __x, long double __y) throw ();



extern long double significandl (long double __x) throw (); extern long double __significandl (long double __x) throw ();





extern long double copysignl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __copysignl (long double __x, long double __y) throw () __attribute__ ((__const__));






extern long double nanl (const char *__tagb) throw () __attribute__ ((__const__)); extern long double __nanl (const char *__tagb) throw () __attribute__ ((__const__));





extern int __isnanl (long double __value) throw () __attribute__ ((__const__));



extern int isnanl (long double __value) throw () __attribute__ ((__const__));


extern long double j0l (long double) throw (); extern long double __j0l (long double) throw ();
extern long double j1l (long double) throw (); extern long double __j1l (long double) throw ();
extern long double jnl (int, long double) throw (); extern long double __jnl (int, long double) throw ();
extern long double y0l (long double) throw (); extern long double __y0l (long double) throw ();
extern long double y1l (long double) throw (); extern long double __y1l (long double) throw ();
extern long double ynl (int, long double) throw (); extern long double __ynl (int, long double) throw ();






extern long double erfl (long double) throw (); extern long double __erfl (long double) throw ();
extern long double erfcl (long double) throw (); extern long double __erfcl (long double) throw ();
extern long double lgammal (long double) throw (); extern long double __lgammal (long double) throw ();






extern long double tgammal (long double) throw (); extern long double __tgammal (long double) throw ();





extern long double gammal (long double) throw (); extern long double __gammal (long double) throw ();






extern long double lgammal_r (long double, int *__signgamp) throw (); extern long double __lgammal_r (long double, int *__signgamp) throw ();







extern long double rintl (long double __x) throw (); extern long double __rintl (long double __x) throw ();


extern long double nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nextafterl (long double __x, long double __y) throw () __attribute__ ((__const__));

extern long double nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __nexttowardl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern long double remainderl (long double __x, long double __y) throw (); extern long double __remainderl (long double __x, long double __y) throw ();



extern long double scalbnl (long double __x, int __n) throw (); extern long double __scalbnl (long double __x, int __n) throw ();



extern int ilogbl (long double __x) throw (); extern int __ilogbl (long double __x) throw ();




extern long double scalblnl (long double __x, long int __n) throw (); extern long double __scalblnl (long double __x, long int __n) throw ();



extern long double nearbyintl (long double __x) throw (); extern long double __nearbyintl (long double __x) throw ();



extern long double roundl (long double __x) throw () __attribute__ ((__const__)); extern long double __roundl (long double __x) throw () __attribute__ ((__const__));



extern long double truncl (long double __x) throw () __attribute__ ((__const__)); extern long double __truncl (long double __x) throw () __attribute__ ((__const__));




extern long double remquol (long double __x, long double __y, int *__quo) throw (); extern long double __remquol (long double __x, long double __y, int *__quo) throw ();






extern long int lrintl (long double __x) throw (); extern long int __lrintl (long double __x) throw ();
extern long long int llrintl (long double __x) throw (); extern long long int __llrintl (long double __x) throw ();



extern long int lroundl (long double __x) throw (); extern long int __lroundl (long double __x) throw ();
extern long long int llroundl (long double __x) throw (); extern long long int __llroundl (long double __x) throw ();



extern long double fdiml (long double __x, long double __y) throw (); extern long double __fdiml (long double __x, long double __y) throw ();


extern long double fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fmaxl (long double __x, long double __y) throw () __attribute__ ((__const__));


extern long double fminl (long double __x, long double __y) throw () __attribute__ ((__const__)); extern long double __fminl (long double __x, long double __y) throw () __attribute__ ((__const__));



extern int __fpclassifyl (long double __value) throw ()
     __attribute__ ((__const__));


extern int __signbitl (long double __value) throw ()
     __attribute__ ((__const__));



extern long double fmal (long double __x, long double __y, long double __z) throw (); extern long double __fmal (long double __x, long double __y, long double __z) throw ();








extern long double scalbl (long double __x, long double __n) throw (); extern long double __scalbl (long double __x, long double __n) throw ();
// # 134 "/usr/include/math.h" 2 3 4
// # 149 "/usr/include/math.h" 3 4
extern int signgam;
// # 190 "/usr/include/math.h" 3 4
enum
  {
    FP_NAN =

      0,
    FP_INFINITE =

      1,
    FP_ZERO =

      2,
    FP_SUBNORMAL =

      3,
    FP_NORMAL =

      4
  };
// # 288 "/usr/include/math.h" 3 4
typedef enum
{
  _IEEE_ = -1,
  _SVID_,
  _XOPEN_,
  _POSIX_,
  _ISOC_
} _LIB_VERSION_TYPE;




extern _LIB_VERSION_TYPE _LIB_VERSION;
// # 311 "/usr/include/math.h" 3 4
struct __exception



  {
    int type;
    char *name;
    double arg1;
    double arg2;
    double retval;
  };


extern int matherr (struct __exception *__exc) throw ();
// # 413 "/usr/include/math.h" 3 4
// # 1 "/usr/include/bits/mathinline.h" 1 3 4
// # 123 "/usr/include/bits/mathinline.h" 3 4



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitf (float __x) throw ()
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x8) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbit (double __x) throw ()
{

  int __m;
  __asm ("pmovmskb %1, %0" : "=r" (__m) : "x" (__x));
  return (__m & 0x80) != 0;




}
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) __signbitl (long double __x) throw ()
{
  __extension__ union { long double __l; int __i[3]; } __u = { __l: __x };
  return (__u.__i[2] & 0x8000) != 0;
}


// # 414 "/usr/include/math.h" 2 3 4
// # 475 "/usr/include/math.h" 3 4
}
// # 46 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 1 3 4
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/syslimits.h" 1 3 4






// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 1 3 4
// # 168 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 3 4
// # 1 "/usr/include/limits.h" 1 3 4
// # 144 "/usr/include/limits.h" 3 4
// # 1 "/usr/include/bits/posix1_lim.h" 1 3 4
// # 160 "/usr/include/bits/posix1_lim.h" 3 4
// # 1 "/usr/include/bits/local_lim.h" 1 3 4
// # 38 "/usr/include/bits/local_lim.h" 3 4
// # 1 "/usr/include/linux/limits.h" 1 3 4
// # 39 "/usr/include/bits/local_lim.h" 2 3 4
// # 161 "/usr/include/bits/posix1_lim.h" 2 3 4
// # 145 "/usr/include/limits.h" 2 3 4



// # 1 "/usr/include/bits/posix2_lim.h" 1 3 4
// # 149 "/usr/include/limits.h" 2 3 4



// # 1 "/usr/include/bits/xopen_lim.h" 1 3 4
// # 33 "/usr/include/bits/xopen_lim.h" 3 4
// # 1 "/usr/include/bits/stdio_lim.h" 1 3 4
// # 34 "/usr/include/bits/xopen_lim.h" 2 3 4
// # 153 "/usr/include/limits.h" 2 3 4
// # 169 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 2 3 4
// # 8 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/syslimits.h" 2 3 4
// # 35 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include-fixed/limits.h" 2 3 4
// # 47 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/float.h" 1 3 4
// # 48 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/usr/include/fcntl.h" 1 3 4
// # 28 "/usr/include/fcntl.h" 3 4
extern "C" {






// # 1 "/usr/include/bits/fcntl.h" 1 3 4
// # 35 "/usr/include/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;




    __off64_t l_start;
    __off64_t l_len;

    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



// # 1 "/usr/include/bits/fcntl-linux.h" 1 3 4
// # 38 "/usr/include/bits/fcntl-linux.h" 3 4
// # 1 "/usr/include/bits/uio.h" 1 3 4
// # 43 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
// # 39 "/usr/include/bits/fcntl-linux.h" 2 3 4
// # 237 "/usr/include/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
// # 300 "/usr/include/bits/fcntl-linux.h" 3 4
struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};





extern "C" {




extern ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    throw ();






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern ssize_t vmsplice (int __fdout, const struct iovec *__iov,
    size_t __count, unsigned int __flags);





extern ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
         __off64_t *__offout, size_t __len,
         unsigned int __flags);





extern ssize_t tee (int __fdin, int __fdout, size_t __len,
      unsigned int __flags);
// # 359 "/usr/include/bits/fcntl-linux.h" 3 4
extern int fallocate (int __fd, int __mode, __off64_t __offset, __off64_t __len) __asm__ ("" "fallocate64")

                     ;





extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) throw ();





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);



}
// # 61 "/usr/include/bits/fcntl.h" 2 3 4
// # 36 "/usr/include/fcntl.h" 2 3 4
// # 67 "/usr/include/fcntl.h" 3 4
// # 1 "/usr/include/time.h" 1 3 4
// # 68 "/usr/include/fcntl.h" 2 3 4
// # 1 "/usr/include/bits/stat.h" 1 3 4
// # 46 "/usr/include/bits/stat.h" 3 4
struct stat
  {
    __dev_t st_dev;




    __ino_t st_ino;







    __nlink_t st_nlink;
    __mode_t st_mode;

    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;

    __dev_t st_rdev;




    __off_t st_size;



    __blksize_t st_blksize;

    __blkcnt_t st_blocks;
// # 91 "/usr/include/bits/stat.h" 3 4
    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
// # 106 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];
// # 115 "/usr/include/bits/stat.h" 3 4
  };



struct stat64
  {
    __dev_t st_dev;

    __ino64_t st_ino;
    __nlink_t st_nlink;
    __mode_t st_mode;






    __uid_t st_uid;
    __gid_t st_gid;

    int __pad0;
    __dev_t st_rdev;
    __off_t st_size;





    __blksize_t st_blksize;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
// # 164 "/usr/include/bits/stat.h" 3 4
    __syscall_slong_t __unused[3];



  };
// # 69 "/usr/include/fcntl.h" 2 3 4
// # 154 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
// # 166 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __asm__ ("" "open64")
     __attribute__ ((__nonnull__ (1)));





extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
// # 191 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...) __asm__ ("" "openat64")
                    __attribute__ ((__nonnull__ (2)));





extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
// # 212 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __asm__ ("" "creat64")
                  __attribute__ ((__nonnull__ (1)));





extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
// # 241 "/usr/include/fcntl.h" 3 4
extern int lockf (int __fd, int __cmd, __off64_t __len) __asm__ ("" "lockf64");





extern int lockf64 (int __fd, int __cmd, off64_t __len);
// # 259 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, __off64_t __offset, __off64_t __len, int __advise) throw () __asm__ ("" "posix_fadvise64")

                      ;





extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) throw ();
// # 280 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, __off64_t __offset, __off64_t __len) __asm__ ("" "posix_fallocate64")

                           ;





extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);
// # 299 "/usr/include/fcntl.h" 3 4
}
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/usr/include/time.h" 1 3 4
// # 29 "/usr/include/time.h" 3 4
extern "C" {







// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 38 "/usr/include/time.h" 2 3 4



// # 1 "/usr/include/bits/time.h" 1 3 4
// # 86 "/usr/include/bits/time.h" 3 4
// # 1 "/usr/include/bits/timex.h" 1 3 4
// # 25 "/usr/include/bits/timex.h" 3 4
struct timex
{
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;
};
// # 87 "/usr/include/bits/time.h" 2 3 4

extern "C" {


extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) throw ();

}
// # 42 "/usr/include/time.h" 2 3 4
// # 131 "/usr/include/time.h" 3 4


struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;
// # 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) throw ();


extern time_t time (time_t *__timer) throw ();


extern double difftime (time_t __time1, time_t __time0)
     throw () __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) throw ();





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) throw ();





extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     throw ();







extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    __locale_t __loc) throw ();






extern struct tm *gmtime (const time_t *__timer) throw ();



extern struct tm *localtime (const time_t *__timer) throw ();





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) throw ();



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) throw ();





extern char *asctime (const struct tm *__tp) throw ();


extern char *ctime (const time_t *__timer) throw ();







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) throw ();


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) throw ();




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) throw ();



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) throw ();
// # 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) throw ();


extern time_t timelocal (struct tm *__tp) throw ();


extern int dysize (int __year) throw () __attribute__ ((__const__));
// # 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) throw ();


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) throw ();


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     throw ();






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) throw ();




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) throw ();


extern int timer_delete (timer_t __timerid) throw ();


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) throw ();


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     throw ();


extern int timer_getoverrun (timer_t __timerid) throw ();





extern int timespec_get (struct timespec *__ts, int __base)
     throw () __attribute__ ((__nonnull__ (1)));
// # 403 "/usr/include/time.h" 3 4
extern int getdate_err;
// # 412 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
// # 426 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);


}
// # 50 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 1 "/usr/include/errno.h" 1 3 4
// # 31 "/usr/include/errno.h" 3 4
extern "C" {



// # 1 "/usr/include/bits/errno.h" 1 3 4
// # 24 "/usr/include/bits/errno.h" 3 4
// # 1 "/usr/include/linux/errno.h" 1 3 4
// # 1 "/usr/include/asm/errno.h" 1 3 4
// # 1 "/usr/include/asm-generic/errno.h" 1 3 4



// # 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
// # 5 "/usr/include/asm-generic/errno.h" 2 3 4
// # 1 "/usr/include/asm/errno.h" 2 3 4
// # 1 "/usr/include/linux/errno.h" 2 3 4
// # 25 "/usr/include/bits/errno.h" 2 3 4
// # 50 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) throw () __attribute__ ((__const__));
// # 36 "/usr/include/errno.h" 2 3 4
// # 54 "/usr/include/errno.h" 3 4
extern char *program_invocation_name, *program_invocation_short_name;



}
// # 68 "/usr/include/errno.h" 3 4
typedef int error_t;
// # 51 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2



// # 1 "/usr/include/sys/socket.h" 1 3 4
// # 25 "/usr/include/sys/socket.h" 3 4
extern "C" {

// # 1 "/usr/include/sys/uio.h" 1 3 4
// # 26 "/usr/include/sys/uio.h" 3 4
extern "C" {


// # 1 "/usr/include/bits/uio.h" 1 3 4
// # 56 "/usr/include/bits/uio.h" 3 4
extern "C" {


extern ssize_t process_vm_readv (pid_t __pid, const struct iovec *__lvec,
     unsigned long int __liovcnt,
     const struct iovec *__rvec,
     unsigned long int __riovcnt,
     unsigned long int __flags)
  throw ();


extern ssize_t process_vm_writev (pid_t __pid, const struct iovec *__lvec,
      unsigned long int __liovcnt,
      const struct iovec *__rvec,
      unsigned long int __riovcnt,
      unsigned long int __flags)
  throw ();

}
// # 30 "/usr/include/sys/uio.h" 2 3 4
// # 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
// # 51 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
// # 82 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "preadv64")

                     ;
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count, __off64_t __offset) __asm__ ("" "pwritev64")

                      ;
// # 104 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv64 (int __fd, const struct iovec *__iovec, int __count,
    __off64_t __offset) ;
// # 116 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev64 (int __fd, const struct iovec *__iovec, int __count,
     __off64_t __offset) ;



}
// # 28 "/usr/include/sys/socket.h" 2 3 4

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 30 "/usr/include/sys/socket.h" 2 3 4


// # 1 "/usr/include/bits/sigset.h" 1 3 4
// # 33 "/usr/include/sys/socket.h" 2 3 4






// # 1 "/usr/include/bits/socket.h" 1 3 4
// # 28 "/usr/include/bits/socket.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 29 "/usr/include/bits/socket.h" 2 3 4





typedef __socklen_t socklen_t;




// # 1 "/usr/include/bits/socket_type.h" 1 3 4
// # 24 "/usr/include/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
// # 40 "/usr/include/bits/socket.h" 2 3 4
// # 145 "/usr/include/bits/socket.h" 3 4
// # 1 "/usr/include/bits/sockaddr.h" 1 3 4
// # 28 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
// # 146 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
// # 161 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
// # 269 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) throw ();




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg) throw ()
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};
// # 342 "/usr/include/bits/socket.h" 3 4
// # 1 "/usr/include/asm/socket.h" 1 3 4
// # 1 "/usr/include/asm-generic/socket.h" 1 3 4



// # 1 "/usr/include/asm/sockios.h" 1 3 4
// # 1 "/usr/include/asm-generic/sockios.h" 1 3 4
// # 1 "/usr/include/asm/sockios.h" 2 3 4
// # 5 "/usr/include/asm-generic/socket.h" 2 3 4
// # 1 "/usr/include/asm/socket.h" 2 3 4
// # 343 "/usr/include/bits/socket.h" 2 3 4
// # 376 "/usr/include/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
// # 40 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
// # 102 "/usr/include/sys/socket.h" 3 4
struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) throw ();





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) throw ();


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     throw ();


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();
// # 138 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) throw ();






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
// # 175 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);







extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);







extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);







extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       const struct timespec *__tmo);






extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) throw ();




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) throw ();





extern int listen (int __fd, int __n) throw ();
// # 244 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, struct sockaddr *__restrict __addr,
      socklen_t *__restrict __addr_len, int __flags);
// # 262 "/usr/include/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) throw ();




extern int sockatmark (int __fd) throw ();







extern int isfdtype (int __fd, int __fdtype) throw ();
// # 284 "/usr/include/sys/socket.h" 3 4
}
// # 55 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2


// # 1 "/usr/include/netdb.h" 1 3 4
// # 27 "/usr/include/netdb.h" 3 4
// # 1 "/usr/include/netinet/in.h" 1 3 4
// # 23 "/usr/include/netinet/in.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdint.h" 1 3 4
// # 9 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdint.h" 3 4
// # 1 "/usr/include/stdint.h" 1 3 4
// # 26 "/usr/include/stdint.h" 3 4
// # 1 "/usr/include/bits/wchar.h" 1 3 4
// # 22 "/usr/include/bits/wchar.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 23 "/usr/include/bits/wchar.h" 2 3 4
// # 27 "/usr/include/stdint.h" 2 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 28 "/usr/include/stdint.h" 2 3 4
// # 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
// # 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
// # 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
// # 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
// # 119 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
// # 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
// # 10 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stdint.h" 2 3 4
// # 24 "/usr/include/netinet/in.h" 2 3 4




extern "C" {


typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


// # 1 "/usr/include/bits/in.h" 1 3 4
// # 120 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
// # 39 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
// # 210 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
// # 238 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
// # 375 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) throw () __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     throw () __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     throw () __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     throw () __attribute__ ((__const__));




// # 1 "/usr/include/bits/byteswap.h" 1 3 4
// # 387 "/usr/include/netinet/in.h" 2 3 4
// # 502 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) throw ();


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     throw ();
// # 532 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) throw () __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) throw () __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     throw () __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     throw () __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) throw ();
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) throw ();
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     throw ();
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) throw ();
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) throw ();



extern socklen_t inet6_rth_space (int __type, int __segments) throw ();
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) throw ();
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) throw ();
extern int inet6_rth_reverse (const void *__in, void *__out) throw ();
extern int inet6_rth_segments (const void *__bp) throw ();
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     throw ();





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     throw ();


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     throw ();



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) throw ();


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) throw ();


}
// # 28 "/usr/include/netdb.h" 2 3 4




// # 1 "/usr/include/rpc/netdb.h" 1 3 4
// # 42 "/usr/include/rpc/netdb.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 43 "/usr/include/rpc/netdb.h" 2 3 4

extern "C" {

struct rpcent
{
  char *r_name;
  char **r_aliases;
  int r_number;
};

extern void setrpcent (int __stayopen) throw ();
extern void endrpcent (void) throw ();
extern struct rpcent *getrpcbyname (const char *__name) throw ();
extern struct rpcent *getrpcbynumber (int __number) throw ();
extern struct rpcent *getrpcent (void) throw ();


extern int getrpcbyname_r (const char *__name, struct rpcent *__result_buf,
      char *__buffer, size_t __buflen,
      struct rpcent **__result) throw ();

extern int getrpcbynumber_r (int __number, struct rpcent *__result_buf,
        char *__buffer, size_t __buflen,
        struct rpcent **__result) throw ();

extern int getrpcent_r (struct rpcent *__result_buf, char *__buffer,
   size_t __buflen, struct rpcent **__result) throw ();


}
// # 33 "/usr/include/netdb.h" 2 3 4




// # 1 "/usr/include/bits/siginfo.h" 1 3 4
// # 24 "/usr/include/bits/siginfo.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 25 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
// # 301 "/usr/include/bits/siginfo.h" 3 4
typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
// # 38 "/usr/include/netdb.h" 2 3 4




// # 1 "/usr/include/bits/netdb.h" 1 3 4
// # 26 "/usr/include/bits/netdb.h" 3 4
struct netent
{
  char *n_name;
  char **n_aliases;
  int n_addrtype;
  uint32_t n_net;
};
// # 43 "/usr/include/netdb.h" 2 3 4
// # 53 "/usr/include/netdb.h" 3 4
extern "C" {







extern int *__h_errno_location (void) throw () __attribute__ ((__const__));
// # 92 "/usr/include/netdb.h" 3 4
extern void herror (const char *__str) throw ();


extern const char *hstrerror (int __err_num) throw ();




struct hostent
{
  char *h_name;
  char **h_aliases;
  int h_addrtype;
  int h_length;
  char **h_addr_list;



};






extern void sethostent (int __stay_open);





extern void endhostent (void);






extern struct hostent *gethostent (void);






extern struct hostent *gethostbyaddr (const void *__addr, __socklen_t __len,
          int __type);





extern struct hostent *gethostbyname (const char *__name);
// # 155 "/usr/include/netdb.h" 3 4
extern struct hostent *gethostbyname2 (const char *__name, int __af);
// # 167 "/usr/include/netdb.h" 3 4
extern int gethostent_r (struct hostent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct hostent **__restrict __result,
    int *__restrict __h_errnop);

extern int gethostbyaddr_r (const void *__restrict __addr, __socklen_t __len,
       int __type,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname_r (const char *__restrict __name,
       struct hostent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct hostent **__restrict __result,
       int *__restrict __h_errnop);

extern int gethostbyname2_r (const char *__restrict __name, int __af,
        struct hostent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct hostent **__restrict __result,
        int *__restrict __h_errnop);
// # 198 "/usr/include/netdb.h" 3 4
extern void setnetent (int __stay_open);





extern void endnetent (void);






extern struct netent *getnetent (void);






extern struct netent *getnetbyaddr (uint32_t __net, int __type);





extern struct netent *getnetbyname (const char *__name);
// # 237 "/usr/include/netdb.h" 3 4
extern int getnetent_r (struct netent *__restrict __result_buf,
   char *__restrict __buf, size_t __buflen,
   struct netent **__restrict __result,
   int *__restrict __h_errnop);

extern int getnetbyaddr_r (uint32_t __net, int __type,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);

extern int getnetbyname_r (const char *__restrict __name,
      struct netent *__restrict __result_buf,
      char *__restrict __buf, size_t __buflen,
      struct netent **__restrict __result,
      int *__restrict __h_errnop);




struct servent
{
  char *s_name;
  char **s_aliases;
  int s_port;
  char *s_proto;
};






extern void setservent (int __stay_open);





extern void endservent (void);






extern struct servent *getservent (void);






extern struct servent *getservbyname (const char *__name, const char *__proto);






extern struct servent *getservbyport (int __port, const char *__proto);
// # 308 "/usr/include/netdb.h" 3 4
extern int getservent_r (struct servent *__restrict __result_buf,
    char *__restrict __buf, size_t __buflen,
    struct servent **__restrict __result);

extern int getservbyname_r (const char *__restrict __name,
       const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);

extern int getservbyport_r (int __port, const char *__restrict __proto,
       struct servent *__restrict __result_buf,
       char *__restrict __buf, size_t __buflen,
       struct servent **__restrict __result);




struct protoent
{
  char *p_name;
  char **p_aliases;
  int p_proto;
};






extern void setprotoent (int __stay_open);





extern void endprotoent (void);






extern struct protoent *getprotoent (void);





extern struct protoent *getprotobyname (const char *__name);





extern struct protoent *getprotobynumber (int __proto);
// # 374 "/usr/include/netdb.h" 3 4
extern int getprotoent_r (struct protoent *__restrict __result_buf,
     char *__restrict __buf, size_t __buflen,
     struct protoent **__restrict __result);

extern int getprotobyname_r (const char *__restrict __name,
        struct protoent *__restrict __result_buf,
        char *__restrict __buf, size_t __buflen,
        struct protoent **__restrict __result);

extern int getprotobynumber_r (int __proto,
          struct protoent *__restrict __result_buf,
          char *__restrict __buf, size_t __buflen,
          struct protoent **__restrict __result);
// # 395 "/usr/include/netdb.h" 3 4
extern int setnetgrent (const char *__netgroup);







extern void endnetgrent (void);
// # 412 "/usr/include/netdb.h" 3 4
extern int getnetgrent (char **__restrict __hostp,
   char **__restrict __userp,
   char **__restrict __domainp);
// # 423 "/usr/include/netdb.h" 3 4
extern int innetgr (const char *__netgroup, const char *__host,
      const char *__user, const char *__domain);







extern int getnetgrent_r (char **__restrict __hostp,
     char **__restrict __userp,
     char **__restrict __domainp,
     char *__restrict __buffer, size_t __buflen);
// # 451 "/usr/include/netdb.h" 3 4
extern int rcmd (char **__restrict __ahost, unsigned short int __rport,
   const char *__restrict __locuser,
   const char *__restrict __remuser,
   const char *__restrict __cmd, int *__restrict __fd2p);
// # 463 "/usr/include/netdb.h" 3 4
extern int rcmd_af (char **__restrict __ahost, unsigned short int __rport,
      const char *__restrict __locuser,
      const char *__restrict __remuser,
      const char *__restrict __cmd, int *__restrict __fd2p,
      sa_family_t __af);
// # 479 "/usr/include/netdb.h" 3 4
extern int rexec (char **__restrict __ahost, int __rport,
    const char *__restrict __name,
    const char *__restrict __pass,
    const char *__restrict __cmd, int *__restrict __fd2p);
// # 491 "/usr/include/netdb.h" 3 4
extern int rexec_af (char **__restrict __ahost, int __rport,
       const char *__restrict __name,
       const char *__restrict __pass,
       const char *__restrict __cmd, int *__restrict __fd2p,
       sa_family_t __af);
// # 505 "/usr/include/netdb.h" 3 4
extern int ruserok (const char *__rhost, int __suser,
      const char *__remuser, const char *__locuser);
// # 515 "/usr/include/netdb.h" 3 4
extern int ruserok_af (const char *__rhost, int __suser,
         const char *__remuser, const char *__locuser,
         sa_family_t __af);
// # 528 "/usr/include/netdb.h" 3 4
extern int iruserok (uint32_t __raddr, int __suser,
       const char *__remuser, const char *__locuser);
// # 539 "/usr/include/netdb.h" 3 4
extern int iruserok_af (const void *__raddr, int __suser,
   const char *__remuser, const char *__locuser,
   sa_family_t __af);
// # 551 "/usr/include/netdb.h" 3 4
extern int rresvport (int *__alport);
// # 560 "/usr/include/netdb.h" 3 4
extern int rresvport_af (int *__alport, sa_family_t __af);






struct addrinfo
{
  int ai_flags;
  int ai_family;
  int ai_socktype;
  int ai_protocol;
  socklen_t ai_addrlen;
  struct sockaddr *ai_addr;
  char *ai_canonname;
  struct addrinfo *ai_next;
};



struct gaicb
{
  const char *ar_name;
  const char *ar_service;
  const struct addrinfo *ar_request;
  struct addrinfo *ar_result;

  int __return;
  int __unused[5];
};
// # 662 "/usr/include/netdb.h" 3 4
extern int getaddrinfo (const char *__restrict __name,
   const char *__restrict __service,
   const struct addrinfo *__restrict __req,
   struct addrinfo **__restrict __pai);


extern void freeaddrinfo (struct addrinfo *__ai) throw ();


extern const char *gai_strerror (int __ecode) throw ();





extern int getnameinfo (const struct sockaddr *__restrict __sa,
   socklen_t __salen, char *__restrict __host,
   socklen_t __hostlen, char *__restrict __serv,
   socklen_t __servlen, int __flags);
// # 692 "/usr/include/netdb.h" 3 4
extern int getaddrinfo_a (int __mode, struct gaicb *__list[],
     int __ent, struct sigevent *__restrict __sig);
// # 703 "/usr/include/netdb.h" 3 4
extern int gai_suspend (const struct gaicb *const __list[], int __ent,
   const struct timespec *__timeout);


extern int gai_error (struct gaicb *__req) throw ();


extern int gai_cancel (struct gaicb *__gaicbp) throw ();


}
// # 58 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 68 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
// # 1 "/usr/include/assert.h" 1 3 4
// # 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
// # 69 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2



// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 1 3
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 3
       
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++config.h" 1 3
// # 184 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++config.h" 3
namespace std
{
  typedef long unsigned int size_t;
  typedef long int ptrdiff_t;




}
// # 426 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++config.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/os_defines.h" 1 3
// # 427 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/cpu_defines.h" 1 3
// # 430 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++config.h" 2 3
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 3
       
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 3

#pragma GCC visibility push(default)


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/atomic_lockfree_defines.h" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/atomic_lockfree_defines.h" 3
       
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/atomic_lockfree_defines.h" 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 2 3

extern "C++" {

namespace std
{
// # 60 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 3
  class exception
  {
  public:
    exception() throw() { }
    virtual ~exception() throw();



    virtual const char* what() const throw();
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() throw() { }



    virtual ~bad_exception() throw();


    virtual const char* what() const throw();
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) throw();



  void terminate() throw() __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) throw();



  void unexpected() __attribute__ ((__noreturn__));
// # 117 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 3
  bool uncaught_exception() throw() __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

// # 142 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };

  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();
}
// # 91 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/new" 3
void* operator new(std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t) throw(std::bad_alloc)
  __attribute__((__externally_visible__));
void operator delete(void*) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*) throw()
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) throw()
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) throw()
{ return __p; }
inline void* operator new[](std::size_t, void* __p) throw()
{ return __p; }


inline void operator delete (void*, void*) throw() { }
inline void operator delete[](void*, void*) throw() { }

}

#pragma GCC visibility pop
// # 73 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h" 2
// # 55 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h"
inline bool likely(bool expr)
{
  return __builtin_expect(expr, true);
}
inline bool unlikely(bool expr)
{
  return __builtin_expect(expr, false);
}
// # 126 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h"
template<size_t alignment> struct my_alignment_imp;
template<> struct __attribute__((__aligned__((1)))) my_alignment_imp<1> {};
template<> struct __attribute__((__aligned__((2)))) my_alignment_imp<2> {};
template<> struct __attribute__((__aligned__((4)))) my_alignment_imp<4> {};
template<> struct __attribute__((__aligned__((8)))) my_alignment_imp<8> {};
template<> struct __attribute__((__aligned__((16)))) my_alignment_imp<16> {};
// # 143 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_compiler.h"
template <size_t size, size_t alignment>
struct my_aligned_storage
{
  union
  {
    char data[size];
    my_alignment_imp<alignment> align;
  };
};
// # 76 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 196 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef int File;



typedef int my_socket;


extern "C" {
typedef void (*sig_return)();
}

typedef char pchar;
typedef char pbool;




extern "C" {
typedef int (*qsort_cmp)(const void *,const void *);
typedef int (*qsort_cmp2)(const void*, const void *,const void *);
}






typedef socklen_t socket_len_t;

typedef socket_len_t SOCKET_SIZE_TYPE;
// # 293 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
static inline int is_directory_separator(char c)
{



  return c == '/';

}
// # 447 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef long long my_ptrdiff_t;
// # 481 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef unsigned char uchar;
typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;

typedef int int32;
typedef unsigned int uint32;
// # 504 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef unsigned long long int ulonglong;
typedef long long int longlong;
typedef longlong int64;
typedef ulonglong uint64;




typedef unsigned long long my_ulonglong;





typedef long intptr;
// # 531 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef off_t os_off_t;

typedef ulonglong my_off_t;
// # 543 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef ulonglong table_map;
typedef ulonglong nesting_map;
// # 569 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
typedef int myf;
typedef char my_bool;
// # 580 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_byteorder.h" 1
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_byteorder.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/byte_order_generic_x86.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/byte_order_generic_x86.h"
static inline int16 sint2korr(const uchar *A) ;
static inline int16 sint2korr(const uchar *A) { return *((int16*) A); }

static inline int32 sint4korr(const uchar *A) ;
static inline int32 sint4korr(const uchar *A) { return *((int32*) A); }

static inline uint16 uint2korr(const uchar *A) ;
static inline uint16 uint2korr(const uchar *A) { return *((uint16*) A); }

static inline uint32 uint4korr(const uchar *A) ;
static inline uint32 uint4korr(const uchar *A) { return *((uint32*) A); }

static inline ulonglong uint8korr(const uchar *A) ;
static inline ulonglong uint8korr(const uchar *A) { return *((ulonglong*) A);}

static inline longlong sint8korr(const uchar *A) ;
static inline longlong sint8korr(const uchar *A) { return *((longlong*) A); }

static inline void int2store(uchar *T, uint16 A) ;
static inline void int2store(uchar *T, uint16 A)
{
  *((uint16*) T)= A;
}

static inline void int4store(uchar *T, uint32 A) ;
static inline void int4store(uchar *T, uint32 A)
{
  *((uint32*) T)= A;
}

static inline void int8store(uchar *T, ulonglong A) ;
static inline void int8store(uchar *T, ulonglong A)
{
  *((ulonglong*) T)= A;
}
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_byteorder.h" 2




static inline int32 sint3korr(const uchar *A)
{
  return
    ((int32) (((A[2]) & 128) ?
              (((uint32) 255L << 24) |
               (((uint32) A[2]) << 16) |
               (((uint32) A[1]) << 8) |
               ((uint32) A[0])) :
              (((uint32) A[2]) << 16) |
              (((uint32) A[1]) << 8) |
              ((uint32) A[0])))
    ;
}

static inline uint32 uint3korr(const uchar *A)
{
  return
    (uint32) (((uint32) (A[0])) +
              (((uint32) (A[1])) << 8) +
              (((uint32) (A[2])) << 16))
    ;
}

static inline ulonglong uint5korr(const uchar *A)
{
  return
    ((ulonglong)(((uint32) (A[0])) +
                 (((uint32) (A[1])) << 8) +
                 (((uint32) (A[2])) << 16) +
                 (((uint32) (A[3])) << 24)) +
     (((ulonglong) (A[4])) << 32))
    ;
}

static inline ulonglong uint6korr(const uchar *A)
{
  return
    ((ulonglong)(((uint32) (A[0])) +
                 (((uint32) (A[1])) << 8) +
                 (((uint32) (A[2])) << 16) +
                 (((uint32) (A[3])) << 24)) +
     (((ulonglong) (A[4])) << 32) +
     (((ulonglong) (A[5])) << 40))
    ;
}

static inline void int3store(uchar *T, uint A)
{
  *(T)= (uchar) (A);
  *(T+1)= (uchar) (A >> 8);
  *(T+2)= (uchar) (A >> 16);
}

static inline void int5store(uchar *T, ulonglong A)
{
  *(T)= (uchar) (A);
  *(T+1)= (uchar) (A >> 8);
  *(T+2)= (uchar) (A >> 16);
  *(T+3)= (uchar) (A >> 24);
  *(T+4)= (uchar) (A >> 32);
}

static inline void int6store(uchar *T, ulonglong A)
{
  *(T)= (uchar) (A);
  *(T+1)= (uchar) (A >> 8);
  *(T+2)= (uchar) (A >> 16);
  *(T+3)= (uchar) (A >> 24);
  *(T+4)= (uchar) (A >> 32);
  *(T+5)= (uchar) (A >> 40);
}



static inline int16 sint2korr(const char *pT)
{
  return sint2korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline uint16 uint2korr(const char *pT)
{
  return uint2korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline uint32 uint3korr(const char *pT)
{
  return uint3korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline int32 sint3korr(const char *pT)
{
  return sint3korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline uint32 uint4korr(const char *pT)
{
  return uint4korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline int32 sint4korr(const char *pT)
{
  return sint4korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline ulonglong uint6korr(const char *pT)
{
  return uint6korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline ulonglong uint8korr(const char *pT)
{
  return uint8korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}

static inline longlong sint8korr(const char *pT)
{
  return sint8korr(static_cast<const uchar*>(static_cast<const void*>(pT)));
}


static inline void int2store(char *pT, uint16 A)
{
  int2store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}

static inline void int3store(char *pT, uint A)
{
  int3store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}

static inline void int4store(char *pT, uint32 A)
{
  int4store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}

static inline void int5store(char *pT, ulonglong A)
{
  int5store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}

static inline void int6store(char *pT, ulonglong A)
{
  int6store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}

static inline void int8store(char *pT, ulonglong A)
{
  int8store(static_cast<uchar*>(static_cast<void*>(pT)), A);
}
// # 191 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_byteorder.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/little_endian.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/little_endian.h"
// # 1 "/usr/include/string.h" 1 3 4
// # 27 "/usr/include/string.h" 3 4
extern "C" {




// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern void *memchr (void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const void *memchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) void *
memchr (void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const void *
memchr (const void *__s, int __c, size_t __n) throw ()
{
  return __builtin_memchr (__s, __c, __n);
}

}










extern "C++" void *rawmemchr (void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *rawmemchr (const void *__s, int __c)
     throw () __asm ("rawmemchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));







extern "C++" void *memrchr (void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const void *memrchr (const void *__s, int __c, size_t __n)
      throw () __asm ("memrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (2)));

// # 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) throw () __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     throw () __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
// # 207 "/usr/include/string.h" 3 4



extern "C++"
{
extern char *strchr (char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strchr (const char *__s, int __c)
     throw () __asm ("strchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strchr (char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strchr (const char *__s, int __c) throw ()
{
  return __builtin_strchr (__s, __c);
}

}






extern "C++"
{
extern char *strrchr (char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *strrchr (const char *__s, int __c)
     throw () __asm ("strrchr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strrchr (char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strrchr (const char *__s, int __c) throw ()
{
  return __builtin_strrchr (__s, __c);
}

}










extern "C++" char *strchrnul (char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern "C++" const char *strchrnul (const char *__s, int __c)
     throw () __asm ("strchrnul") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));









extern size_t strcspn (const char *__s, const char *__reject)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern "C++"
{
extern char *strpbrk (char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strpbrk (const char *__s, const char *__accept)
     throw () __asm ("strpbrk") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strpbrk (char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strpbrk (const char *__s, const char *__accept) throw ()
{
  return __builtin_strpbrk (__s, __accept);
}

}






extern "C++"
{
extern char *strstr (char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern const char *strstr (const char *__haystack, const char *__needle)
     throw () __asm ("strstr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
strstr (char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
strstr (const char *__haystack, const char *__needle) throw ()
{
  return __builtin_strstr (__haystack, __needle);
}

}







extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     throw () __attribute__ ((__nonnull__ (2, 3)));





extern "C++" char *strcasestr (char *__haystack, const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
extern "C++" const char *strcasestr (const char *__haystack,
         const char *__needle)
     throw () __asm ("strcasestr") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
// # 378 "/usr/include/string.h" 3 4
extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern size_t strlen (const char *__s)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) throw ();

// # 434 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;





extern char *strerror_l (int __errnum, __locale_t __l) throw ();





extern void __bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));



extern "C++"
{
extern char *index (char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *index (const char *__s, int __c)
     throw () __asm ("index") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
index (char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
index (const char *__s, int __c) throw ()
{
  return __builtin_index (__s, __c);
}

}







extern "C++"
{
extern char *rindex (char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
extern const char *rindex (const char *__s, int __c)
     throw () __asm ("rindex") __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) char *
rindex (char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) const char *
rindex (const char *__s, int __c) throw ()
{
  return __builtin_rindex (__s, __c);
}

}







extern int ffs (int __i) throw () __attribute__ ((__const__));




extern int ffsl (long int __l) throw () __attribute__ ((__const__));

__extension__ extern int ffsll (long long int __ll)
     throw () __attribute__ ((__const__));




extern int strcasecmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));





extern int strcasecmp_l (const char *__s1, const char *__s2,
    __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, __locale_t __loc)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));





extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) throw ();


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     throw () __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) throw () __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) throw () __attribute__ ((__nonnull__ (1)));







extern "C++" char *basename (char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
extern "C++" const char *basename (const char *__filename)
     throw () __asm ("basename") __attribute__ ((__nonnull__ (1)));
// # 642 "/usr/include/string.h" 3 4
}
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/little_endian.h" 2

static inline void float4get (float *V, const uchar *M)
{
  memcpy(V, (M), sizeof(float));
}

static inline void float4store(uchar *V, float M)
{
  memcpy(V, (&M), sizeof(float));
}

static inline void float8get (double *V, const uchar *M)
{
  memcpy(V, M, sizeof(double));
}

static inline void float8store(uchar *V, double M)
{
  memcpy(V, &M, sizeof(double));
}

static inline void floatget (float *V, const uchar *M) { float4get(V, M); }
static inline void floatstore (uchar *V, float M) { float4store(V, M); }
// # 72 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/little_endian.h"
static inline void doublestore(uchar *T, double V) { memcpy(T, &V, sizeof(double)); }
static inline void doubleget (double *V, const uchar *M) { memcpy(V, M, sizeof(double)); }



static inline void ushortget(uint16 *V, const uchar *pM) { *V= uint2korr(pM); }
static inline void shortget (int16 *V, const uchar *pM) { *V= sint2korr(pM); }
static inline void longget (int32 *V, const uchar *pM) { *V= sint4korr(pM); }
static inline void ulongget (uint32 *V, const uchar *pM) { *V= uint4korr(pM); }
static inline void shortstore(uchar *T, int16 V) { int2store(T, V); }
static inline void longstore (uchar *T, int32 V) { int4store(T, V); }

static inline void longlongget(longlong *V, const uchar *M)
{
  memcpy(V, (M), sizeof(ulonglong));
}
static inline void longlongstore(uchar *T, longlong V)
{
  memcpy((T), &V, sizeof(ulonglong));
}
// # 192 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_byteorder.h" 2




static inline void float4store(char *V, float M)
{
  float4store(static_cast<uchar*>(static_cast<void*>(V)), M);
}

static inline void float8get(double *V, const char *M)
{
  float8get(V, static_cast<const uchar*>(static_cast<const void*>(M)));
}

static inline void float8store(char *V, double M)
{
  float8store(static_cast<uchar*>(static_cast<void*>(V)), M);
}
// # 581 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 642 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dbug.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dbug.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dbug.h" 2


extern "C" {
// # 216 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dbug.h"
}
// # 643 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h" 2
// # 651 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
enum loglevel {
   ERROR_LEVEL= 0,
   WARNING_LEVEL= 1,
   INFORMATION_LEVEL= 2
};
// # 695 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
extern "C" {
extern ulonglong my_getsystime(void);
}

static inline void set_timespec_nsec(struct timespec *abstime, ulonglong nsec)
{

  ulonglong now= my_getsystime() + (nsec / 100);
  ulonglong tv_sec= now / 10000000ULL;




  abstime->tv_sec= (time_t)tv_sec;
  abstime->tv_nsec= (now % 10000000ULL) * 100 + (nsec % 100);
// # 721 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
}

static inline void set_timespec(struct timespec *abstime, ulonglong sec)
{
  set_timespec_nsec(abstime, sec * 1000000000ULL);
}
// # 735 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_global.h"
static inline int cmp_timespec(struct timespec *ts1, struct timespec *ts2)
{

  if (ts1->tv_sec > ts2->tv_sec ||
      (ts1->tv_sec == ts2->tv_sec && ts1->tv_nsec > ts2->tv_nsec))
    return 1;
  if (ts1->tv_sec < ts2->tv_sec ||
      (ts1->tv_sec == ts2->tv_sec && ts1->tv_nsec < ts2->tv_nsec))
    return -1;






  return 0;
}

static inline ulonglong diff_timespec(struct timespec *ts1, struct timespec *ts2)
{

  return (ts1->tv_sec - ts2->tv_sec) * 1000000000ULL +
    ts1->tv_nsec - ts2->tv_nsec;



}




typedef mode_t MY_MODE;
// # 17 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_version.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 2
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
class THD;
class Item;





typedef void * MYSQL_PLUGIN;


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session.h" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session.h"
class Srv_session;
typedef class Srv_session* MYSQL_SESSION;






// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 1
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session.h" 2



extern "C" {


typedef void (*srv_session_error_cb)(void *ctx,
                                     unsigned int sql_errno,
                                     const char *err_msg);

extern struct srv_session_service_st
{
  int (*init_session_thread)(const void *plugin);

  void (*deinit_session_thread)();

  MYSQL_SESSION (*open_session)(srv_session_error_cb error_cb,
                                void *plugix_ctx);

  int (*detach_session)(MYSQL_SESSION session);

  int (*close_session)(MYSQL_SESSION session);

  int (*server_is_available)();
} *srv_session_service;
// # 170 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session.h"
}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h"
// # 1 "/usr/include/pthread.h" 1 3 4
// # 23 "/usr/include/pthread.h" 3 4
// # 1 "/usr/include/sched.h" 1 3 4
// # 29 "/usr/include/sched.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 30 "/usr/include/sched.h" 2 3 4
// # 42 "/usr/include/sched.h" 3 4
// # 1 "/usr/include/bits/sched.h" 1 3 4
// # 73 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };

extern "C" {



extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) throw ();


extern int unshare (int __flags) throw ();


extern int sched_getcpu (void) throw ();


extern int setns (int __fd, int __nstype) throw ();



}







struct __sched_param
  {
    int __sched_priority;
  };
// # 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
// # 202 "/usr/include/bits/sched.h" 3 4
extern "C" {

extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  throw ();
extern cpu_set_t *__sched_cpualloc (size_t __count) throw () ;
extern void __sched_cpufree (cpu_set_t *__set) throw ();

}
// # 43 "/usr/include/sched.h" 2 3 4




extern "C" {


extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     throw ();


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) throw ();


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) throw ();


extern int sched_getscheduler (__pid_t __pid) throw ();


extern int sched_yield (void) throw ();


extern int sched_get_priority_max (int __algorithm) throw ();


extern int sched_get_priority_min (int __algorithm) throw ();


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) throw ();
// # 117 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) throw ();


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) throw ();


}
// # 24 "/usr/include/pthread.h" 2 3 4



// # 1 "/usr/include/bits/setjmp.h" 1 3 4
// # 26 "/usr/include/bits/setjmp.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
// # 28 "/usr/include/pthread.h" 2 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
// # 113 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
// # 154 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
// # 189 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
// # 227 "/usr/include/pthread.h" 3 4
extern "C" {




extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) throw () __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) throw ();







extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);






extern int pthread_detach (pthread_t __th) throw ();



extern pthread_t pthread_self (void) throw () __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  throw () __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     throw () __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     throw () __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (1, 3)));





extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     throw () __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     throw () __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     throw ();




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     throw () __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) throw ();


extern int pthread_setconcurrency (int __level) throw ();







extern int pthread_yield (void) throw ();




extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     throw () __attribute__ ((__nonnull__ (3)));
// # 485 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
// # 497 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
// # 531 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};




class __pthread_cleanup_class
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;

 public:
  __pthread_cleanup_class (void (*__fct) (void *), void *__arg)
    : __cancel_routine (__fct), __cancel_arg (__arg), __do_it (1) { }
  ~__pthread_cleanup_class () { if (__do_it) __cancel_routine (__cancel_arg); }
  void __setdoit (int __newval) { __do_it = __newval; }
  void __defer () { pthread_setcanceltype (PTHREAD_CANCEL_DEFERRED,
        &__cancel_type); }
  void __restore () const { pthread_setcanceltype (__cancel_type, 0); }
};
// # 733 "/usr/include/pthread.h" 3 4
struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) throw ();





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     throw () __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutex_consistent_np (pthread_mutex_t *__mutex)
     throw () __attribute__ ((__nonnull__ (1)));
// # 797 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));

extern int pthread_mutexattr_getrobust_np (const pthread_mutexattr_t *__attr,
        int *__robustness)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));

extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *__attr,
        int __robustness)
     throw () __attribute__ ((__nonnull__ (1)));
// # 879 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) throw () __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     throw () __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) throw () __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
// # 991 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     throw () __attribute__ ((__nonnull__ (1)));
// # 1035 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     throw () __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     throw () __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     throw () __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     throw () __attribute__ ((__nonnull__ (1)));
// # 1102 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     throw () __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) throw ();


extern void *pthread_getspecific (pthread_key_t __key) throw ();


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) throw () ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     throw () __attribute__ ((__nonnull__ (2)));
// # 1136 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) throw ();




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2) throw ()
{
  return __thread1 == __thread2;
}


}
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h" 2
// # 51 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h"
extern "C" {
// # 68 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h"
typedef pthread_once_t my_thread_once_t;
typedef pthread_t my_thread_t;
typedef pthread_attr_t my_thread_attr_t;


typedef void *(* my_start_routine)(void *);



typedef struct st_my_thread_handle
{
  my_thread_t thread;



} my_thread_handle;

int my_thread_once(my_thread_once_t *once_control, void (*init_routine)(void));

static inline my_thread_t my_thread_self()
{



  return pthread_self();

}

static inline int my_thread_equal(my_thread_t t1, my_thread_t t2)
{



  return pthread_equal(t1, t2);

}

static inline int my_thread_attr_init(my_thread_attr_t *attr)
{






  return pthread_attr_init(attr);

}

static inline int my_thread_attr_destroy(my_thread_attr_t *attr)
{






  return pthread_attr_destroy(attr);

}

static inline int my_thread_attr_setstacksize(my_thread_attr_t *attr,
                                              size_t stacksize)
{




  return pthread_attr_setstacksize(attr, stacksize);

}

static inline int my_thread_attr_setdetachstate(my_thread_attr_t *attr,
                                                int detachstate)
{




  return pthread_attr_setdetachstate(attr, detachstate);

}

static inline int my_thread_attr_getstacksize(my_thread_attr_t *attr,
                                              size_t *stacksize)
{




  return pthread_attr_getstacksize(attr, stacksize);

}

static inline void my_thread_yield()
{



  sched_yield();

}

int my_thread_create(my_thread_handle *thread, const my_thread_attr_t *attr,
                     my_start_routine func, void *arg);
int my_thread_join(my_thread_handle *thread, void **value_ptr);
int my_thread_cancel(my_thread_handle *thread);
void my_thread_exit(void *value_ptr);


extern my_bool my_thread_global_init();
extern void my_thread_global_reinit();
extern void my_thread_global_end();
extern my_bool my_thread_init();
extern void my_thread_end();

}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_snprintf.h" 1
// # 72 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_snprintf.h"
extern "C" {







extern struct my_snprintf_service_st {
  size_t (*my_snprintf_type)(char*, size_t, const char*, ...);
  size_t (*my_vsnprintf_type)(char *, size_t, const char*, va_list);
} *my_snprintf_service;
// # 98 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_snprintf.h"
}
// # 31 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h" 2


extern "C" {







extern void *(*my_str_malloc)(size_t);
extern void *(*my_str_realloc)(void *, size_t);
extern void (*my_str_free)(void *);


extern char _dig_vec_upper[];
extern char _dig_vec_lower[];



extern void bchange(uchar *dst,size_t old_len,const uchar *src,
       size_t new_len,size_t tot_len);
extern void strappend(char *s,size_t len,pchar fill);
extern char *strend(const char *s);
extern char *strcend(const char *, pchar);
extern char *strfill(char * s,size_t len,pchar fill);
extern char *strmake(char *dst,const char *src,size_t length);

extern char *my_stpmov(char *dst,const char *src);
extern char *my_stpnmov(char *dst, const char *src, size_t n);
extern char *strcont(const char *src, const char *set);
extern char *strxmov(char *dst, const char *src, ...);
extern char *strxnmov(char *dst, size_t len, const char *src, ...);
// # 78 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
static inline char *my_stpcpy(char *dst, const char *src)
{

  return __builtin_stpcpy(dst, src);






}
// # 102 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
static inline char *my_stpncpy(char *dst, const char *src, size_t n)
{

  return stpncpy(dst, src, n);




}

static inline longlong my_strtoll(const char *nptr, char **endptr, int base)
{



  return strtoll(nptr, endptr, base);

}

static inline ulonglong my_strtoull(const char *nptr, char **endptr, int base)
{



  return strtoull(nptr, endptr, base);

}

static inline char *my_strtok_r(char *str, const char *delim, char **saveptr)
{



  return strtok_r(str, delim, saveptr);

}


static inline int native_strcasecmp(const char *s1, const char *s2)
{



  return strcasecmp(s1, s2);

}


static inline int native_strncasecmp(const char *s1, const char *s2, size_t n)
{



  return strncasecmp(s1, s2, n);

}






extern int is_prefix(const char *, const char *);


typedef enum {
  MY_GCVT_ARG_FLOAT,
  MY_GCVT_ARG_DOUBLE
} my_gcvt_arg_type;

double my_strtod(const char *str, char **end, int *error);
double my_atof(const char *nptr);
size_t my_fcvt(double x, int precision, char *to, my_bool *error);
size_t my_gcvt(double x, my_gcvt_arg_type type, int width, char *to,
               my_bool *error);
// # 204 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
extern char *llstr(longlong value,char *buff);
extern char *ullstr(longlong value,char *buff);

extern char *int2str(long val, char *dst, int radix, int upcase);
extern char *int10_to_str(long val,char *dst,int radix);
extern char *str2int(const char *src,int radix,long lower,long upper,
    long *val);
longlong my_strtoll10(const char *nptr, char **endptr, int *error);
// # 225 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
}
// # 234 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/mysql_lex_string.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/mysql_lex_string.h"
struct st_mysql_lex_string
{
  char *str;
  size_t length;
};
typedef struct st_mysql_lex_string MYSQL_LEX_STRING;

struct st_mysql_const_lex_string
{
  const char *str;
  size_t length;
};
typedef struct st_mysql_const_lex_string MYSQL_LEX_CSTRING;
// # 235 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h" 2
typedef struct st_mysql_lex_string LEX_STRING;
typedef struct st_mysql_const_lex_string LEX_CSTRING;
// # 314 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_string.h"
static inline const uchar *skip_trailing_space(const uchar *ptr, size_t len)
{
  const uchar *end= ptr + len;
  while (end - ptr >= 8)
  {
    if (uint8korr(end-8) != 0x2020202020202020ULL)
      break;
    end-= 8;
  }
  while (end > ptr && end[-1] == 0x20)
    end--;
  return (end);
}


static inline void lex_string_set(LEX_STRING *lex_str, const char *c_str)
{
  lex_str->str= (char *) c_str;
  lex_str->length= strlen(c_str);
}

static inline void lex_cstring_set(LEX_CSTRING *lex_str, const char *c_str)
{
  lex_str->str= c_str;
  lex_str->length= strlen(c_str);
}
// # 29 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/libbinlogevents/export/binary_log_types.h" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/libbinlogevents/export/binary_log_types.h"
extern "C"
{






typedef enum enum_field_types {
  MYSQL_TYPE_DECIMAL, MYSQL_TYPE_TINY,
  MYSQL_TYPE_SHORT, MYSQL_TYPE_LONG,
  MYSQL_TYPE_FLOAT, MYSQL_TYPE_DOUBLE,
  MYSQL_TYPE_NULL, MYSQL_TYPE_TIMESTAMP,
  MYSQL_TYPE_LONGLONG,MYSQL_TYPE_INT24,
  MYSQL_TYPE_DATE, MYSQL_TYPE_TIME,
  MYSQL_TYPE_DATETIME, MYSQL_TYPE_YEAR,
  MYSQL_TYPE_NEWDATE, MYSQL_TYPE_VARCHAR,
  MYSQL_TYPE_BIT,
  MYSQL_TYPE_TIMESTAMP2,
  MYSQL_TYPE_DATETIME2,
  MYSQL_TYPE_TIME2,
  MYSQL_TYPE_JSON=245,
  MYSQL_TYPE_NEWDECIMAL=246,
  MYSQL_TYPE_ENUM=247,
  MYSQL_TYPE_SET=248,
  MYSQL_TYPE_TINY_BLOB=249,
  MYSQL_TYPE_MEDIUM_BLOB=250,
  MYSQL_TYPE_LONG_BLOB=251,
  MYSQL_TYPE_BLOB=252,
  MYSQL_TYPE_VAR_STRING=253,
  MYSQL_TYPE_STRING=254,
  MYSQL_TYPE_GEOMETRY=255
} enum_field_types;




}
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_command.h" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_command.h"
enum enum_server_command
{
  COM_SLEEP,
  COM_QUIT,
  COM_INIT_DB,
  COM_QUERY,
  COM_FIELD_LIST,
  COM_CREATE_DB,
  COM_DROP_DB,
  COM_REFRESH,
  COM_SHUTDOWN,
  COM_STATISTICS,
  COM_PROCESS_INFO,
  COM_CONNECT,
  COM_PROCESS_KILL,
  COM_DEBUG,
  COM_PING,
  COM_TIME,
  COM_DELAYED_INSERT,
  COM_CHANGE_USER,
  COM_BINLOG_DUMP,
  COM_TABLE_DUMP,
  COM_CONNECT_OUT,
  COM_REGISTER_SLAVE,
  COM_STMT_PREPARE,
  COM_STMT_EXECUTE,
  COM_STMT_SEND_LONG_DATA,
  COM_STMT_CLOSE,
  COM_STMT_RESET,
  COM_SET_OPTION,
  COM_STMT_FETCH,
  COM_DAEMON,
  COM_BINLOG_DUMP_GTID,
  COM_RESET_CONNECTION,



  COM_END
};
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h" 2
// # 320 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
struct st_vio;
typedef struct st_vio Vio;
// # 331 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
typedef struct st_net {
  Vio *vio;
  unsigned char *buff,*buff_end,*write_pos,*read_pos;
  my_socket fd;





  unsigned long remain_in_buf,length, buf_length, where_b;
  unsigned long max_packet,max_packet_size;
  unsigned int pkt_nr,compress_pkt_nr;
  unsigned int write_timeout, read_timeout, retry_count;
  int fcntl;
  unsigned int *return_status;
  unsigned char reading_or_writing;
  char save_char;
  my_bool unused1;
  my_bool unused2;
  my_bool compress;
  my_bool unused3;







  unsigned char *unused;
  unsigned int last_errno;
  unsigned char error;
  my_bool unused4;
  my_bool unused5;

  char last_error[512];

  char sqlstate[5 +1];
// # 376 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
  void *extension;
} NET;
// # 421 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
enum mysql_enum_shutdown_level {





  SHUTDOWN_DEFAULT = 0,

  SHUTDOWN_WAIT_CONNECTIONS= (unsigned char)(1 << 0),

  SHUTDOWN_WAIT_TRANSACTIONS= (unsigned char)(1 << 1),

  SHUTDOWN_WAIT_UPDATES= (unsigned char)(1 << 3),

  SHUTDOWN_WAIT_ALL_BUFFERS= ((unsigned char)(1 << 3) << 1),

  SHUTDOWN_WAIT_CRITICAL_BUFFERS= ((unsigned char)(1 << 3) << 1) + 1,

  KILL_QUERY= 254,
  KILL_CONNECTION= 255
};


enum enum_cursor_type
{
  CURSOR_TYPE_NO_CURSOR= 0,
  CURSOR_TYPE_READ_ONLY= 1,
  CURSOR_TYPE_FOR_UPDATE= 2,
  CURSOR_TYPE_SCROLLABLE= 4
};



enum enum_mysql_set_option
{
  MYSQL_OPTION_MULTI_STATEMENTS_ON,
  MYSQL_OPTION_MULTI_STATEMENTS_OFF
};
// # 467 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
enum enum_session_state_type
{
  SESSION_TRACK_SYSTEM_VARIABLES,
  SESSION_TRACK_SCHEMA,
  SESSION_TRACK_STATE_CHANGE,
  SESSION_TRACK_GTIDS,
  SESSION_TRACK_TRANSACTION_CHARACTERISTICS,
  SESSION_TRACK_TRANSACTION_STATE
};
// # 487 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
extern "C" {


my_bool my_net_init(NET *net, Vio* vio);
void my_net_local_init(NET *net);
void net_end(NET *net);
void net_clear(NET *net, my_bool check_buffer);
void net_claim_memory_ownership(NET *net);
my_bool net_realloc(NET *net, size_t length);
my_bool net_flush(NET *net);
my_bool my_net_write(NET *net,const unsigned char *packet, size_t len);
my_bool net_write_command(NET *net,unsigned char command,
     const unsigned char *header, size_t head_len,
     const unsigned char *packet, size_t len);
my_bool net_write_packet(NET *net, const unsigned char *packet, size_t length);
unsigned long my_net_read(NET *net);


void my_net_set_write_timeout(NET *net, uint timeout);
void my_net_set_read_timeout(NET *net, uint timeout);


struct rand_struct {
  unsigned long seed1,seed2,max_value;
  double max_value_dbl;
};


}




enum Item_result {STRING_RESULT=0, REAL_RESULT, INT_RESULT, ROW_RESULT,
                  DECIMAL_RESULT};

typedef struct st_udf_args
{
  unsigned int arg_count;
  enum Item_result *arg_type;
  char **args;
  unsigned long *lengths;
  char *maybe_null;
  char **attributes;
  unsigned long *attribute_lengths;
  void *extension;
} UDF_ARGS;



typedef struct st_udf_init
{
  my_bool maybe_null;
  unsigned int decimals;
  unsigned long max_length;
  char *ptr;
  my_bool const_item;
  void *extension;
} UDF_INIT;
// # 558 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_com.h"
extern "C" {







void randominit(struct rand_struct *, unsigned long seed1,
                unsigned long seed2);
double my_rnd(struct rand_struct *);
void create_random_string(char *to, unsigned int length, struct rand_struct *rand_st);

void hash_password(unsigned long *to, const char *password, unsigned int password_len);
void make_scrambled_password_323(char *to, const char *password);
void scramble_323(char *to, const char *message, const char *password);
my_bool check_scramble_323(const unsigned char *reply, const char *message,
                           unsigned long *salt);
void get_salt_from_password_323(unsigned long *res, const char *password);
void make_password_from_salt_323(char *to, const unsigned long *salt);

void make_scrambled_password(char *to, const char *password);
void scramble(char *to, const char *message, const char *password);
my_bool check_scramble(const unsigned char *reply, const char *message,
                       const unsigned char *hash_stage2);
void get_salt_from_password(unsigned char *res, const char *password);
void make_password_from_salt(char *to, const unsigned char *hash_stage2);
char *octet2hex(char *to, const char *str, unsigned int len);



char *get_tty_password(const char *opt_message);
const char *mysql_errno_to_sqlstate(unsigned int mysql_errno);



my_bool my_thread_init(void);
void my_thread_end(void);


ulong net_field_length(uchar **packet);
my_ulonglong net_field_length_ll(uchar **packet);
uchar *net_store_length(uchar *pkg, ulonglong length);
unsigned int net_length_size(ulonglong num);



}
// # 31 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h" 1
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_base.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_base.h"
extern "C" {
// # 151 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_base.h"
}
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
extern "C" {
// # 42 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
struct PSI_thread;






typedef unsigned int PSI_memory_key;
// # 64 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
struct PSI_memory_info_v1
{

  PSI_memory_key *m_key;

  const char *m_name;




  int m_flags;
};
typedef struct PSI_memory_info_v1 PSI_memory_info_v1;







typedef void (*register_memory_v1_t)
  (const char *category, struct PSI_memory_info_v1 *info, int count);
// # 94 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
typedef PSI_memory_key (*memory_alloc_v1_t)
  (PSI_memory_key key, size_t size, struct PSI_thread ** owner);
// # 105 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
typedef PSI_memory_key (*memory_realloc_v1_t)
  (PSI_memory_key key, size_t old_size, size_t new_size, struct PSI_thread ** owner);
// # 115 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
typedef PSI_memory_key (*memory_claim_v1_t)
  (PSI_memory_key key, size_t size, struct PSI_thread ** owner);







typedef void (*memory_free_v1_t)
  (PSI_memory_key key, size_t size, struct PSI_thread * owner);
// # 140 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
typedef struct PSI_memory_info_v1 PSI_memory_info;
// # 150 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h"
}
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h" 2
// # 44 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
extern "C" {


struct MDL_key;
typedef struct MDL_key MDL_key;


typedef int opaque_mdl_type;


typedef int opaque_mdl_duration;


typedef int opaque_mdl_status;


typedef int opaque_vio_type;

struct TABLE_SHARE;

struct sql_digest_storage;


  class THD;
// # 93 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_mutex;
typedef struct PSI_mutex PSI_mutex;





struct PSI_rwlock;
typedef struct PSI_rwlock PSI_rwlock;





struct PSI_cond;
typedef struct PSI_cond PSI_cond;





struct PSI_table_share;
typedef struct PSI_table_share PSI_table_share;





struct PSI_table;
typedef struct PSI_table PSI_table;





struct PSI_thread;
typedef struct PSI_thread PSI_thread;





struct PSI_file;
typedef struct PSI_file PSI_file;





struct PSI_socket;
typedef struct PSI_socket PSI_socket;





struct PSI_prepared_stmt;
typedef struct PSI_prepared_stmt PSI_prepared_stmt;





struct PSI_table_locker;
typedef struct PSI_table_locker PSI_table_locker;





struct PSI_statement_locker;
typedef struct PSI_statement_locker PSI_statement_locker;





struct PSI_transaction_locker;
typedef struct PSI_transaction_locker PSI_transaction_locker;





struct PSI_idle_locker;
typedef struct PSI_idle_locker PSI_idle_locker;





struct PSI_digest_locker;
typedef struct PSI_digest_locker PSI_digest_locker;





struct PSI_sp_share;
typedef struct PSI_sp_share PSI_sp_share;





struct PSI_sp_locker;
typedef struct PSI_sp_locker PSI_sp_locker;





struct PSI_metadata_lock;
typedef struct PSI_metadata_lock PSI_metadata_lock;





struct PSI_stage_progress
{
  ulonglong m_work_completed;
  ulonglong m_work_estimated;
};
typedef struct PSI_stage_progress PSI_stage_progress;


enum PSI_table_io_operation
{

  PSI_TABLE_FETCH_ROW= 0,

  PSI_TABLE_WRITE_ROW= 1,

  PSI_TABLE_UPDATE_ROW= 2,

  PSI_TABLE_DELETE_ROW= 3
};
typedef enum PSI_table_io_operation PSI_table_io_operation;
// # 244 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_table_locker_state
{

  uint m_flags;

  enum PSI_table_io_operation m_io_operation;

  struct PSI_table *m_table;

  struct PSI_table_share *m_table_share;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;





  uint m_index;
};
typedef struct PSI_table_locker_state PSI_table_locker_state;


struct PSI_bootstrap
{
// # 287 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
  void* (*get_interface)(int version);
};
typedef struct PSI_bootstrap PSI_bootstrap;
// # 572 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_mutex_locker;
typedef struct PSI_mutex_locker PSI_mutex_locker;





struct PSI_rwlock_locker;
typedef struct PSI_rwlock_locker PSI_rwlock_locker;





struct PSI_cond_locker;
typedef struct PSI_cond_locker PSI_cond_locker;





struct PSI_file_locker;
typedef struct PSI_file_locker PSI_file_locker;





struct PSI_socket_locker;
typedef struct PSI_socket_locker PSI_socket_locker;





struct PSI_metadata_locker;
typedef struct PSI_metadata_locker PSI_metadata_locker;


enum PSI_mutex_operation
{

  PSI_MUTEX_LOCK= 0,

  PSI_MUTEX_TRYLOCK= 1
};
typedef enum PSI_mutex_operation PSI_mutex_operation;







enum PSI_rwlock_operation
{

  PSI_RWLOCK_READLOCK= 0,

  PSI_RWLOCK_WRITELOCK= 1,

  PSI_RWLOCK_TRYREADLOCK= 2,

  PSI_RWLOCK_TRYWRITELOCK= 3,


  PSI_RWLOCK_SHAREDLOCK= 4,

  PSI_RWLOCK_SHAREDEXCLUSIVELOCK= 5,

  PSI_RWLOCK_EXCLUSIVELOCK= 6,

  PSI_RWLOCK_TRYSHAREDLOCK= 7,

  PSI_RWLOCK_TRYSHAREDEXCLUSIVELOCK= 8,

  PSI_RWLOCK_TRYEXCLUSIVELOCK= 9

};
typedef enum PSI_rwlock_operation PSI_rwlock_operation;


enum PSI_cond_operation
{

  PSI_COND_WAIT= 0,

  PSI_COND_TIMEDWAIT= 1
};
typedef enum PSI_cond_operation PSI_cond_operation;


enum PSI_file_operation
{

  PSI_FILE_CREATE= 0,

  PSI_FILE_CREATE_TMP= 1,

  PSI_FILE_OPEN= 2,

  PSI_FILE_STREAM_OPEN= 3,

  PSI_FILE_CLOSE= 4,

  PSI_FILE_STREAM_CLOSE= 5,




  PSI_FILE_READ= 6,




  PSI_FILE_WRITE= 7,

  PSI_FILE_SEEK= 8,

  PSI_FILE_TELL= 9,

  PSI_FILE_FLUSH= 10,

  PSI_FILE_STAT= 11,

  PSI_FILE_FSTAT= 12,

  PSI_FILE_CHSIZE= 13,

  PSI_FILE_DELETE= 14,

  PSI_FILE_RENAME= 15,

  PSI_FILE_SYNC= 16
};
typedef enum PSI_file_operation PSI_file_operation;


enum PSI_table_lock_operation
{

  PSI_TABLE_LOCK= 0,

  PSI_TABLE_EXTERNAL_LOCK= 1
};
typedef enum PSI_table_lock_operation PSI_table_lock_operation;


enum PSI_socket_state
{

  PSI_SOCKET_STATE_IDLE= 1,

  PSI_SOCKET_STATE_ACTIVE= 2
};
typedef enum PSI_socket_state PSI_socket_state;


enum PSI_socket_operation
{

  PSI_SOCKET_CREATE= 0,

  PSI_SOCKET_CONNECT= 1,

  PSI_SOCKET_BIND= 2,

  PSI_SOCKET_CLOSE= 3,

  PSI_SOCKET_SEND= 4,

  PSI_SOCKET_RECV= 5,

  PSI_SOCKET_SENDTO= 6,

  PSI_SOCKET_RECVFROM= 7,

  PSI_SOCKET_SENDMSG= 8,

  PSI_SOCKET_RECVMSG= 9,

  PSI_SOCKET_SEEK= 10,

  PSI_SOCKET_OPT= 11,

  PSI_SOCKET_STAT= 12,

  PSI_SOCKET_SHUTDOWN= 13,

  PSI_SOCKET_SELECT= 14
};
typedef enum PSI_socket_operation PSI_socket_operation;






typedef unsigned int PSI_mutex_key;







typedef unsigned int PSI_rwlock_key;







typedef unsigned int PSI_cond_key;







typedef unsigned int PSI_thread_key;







typedef unsigned int PSI_file_key;
// # 811 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef unsigned int PSI_stage_key;






typedef unsigned int PSI_statement_key;






typedef unsigned int PSI_socket_key;
// # 840 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_mutex_info_v1
{



  PSI_mutex_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_mutex_info_v1 PSI_mutex_info_v1;






struct PSI_rwlock_info_v1
{



  PSI_rwlock_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_rwlock_info_v1 PSI_rwlock_info_v1;






struct PSI_cond_info_v1
{



  PSI_cond_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_cond_info_v1 PSI_cond_info_v1;






struct PSI_thread_info_v1
{



  PSI_thread_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_thread_info_v1 PSI_thread_info_v1;






struct PSI_file_info_v1
{



  PSI_file_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_file_info_v1 PSI_file_info_v1;






struct PSI_stage_info_v1
{

  PSI_stage_key m_key;

  const char *m_name;

  int m_flags;
};
typedef struct PSI_stage_info_v1 PSI_stage_info_v1;






struct PSI_statement_info_v1
{

  PSI_statement_key m_key;

  const char *m_name;

  int m_flags;
};
typedef struct PSI_statement_info_v1 PSI_statement_info_v1;






struct PSI_socket_info_v1
{



  PSI_socket_key *m_key;



  const char *m_name;




  int m_flags;
};
typedef struct PSI_socket_info_v1 PSI_socket_info_v1;
// # 1014 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_idle_locker_state_v1
{

  uint m_flags;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_idle_locker_state_v1 PSI_idle_locker_state_v1;
// # 1038 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_mutex_locker_state_v1
{

  uint m_flags;

  enum PSI_mutex_operation m_operation;

  struct PSI_mutex *m_mutex;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_mutex_locker_state_v1 PSI_mutex_locker_state_v1;
// # 1067 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_rwlock_locker_state_v1
{

  uint m_flags;

  enum PSI_rwlock_operation m_operation;

  struct PSI_rwlock *m_rwlock;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_rwlock_locker_state_v1 PSI_rwlock_locker_state_v1;
// # 1095 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_cond_locker_state_v1
{

  uint m_flags;

  enum PSI_cond_operation m_operation;

  struct PSI_cond *m_cond;

  struct PSI_mutex *m_mutex;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_cond_locker_state_v1 PSI_cond_locker_state_v1;
// # 1127 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_file_locker_state_v1
{

  uint m_flags;

  enum PSI_file_operation m_operation;

  struct PSI_file *m_file;

  const char *m_name;

  void *m_class;

  struct PSI_thread *m_thread;

  size_t m_number_of_bytes;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_file_locker_state_v1 PSI_file_locker_state_v1;
// # 1161 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_metadata_locker_state_v1
{

  uint m_flags;

  struct PSI_metadata_lock *m_metadata_lock;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_wait;
};
typedef struct PSI_metadata_locker_state_v1 PSI_metadata_locker_state_v1;
// # 1191 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_statement_locker_state_v1
{

  my_bool m_discarded;

  my_bool m_in_prepare;

  uchar m_no_index_used;

  uchar m_no_good_index_used;

  uint m_flags;

  void *m_class;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_statement;

  ulonglong m_lock_time;

  ulonglong m_rows_sent;

  ulonglong m_rows_examined;

  ulong m_created_tmp_disk_tables;

  ulong m_created_tmp_tables;

  ulong m_select_full_join;

  ulong m_select_full_range_join;

  ulong m_select_range;

  ulong m_select_range_check;

  ulong m_select_scan;

  ulong m_sort_merge_passes;

  ulong m_sort_range;

  ulong m_sort_rows;

  ulong m_sort_scan;

  const struct sql_digest_storage *m_digest;

  char m_schema_name[(64 * 3)];

  uint m_schema_name_length;

  uint m_cs_number;
  PSI_sp_share *m_parent_sp_share;
  PSI_prepared_stmt *m_parent_prepared_stmt;
};
typedef struct PSI_statement_locker_state_v1 PSI_statement_locker_state_v1;
// # 1264 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_transaction_locker_state_v1
{

  uint m_flags;

  void *m_class;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  void *m_transaction;

  my_bool m_read_only;

  my_bool m_autocommit;

  ulong m_statement_count;

  ulong m_savepoint_count;

  ulong m_rollback_to_savepoint_count;

  ulong m_release_savepoint_count;
};

typedef struct PSI_transaction_locker_state_v1 PSI_transaction_locker_state_v1;
// # 1303 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
struct PSI_socket_locker_state_v1
{

  uint m_flags;

  struct PSI_socket *m_socket;

  struct PSI_thread *m_thread;

  size_t m_number_of_bytes;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  enum PSI_socket_operation m_operation;

  const char* m_src_file;

  int m_src_line;

  void *m_wait;
};
typedef struct PSI_socket_locker_state_v1 PSI_socket_locker_state_v1;

struct PSI_sp_locker_state_v1
{

  uint m_flags;

  struct PSI_thread *m_thread;

  ulonglong m_timer_start;

  ulonglong (*m_timer)(void);

  PSI_sp_share* m_sp_share;
};
typedef struct PSI_sp_locker_state_v1 PSI_sp_locker_state_v1;
// # 1351 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*register_mutex_v1_t)
  (const char *category, struct PSI_mutex_info_v1 *info, int count);







typedef void (*register_rwlock_v1_t)
  (const char *category, struct PSI_rwlock_info_v1 *info, int count);







typedef void (*register_cond_v1_t)
  (const char *category, struct PSI_cond_info_v1 *info, int count);







typedef void (*register_thread_v1_t)
  (const char *category, struct PSI_thread_info_v1 *info, int count);







typedef void (*register_file_v1_t)
  (const char *category, struct PSI_file_info_v1 *info, int count);







typedef void (*register_stage_v1_t)
  (const char *category, struct PSI_stage_info_v1 **info, int count);







typedef void (*register_statement_v1_t)
  (const char *category, struct PSI_statement_info_v1 *info, int count);







typedef void (*register_socket_v1_t)
  (const char *category, struct PSI_socket_info_v1 *info, int count);







typedef struct PSI_mutex* (*init_mutex_v1_t)
  (PSI_mutex_key key, const void *identity);





typedef void (*destroy_mutex_v1_t)(struct PSI_mutex *mutex);







typedef struct PSI_rwlock* (*init_rwlock_v1_t)
  (PSI_rwlock_key key, const void *identity);





typedef void (*destroy_rwlock_v1_t)(struct PSI_rwlock *rwlock);







typedef struct PSI_cond* (*init_cond_v1_t)
  (PSI_cond_key key, const void *identity);





typedef void (*destroy_cond_v1_t)(struct PSI_cond *cond);
// # 1470 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_socket* (*init_socket_v1_t)
  (PSI_socket_key key, const my_socket *fd,
  const struct sockaddr *addr, socklen_t addr_len);





typedef void (*destroy_socket_v1_t)(struct PSI_socket *socket);







typedef struct PSI_table_share* (*get_table_share_v1_t)
  (my_bool temporary, struct TABLE_SHARE *share);





typedef void (*release_table_share_v1_t)(struct PSI_table_share *share);
// # 1503 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*drop_table_share_v1_t)
  (my_bool temporary, const char *schema_name, int schema_name_length,
   const char *table_name, int table_name_length);







typedef struct PSI_table* (*open_table_v1_t)
  (struct PSI_table_share *share, const void *identity);






typedef void (*unbind_table_v1_t)
  (struct PSI_table *table);







typedef PSI_table* (*rebind_table_v1_t)
  (PSI_table_share *share, const void *identity, PSI_table *table);






typedef void (*close_table_v1_t)(struct TABLE_SHARE *server_share,
                                 struct PSI_table *table);
// # 1549 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*create_file_v1_t)(PSI_file_key key, const char *name,
                                 File file);
// # 1561 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef int (*spawn_thread_v1_t)(PSI_thread_key key,
                                 my_thread_handle *thread,
                                 const my_thread_attr_t *attr,
                                 void *(*start_routine)(void*), void *arg);







typedef struct PSI_thread* (*new_thread_v1_t)
  (PSI_thread_key key, const void *identity, ulonglong thread_id);






typedef void (*set_thread_THD_v1_t)(struct PSI_thread *thread,
                                    THD *thd);






typedef void (*set_thread_id_v1_t)(struct PSI_thread *thread,
                                   ulonglong id);






typedef void (*set_thread_os_id_v1_t)(struct PSI_thread *thread);
// # 1605 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_thread* (*get_thread_v1_t)(void);






typedef void (*set_thread_user_v1_t)(const char *user, int user_len);
// # 1621 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*set_thread_account_v1_t)(const char *user, int user_len,
                                        const char *host, int host_len);






typedef void (*set_thread_db_v1_t)(const char* db, int db_len);





typedef void (*set_thread_command_v1_t)(int command);





typedef void (*set_connection_type_v1_t)(opaque_vio_type conn_type);






typedef void (*set_thread_start_time_v1_t)(time_t start_time);





typedef void (*set_thread_state_v1_t)(const char* state);






typedef void (*set_thread_info_v1_t)(const char* info, uint info_len);
// # 1672 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*set_thread_v1_t)(struct PSI_thread *thread);


typedef void (*delete_current_thread_v1_t)(void);


typedef void (*delete_thread_v1_t)(struct PSI_thread *thread);
// # 1689 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_file_locker* (*get_thread_file_name_locker_v1_t)
  (struct PSI_file_locker_state_v1 *state,
   PSI_file_key key, enum PSI_file_operation op, const char *name,
   const void *identity);
// # 1701 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_file_locker* (*get_thread_file_stream_locker_v1_t)
  (struct PSI_file_locker_state_v1 *state,
   struct PSI_file *file, enum PSI_file_operation op);
// # 1712 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_file_locker* (*get_thread_file_descriptor_locker_v1_t)
  (struct PSI_file_locker_state_v1 *state,
   File file, enum PSI_file_operation op);





typedef void (*unlock_mutex_v1_t)
  (struct PSI_mutex *mutex);





typedef void (*unlock_rwlock_v1_t)
  (struct PSI_rwlock *rwlock);





typedef void (*signal_cond_v1_t)
  (struct PSI_cond *cond);





typedef void (*broadcast_cond_v1_t)
  (struct PSI_cond *cond);
// # 1751 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_idle_locker* (*start_idle_wait_v1_t)
  (struct PSI_idle_locker_state_v1 *state, const char *src_file, uint src_line);





typedef void (*end_idle_wait_v1_t)
  (struct PSI_idle_locker *locker);
// # 1770 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_mutex_locker* (*start_mutex_wait_v1_t)
  (struct PSI_mutex_locker_state_v1 *state,
   struct PSI_mutex *mutex,
   enum PSI_mutex_operation op,
   const char *src_file, uint src_line);






typedef void (*end_mutex_wait_v1_t)
  (struct PSI_mutex_locker *locker, int rc);






typedef struct PSI_rwlock_locker* (*start_rwlock_rdwait_v1_t)
  (struct PSI_rwlock_locker_state_v1 *state,
   struct PSI_rwlock *rwlock,
   enum PSI_rwlock_operation op,
   const char *src_file, uint src_line);






typedef void (*end_rwlock_rdwait_v1_t)
  (struct PSI_rwlock_locker *locker, int rc);






typedef struct PSI_rwlock_locker* (*start_rwlock_wrwait_v1_t)
  (struct PSI_rwlock_locker_state_v1 *state,
   struct PSI_rwlock *rwlock,
   enum PSI_rwlock_operation op,
   const char *src_file, uint src_line);






typedef void (*end_rwlock_wrwait_v1_t)
  (struct PSI_rwlock_locker *locker, int rc);






typedef struct PSI_cond_locker* (*start_cond_wait_v1_t)
  (struct PSI_cond_locker_state_v1 *state,
   struct PSI_cond *cond,
   struct PSI_mutex *mutex,
   enum PSI_cond_operation op,
   const char *src_file, uint src_line);






typedef void (*end_cond_wait_v1_t)
  (struct PSI_cond_locker *locker, int rc);







typedef struct PSI_table_locker* (*start_table_io_wait_v1_t)
  (struct PSI_table_locker_state *state,
   struct PSI_table *table,
   enum PSI_table_io_operation op,
   uint index,
   const char *src_file, uint src_line);






typedef void (*end_table_io_wait_v1_t)
  (struct PSI_table_locker *locker,
   ulonglong numrows);







typedef struct PSI_table_locker* (*start_table_lock_wait_v1_t)
  (struct PSI_table_locker_state *state,
   struct PSI_table *table,
   enum PSI_table_lock_operation op,
   ulong flags,
   const char *src_file, uint src_line);





typedef void (*end_table_lock_wait_v1_t)(struct PSI_table_locker *locker);

typedef void (*unlock_table_v1_t)(struct PSI_table *table);
// # 1892 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*start_file_open_wait_v1_t)
  (struct PSI_file_locker *locker, const char *src_file, uint src_line);







typedef struct PSI_file* (*end_file_open_wait_v1_t)
  (struct PSI_file_locker *locker, void *result);






typedef void (*end_file_open_wait_and_bind_to_descriptor_v1_t)
  (struct PSI_file_locker *locker, File file);







typedef void (*end_temp_file_open_wait_and_bind_to_descriptor_v1_t)
  (struct PSI_file_locker *locker, File file, const char *filename);
// # 1929 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*start_file_wait_v1_t)
  (struct PSI_file_locker *locker, size_t count,
   const char *src_file, uint src_line);
// # 1945 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*end_file_wait_v1_t)
  (struct PSI_file_locker *locker, size_t count);
// # 1955 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*start_file_close_wait_v1_t)
  (struct PSI_file_locker *locker, const char *src_file, uint src_line);







typedef void (*end_file_close_wait_v1_t)
  (struct PSI_file_locker *locker, int rc);
// # 1974 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef PSI_stage_progress* (*start_stage_v1_t)
  (PSI_stage_key key, const char *src_file, int src_line);

typedef PSI_stage_progress* (*get_current_stage_progress_v1_t)(void);


typedef void (*end_stage_v1_t) (void);
// # 1989 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_statement_locker* (*get_thread_statement_locker_v1_t)
  (struct PSI_statement_locker_state_v1 *state,
   PSI_statement_key key, const void *charset, PSI_sp_share *sp_share);
// # 2000 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_statement_locker* (*refine_statement_v1_t)
  (struct PSI_statement_locker *locker,
   PSI_statement_key key);
// # 2012 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*start_statement_v1_t)
  (struct PSI_statement_locker *locker,
   const char *db, uint db_length,
   const char *src_file, uint src_line);







typedef void (*set_statement_text_v1_t)
  (struct PSI_statement_locker *locker,
   const char *text, uint text_len);






typedef void (*set_statement_lock_time_t)
  (struct PSI_statement_locker *locker, ulonglong lock_time);






typedef void (*set_statement_rows_sent_t)
  (struct PSI_statement_locker *locker, ulonglong count);






typedef void (*set_statement_rows_examined_t)
  (struct PSI_statement_locker *locker, ulonglong count);






typedef void (*inc_statement_created_tmp_disk_tables_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_created_tmp_tables_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_select_full_join_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_select_full_range_join_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_select_range_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_select_range_check_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_select_scan_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_sort_merge_passes_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_sort_range_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_sort_rows_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*inc_statement_sort_scan_t)
  (struct PSI_statement_locker *locker, ulong count);






typedef void (*set_statement_no_index_used_t)
  (struct PSI_statement_locker *locker);






typedef void (*set_statement_no_good_index_used_t)
  (struct PSI_statement_locker *locker);







typedef void (*end_statement_v1_t)
  (struct PSI_statement_locker *locker, void *stmt_da);
// # 2174 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_transaction_locker* (*get_thread_transaction_locker_v1_t)
  (struct PSI_transaction_locker_state_v1 *state, const void *xid,
   const ulonglong *trxid, int isolation_level, my_bool read_only,
   my_bool autocommit);







typedef void (*start_transaction_v1_t)
  (struct PSI_transaction_locker *locker,
   const char *src_file, uint src_line);







typedef void (*set_transaction_xid_v1_t)
  (struct PSI_transaction_locker *locker,
   const void *xid, int xa_state);






typedef void (*set_transaction_xa_state_v1_t)
  (struct PSI_transaction_locker *locker,
   int xa_state);







typedef void (*set_transaction_gtid_v1_t)
  (struct PSI_transaction_locker *locker,
   const void *sid, const void *gtid_spec);






typedef void (*set_transaction_trxid_v1_t)
  (struct PSI_transaction_locker *locker,
   const ulonglong *trxid);






typedef void (*inc_transaction_savepoints_v1_t)
  (struct PSI_transaction_locker *locker, ulong count);






typedef void (*inc_transaction_rollback_to_savepoint_v1_t)
  (struct PSI_transaction_locker *locker, ulong count);






typedef void (*inc_transaction_release_savepoint_v1_t)
  (struct PSI_transaction_locker *locker, ulong count);






typedef void (*end_transaction_v1_t)
  (struct PSI_transaction_locker *locker,
   my_bool commit);
// # 2268 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_socket_locker* (*start_socket_wait_v1_t)
  (struct PSI_socket_locker_state_v1 *state,
   struct PSI_socket *socket,
   enum PSI_socket_operation op,
   size_t count,
   const char *src_file, uint src_line);
// # 2285 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*end_socket_wait_v1_t)
  (struct PSI_socket_locker *locker, size_t count);






typedef void (*set_socket_state_v1_t)(struct PSI_socket *socket,
                                      enum PSI_socket_state state);
// # 2304 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef void (*set_socket_info_v1_t)(struct PSI_socket *socket,
                                     const my_socket *fd,
                                     const struct sockaddr *addr,
                                     socklen_t addr_len);





typedef void (*set_socket_thread_owner_v1_t)(struct PSI_socket *socket);





typedef PSI_prepared_stmt* (*create_prepared_stmt_v1_t)
  (void *identity, uint stmt_id, PSI_statement_locker *locker,
   const char *stmt_name, size_t stmt_name_length,
   const char *name, size_t length);





typedef void (*destroy_prepared_stmt_v1_t)
  (PSI_prepared_stmt *prepared_stmt);





typedef void (*reprepare_prepared_stmt_v1_t)
  (PSI_prepared_stmt *prepared_stmt);






typedef void (*execute_prepared_stmt_v1_t)
  (PSI_statement_locker *locker, PSI_prepared_stmt* prepared_stmt);





typedef struct PSI_digest_locker * (*digest_start_v1_t)
  (struct PSI_statement_locker *locker);







typedef void (*digest_end_v1_t)
  (struct PSI_digest_locker *locker, const struct sql_digest_storage *digest);

typedef PSI_sp_locker* (*start_sp_v1_t)
  (struct PSI_sp_locker_state_v1 *state, struct PSI_sp_share* sp_share);

typedef void (*end_sp_v1_t)
  (struct PSI_sp_locker *locker);

typedef void (*drop_sp_v1_t)
  (uint object_type,
   const char *schema_name, uint schema_name_length,
   const char *object_name, uint object_name_length);
// # 2380 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_sp_share* (*get_sp_share_v1_t)
  (uint object_type,
   const char *schema_name, uint schema_name_length,
   const char *object_name, uint object_name_length);





typedef void (*release_sp_share_v1_t)(struct PSI_sp_share *share);

typedef PSI_metadata_lock* (*create_metadata_lock_v1_t)
  (void *identity,
   const MDL_key *key,
   opaque_mdl_type mdl_type,
   opaque_mdl_duration mdl_duration,
   opaque_mdl_status mdl_status,
   const char *src_file,
   uint src_line);

typedef void (*set_metadata_lock_status_v1_t)(PSI_metadata_lock *lock,
                                              opaque_mdl_status mdl_status);

typedef void (*destroy_metadata_lock_v1_t)(PSI_metadata_lock *lock);

typedef struct PSI_metadata_locker* (*start_metadata_wait_v1_t)
  (struct PSI_metadata_locker_state_v1 *state,
   struct PSI_metadata_lock *mdl,
   const char *src_file, uint src_line);

typedef void (*end_metadata_wait_v1_t)
  (struct PSI_metadata_locker *locker, int rc);
// # 2423 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef int (*set_thread_connect_attrs_v1_t)(const char *buffer, uint length,
                                             const void *from_cs);





struct PSI_v1
{

  register_mutex_v1_t register_mutex;

  register_rwlock_v1_t register_rwlock;

  register_cond_v1_t register_cond;

  register_thread_v1_t register_thread;

  register_file_v1_t register_file;

  register_stage_v1_t register_stage;

  register_statement_v1_t register_statement;

  register_socket_v1_t register_socket;

  init_mutex_v1_t init_mutex;

  destroy_mutex_v1_t destroy_mutex;

  init_rwlock_v1_t init_rwlock;

  destroy_rwlock_v1_t destroy_rwlock;

  init_cond_v1_t init_cond;

  destroy_cond_v1_t destroy_cond;

  init_socket_v1_t init_socket;

  destroy_socket_v1_t destroy_socket;


  get_table_share_v1_t get_table_share;

  release_table_share_v1_t release_table_share;

  drop_table_share_v1_t drop_table_share;

  open_table_v1_t open_table;

  unbind_table_v1_t unbind_table;

  rebind_table_v1_t rebind_table;

  close_table_v1_t close_table;

  create_file_v1_t create_file;

  spawn_thread_v1_t spawn_thread;

  new_thread_v1_t new_thread;

  set_thread_id_v1_t set_thread_id;

  set_thread_THD_v1_t set_thread_THD;

  set_thread_os_id_v1_t set_thread_os_id;

  get_thread_v1_t get_thread;

  set_thread_user_v1_t set_thread_user;

  set_thread_account_v1_t set_thread_account;

  set_thread_db_v1_t set_thread_db;

  set_thread_command_v1_t set_thread_command;

  set_connection_type_v1_t set_connection_type;

  set_thread_start_time_v1_t set_thread_start_time;

  set_thread_state_v1_t set_thread_state;

  set_thread_info_v1_t set_thread_info;

  set_thread_v1_t set_thread;

  delete_current_thread_v1_t delete_current_thread;

  delete_thread_v1_t delete_thread;

  get_thread_file_name_locker_v1_t get_thread_file_name_locker;

  get_thread_file_stream_locker_v1_t get_thread_file_stream_locker;

  get_thread_file_descriptor_locker_v1_t get_thread_file_descriptor_locker;

  unlock_mutex_v1_t unlock_mutex;

  unlock_rwlock_v1_t unlock_rwlock;

  signal_cond_v1_t signal_cond;

  broadcast_cond_v1_t broadcast_cond;

  start_idle_wait_v1_t start_idle_wait;

  end_idle_wait_v1_t end_idle_wait;

  start_mutex_wait_v1_t start_mutex_wait;

  end_mutex_wait_v1_t end_mutex_wait;

  start_rwlock_rdwait_v1_t start_rwlock_rdwait;

  end_rwlock_rdwait_v1_t end_rwlock_rdwait;

  start_rwlock_wrwait_v1_t start_rwlock_wrwait;

  end_rwlock_wrwait_v1_t end_rwlock_wrwait;

  start_cond_wait_v1_t start_cond_wait;

  end_cond_wait_v1_t end_cond_wait;

  start_table_io_wait_v1_t start_table_io_wait;

  end_table_io_wait_v1_t end_table_io_wait;

  start_table_lock_wait_v1_t start_table_lock_wait;

  end_table_lock_wait_v1_t end_table_lock_wait;

  start_file_open_wait_v1_t start_file_open_wait;

  end_file_open_wait_v1_t end_file_open_wait;

  end_file_open_wait_and_bind_to_descriptor_v1_t
    end_file_open_wait_and_bind_to_descriptor;

  end_temp_file_open_wait_and_bind_to_descriptor_v1_t
    end_temp_file_open_wait_and_bind_to_descriptor;

  start_file_wait_v1_t start_file_wait;

  end_file_wait_v1_t end_file_wait;

  start_file_close_wait_v1_t start_file_close_wait;

  end_file_close_wait_v1_t end_file_close_wait;

  start_stage_v1_t start_stage;

  get_current_stage_progress_v1_t get_current_stage_progress;

  end_stage_v1_t end_stage;

  get_thread_statement_locker_v1_t get_thread_statement_locker;

  refine_statement_v1_t refine_statement;

  start_statement_v1_t start_statement;

  set_statement_text_v1_t set_statement_text;

  set_statement_lock_time_t set_statement_lock_time;

  set_statement_rows_sent_t set_statement_rows_sent;

  set_statement_rows_examined_t set_statement_rows_examined;

  inc_statement_created_tmp_disk_tables_t inc_statement_created_tmp_disk_tables;

  inc_statement_created_tmp_tables_t inc_statement_created_tmp_tables;

  inc_statement_select_full_join_t inc_statement_select_full_join;

  inc_statement_select_full_range_join_t inc_statement_select_full_range_join;

  inc_statement_select_range_t inc_statement_select_range;

  inc_statement_select_range_check_t inc_statement_select_range_check;

  inc_statement_select_scan_t inc_statement_select_scan;

  inc_statement_sort_merge_passes_t inc_statement_sort_merge_passes;

  inc_statement_sort_range_t inc_statement_sort_range;

  inc_statement_sort_rows_t inc_statement_sort_rows;

  inc_statement_sort_scan_t inc_statement_sort_scan;

  set_statement_no_index_used_t set_statement_no_index_used;

  set_statement_no_good_index_used_t set_statement_no_good_index_used;

  end_statement_v1_t end_statement;

  get_thread_transaction_locker_v1_t get_thread_transaction_locker;

  start_transaction_v1_t start_transaction;

  set_transaction_xid_v1_t set_transaction_xid;

  set_transaction_xa_state_v1_t set_transaction_xa_state;

  set_transaction_gtid_v1_t set_transaction_gtid;

  set_transaction_trxid_v1_t set_transaction_trxid;

  inc_transaction_savepoints_v1_t inc_transaction_savepoints;

  inc_transaction_rollback_to_savepoint_v1_t inc_transaction_rollback_to_savepoint;

  inc_transaction_release_savepoint_v1_t inc_transaction_release_savepoint;

  end_transaction_v1_t end_transaction;

  start_socket_wait_v1_t start_socket_wait;

  end_socket_wait_v1_t end_socket_wait;

  set_socket_state_v1_t set_socket_state;

  set_socket_info_v1_t set_socket_info;

  set_socket_thread_owner_v1_t set_socket_thread_owner;

  create_prepared_stmt_v1_t create_prepared_stmt;

  destroy_prepared_stmt_v1_t destroy_prepared_stmt;

  reprepare_prepared_stmt_v1_t reprepare_prepared_stmt;

  execute_prepared_stmt_v1_t execute_prepared_stmt;

  digest_start_v1_t digest_start;

  digest_end_v1_t digest_end;

  set_thread_connect_attrs_v1_t set_thread_connect_attrs;

  start_sp_v1_t start_sp;

  end_sp_v1_t end_sp;

  drop_sp_v1_t drop_sp;

  get_sp_share_v1_t get_sp_share;

  release_sp_share_v1_t release_sp_share;

  register_memory_v1_t register_memory;

  memory_alloc_v1_t memory_alloc;

  memory_realloc_v1_t memory_realloc;

  memory_claim_v1_t memory_claim;

  memory_free_v1_t memory_free;

  unlock_table_v1_t unlock_table;

  create_metadata_lock_v1_t create_metadata_lock;
  set_metadata_lock_status_v1_t set_metadata_lock_status;
  destroy_metadata_lock_v1_t destroy_metadata_lock;

  start_metadata_wait_v1_t start_metadata_wait;
  end_metadata_wait_v1_t end_metadata_wait;
};
// # 2880 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
typedef struct PSI_v1 PSI;
typedef struct PSI_mutex_info_v1 PSI_mutex_info;
typedef struct PSI_rwlock_info_v1 PSI_rwlock_info;
typedef struct PSI_cond_info_v1 PSI_cond_info;
typedef struct PSI_thread_info_v1 PSI_thread_info;
typedef struct PSI_file_info_v1 PSI_file_info;
typedef struct PSI_stage_info_v1 PSI_stage_info;
typedef struct PSI_statement_info_v1 PSI_statement_info;
typedef struct PSI_transaction_info_v1 PSI_transaction_info;
typedef struct PSI_socket_info_v1 PSI_socket_info;
typedef struct PSI_idle_locker_state_v1 PSI_idle_locker_state;
typedef struct PSI_mutex_locker_state_v1 PSI_mutex_locker_state;
typedef struct PSI_rwlock_locker_state_v1 PSI_rwlock_locker_state;
typedef struct PSI_cond_locker_state_v1 PSI_cond_locker_state;
typedef struct PSI_file_locker_state_v1 PSI_file_locker_state;
typedef struct PSI_statement_locker_state_v1 PSI_statement_locker_state;
typedef struct PSI_transaction_locker_state_v1 PSI_transaction_locker_state;
typedef struct PSI_socket_locker_state_v1 PSI_socket_locker_state;
typedef struct PSI_sp_locker_state_v1 PSI_sp_locker_state;
typedef struct PSI_metadata_locker_state_v1 PSI_metadata_locker_state;
// # 2965 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
extern PSI *PSI_server;
// # 2978 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h"
}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/pfs_socket_provider.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dir.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dir.h"
// # 1 "/usr/include/sys/stat.h" 1 3 4
// # 104 "/usr/include/sys/stat.h" 3 4
extern "C" {

// # 1 "/usr/include/bits/stat.h" 1 3 4
// # 107 "/usr/include/sys/stat.h" 2 3 4
// # 218 "/usr/include/sys/stat.h" 3 4
extern int stat (const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "stat64")

     __attribute__ ((__nonnull__ (1, 2)));
extern int fstat (int __fd, struct stat *__buf) throw () __asm__ ("" "fstat64")
     __attribute__ ((__nonnull__ (2)));






extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) throw () __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) throw () __attribute__ ((__nonnull__ (2)));
// # 244 "/usr/include/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file, struct stat *__restrict __buf, int __flag) throw () __asm__ ("" "fstatat64")


                 __attribute__ ((__nonnull__ (2, 3)));






extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     throw () __attribute__ ((__nonnull__ (2, 3)));
// # 268 "/usr/include/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file, struct stat *__restrict __buf) throw () __asm__ ("" "lstat64")


     __attribute__ ((__nonnull__ (1, 2)));





extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int chmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) throw ();





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;






extern __mode_t umask (__mode_t __mask) throw ();




extern __mode_t getumask (void) throw ();



extern int mkdir (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) throw () __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     throw () __attribute__ ((__nonnull__ (2)));





extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     throw () __attribute__ ((__nonnull__ (2)));




extern int futimens (int __fd, const struct timespec __times[2]) throw ();
// # 411 "/usr/include/sys/stat.h" 3 4
extern int __fxstat (int __ver, int __fildes, struct stat *__stat_buf) throw () __asm__ ("" "__fxstat64")

     __attribute__ ((__nonnull__ (3)));
extern int __xstat (int __ver, const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__xstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat (int __ver, const char *__filename, struct stat *__stat_buf) throw () __asm__ ("" "__lxstat64")

     __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat (int __ver, int __fildes, const char *__filename, struct stat *__stat_buf, int __flag) throw () __asm__ ("" "__fxstatat64")


                    __attribute__ ((__nonnull__ (3, 4)));
// # 433 "/usr/include/sys/stat.h" 3 4
extern int __fxstat64 (int __ver, int __fildes, struct stat64 *__stat_buf)
     throw () __attribute__ ((__nonnull__ (3)));
extern int __xstat64 (int __ver, const char *__filename,
        struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __lxstat64 (int __ver, const char *__filename,
         struct stat64 *__stat_buf) throw () __attribute__ ((__nonnull__ (2, 3)));
extern int __fxstatat64 (int __ver, int __fildes, const char *__filename,
    struct stat64 *__stat_buf, int __flag)
     throw () __attribute__ ((__nonnull__ (3, 4)));

extern int __xmknod (int __ver, const char *__path, __mode_t __mode,
       __dev_t *__dev) throw () __attribute__ ((__nonnull__ (2, 4)));

extern int __xmknodat (int __ver, int __fd, const char *__path,
         __mode_t __mode, __dev_t *__dev)
     throw () __attribute__ ((__nonnull__ (3, 5)));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat (const char *__path, struct stat *__statbuf) throw ()
{
  return __xstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat (const char *__path, struct stat *__statbuf) throw ()
{
  return __lxstat (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat (int __fd, struct stat *__statbuf) throw ()
{
  return __fxstat (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat (int __fd, const char *__filename, struct stat *__statbuf, int __flag) throw ()

{
  return __fxstatat (1, __fd, __filename, __statbuf, __flag);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknod (const char *__path, __mode_t __mode, __dev_t __dev) throw ()
{
  return __xmknod (0, __path, __mode, &__dev);
}



extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) mknodat (int __fd, const char *__path, __mode_t __mode, __dev_t __dev) throw ()

{
  return __xmknodat (0, __fd, __path, __mode, &__dev);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) stat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __xstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) lstat64 (const char *__path, struct stat64 *__statbuf) throw ()
{
  return __lxstat64 (1, __path, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstat64 (int __fd, struct stat64 *__statbuf) throw ()
{
  return __fxstat64 (1, __fd, __statbuf);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) fstatat64 (int __fd, const char *__filename, struct stat64 *__statbuf, int __flag) throw ()

{
  return __fxstatat64 (1, __fd, __filename, __statbuf, __flag);
}






}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dir.h" 2


extern "C" {
// # 65 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_dir.h"
typedef struct fileinfo
{
  char *name;
  struct stat *mystat;
} FILEINFO;

typedef struct st_my_dir
{






  struct fileinfo *dir_entry;
  uint number_off_files;
} MY_DIR;

extern MY_DIR *my_dir(const char *path,myf MyFlags);
extern void my_dirend(MY_DIR *buffer);
extern struct stat *my_stat(const char *path, struct stat *stat_area, myf my_flags);
extern int my_fstat(int filenr, struct stat *stat_area, myf MyFlags);


}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h" 1
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h"
extern "C" {
// # 58 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h"
typedef struct unicase_info_char_st
{
  uint32 toupper;
  uint32 tolower;
  uint32 sort;
} MY_UNICASE_CHARACTER;


typedef struct unicase_info_st
{
  ulong maxchar;
  const MY_UNICASE_CHARACTER **page;
} MY_UNICASE_INFO;


extern MY_UNICASE_INFO my_unicase_default;
extern MY_UNICASE_INFO my_unicase_turkish;
extern MY_UNICASE_INFO my_unicase_mysql500;
extern MY_UNICASE_INFO my_unicase_unicode520;





typedef struct my_contraction_t
{
  ulong ch[6];
  uint16 weight[8];
  my_bool with_context;
} MY_CONTRACTION;



typedef struct my_contraction_list_t
{
  size_t nitems;
  MY_CONTRACTION *item;
  char *flags;
} MY_CONTRACTIONS;


my_bool my_uca_can_be_contraction_head(const MY_CONTRACTIONS *c, ulong wc);
my_bool my_uca_can_be_contraction_tail(const MY_CONTRACTIONS *c, ulong wc);
uint16 *my_uca_contraction2_weight(const MY_CONTRACTIONS *c,
                                   ulong wc1, ulong wc2);



typedef struct my_uca_level_info_st
{
  ulong maxchar;
  uchar *lengths;
  uint16 **weights;
  MY_CONTRACTIONS contractions;
} MY_UCA_WEIGHT_LEVEL;


typedef struct uca_info_st
{
  MY_UCA_WEIGHT_LEVEL level[1];


  ulong first_non_ignorable;
  ulong last_non_ignorable;
  ulong first_primary_ignorable;
  ulong last_primary_ignorable;
  ulong first_secondary_ignorable;
  ulong last_secondary_ignorable;
  ulong first_tertiary_ignorable;
  ulong last_tertiary_ignorable;
  ulong first_trailing;
  ulong last_trailing;
  ulong first_variable;
  ulong last_variable;

} MY_UCA_INFO;



extern MY_UCA_INFO my_uca_v400;


typedef struct uni_ctype_st
{
  uchar pctype;
  uchar *ctype;
} MY_UNI_CTYPE;

extern MY_UNI_CTYPE my_uni_ctype[256];
// # 221 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h"
typedef struct my_uni_idx_st
{
  uint16 from;
  uint16 to;
  const uchar *tab;
} MY_UNI_IDX;

typedef struct
{
  uint beg;
  uint end;
  uint mb_len;
} my_match_t;

struct charset_info_st;

typedef struct my_charset_loader_st
{
  char error[128];
  void *(*once_alloc)(size_t);
  void *(*mem_malloc)(size_t);
  void *(*mem_realloc)(void *, size_t);
  void (*mem_free)(void *);
  void (*reporter)(enum loglevel, const char *format, ...);
  int (*add_collation)(struct charset_info_st *cs);
} MY_CHARSET_LOADER;


extern int (*my_string_stack_guard)(int);


typedef struct my_collation_handler_st
{
  my_bool (*init)(struct charset_info_st *, MY_CHARSET_LOADER *);

  int (*strnncoll)(const struct charset_info_st *,
         const uchar *, size_t, const uchar *, size_t, my_bool);
  int (*strnncollsp)(const struct charset_info_st *,
                         const uchar *, size_t, const uchar *, size_t,
                         my_bool diff_if_only_endspace_difference);
  size_t (*strnxfrm)(const struct charset_info_st *,
                      uchar *dst, size_t dstlen, uint nweights,
                      const uchar *src, size_t srclen, uint flags);
  size_t (*strnxfrmlen)(const struct charset_info_st *, size_t);
  my_bool (*like_range)(const struct charset_info_st *,
   const char *s, size_t s_length,
   pchar w_prefix, pchar w_one, pchar w_many,
   size_t res_length,
   char *min_str, char *max_str,
   size_t *min_len, size_t *max_len);
  int (*wildcmp)(const struct charset_info_st *,
         const char *str,const char *str_end,
                     const char *wildstr,const char *wildend,
                     int escape,int w_one, int w_many);

  int (*strcasecmp)(const struct charset_info_st *, const char *,
                     const char *);

  uint (*instr)(const struct charset_info_st *,
                const char *b, size_t b_length,
                const char *s, size_t s_length,
                my_match_t *match, uint nmatch);


  void (*hash_sort)(const struct charset_info_st *cs, const uchar *key,
                    size_t len, ulong *nr1, ulong *nr2);
  my_bool (*propagate)(const struct charset_info_st *cs, const uchar *str,
                       size_t len);
} MY_COLLATION_HANDLER;

extern MY_COLLATION_HANDLER my_collation_mb_bin_handler;
extern MY_COLLATION_HANDLER my_collation_8bit_bin_handler;
extern MY_COLLATION_HANDLER my_collation_8bit_simple_ci_handler;
extern MY_COLLATION_HANDLER my_collation_ucs2_uca_handler;


typedef int (*my_charset_conv_mb_wc)(const struct charset_info_st *,
                                     ulong *, const uchar *, const uchar *);
typedef int (*my_charset_conv_wc_mb)(const struct charset_info_st *, ulong,
                                     uchar *, uchar *);
typedef size_t (*my_charset_conv_case)(const struct charset_info_st *,
                                       char *, size_t, char *, size_t);



typedef struct my_charset_handler_st
{
  my_bool (*init)(struct charset_info_st *, MY_CHARSET_LOADER *loader);

  uint (*ismbchar)(const struct charset_info_st *, const char *,
                      const char *);
  uint (*mbcharlen)(const struct charset_info_st *, uint c);
  size_t (*numchars)(const struct charset_info_st *, const char *b,
                      const char *e);
  size_t (*charpos)(const struct charset_info_st *, const char *b,
                     const char *e, size_t pos);
  size_t (*well_formed_len)(const struct charset_info_st *,
                             const char *b,const char *e,
                             size_t nchars, int *error);
  size_t (*lengthsp)(const struct charset_info_st *, const char *ptr,
                      size_t length);
  size_t (*numcells)(const struct charset_info_st *, const char *b,
                      const char *e);


  my_charset_conv_mb_wc mb_wc;
  my_charset_conv_wc_mb wc_mb;


  int (*ctype)(const struct charset_info_st *cs, int *ctype,
               const uchar *s, const uchar *e);


  size_t (*caseup_str)(const struct charset_info_st *, char *);
  size_t (*casedn_str)(const struct charset_info_st *, char *);

  my_charset_conv_case caseup;
  my_charset_conv_case casedn;


  size_t (*snprintf)(const struct charset_info_st *, char *to, size_t n,
                     const char *fmt,
                     ...) __attribute__((format(printf, 4, 5)));
  size_t (*long10_to_str)(const struct charset_info_st *, char *to, size_t n,
                          int radix, long int val);
  size_t (*longlong10_to_str)(const struct charset_info_st *, char *to,
                              size_t n, int radix, longlong val);

  void (*fill)(const struct charset_info_st *, char *to, size_t len,
               int fill);


  long (*strntol)(const struct charset_info_st *, const char *s,
                         size_t l, int base, char **e, int *err);
  ulong (*strntoul)(const struct charset_info_st *, const char *s,
                         size_t l, int base, char **e, int *err);
  longlong (*strntoll)(const struct charset_info_st *, const char *s,
                         size_t l, int base, char **e, int *err);
  ulonglong (*strntoull)(const struct charset_info_st *, const char *s,
                         size_t l, int base, char **e, int *err);
  double (*strntod)(const struct charset_info_st *, char *s,
                         size_t l, char **e, int *err);
  longlong (*strtoll10)(const struct charset_info_st *cs,
                           const char *nptr, char **endptr, int *error);
  ulonglong (*strntoull10rnd)(const struct charset_info_st *cs,
                                const char *str, size_t length,
                                int unsigned_fl,
                                char **endptr, int *error);
  size_t (*scan)(const struct charset_info_st *, const char *b,
                        const char *e, int sq);
} MY_CHARSET_HANDLER;

extern MY_CHARSET_HANDLER my_charset_8bit_handler;
extern MY_CHARSET_HANDLER my_charset_ascii_handler;
extern MY_CHARSET_HANDLER my_charset_ucs2_handler;
// # 385 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h"
typedef struct charset_info_st
{
  uint number;
  uint primary_number;
  uint binary_number;
  uint state;
  const char *csname;
  const char *name;
  const char *comment;
  const char *tailoring;
  const uchar *ctype;
  const uchar *to_lower;
  const uchar *to_upper;
  const uchar *sort_order;
  MY_UCA_INFO *uca;
  const uint16 *tab_to_uni;
  const MY_UNI_IDX *tab_from_uni;
  const MY_UNICASE_INFO *caseinfo;
  const struct lex_state_maps_st *state_maps;
  const uchar *ident_map;
  uint strxfrm_multiply;
  uchar caseup_multiply;
  uchar casedn_multiply;
  uint mbminlen;
  uint mbmaxlen;
  uint mbmaxlenlen;
  ulong min_sort_char;
  ulong max_sort_char;
  uchar pad_char;
  my_bool escape_with_backslash_is_dangerous;
  uchar levels_for_compare;
  uchar levels_for_order;

  MY_CHARSET_HANDLER *cset;
  MY_COLLATION_HANDLER *coll;

} CHARSET_INFO;



extern CHARSET_INFO my_charset_bin;
extern CHARSET_INFO my_charset_latin1;
extern CHARSET_INFO my_charset_filename;

extern CHARSET_INFO my_charset_big5_chinese_ci;
extern CHARSET_INFO my_charset_big5_bin;
extern CHARSET_INFO my_charset_cp932_japanese_ci;
extern CHARSET_INFO my_charset_cp932_bin;
extern CHARSET_INFO my_charset_cp1250_czech_ci;
extern CHARSET_INFO my_charset_eucjpms_japanese_ci;
extern CHARSET_INFO my_charset_eucjpms_bin;
extern CHARSET_INFO my_charset_euckr_korean_ci;
extern CHARSET_INFO my_charset_euckr_bin;
extern CHARSET_INFO my_charset_gb2312_chinese_ci;
extern CHARSET_INFO my_charset_gb2312_bin;
extern CHARSET_INFO my_charset_gbk_chinese_ci;
extern CHARSET_INFO my_charset_gbk_bin;
extern CHARSET_INFO my_charset_gb18030_chinese_ci;
extern CHARSET_INFO my_charset_gb18030_bin;
extern CHARSET_INFO my_charset_latin1_german2_ci;
extern CHARSET_INFO my_charset_latin1_bin;
extern CHARSET_INFO my_charset_latin2_czech_ci;
extern CHARSET_INFO my_charset_sjis_japanese_ci;
extern CHARSET_INFO my_charset_sjis_bin;
extern CHARSET_INFO my_charset_tis620_thai_ci;
extern CHARSET_INFO my_charset_tis620_bin;
extern CHARSET_INFO my_charset_ucs2_general_ci;
extern CHARSET_INFO my_charset_ucs2_bin;
extern CHARSET_INFO my_charset_ucs2_unicode_ci;
extern CHARSET_INFO my_charset_ucs2_general_mysql500_ci;
extern CHARSET_INFO my_charset_ujis_japanese_ci;
extern CHARSET_INFO my_charset_ujis_bin;
extern CHARSET_INFO my_charset_utf16_bin;
extern CHARSET_INFO my_charset_utf16_general_ci;
extern CHARSET_INFO my_charset_utf16_unicode_ci;
extern CHARSET_INFO my_charset_utf16le_bin;
extern CHARSET_INFO my_charset_utf16le_general_ci;
extern CHARSET_INFO my_charset_utf32_bin;
extern CHARSET_INFO my_charset_utf32_general_ci;
extern CHARSET_INFO my_charset_utf32_unicode_ci;

extern CHARSET_INFO my_charset_utf8_general_ci;
extern CHARSET_INFO my_charset_utf8_tolower_ci;
extern CHARSET_INFO my_charset_utf8_unicode_ci;
extern CHARSET_INFO my_charset_utf8_bin;
extern CHARSET_INFO my_charset_utf8_general_mysql500_ci;
extern CHARSET_INFO my_charset_utf8mb4_bin;
extern CHARSET_INFO my_charset_utf8mb4_general_ci;
extern CHARSET_INFO my_charset_utf8mb4_unicode_ci;





extern size_t my_strnxfrm_simple(const CHARSET_INFO *,
                                 uchar *dst, size_t dstlen, uint nweights,
                                 const uchar *src, size_t srclen, uint flags);
size_t my_strnxfrmlen_simple(const CHARSET_INFO *, size_t);
extern int my_strnncoll_simple(const CHARSET_INFO *, const uchar *, size_t,
    const uchar *, size_t, my_bool);

extern int my_strnncollsp_simple(const CHARSET_INFO *, const uchar *, size_t,
                                  const uchar *, size_t,
                                  my_bool diff_if_only_endspace_difference);

extern void my_hash_sort_simple(const CHARSET_INFO *cs,
    const uchar *key, size_t len,
    ulong *nr1, ulong *nr2);

extern size_t my_lengthsp_8bit(const CHARSET_INFO *cs, const char *ptr,
                               size_t length);

extern uint my_instr_simple(const struct charset_info_st *,
                            const char *b, size_t b_length,
                            const char *s, size_t s_length,
                            my_match_t *match, uint nmatch);



extern size_t my_caseup_str_8bit(const CHARSET_INFO *, char *);
extern size_t my_casedn_str_8bit(const CHARSET_INFO *, char *);
extern size_t my_caseup_8bit(const CHARSET_INFO *, char *src, size_t srclen,
                             char *dst, size_t dstlen);
extern size_t my_casedn_8bit(const CHARSET_INFO *, char *src, size_t srclen,
                             char *dst, size_t dstlen);

extern int my_strcasecmp_8bit(const CHARSET_INFO * cs, const char *,
                              const char *);

int my_mb_wc_8bit(const CHARSET_INFO *cs,ulong *wc, const uchar *s,
                  const uchar *e);
int my_wc_mb_8bit(const CHARSET_INFO *cs,ulong wc, uchar *s, uchar *e);

int my_mb_ctype_8bit(const CHARSET_INFO *,int *, const uchar *,const uchar *);
int my_mb_ctype_mb(const CHARSET_INFO *,int *, const uchar *,const uchar *);

size_t my_scan_8bit(const CHARSET_INFO *cs, const char *b, const char *e,
                    int sq);

size_t my_snprintf_8bit(const struct charset_info_st *, char *to, size_t n,
                        const char *fmt, ...)
  __attribute__((format(printf, 4, 5)));

long my_strntol_8bit(const CHARSET_INFO *, const char *s, size_t l,
                           int base, char **e, int *err);
ulong my_strntoul_8bit(const CHARSET_INFO *, const char *s, size_t l,
                            int base, char **e, int *err);
longlong my_strntoll_8bit(const CHARSET_INFO *, const char *s, size_t l,
                            int base, char **e, int *err);
ulonglong my_strntoull_8bit(const CHARSET_INFO *, const char *s, size_t l,
                            int base, char **e, int *err);
double my_strntod_8bit(const CHARSET_INFO *, char *s, size_t l, char **e,
       int *err);
size_t my_long10_to_str_8bit(const CHARSET_INFO *, char *to, size_t l,
                             int radix, long int val);
size_t my_longlong10_to_str_8bit(const CHARSET_INFO *, char *to, size_t l,
                                 int radix, longlong val);

longlong my_strtoll10_8bit(const CHARSET_INFO *cs,
                           const char *nptr, char **endptr, int *error);
longlong my_strtoll10_ucs2(const CHARSET_INFO *cs,
                           const char *nptr, char **endptr, int *error);

ulonglong my_strntoull10rnd_8bit(const CHARSET_INFO *cs,
                                 const char *str, size_t length, int
                                 unsigned_fl, char **endptr, int *error);
ulonglong my_strntoull10rnd_ucs2(const CHARSET_INFO *cs,
                                 const char *str, size_t length,
                                 int unsigned_fl, char **endptr, int *error);

void my_fill_8bit(const CHARSET_INFO *cs, char* to, size_t l, int fill);


my_bool my_like_range_simple(const CHARSET_INFO *cs,
         const char *ptr, size_t ptr_length,
         pbool escape, pbool w_one, pbool w_many,
         size_t res_length,
         char *min_str, char *max_str,
         size_t *min_length, size_t *max_length);


my_bool my_like_range_mb(const CHARSET_INFO *cs,
     const char *ptr, size_t ptr_length,
     pbool escape, pbool w_one, pbool w_many,
     size_t res_length,
     char *min_str, char *max_str,
     size_t *min_length, size_t *max_length);


my_bool my_like_range_generic(const CHARSET_INFO *cs,
                               const char *ptr, size_t ptr_length,
                               pbool escape, pbool w_one, pbool w_many,
                               size_t res_length,
                               char *min_str, char *max_str,
                               size_t *min_length, size_t *max_length);

int my_wildcmp_8bit(const CHARSET_INFO *,
      const char *str,const char *str_end,
      const char *wildstr,const char *wildend,
      int escape, int w_one, int w_many);

int my_wildcmp_bin(const CHARSET_INFO *,
     const char *str,const char *str_end,
     const char *wildstr,const char *wildend,
     int escape, int w_one, int w_many);

size_t my_numchars_8bit(const CHARSET_INFO *, const char *b, const char *e);
size_t my_numcells_8bit(const CHARSET_INFO *, const char *b, const char *e);
size_t my_charpos_8bit(const CHARSET_INFO *, const char *b, const char *e,
                       size_t pos);
size_t my_well_formed_len_8bit(const CHARSET_INFO *, const char *b,
                               const char *e, size_t pos, int *error);
uint my_mbcharlen_8bit(const CHARSET_INFO *, uint c);



extern size_t my_caseup_str_mb(const CHARSET_INFO *, char *);
extern size_t my_casedn_str_mb(const CHARSET_INFO *, char *);
extern size_t my_caseup_mb(const CHARSET_INFO *, char *src, size_t srclen,
                                         char *dst, size_t dstlen);
extern size_t my_casedn_mb(const CHARSET_INFO *, char *src, size_t srclen,
                                         char *dst, size_t dstlen);
extern size_t my_caseup_mb_varlen(const CHARSET_INFO *, char *src,
                                  size_t srclen, char *dst, size_t dstlen);
extern size_t my_casedn_mb_varlen(const CHARSET_INFO *, char *src,
                                  size_t srclen, char *dst, size_t dstlen);
extern size_t my_caseup_ujis(const CHARSET_INFO *, char *src, size_t srclen,
                             char *dst, size_t dstlen);
extern size_t my_casedn_ujis(const CHARSET_INFO *, char *src, size_t srclen,
                             char *dst, size_t dstlen);
extern int my_strcasecmp_mb(const CHARSET_INFO * cs,const char *,
                            const char *);

int my_wildcmp_mb(const CHARSET_INFO *,
    const char *str,const char *str_end,
    const char *wildstr,const char *wildend,
    int escape, int w_one, int w_many);
size_t my_numchars_mb(const CHARSET_INFO *, const char *b, const char *e);
size_t my_numcells_mb(const CHARSET_INFO *, const char *b, const char *e);
size_t my_charpos_mb(const CHARSET_INFO *, const char *b, const char *e,
                     size_t pos);
size_t my_well_formed_len_mb(const CHARSET_INFO *, const char *b,
                             const char *e, size_t pos, int *error);
uint my_instr_mb(const struct charset_info_st *,
                 const char *b, size_t b_length,
                 const char *s, size_t s_length,
                 my_match_t *match, uint nmatch);

int my_strnncoll_mb_bin(const CHARSET_INFO * cs,
                        const uchar *s, size_t slen,
                        const uchar *t, size_t tlen,
                        my_bool t_is_prefix);

int my_strnncollsp_mb_bin(const CHARSET_INFO *cs,
                          const uchar *a, size_t a_length,
                          const uchar *b, size_t b_length,
                          my_bool diff_if_only_endspace_difference);

int my_wildcmp_mb_bin(const CHARSET_INFO *cs,
                      const char *str,const char *str_end,
                      const char *wildstr,const char *wildend,
                      int escape, int w_one, int w_many);

int my_strcasecmp_mb_bin(const CHARSET_INFO * cs __attribute__((unused)),
                         const char *s, const char *t);

void my_hash_sort_mb_bin(const CHARSET_INFO *cs __attribute__((unused)),
                         const uchar *key, size_t len,ulong *nr1, ulong *nr2);

size_t my_strnxfrm_mb(const CHARSET_INFO *,
                      uchar *dst, size_t dstlen, uint nweights,
                      const uchar *src, size_t srclen, uint flags);

size_t my_strnxfrm_unicode(const CHARSET_INFO *,
                           uchar *dst, size_t dstlen, uint nweights,
                           const uchar *src, size_t srclen, uint flags);

size_t my_strnxfrm_unicode_full_bin(const CHARSET_INFO *,
                                    uchar *dst, size_t dstlen, uint nweights,
                                    const uchar *src, size_t srclen, uint flags);
size_t my_strnxfrmlen_unicode_full_bin(const CHARSET_INFO *, size_t);

int my_wildcmp_unicode(const CHARSET_INFO *cs,
                       const char *str, const char *str_end,
                       const char *wildstr, const char *wildend,
                       int escape, int w_one, int w_many,
                       const MY_UNICASE_INFO *weights);

extern my_bool my_parse_charset_xml(MY_CHARSET_LOADER *loader,
                                    const char *buf, size_t buflen);
extern char *my_strchr(const CHARSET_INFO *cs, const char *str,
                       const char *end, pchar c);
extern size_t my_strcspn(const CHARSET_INFO *cs, const char *str,
                         const char *end, const char *reject,
                         size_t reject_length);

my_bool my_propagate_simple(const CHARSET_INFO *cs, const uchar *str,
                            size_t len);
my_bool my_propagate_complex(const CHARSET_INFO *cs, const uchar *str,
                             size_t len);


uint my_string_repertoire(const CHARSET_INFO *cs, const char *str, size_t len);
my_bool my_charset_is_ascii_based(const CHARSET_INFO *cs);
my_bool my_charset_is_8bit_pure_ascii(const CHARSET_INFO *cs);
uint my_charset_repertoire(const CHARSET_INFO *cs);


uint my_strxfrm_flag_normalize(uint flags, uint nlevels);
void my_strxfrm_desc_and_reverse(uchar *str, uchar *strend,
                                 uint flags, uint level);
size_t my_strxfrm_pad_desc_and_reverse(const CHARSET_INFO *cs,
                                       uchar *str, uchar *frmend, uchar *strend,
                                       uint nweights, uint flags, uint level);

my_bool my_charset_is_ascii_compatible(const CHARSET_INFO *cs);

const MY_CONTRACTIONS *my_charset_get_contractions(const CHARSET_INFO *cs,
                                                   int level);

extern size_t my_vsnprintf_ex(const CHARSET_INFO *cs, char *to, size_t n,
                              const char* fmt, va_list ap);

size_t my_convert(char *to, size_t to_length, const CHARSET_INFO *to_cs,
                  const char *from, size_t from_length,
                  const CHARSET_INFO *from_cs, uint *errors);

uint my_mbcharlen_ptr(const CHARSET_INFO *cs, const char *s, const char *e);
// # 803 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h"
}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi.h" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_alloc.h" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_alloc.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_alloc.h" 2


extern "C" {



typedef int myf_t;

typedef void * (*mysql_malloc_t)(PSI_memory_key key, size_t size, myf_t flags);
typedef void * (*mysql_realloc_t)(PSI_memory_key key, void *ptr, size_t size, myf_t flags);
typedef void (*mysql_claim_t)(void *ptr);
typedef void (*mysql_free_t)(void *ptr);
typedef void * (*my_memdup_t)(PSI_memory_key key, const void *from, size_t length, myf_t flags);
typedef char * (*my_strdup_t)(PSI_memory_key key, const char *from, myf_t flags);
typedef char * (*my_strndup_t)(PSI_memory_key key, const char *from, size_t length, myf_t flags);

struct mysql_malloc_service_st
{
  mysql_malloc_t mysql_malloc;
  mysql_realloc_t mysql_realloc;
  mysql_claim_t mysql_claim;
  mysql_free_t mysql_free;
  my_memdup_t my_memdup;
  my_strdup_t my_strdup;
  my_strndup_t my_strndup;
};

extern struct mysql_malloc_service_st *mysql_malloc_service;
// # 77 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_alloc.h"
}
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_memory.h" 1
// # 43 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_memory.h"
static inline void inline_mysql_memory_register(

  const char *category,
  PSI_memory_info *info,
  int count)





{

  PSI_server->register_memory(category, info, count);

}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h" 1
// # 58 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread_local.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread_local.h"
struct _db_code_state_;
typedef uint32 my_thread_id;

extern "C" {




typedef pthread_key_t thread_local_key_t;


static inline int my_create_thread_local_key(thread_local_key_t *key,
                                             void (*destructor)(void *))
{




  return pthread_key_create(key, destructor);

}

static inline int my_delete_thread_local_key(thread_local_key_t key)
{



  return pthread_key_delete(key);

}

static inline void* my_get_thread_local(thread_local_key_t key)
{



  return pthread_getspecific(key);

}

static inline int my_set_thread_local(thread_local_key_t key,
                                      void *value)
{



  return pthread_setspecific(key, value);

}




int my_errno();




void set_my_errno(int my_errno);
// # 105 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_thread_local.h"
}
// # 59 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_mutex.h" 1
// # 38 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_mutex.h"
extern "C" {





typedef pthread_mutex_t native_mutex_t;
typedef pthread_mutexattr_t native_mutexattr_t;







extern native_mutexattr_t my_fast_mutexattr;







extern native_mutexattr_t my_errorcheck_mutexattr;





static inline int native_mutex_init(native_mutex_t *mutex,
                                    const native_mutexattr_t *attr)
{




  return pthread_mutex_init(mutex, attr);

}

static inline int native_mutex_lock(native_mutex_t *mutex)
{




  return pthread_mutex_lock(mutex);

}

static inline int native_mutex_trylock(native_mutex_t *mutex)
{
// # 102 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_mutex.h"
  return pthread_mutex_trylock(mutex);

}

static inline int native_mutex_unlock(native_mutex_t *mutex)
{




  return pthread_mutex_unlock(mutex);

}

static inline int native_mutex_destroy(native_mutex_t *mutex)
{




  return pthread_mutex_destroy(mutex);

}
// # 157 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_mutex.h"
typedef native_mutex_t my_mutex_t;


static inline int my_mutex_init(my_mutex_t *mp, const native_mutexattr_t *attr



                                )
{



  return native_mutex_init(mp, attr);

}

static inline int my_mutex_lock(my_mutex_t *mp



                                )
{



  return native_mutex_lock(mp);

}

static inline int my_mutex_trylock(my_mutex_t *mp



                                   )
{



  return native_mutex_trylock(mp);

}

static inline int my_mutex_unlock(my_mutex_t *mp



                                  )
{



  return native_mutex_unlock(mp);

}

static inline int my_mutex_destroy(my_mutex_t *mp



                                   )
{



  return native_mutex_destroy(mp);

}

}
// # 60 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h" 1
// # 38 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_cond.h" 1
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_cond.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_mutex.h" 1
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_cond.h" 2

extern "C" {




typedef pthread_cond_t native_cond_t;
// # 99 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_cond.h"
static inline int native_cond_init(native_cond_t *cond)
{





  return pthread_cond_init(cond, __null);

}

static inline int native_cond_destroy(native_cond_t *cond)
{



  return pthread_cond_destroy(cond);

}

static inline int native_cond_timedwait(native_cond_t *cond,
                                        native_mutex_t *mutex,
                                        const struct timespec *abstime)
{






  return pthread_cond_timedwait(cond, mutex, abstime);

}

static inline int native_cond_wait(native_cond_t *cond, native_mutex_t *mutex)
{





  return pthread_cond_wait(cond, mutex);

}

static inline int native_cond_signal(native_cond_t *cond)
{




  return pthread_cond_signal(cond);

}

static inline int native_cond_broadcast(native_cond_t *cond)
{




  return pthread_cond_broadcast(cond);

}
// # 172 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_cond.h"
static inline int my_cond_timedwait(native_cond_t *cond, my_mutex_t *mp,
                                    const struct timespec *abstime



                                    )
{



  return native_cond_timedwait(cond, mp, abstime);

}

static inline int my_cond_wait(native_cond_t *cond, my_mutex_t *mp



                               )
{



  return native_cond_wait(cond, mp);

}

}
// # 39 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h" 2

extern "C" {
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h"
typedef pthread_rwlock_t native_rw_lock_t;


static inline int native_rw_init(native_rw_lock_t *rwp)
{






  return pthread_rwlock_init(rwp, __null);

}

static inline int native_rw_destroy(native_rw_lock_t *rwp)
{



  return pthread_rwlock_destroy(rwp);

}

static inline int native_rw_rdlock(native_rw_lock_t *rwp)
{




  return pthread_rwlock_rdlock(rwp);

}

static inline int native_rw_tryrdlock(native_rw_lock_t *rwp)
{





  return pthread_rwlock_tryrdlock(rwp);

}

static inline int native_rw_wrlock(native_rw_lock_t *rwp)
{





  return pthread_rwlock_wrlock(rwp);

}

static inline int native_rw_trywrlock(native_rw_lock_t *rwp)
{






  return pthread_rwlock_trywrlock(rwp);

}

static inline int native_rw_unlock(native_rw_lock_t *rwp)
{
// # 129 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h"
  return pthread_rwlock_unlock(rwp);

}
// # 165 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/thr_rwlock.h"
typedef struct st_rw_pr_lock_t {




  native_mutex_t lock;




  native_cond_t no_active_readers;

  uint active_readers;

  uint writers_waiting_readers;

  my_bool active_writer;




} rw_pr_lock_t;

extern int rw_pr_init(rw_pr_lock_t *);
extern int rw_pr_rdlock(rw_pr_lock_t *);
extern int rw_pr_wrlock(rw_pr_lock_t *);
extern int rw_pr_unlock(rw_pr_lock_t *);
extern int rw_pr_destroy(rw_pr_lock_t *);

static inline void
rw_pr_lock_assert_write_owner(const rw_pr_lock_t *rwlock __attribute__((unused)))
{




}

static inline void
rw_pr_lock_assert_not_write_owner(const rw_pr_lock_t *rwlock __attribute__((unused)))
{




}

}
// # 61 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h" 2
// # 94 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
struct st_mysql_mutex
{

  my_mutex_t m_mutex;





  struct PSI_mutex *m_psi;
};
// # 116 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
typedef struct st_mysql_mutex mysql_mutex_t;





struct st_mysql_rwlock
{

  native_rw_lock_t m_rwlock;





  struct PSI_rwlock *m_psi;
};





struct st_mysql_prlock
{

  rw_pr_lock_t m_prlock;





  struct PSI_rwlock *m_psi;
};
// # 161 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
typedef struct st_mysql_rwlock mysql_rwlock_t;
// # 173 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
typedef struct st_mysql_prlock mysql_prlock_t;





struct st_mysql_cond
{

  native_cond_t m_cond;





  struct PSI_cond *m_psi;
};
// # 201 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
typedef struct st_mysql_cond mysql_cond_t;
// # 631 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_thread.h"
static inline void inline_mysql_mutex_register(

  const char *category,
  PSI_mutex_info *info,
  int count





)
{

  PSI_server->register_mutex(category, info, count);

}

static inline int inline_mysql_mutex_init(

  PSI_mutex_key key,

  mysql_mutex_t *that,
  const native_mutexattr_t *attr



  )
{

  that->m_psi= PSI_server->init_mutex(key, &that->m_mutex);



  return my_mutex_init(&that->m_mutex, attr



                       );
}

static inline int inline_mysql_mutex_destroy(
  mysql_mutex_t *that



  )
{

  if (that->m_psi != __null)
  {
    PSI_server->destroy_mutex(that->m_psi);
    that->m_psi= __null;
  }

  return my_mutex_destroy(&that->m_mutex



                          );
}

static inline int inline_mysql_mutex_lock(
  mysql_mutex_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_mutex_locker *locker;
    PSI_mutex_locker_state state;
    locker= PSI_server->start_mutex_wait(&state, that->m_psi,
                                       PSI_MUTEX_LOCK, src_file, src_line);


    result= my_mutex_lock(&that->m_mutex



                          );


    if (locker != __null)
      PSI_server->end_mutex_wait(locker, result);

    return result;
  }



  result= my_mutex_lock(&that->m_mutex



                        );

  return result;
}

static inline int inline_mysql_mutex_trylock(
  mysql_mutex_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_mutex_locker *locker;
    PSI_mutex_locker_state state;
    locker= PSI_server->start_mutex_wait(&state, that->m_psi,
                                       PSI_MUTEX_TRYLOCK, src_file, src_line);


    result= my_mutex_trylock(&that->m_mutex



                             );


    if (locker != __null)
      PSI_server->end_mutex_wait(locker, result);

    return result;
  }



  result= my_mutex_trylock(&that->m_mutex



                           );

  return result;
}

static inline int inline_mysql_mutex_unlock(
  mysql_mutex_t *that



  )
{
  int result;


  if (that->m_psi != __null)
    PSI_server->unlock_mutex(that->m_psi);


  result= my_mutex_unlock(&that->m_mutex



                          );

  return result;
}

static inline void inline_mysql_rwlock_register(

  const char *category,
  PSI_rwlock_info *info,
  int count





)
{

  PSI_server->register_rwlock(category, info, count);

}

static inline int inline_mysql_rwlock_init(

  PSI_rwlock_key key,

  mysql_rwlock_t *that)
{

  that->m_psi= PSI_server->init_rwlock(key, &that->m_rwlock);



  return native_rw_init(&that->m_rwlock);
}


static inline int inline_mysql_prlock_init(

  PSI_rwlock_key key,

  mysql_prlock_t *that)
{

  that->m_psi= PSI_server->init_rwlock(key, &that->m_prlock);



  return rw_pr_init(&that->m_prlock);
}


static inline int inline_mysql_rwlock_destroy(
  mysql_rwlock_t *that)
{

  if (that->m_psi != __null)
  {
    PSI_server->destroy_rwlock(that->m_psi);
    that->m_psi= __null;
  }

  return native_rw_destroy(&that->m_rwlock);
}


static inline int inline_mysql_prlock_destroy(
  mysql_prlock_t *that)
{

  if (that->m_psi != __null)
  {
    PSI_server->destroy_rwlock(that->m_psi);
    that->m_psi= __null;
  }

  return rw_pr_destroy(&that->m_prlock);
}


static inline int inline_mysql_rwlock_rdlock(
  mysql_rwlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_rdwait(&state, that->m_psi,
                                          PSI_RWLOCK_READLOCK, src_file, src_line);


    result= native_rw_rdlock(&that->m_rwlock);


    if (locker != __null)
      PSI_server->end_rwlock_rdwait(locker, result);

    return result;
  }



  result= native_rw_rdlock(&that->m_rwlock);

  return result;
}


static inline int inline_mysql_prlock_rdlock(
  mysql_prlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_rdwait(&state, that->m_psi,
                                          PSI_RWLOCK_READLOCK, src_file, src_line);


    result= rw_pr_rdlock(&that->m_prlock);


    if (locker != __null)
      PSI_server->end_rwlock_rdwait(locker, result);

    return result;
  }



  result= rw_pr_rdlock(&that->m_prlock);

  return result;
}


static inline int inline_mysql_rwlock_wrlock(
  mysql_rwlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_wrwait(&state, that->m_psi,
                                          PSI_RWLOCK_WRITELOCK, src_file, src_line);


    result= native_rw_wrlock(&that->m_rwlock);


    if (locker != __null)
      PSI_server->end_rwlock_wrwait(locker, result);

    return result;
  }



  result= native_rw_wrlock(&that->m_rwlock);

  return result;
}


static inline int inline_mysql_prlock_wrlock(
  mysql_prlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_wrwait(&state, that->m_psi,
                                          PSI_RWLOCK_WRITELOCK, src_file, src_line);


    result= rw_pr_wrlock(&that->m_prlock);


    if (locker != __null)
      PSI_server->end_rwlock_wrwait(locker, result);

    return result;
  }



  result= rw_pr_wrlock(&that->m_prlock);

  return result;
}


static inline int inline_mysql_rwlock_tryrdlock(
  mysql_rwlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_rdwait(&state, that->m_psi,
                                          PSI_RWLOCK_TRYREADLOCK, src_file, src_line);


    result= native_rw_tryrdlock(&that->m_rwlock);


    if (locker != __null)
      PSI_server->end_rwlock_rdwait(locker, result);

    return result;
  }



  result= native_rw_tryrdlock(&that->m_rwlock);

  return result;
}

static inline int inline_mysql_rwlock_trywrlock(
  mysql_rwlock_t *that

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_rwlock_locker *locker;
    PSI_rwlock_locker_state state;
    locker= PSI_server->start_rwlock_wrwait(&state, that->m_psi,
                                          PSI_RWLOCK_TRYWRITELOCK, src_file, src_line);


    result= native_rw_trywrlock(&that->m_rwlock);


    if (locker != __null)
      PSI_server->end_rwlock_wrwait(locker, result);

    return result;
  }



  result= native_rw_trywrlock(&that->m_rwlock);

  return result;
}

static inline int inline_mysql_rwlock_unlock(
  mysql_rwlock_t *that)
{
  int result;

  if (that->m_psi != __null)
    PSI_server->unlock_rwlock(that->m_psi);

  result= native_rw_unlock(&that->m_rwlock);
  return result;
}


static inline int inline_mysql_prlock_unlock(
  mysql_prlock_t *that)
{
  int result;

  if (that->m_psi != __null)
    PSI_server->unlock_rwlock(that->m_psi);

  result= rw_pr_unlock(&that->m_prlock);
  return result;
}


static inline void inline_mysql_cond_register(

  const char *category,
  PSI_cond_info *info,
  int count





)
{

  PSI_server->register_cond(category, info, count);

}

static inline int inline_mysql_cond_init(

  PSI_cond_key key,

  mysql_cond_t *that)
{

  that->m_psi= PSI_server->init_cond(key, &that->m_cond);



  return native_cond_init(&that->m_cond);
}

static inline int inline_mysql_cond_destroy(
  mysql_cond_t *that)
{

  if (that->m_psi != __null)
  {
    PSI_server->destroy_cond(that->m_psi);
    that->m_psi= __null;
  }

  return native_cond_destroy(&that->m_cond);
}

static inline int inline_mysql_cond_wait(
  mysql_cond_t *that,
  mysql_mutex_t *mutex

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_cond_locker *locker;
    PSI_cond_locker_state state;
    locker= PSI_server->start_cond_wait(&state, that->m_psi, mutex->m_psi,
                                      PSI_COND_WAIT, src_file, src_line);


    result= my_cond_wait(&that->m_cond, &mutex->m_mutex



                         );


    if (locker != __null)
      PSI_server->end_cond_wait(locker, result);

    return result;
  }



  result= my_cond_wait(&that->m_cond, &mutex->m_mutex



                       );

  return result;
}

static inline int inline_mysql_cond_timedwait(
  mysql_cond_t *that,
  mysql_mutex_t *mutex,
  const struct timespec *abstime

  , const char *src_file, uint src_line

  )
{
  int result;


  if (that->m_psi != __null)
  {

    PSI_cond_locker *locker;
    PSI_cond_locker_state state;
    locker= PSI_server->start_cond_wait(&state, that->m_psi, mutex->m_psi,
                                      PSI_COND_TIMEDWAIT, src_file, src_line);


    result= my_cond_timedwait(&that->m_cond, &mutex->m_mutex, abstime



                              );


    if (locker != __null)
      PSI_server->end_cond_wait(locker, result);

    return result;
  }



  result= my_cond_timedwait(&that->m_cond, &mutex->m_mutex, abstime



                            );

  return result;
}

static inline int inline_mysql_cond_signal(
  mysql_cond_t *that)
{
  int result;

  if (that->m_psi != __null)
    PSI_server->signal_cond(that->m_psi);

  result= native_cond_signal(&that->m_cond);
  return result;
}

static inline int inline_mysql_cond_broadcast(
  mysql_cond_t *that)
{
  int result;

  if (that->m_psi != __null)
    PSI_server->broadcast_cond(that->m_psi);

  result= native_cond_broadcast(&that->m_cond);
  return result;
}

static inline void inline_mysql_thread_register(

  const char *category,
  PSI_thread_info *info,
  int count





)
{

  PSI_server->register_thread(category, info, count);

}


static inline int inline_mysql_thread_create(
  PSI_thread_key key,
  my_thread_handle *thread, const my_thread_attr_t *attr,
  my_start_routine start_routine, void *arg)
{
  int result;
  result= PSI_server->spawn_thread(key, thread, attr, start_routine, arg);
  return result;
}

static inline void inline_mysql_thread_set_psi_id(my_thread_id id)
{
  struct PSI_thread *psi= PSI_server->get_thread();
  PSI_server->set_thread_id(psi, id);
}


class THD;
static inline void inline_mysql_thread_set_psi_THD(THD *thd)
{
  struct PSI_thread *psi= PSI_server->get_thread();
  PSI_server->set_thread_THD(psi, thd);
}
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
// # 1 "/usr/include/unistd.h" 1 3 4
// # 27 "/usr/include/unistd.h" 3 4
extern "C" {
// # 202 "/usr/include/unistd.h" 3 4
// # 1 "/usr/include/bits/posix_opt.h" 1 3 4
// # 203 "/usr/include/unistd.h" 2 3 4



// # 1 "/usr/include/bits/environments.h" 1 3 4
// # 22 "/usr/include/bits/environments.h" 3 4
// # 1 "/usr/include/bits/wordsize.h" 1 3 4
// # 23 "/usr/include/bits/environments.h" 2 3 4
// # 207 "/usr/include/unistd.h" 2 3 4
// # 226 "/usr/include/unistd.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 227 "/usr/include/unistd.h" 2 3 4
// # 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) throw () __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     throw () __attribute__ ((__nonnull__ (1)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;
// # 337 "/usr/include/unistd.h" 3 4
extern __off64_t lseek (int __fd, __off64_t __offset, int __whence) throw () __asm__ ("" "lseek64")

             ;





extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     throw ();






extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
// # 388 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")

                    ;
extern ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pwrite64")

                     ;
// # 404 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) ;


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) ;







extern int pipe (int __pipedes[2]) throw () ;




extern int pipe2 (int __pipedes[2], int __flags) throw () ;
// # 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) throw ();
// # 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     throw ();






extern int usleep (__useconds_t __useconds);
// # 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) throw () ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     throw () __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) throw () ;
// # 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) throw () ;





extern char *get_current_dir_name (void) throw ();







extern char *getwd (char *__buf)
     throw () __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) throw () ;


extern int dup2 (int __fd, int __fd2) throw ();




extern int dup3 (int __fd, int __fd2, int __flags) throw ();



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) throw () __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     throw () __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     throw () __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     throw () __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) throw () ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





// # 1 "/usr/include/bits/confname.h" 1 3 4
// # 25 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
// # 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     throw () __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) throw ();


extern long int sysconf (int __name) throw ();



extern size_t confstr (int __name, char *__buf, size_t __len) throw ();




extern __pid_t getpid (void) throw ();


extern __pid_t getppid (void) throw ();




extern __pid_t getpgrp (void) throw ();
// # 646 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) throw ();

extern __pid_t getpgid (__pid_t __pid) throw ();






extern int setpgid (__pid_t __pid, __pid_t __pgid) throw ();
// # 672 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) throw ();
// # 689 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) throw ();



extern __pid_t getsid (__pid_t __pid) throw ();



extern __uid_t getuid (void) throw ();


extern __uid_t geteuid (void) throw ();


extern __gid_t getgid (void) throw ();


extern __gid_t getegid (void) throw ();




extern int getgroups (int __size, __gid_t __list[]) throw () ;



extern int group_member (__gid_t __gid) throw ();






extern int setuid (__uid_t __uid) throw () ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) throw () ;




extern int seteuid (__uid_t __uid) throw () ;






extern int setgid (__gid_t __gid) throw () ;




extern int setregid (__gid_t __rgid, __gid_t __egid) throw () ;




extern int setegid (__gid_t __gid) throw () ;





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     throw ();



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     throw ();



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     throw () ;



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     throw () ;






extern __pid_t fork (void) throw ();







extern __pid_t vfork (void) throw ();





extern char *ttyname (int __fd) throw ();



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     throw () __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) throw ();





extern int ttyslot (void) throw ();




extern int link (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     throw () __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) throw () __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     throw () __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) throw () __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     throw () __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) throw () __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) throw ();


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) throw ();






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) throw () __attribute__ ((__nonnull__ (1)));
// # 893 "/usr/include/unistd.h" 3 4
// # 1 "/usr/include/getopt.h" 1 3 4
// # 49 "/usr/include/getopt.h" 3 4
extern "C" {
// # 58 "/usr/include/getopt.h" 3 4
extern char *optarg;
// # 72 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
// # 151 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       throw ();
// # 186 "/usr/include/getopt.h" 3 4
}
// # 894 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) throw () __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) throw () ;





extern int getdomainname (char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     throw () __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) throw ();


extern int revoke (const char *__file) throw () __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     throw () __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) throw ();



extern char *getusershell (void) throw ();
extern void endusershell (void) throw ();
extern void setusershell (void) throw ();





extern int daemon (int __nochdir, int __noclose) throw () ;






extern int chroot (const char *__path) throw () __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) throw ();






extern long int gethostid (void);


extern void sync (void) throw ();





extern int getpagesize (void) throw () __attribute__ ((__const__));




extern int getdtablesize (void) throw ();
// # 1019 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off64_t __length) throw () __asm__ ("" "truncate64")

                  __attribute__ ((__nonnull__ (1))) ;





extern int truncate64 (const char *__file, __off64_t __length)
     throw () __attribute__ ((__nonnull__ (1))) ;
// # 1041 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off64_t __length) throw () __asm__ ("" "ftruncate64")
                        ;





extern int ftruncate64 (int __fd, __off64_t __length) throw () ;
// # 1059 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) throw () ;





extern void *sbrk (intptr_t __delta) throw ();
// # 1080 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) throw ();
// # 1134 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);







extern char *crypt (const char *__key, const char *__salt)
     throw () __attribute__ ((__nonnull__ (1, 2)));



extern void encrypt (char *__block, int __edflag) throw () __attribute__ ((__nonnull__ (1)));






extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) throw () __attribute__ ((__nonnull__ (1, 2)));
// # 1172 "/usr/include/unistd.h" 3 4
}
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2


extern "C" {
// # 56 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/typelib.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/typelib.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_alloc.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_alloc.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/psi_memory.h" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_alloc.h" 2


extern "C" {


typedef struct st_used_mem
{
  struct st_used_mem *next;
  unsigned int left;
  unsigned int size;
} USED_MEM;


typedef struct st_mem_root
{
  USED_MEM *free;
  USED_MEM *used;
  USED_MEM *pre_alloc;

  size_t min_malloc;
  size_t block_size;
  unsigned int block_num;




  unsigned int first_block_usage;





  size_t max_capacity;



  size_t allocated_size;


  my_bool error_for_capacity_exceeded;

  void (*error_handler)(void);

  PSI_memory_key m_psi_key;
} MEM_ROOT;


}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/typelib.h" 2

typedef struct st_typelib {
  unsigned int count;
  const char *name;
  const char **type_names;
  unsigned int *type_lengths;
} TYPELIB;

extern my_ulonglong find_typeset(char *x, TYPELIB *typelib,int *error_position);
extern int find_type_or_exit(const char *x, TYPELIB *typelib,
                             const char *option);
// # 42 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/typelib.h"
extern int find_type(const char *x, const TYPELIB *typelib, unsigned int flags);
extern void make_type(char *to,unsigned int nr,TYPELIB *typelib);
extern const char *get_type(TYPELIB *typelib,unsigned int nr);
extern TYPELIB *copy_typelib(MEM_ROOT *root, TYPELIB *from);

extern TYPELIB sql_protocol_typelib;

my_ulonglong find_set_from_flags(const TYPELIB *lib, unsigned int default_name,
                              my_ulonglong cur_set, my_ulonglong default_set,
                              const char *str, unsigned int length,
                              char **err_pos, unsigned int *err_len);
// # 57 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 153 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern void *my_multi_malloc(PSI_memory_key key, myf flags, ...);





extern PSI_memory_key key_memory_max_alloca;
// # 198 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern uint my_get_large_page_size(void);
extern uchar * my_large_malloc(PSI_memory_key key, size_t size, myf my_flags);
extern void my_large_free(uchar *ptr);
extern my_bool my_use_large_pages;
extern uint my_large_page_size;
// # 211 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
// # 1 "/usr/include/errno.h" 1 3 4
// # 212 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2

extern char *home_dir;
extern const char *my_progname;
extern char curr_dir[];
extern void (*error_handler_hook)(uint my_err, const char *str,myf MyFlags);
extern void (*fatal_error_handler_hook)(uint my_err, const char *str,
           myf MyFlags);
extern void (*local_message_hook)(enum loglevel ll,
                                  const char *format, va_list args);
extern uint my_file_limit;
extern ulong my_thread_stack_size;






extern void (*enter_cond_hook)(void *opaque_thd,
                               mysql_cond_t *cond,
                               mysql_mutex_t *mutex,
                               const PSI_stage_info *stage,
                               PSI_stage_info *old_stage,
                               const char *src_function,
                               const char *src_file,
                               int src_line);

extern void (*exit_cond_hook)(void *opaque_thd,
                              const PSI_stage_info *stage,
                              const char *src_function,
                              const char *src_file,
                              int src_line);




extern int (*is_killed_hook)(const void *opaque_thd);



extern CHARSET_INFO *default_charset_info;
extern CHARSET_INFO *all_charsets[2048];
extern CHARSET_INFO compiled_charsets[];


extern ulong my_file_opened,my_stream_opened, my_tmp_file_created;
extern ulong my_file_total_opened;
extern my_bool my_init_done;

extern int my_umask;
extern int my_umask_dir;

extern ulong my_default_record_cache_size;
extern my_bool my_disable_locking,
                my_enable_symlinks;
extern char wild_many,wild_one,wild_prefix;
extern const char *charsets_dir;

enum cache_type
{
  TYPE_NOT_SET= 0, READ_CACHE, WRITE_CACHE,
  SEQ_READ_APPEND ,
  READ_FIFO, READ_NET,WRITE_NET};

enum flush_type
{
  FLUSH_KEEP,
  FLUSH_RELEASE,
  FLUSH_IGNORE_CHANGED,




  FLUSH_FORCE_WRITE
};

enum file_type
{
  UNOPEN = 0, FILE_BY_OPEN, FILE_BY_CREATE, STREAM_BY_FOPEN, STREAM_BY_FDOPEN,
  FILE_BY_MKSTEMP, FILE_BY_DUP
};

struct st_my_file_info
{
  char *name;




  enum file_type type;
};

extern struct st_my_file_info *my_file_info;







typedef struct st_dynamic_array
{
  uchar *buffer;
  uint elements,max_element;
  uint alloc_increment;
  uint size_of_element;
  PSI_memory_key m_psi_key;
} DYNAMIC_ARRAY;

typedef struct st_my_tmpdir
{
  char **list;
  uint cur, max;
  mysql_mutex_t mutex;
} MY_TMPDIR;

typedef struct st_dynamic_string
{
  char *str;
  size_t length,max_length,alloc_increment;
} DYNAMIC_STRING;

struct st_io_cache;
typedef int (*IO_CACHE_CALLBACK)(struct st_io_cache*);

typedef struct st_io_cache_share
{
  mysql_mutex_t mutex;
  mysql_cond_t cond;
  mysql_cond_t cond_writer;

  my_off_t pos_in_file;

  struct st_io_cache *source_cache;
  uchar *buffer;
  uchar *read_end;
  int running_threads;
  int total_threads;
  int error;
} IO_CACHE_SHARE;

typedef struct st_io_cache
{

  my_off_t pos_in_file;





  my_off_t end_of_file;

  uchar *read_pos;

  uchar *read_end;
  uchar *buffer;

  uchar *request_pos;


  uchar *write_buffer;






  uchar *append_read_pos;

  uchar *write_pos;

  uchar *write_end;







  uchar **current_pos, **current_end;





  mysql_mutex_t append_buffer_lock;







  IO_CACHE_SHARE *share;
// # 414 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
  int (*read_function)(struct st_io_cache *,uchar *,size_t);




  int (*write_function)(struct st_io_cache *,const uchar *,size_t);





  enum cache_type type;







  IO_CACHE_CALLBACK pre_read;
  IO_CACHE_CALLBACK post_read;
  IO_CACHE_CALLBACK pre_close;





  ulong disk_writes;
  void* arg;
  char *file_name;
  char *dir,*prefix;
  File file;
  PSI_file_key file_key;
// # 455 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
  int seek_not_done,error;

  size_t buffer_length;

  size_t read_length;
  myf myflags;






  my_bool alloced_buffer;
} IO_CACHE;

typedef int (*qsort2_cmp)(const void *, const void *, const void *);

typedef void (*my_error_reporter)(enum loglevel level, const char *format, ...)
  __attribute__((format(printf, 2, 3)));

extern my_error_reporter my_charset_error_reporter;


extern PSI_file_key key_file_io_cache;
// # 511 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
int my_b_copy_to_file(IO_CACHE *cache, FILE *file);
my_off_t my_b_append_tell(IO_CACHE* info);
my_off_t my_b_safe_tell(IO_CACHE* info);




typedef uint32 ha_checksum;

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_alloc.h" 1
// # 521 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2




extern int my_copy(const char *from,const char *to,myf MyFlags);
extern int my_delete(const char *name,myf MyFlags);
extern int my_getwd(char * buf,size_t size,myf MyFlags);
extern int my_setwd(const char *dir,myf MyFlags);
extern int my_lock(File fd,int op,my_off_t start, my_off_t length,myf MyFlags);
extern void *my_once_alloc(size_t Size,myf MyFlags);
extern void my_once_free(void);
extern char *my_once_strdup(const char *src,myf myflags);
extern void *my_once_memdup(const void *src, size_t len, myf myflags);
extern File my_open(const char *FileName,int Flags,myf MyFlags);
extern File my_register_filename(File fd, const char *FileName,
     enum file_type type_of_file,
     uint error_message_number, myf MyFlags);
extern File my_create(const char *FileName,int CreateFlags,
        int AccessFlags, myf MyFlags);
extern int my_close(File Filedes,myf MyFlags);
extern int my_mkdir(const char *dir, int Flags, myf MyFlags);
extern int my_readlink(char *to, const char *filename, myf MyFlags);
extern int my_is_symlink(const char *filename);
extern int my_realpath(char *to, const char *filename, myf MyFlags);
extern File my_create_with_symlink(const char *linkname, const char *filename,
       int createflags, int access_flags,
       myf MyFlags);
extern int my_delete_with_symlink(const char *name, myf MyFlags);
extern int my_rename_with_symlink(const char *from,const char *to,myf MyFlags);
extern int my_symlink(const char *content, const char *linkname, myf MyFlags);
extern size_t my_read(File Filedes,uchar *Buffer,size_t Count,myf MyFlags);
extern size_t my_pread(File Filedes,uchar *Buffer,size_t Count,my_off_t offset,
       myf MyFlags);
extern int my_rename(const char *from,const char *to,myf MyFlags);
extern my_off_t my_seek(File fd,my_off_t pos,int whence,myf MyFlags);
extern my_off_t my_tell(File fd,myf MyFlags);
extern size_t my_write(File Filedes,const uchar *Buffer,size_t Count,
       myf MyFlags);
extern size_t my_pwrite(File Filedes,const uchar *Buffer,size_t Count,
        my_off_t offset,myf MyFlags);
extern size_t my_fread(FILE *stream,uchar *Buffer,size_t Count,myf MyFlags);
extern size_t my_fwrite(FILE *stream,const uchar *Buffer,size_t Count,
        myf MyFlags);
extern my_off_t my_fseek(FILE *stream,my_off_t pos,int whence,myf MyFlags);
extern my_off_t my_ftell(FILE *stream,myf MyFlags);
// # 575 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
typedef struct st_syslog_facility { int id; const char *name; } SYSLOG_FACILITY;
extern SYSLOG_FACILITY syslog_facility[];

enum my_syslog_options { MY_SYSLOG_PIDS= 1 };

int my_openlog(const char *eventSourceName, int option, int facility);
int my_closelog();
int my_syslog(const CHARSET_INFO *cs, enum loglevel level, const char *msg);


extern void *my_memmem(const void *haystack, size_t haystacklen,
                       const void *needle, size_t needlelen);
// # 595 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern int check_if_legal_filename(const char *path);
extern int check_if_legal_tablename(const char *path);
// # 618 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern const char* get_global_errmsg(int nr);
extern void wait_for_free_space(const char *filename, int errors);
extern FILE *my_fopen(const char *FileName,int Flags,myf MyFlags);
extern FILE *my_fdopen(File Filedes,const char *name, int Flags,myf MyFlags);
extern FILE *my_freopen(const char *path, const char *mode, FILE *stream);
extern int my_fclose(FILE *fd,myf MyFlags);
extern File my_fileno(FILE *fd);
extern int my_chsize(File fd,my_off_t newlength, int filler, myf MyFlags);
extern void thr_set_sync_wait_callback(void (*before_sync)(void),
                                       void (*after_sync)(void));
extern int my_sync(File fd, myf my_flags);
extern int my_sync_dir(const char *dir_name, myf my_flags);
extern int my_sync_dir_by_file(const char *file_name, myf my_flags);
extern char *my_strerror(char *buf, size_t len, int errnum);
extern const char *my_get_err_msg(int nr);
extern void my_error(int nr,myf MyFlags, ...);
extern void my_printf_error(uint my_err, const char *format,
                            myf MyFlags, ...)
  __attribute__((format(printf, 2, 4)));
extern void my_printv_error(uint error, const char *format, myf MyFlags,
                            va_list ap);
extern int my_error_register(const char* (*get_errmsg) (int),
                             int first, int last);
extern my_bool my_error_unregister(int first, int last);
extern void my_message(uint my_err, const char *str,myf MyFlags);
extern void my_message_stderr(uint my_err, const char *str, myf MyFlags);
void my_message_local_stderr(enum loglevel ll,
                             const char *format, va_list args);
extern void my_message_local(enum loglevel ll, const char *format, ...);
extern my_bool my_init(void);
extern void my_end(int infoflag);
extern int my_redel(const char *from, const char *to, int MyFlags);
extern int my_copystat(const char *from, const char *to, int MyFlags);
extern char * my_filename(File fd);
extern MY_MODE get_file_perm(ulong perm_flags);
extern my_bool my_chmod(const char *filename, ulong perm_flags, myf my_flags);







extern my_bool init_tmpdir(MY_TMPDIR *tmpdir, const char *pathlist);
extern char *my_tmpdir(MY_TMPDIR *tmpdir);
extern void free_tmpdir(MY_TMPDIR *tmpdir);

extern size_t dirname_part(char * to,const char *name, size_t *to_res_length);
extern size_t dirname_length(const char *name);

extern int test_if_hard_path(const char *dir_name);
extern my_bool has_path(const char *name);
extern char *convert_dirname(char *to, const char *from, const char *from_end);
extern void to_unix_path(char * name);
extern char * fn_ext(const char *name);
extern char * fn_same(char * toname,const char *name,int flag);
extern char * fn_format(char * to,const char *name,const char *dir,
      const char *form, uint flag);
extern size_t strlength(const char *str);
extern void pack_dirname(char * to,const char *from);
extern size_t normalize_dirname(char * to, const char *from);
extern size_t unpack_dirname(char * to,const char *from);
extern size_t cleanup_dirname(char * to,const char *from);
extern size_t system_filename(char * to,const char *from);
extern size_t unpack_filename(char * to,const char *from);
extern char * intern_filename(char * to,const char *from);
extern int pack_filename(char * to, const char *name, size_t max_length);
extern char * my_path(char * to,const char *progname,
    const char *own_pathname_part);
extern char * my_load_path(char * to, const char *path,
         const char *own_path_prefix);
extern int wild_compare(const char *str,const char *wildstr,
                        pbool str_is_pattern);
extern my_bool array_append_string_unique(const char *str,
                                          const char **array, size_t size);
extern void get_date(char * to,int timeflag,time_t use_time);
extern void soundex(CHARSET_INFO *, char * out_pntr, char * in_pntr,
                    pbool remove_garbage);

extern my_bool radixsort_is_appliccable(uint n_items, size_t size_of_element);
extern void radixsort_for_str_ptr(uchar* base[], uint number_of_elements,
      size_t size_of_element,uchar *buffer[]);
extern void my_qsort(void *base_ptr, size_t total_elems, size_t size,
                     qsort_cmp cmp);
extern void my_qsort2(void *base_ptr, size_t total_elems, size_t size,
                      qsort2_cmp cmp, const void *cmp_argument);
void my_store_ptr(uchar *buff, size_t pack_length, my_off_t pos);
my_off_t my_get_ptr(uchar *ptr, size_t pack_length);
extern int init_io_cache_ext(IO_CACHE *info,File file,size_t cachesize,
                             enum cache_type type,my_off_t seek_offset,
                             pbool use_async_io, myf cache_myflags,
                             PSI_file_key file_key);
extern int init_io_cache(IO_CACHE *info,File file,size_t cachesize,
                         enum cache_type type,my_off_t seek_offset,
                         pbool use_async_io, myf cache_myflags);
extern my_bool reinit_io_cache(IO_CACHE *info,enum cache_type type,
                               my_off_t seek_offset,pbool use_async_io,
                               pbool clear_cache);
extern void setup_io_cache(IO_CACHE* info);
extern int _my_b_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_read_r(IO_CACHE *info,uchar *Buffer,size_t Count);
extern void init_io_cache_share(IO_CACHE *read_cache, IO_CACHE_SHARE *cshare,
                                IO_CACHE *write_cache, uint num_threads);
extern void remove_io_thread(IO_CACHE *info);
extern int _my_b_seq_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_net_read(IO_CACHE *info,uchar *Buffer,size_t Count);
extern int _my_b_get(IO_CACHE *info);
extern int _my_b_write(IO_CACHE *info,const uchar *Buffer,size_t Count);
extern int my_b_append(IO_CACHE *info,const uchar *Buffer,size_t Count);
extern int my_b_safe_write(IO_CACHE *info,const uchar *Buffer,size_t Count);

extern int my_block_write(IO_CACHE *info, const uchar *Buffer,
     size_t Count, my_off_t pos);
extern int my_b_flush_io_cache(IO_CACHE *info, int need_append_buffer_lock);



extern int end_io_cache(IO_CACHE *info);
extern size_t my_b_fill(IO_CACHE *info);
extern void my_b_seek(IO_CACHE *info,my_off_t pos);
extern size_t my_b_gets(IO_CACHE *info, char *to, size_t max_length);
extern my_off_t my_b_filelength(IO_CACHE *info);
extern size_t my_b_printf(IO_CACHE *info, const char* fmt, ...)
  __attribute__((format(printf, 2, 3)));
extern size_t my_b_vprintf(IO_CACHE *info, const char* fmt, va_list ap);
extern my_bool open_cached_file(IO_CACHE *cache,const char *dir,
     const char *prefix, size_t cache_size,
     myf cache_myflags);
extern my_bool real_open_cached_file(IO_CACHE *cache);
extern void close_cached_file(IO_CACHE *cache);
File create_temp_file(char *to, const char *dir, const char *pfx,
        int mode, myf MyFlags);
// # 774 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern my_bool insert_dynamic(DYNAMIC_ARRAY *array, const void *element);
extern void *alloc_dynamic(DYNAMIC_ARRAY *array);
extern void *pop_dynamic(DYNAMIC_ARRAY*);
extern void get_dynamic(DYNAMIC_ARRAY *array, void *element, uint array_index);
extern void claim_dynamic(DYNAMIC_ARRAY *array);
extern void delete_dynamic(DYNAMIC_ARRAY *array);
extern void freeze_size(DYNAMIC_ARRAY *array);
static inline void reset_dynamic(DYNAMIC_ARRAY *array)
{
  array->elements= 0;
}

extern my_bool init_dynamic_string(DYNAMIC_STRING *str, const char *init_str,
       size_t init_alloc,size_t alloc_increment);
extern my_bool dynstr_append(DYNAMIC_STRING *str, const char *append);
my_bool dynstr_append_mem(DYNAMIC_STRING *str, const char *append,
     size_t length);
extern my_bool dynstr_append_os_quoted(DYNAMIC_STRING *str, const char *append,
                                       ...);
extern my_bool dynstr_set(DYNAMIC_STRING *str, const char *init_str);
extern my_bool dynstr_realloc(DYNAMIC_STRING *str, size_t additional_size);
extern my_bool dynstr_trunc(DYNAMIC_STRING *str, size_t n);
extern void dynstr_free(DYNAMIC_STRING *str);



extern void init_alloc_root(PSI_memory_key key,
                            MEM_ROOT *mem_root, size_t block_size,
       size_t pre_alloc_size);
extern void *alloc_root(MEM_ROOT *mem_root, size_t Size);
extern void *multi_alloc_root(MEM_ROOT *mem_root, ...);
extern void claim_root(MEM_ROOT *root);
extern void free_root(MEM_ROOT *root, myf MyFLAGS);
extern void reset_root_defaults(MEM_ROOT *mem_root, size_t block_size,
                                size_t prealloc_size);
extern char *strdup_root(MEM_ROOT *root,const char *str);
static inline char *safe_strdup_root(MEM_ROOT *root, const char *str)
{
  return str ? strdup_root(root, str) : 0;
}
extern char *strmake_root(MEM_ROOT *root,const char *str,size_t len);
extern void *memdup_root(MEM_ROOT *root,const void *str, size_t len);
extern void set_memroot_max_capacity(MEM_ROOT *mem_root, size_t size);
extern void set_memroot_error_reporting(MEM_ROOT *mem_root,
                                       my_bool report_error);
extern my_bool my_compress(uchar *, size_t *, size_t *);
extern my_bool my_uncompress(uchar *, size_t , size_t *);
extern uchar *my_compress_alloc(const uchar *packet, size_t *len,
                                size_t *complen);
extern int packfrm(uchar *, size_t, uchar **, size_t *);
extern int unpackfrm(uchar **, size_t *, const uchar *);

extern ha_checksum my_checksum(ha_checksum crc, const uchar *mem,
                               size_t count);


static inline void my_sleep(time_t m_seconds)
{



  struct timeval t;
  t.tv_sec= m_seconds / 1000000L;
  t.tv_usec= m_seconds % 1000000L;
  select(0,0,0,0,&t);

}

extern ulong crc32(ulong crc, const uchar *buf, uint len);
extern uint my_set_max_open_files(uint files);
void my_free_open_file_info(void);

extern time_t my_time(myf flags);
extern ulonglong my_getsystime(void);
extern ulonglong my_micro_time();
extern my_bool my_gethwaddr(uchar *to);


// # 1 "/usr/include/sys/mman.h" 1 3 4
// # 25 "/usr/include/sys/mman.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 26 "/usr/include/sys/mman.h" 2 3 4
// # 41 "/usr/include/sys/mman.h" 3 4
// # 1 "/usr/include/bits/mman.h" 1 3 4
// # 42 "/usr/include/sys/mman.h" 2 3 4




extern "C" {
// # 61 "/usr/include/sys/mman.h" 3 4
extern void * mmap (void *__addr, size_t __len, int __prot, int __flags, int __fd, __off64_t __offset) throw () __asm__ ("" "mmap64")


                ;





extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) throw ();




extern int munmap (void *__addr, size_t __len) throw ();




extern int mprotect (void *__addr, size_t __len, int __prot) throw ();







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) throw ();



extern int posix_madvise (void *__addr, size_t __len, int __advice) throw ();




extern int mlock (const void *__addr, size_t __len) throw ();


extern int munlock (const void *__addr, size_t __len) throw ();




extern int mlockall (int __flags) throw ();



extern int munlockall (void) throw ();







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     throw ();
// # 133 "/usr/include/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) throw ();



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) throw ();




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);

}
// # 853 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 2
// # 889 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
static inline int my_getpagesize()
{

  return getpagesize();





}

int my_msync(int, void *, size_t, int);


extern void my_charset_loader_init_mysys(MY_CHARSET_LOADER *loader);
extern uint get_charset_number(const char *cs_name, uint cs_flags);
extern uint get_collation_number(const char *name);
extern const char *get_charset_name(uint cs_number);

extern CHARSET_INFO *get_charset(uint cs_number, myf flags);
extern CHARSET_INFO *get_charset_by_name(const char *cs_name, myf flags);
extern CHARSET_INFO *my_collation_get_by_name(MY_CHARSET_LOADER *loader,
                                              const char *name, myf flags);
extern CHARSET_INFO *get_charset_by_csname(const char *cs_name,
        uint cs_flags, myf my_flags);
extern CHARSET_INFO *my_charset_get_by_name(MY_CHARSET_LOADER *loader,
                                            const char *name,
                                            uint cs_flags, myf my_flags);
extern my_bool resolve_charset(const char *cs_name,
                               const CHARSET_INFO *default_cs,
                               const CHARSET_INFO **cs);
extern my_bool resolve_collation(const char *cl_name,
                                 const CHARSET_INFO *default_cl,
                                 const CHARSET_INFO **cl);
extern void free_charsets(void);
extern char *get_charsets_dir(char *buf);
extern my_bool my_charset_same(const CHARSET_INFO *cs1,
                               const CHARSET_INFO *cs2);
extern my_bool init_compiled_charsets(myf flags);
extern void add_compiled_collation(CHARSET_INFO *cs);
extern size_t escape_string_for_mysql(const CHARSET_INFO *charset_info,
                                      char *to, size_t to_length,
                                      const char *from, size_t length);




extern size_t escape_quotes_for_mysql(CHARSET_INFO *charset_info,
                                  char *to, size_t to_length,
                                  const char *from, size_t length, char quote);
// # 961 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h"
extern struct PSI_bootstrap *PSI_hook;
extern void set_psi_server(PSI *psi);
void my_init_mysys_psi_keys(void);


struct st_mysql_file;
extern struct st_mysql_file *mysql_stdin;

}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h" 2
// # 68 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
struct st_mysql_socket
{

  my_socket fd;






  struct PSI_socket *m_psi;
};





typedef struct st_mysql_socket MYSQL_SOCKET;
// # 100 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
static inline MYSQL_SOCKET
mysql_socket_invalid()
{
  MYSQL_SOCKET mysql_socket= {-1, __null};
  return mysql_socket;
}
// # 114 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
static inline void
mysql_socket_set_address(

  MYSQL_SOCKET socket,
  const struct sockaddr *addr,
  socklen_t addr_len





)
{

  if (socket.m_psi != __null)
    PSI_server->set_socket_info(socket.m_psi, __null, addr, addr_len);

}





static inline void
mysql_socket_set_thread_owner(

MYSQL_SOCKET socket



)
{

  if (socket.m_psi != __null)
    PSI_server->set_socket_thread_owner(socket.m_psi);

}






static inline my_socket
mysql_socket_getfd(MYSQL_SOCKET mysql_socket)
{
  return mysql_socket.fd;
}







static inline void
mysql_socket_setfd(MYSQL_SOCKET *mysql_socket, my_socket fd)
{
  if (likely(mysql_socket != __null))
    mysql_socket->fd= fd;
}
// # 250 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
static inline struct PSI_socket_locker*
inline_mysql_start_socket_wait(PSI_socket_locker_state *state,
                               MYSQL_SOCKET mysql_socket,
                               enum PSI_socket_operation op,
                               size_t byte_count,
                               const char *src_file, int src_line)
{
  struct PSI_socket_locker *locker;
  if (mysql_socket.m_psi != __null)
  {
    locker= PSI_server->start_socket_wait
      (state, mysql_socket.m_psi, op, byte_count, src_file, src_line);
  }
  else
    locker= __null;
  return locker;
}





static inline void
inline_mysql_end_socket_wait(struct PSI_socket_locker *locker, size_t byte_count)
{
  if (locker != __null)
    PSI_server->end_socket_wait(locker, byte_count);
}







static inline void
inline_mysql_socket_set_state(MYSQL_SOCKET socket, enum PSI_socket_state state)
{
  if (socket.m_psi != __null)
    PSI_server->set_socket_state(socket.m_psi, state);
}
// # 558 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
static inline void inline_mysql_socket_register(
  const char *category,
  PSI_socket_info *info,
  int count)
{
  PSI_server->register_socket(category, info, count);
}




static inline MYSQL_SOCKET
inline_mysql_socket_socket
(

  PSI_socket_key key,

  int domain, int type, int protocol)
{
  MYSQL_SOCKET mysql_socket= mysql_socket_invalid();
  mysql_socket.fd= socket(domain, type, protocol);


  if (likely(mysql_socket.fd != -1))
  {
    mysql_socket.m_psi= PSI_server->init_socket
      (key, (const my_socket*)&mysql_socket.fd, __null, 0);
  }

  return mysql_socket;
}



static inline int
inline_mysql_socket_bind
(

  const char *src_file, uint src_line,

  MYSQL_SOCKET mysql_socket, const struct sockaddr *addr, socklen_t len)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker_state state;
    PSI_socket_locker *locker;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_BIND, (size_t)0, src_file, src_line);


    result= bind(mysql_socket.fd, addr, len);


    if (result == 0)
      PSI_server->set_socket_info(mysql_socket.m_psi, __null, addr, len);

    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= bind(mysql_socket.fd, addr, len);
  return result;
}



static inline int
inline_mysql_socket_getsockname
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, struct sockaddr *addr, socklen_t *len)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_BIND, (size_t)0, src_file, src_line);


    result= getsockname(mysql_socket.fd, addr, len);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= getsockname(mysql_socket.fd, addr, len);

  return result;
}



static inline int
inline_mysql_socket_connect
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, const struct sockaddr *addr, socklen_t len)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_CONNECT, (size_t)0, src_file, src_line);


    result= connect(mysql_socket.fd, addr, len);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= connect(mysql_socket.fd, addr, len);

  return result;
}



static inline int
inline_mysql_socket_getpeername
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, struct sockaddr *addr, socklen_t *len)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_BIND, (size_t)0, src_file, src_line);


    result= getpeername(mysql_socket.fd, addr, len);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= getpeername(mysql_socket.fd, addr, len);

  return result;
}



static inline ssize_t
inline_mysql_socket_send
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, const void *buf, size_t n, int flags)
{
  ssize_t result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_SEND, n, src_file, src_line);


    result= send(mysql_socket.fd, buf, n, flags);


    if (locker != __null)
    {
      size_t bytes_written;
      bytes_written= (result > -1) ? result : 0;
      PSI_server->end_socket_wait(locker, bytes_written);
    }

    return result;
  }



  result= send(mysql_socket.fd, buf, n, flags);

  return result;
}



static inline ssize_t
inline_mysql_socket_recv
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, void *buf, size_t n, int flags)
{
  ssize_t result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_RECV, (size_t)0, src_file, src_line);


    result= recv(mysql_socket.fd, buf, n, flags);


    if (locker != __null)
    {
      size_t bytes_read;
      bytes_read= (result > -1) ? result : 0;
      PSI_server->end_socket_wait(locker, bytes_read);
    }

    return result;
  }



  result= recv(mysql_socket.fd, buf, n, flags);

  return result;
}



static inline ssize_t
inline_mysql_socket_sendto
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, const void *buf, size_t n, int flags, const struct sockaddr *addr, socklen_t addr_len)
{
  ssize_t result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_SEND, n, src_file, src_line);


    result= sendto(mysql_socket.fd, buf, n, flags, addr, addr_len);


    if (locker != __null)
    {
      size_t bytes_written;
      bytes_written = (result > -1) ? result : 0;
      PSI_server->end_socket_wait(locker, bytes_written);
    }

    return result;
  }



  result= sendto(mysql_socket.fd, buf, n, flags, addr, addr_len);

  return result;
}



static inline ssize_t
inline_mysql_socket_recvfrom
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, void *buf, size_t n, int flags,
 struct sockaddr *addr, socklen_t *addr_len)
{
  ssize_t result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_RECV, (size_t)0, src_file, src_line);


    result= recvfrom(mysql_socket.fd, buf, n, flags, addr, addr_len);


    if (locker != __null)
    {
      size_t bytes_read;
      bytes_read = (result > -1) ? result : 0;
      PSI_server->end_socket_wait(locker, bytes_read);
    }

    return result;
  }



  result= recvfrom(mysql_socket.fd, buf, n, flags, addr, addr_len);

  return result;
}



static inline int
inline_mysql_socket_getsockopt
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, int level, int optname, void *optval, socklen_t *optlen)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_OPT, (size_t)0, src_file, src_line);


    result= getsockopt(mysql_socket.fd, level, optname, optval, optlen);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= getsockopt(mysql_socket.fd, level, optname, optval, optlen);

  return result;
}



static inline int
inline_mysql_socket_setsockopt
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, int level, int optname, const void *optval,
 socklen_t optlen)
{
  int result;


  if (mysql_socket.m_psi)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_OPT, (size_t)0, src_file, src_line);


    result= setsockopt(mysql_socket.fd, level, optname, optval, optlen);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= setsockopt(mysql_socket.fd, level, optname, optval, optlen);

  return result;
}


static inline int
set_socket_nonblock(my_socket fd)
{
  int ret= 0;






  {
    int fd_flags;
    fd_flags= fcntl(fd, 3, 0);
    if (fd_flags < 0)
      return (*__errno_location ());

    fd_flags |= 04000;







    if (fcntl(fd, 4, fd_flags) == -1)
      ret= (*__errno_location ());
  }

  return ret;
}



static inline int
inline_mysql_sock_set_nonblocking
(

  const char *src_file, uint src_line,

  MYSQL_SOCKET mysql_socket
)
{
  int result= 0;


  if (mysql_socket.m_psi)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
        (&state, mysql_socket.m_psi, PSI_SOCKET_OPT,
         (size_t)0, src_file, src_line);


    result= set_socket_nonblock(mysql_socket.fd);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= set_socket_nonblock(mysql_socket.fd);

  return result;
}



static inline int
inline_mysql_socket_listen
(

  const char *src_file, uint src_line,

 MYSQL_SOCKET mysql_socket, int backlog)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_CONNECT, (size_t)0, src_file, src_line);


    result= listen(mysql_socket.fd, backlog);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }



  result= listen(mysql_socket.fd, backlog);

  return result;
}



static inline MYSQL_SOCKET
inline_mysql_socket_accept
(

  const char *src_file, uint src_line, PSI_socket_key key,

  MYSQL_SOCKET socket_listen, struct sockaddr *addr, socklen_t *addr_len)
{
  MYSQL_SOCKET socket_accept= mysql_socket_invalid();
  socklen_t addr_length= (addr_len != __null) ? *addr_len : 0;


  if (socket_listen.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, socket_listen.m_psi, PSI_SOCKET_CONNECT, (size_t)0, src_file, src_line);


    socket_accept.fd= accept(socket_listen.fd, addr, &addr_length);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);
  }
  else

  {

    socket_accept.fd= accept(socket_listen.fd, addr, &addr_length);
  }


  if (likely(socket_accept.fd != -1))
  {

    socket_accept.m_psi= PSI_server->init_socket
      (key, (const my_socket*)&socket_accept.fd, addr, addr_length);
  }


  return socket_accept;
}



static inline int
inline_mysql_socket_close
(

  const char *src_file, uint src_line,

  MYSQL_SOCKET mysql_socket)
{
  int result;


  if (mysql_socket.m_psi != __null)
  {

    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_CLOSE, (size_t)0, src_file, src_line);


    result= close(mysql_socket.fd);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    if (mysql_socket.m_psi != __null)
      PSI_server->destroy_socket(mysql_socket.m_psi);

    return result;
  }



  result= close(mysql_socket.fd);

  return result;
}



static inline int
inline_mysql_socket_shutdown
(

  const char *src_file, uint src_line,

  MYSQL_SOCKET mysql_socket, int how)
{
  int result;
// # 1216 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
  if (mysql_socket.m_psi != __null)
  {
    PSI_socket_locker *locker;
    PSI_socket_locker_state state;
    locker= PSI_server->start_socket_wait
      (&state, mysql_socket.m_psi, PSI_SOCKET_SHUTDOWN, (size_t)0, src_file, src_line);
// # 1230 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
      result= shutdown(mysql_socket.fd, how);


    if (locker != __null)
      PSI_server->end_socket_wait(locker, (size_t)0);

    return result;
  }
// # 1247 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/psi/mysql_socket.h"
    result= shutdown(mysql_socket.fd, how);

  return result;
}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2




extern "C" {



void init_vio_psi_keys();



typedef struct st_vio Vio;


enum enum_vio_type
{



  NO_VIO_TYPE= 0,



  VIO_TYPE_TCPIP= 1,



  VIO_TYPE_SOCKET= 2,



  VIO_TYPE_NAMEDPIPE= 3,



  VIO_TYPE_SSL= 4,



  VIO_TYPE_SHARED_MEMORY= 5,



  VIO_TYPE_LOCAL= 6,



  VIO_TYPE_PLUGIN= 7,

  FIRST_VIO_TYPE= VIO_TYPE_TCPIP,




  LAST_VIO_TYPE= VIO_TYPE_PLUGIN
};







void get_vio_type_name(enum enum_vio_type vio_type, const char ** str, int * len);




enum enum_vio_io_event
{
  VIO_IO_EVENT_READ,
  VIO_IO_EVENT_WRITE,
  VIO_IO_EVENT_CONNECT
};






Vio* vio_new(my_socket sd, enum enum_vio_type type, uint flags);
Vio* mysql_socket_vio_new(MYSQL_SOCKET mysql_socket, enum enum_vio_type type, uint flags);
// # 124 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
void vio_delete(Vio* vio);
int vio_shutdown(Vio* vio);
my_bool vio_reset(Vio* vio, enum enum_vio_type type,
                  my_socket sd, void *ssl, uint flags);
size_t vio_read(Vio *vio, uchar * buf, size_t size);
size_t vio_read_buff(Vio *vio, uchar * buf, size_t size);
size_t vio_write(Vio *vio, const uchar * buf, size_t size);

int vio_fastsend(Vio *vio);

int vio_keepalive(Vio *vio, my_bool onoff);

my_bool vio_should_retry(Vio *vio);

my_bool vio_was_timeout(Vio *vio);

const char* vio_description(Vio *vio);

enum enum_vio_type vio_type(Vio* vio);

int vio_errno(Vio*vio);

my_socket vio_fd(Vio*vio);

my_bool vio_peer_addr(Vio *vio, char *buf, uint16 *port, size_t buflen);

int vio_io_wait(Vio *vio, enum enum_vio_io_event event, int timeout);
my_bool vio_is_connected(Vio *vio);




int vio_timeout(Vio *vio, uint which, int timeout_sec);

my_bool vio_socket_connect(Vio *vio, struct sockaddr *addr, socklen_t len,
                           int timeout);

my_bool vio_get_normalized_ip_string(const struct sockaddr *addr, size_t addr_length,
                                     char *ip_string, size_t ip_string_size);

my_bool vio_is_no_name_error(int err_code);

int vio_getnameinfo(const struct sockaddr *sa,
                    char *hostname, size_t hostname_size,
                    char *port, size_t port_size,
                    int flags);


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/opensslv.h" 1
// # 173 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2
// # 190 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
typedef my_socket YASSL_SOCKET_T;

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h" 1
// # 29 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/prefix_ssl.h" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/opensslv.h" 1
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/rsa.h" 1
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/rsa.h"
enum { RSA_F4 = 1 };
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h" 2






extern "C" {


 void yayaSSL_CleanUp();





}
// # 72 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
    typedef struct SSL SSL;
    typedef struct SSL_SESSION SSL_SESSION;
    typedef struct SSL_METHOD SSL_METHOD;
    typedef struct SSL_CTX SSL_CTX;
    typedef struct SSL_CIPHER SSL_CIPHER;

    typedef struct RSA RSA;

    typedef struct X509 X509;
    typedef struct X509_NAME X509_NAME;




typedef struct BIGNUM BIGNUM;

BIGNUM *yaBN_bin2bn(const unsigned char*, int, BIGNUM*);




typedef struct DH {
    BIGNUM* p;
    BIGNUM* g;
} DH;

DH* yaDH_new(void);
void yaDH_free(DH*);



void yaRSA_free(RSA*);
RSA* yaRSA_generate_key(int, unsigned long, void(*)(int, int, void*), void*);






typedef struct X509_STORE_CTX {
    int error;
    int error_depth;
    X509* current_cert;
} X509_STORE_CTX;


typedef struct X509_STORE X509_STORE;
typedef struct X509_LOOKUP X509_LOOKUP;
typedef struct X509_OBJECT { char c; } X509_OBJECT;
typedef struct X509_CRL X509_CRL;
typedef struct X509_REVOKED X509_REVOKED;
typedef struct X509_LOOKUP_METHOD X509_LOOKUP_METHOD;


void yaX509_free(X509*);



typedef struct BIO BIO;





X509* yaX509_STORE_CTX_get_current_cert(X509_STORE_CTX*);
int yaX509_STORE_CTX_get_error(X509_STORE_CTX*);
int yaX509_STORE_CTX_get_error_depth(X509_STORE_CTX*);

char* yaX509_NAME_oneline(X509_NAME*, char*, int);
X509_NAME* yaX509_get_issuer_name(X509*);
X509_NAME* yaX509_get_subject_name(X509*);
const char* yaX509_verify_cert_error_string(long);

int yaX509_LOOKUP_add_dir(X509_LOOKUP*, const char*, long);
int yaX509_LOOKUP_load_file(X509_LOOKUP*, const char*, long);
X509_LOOKUP_METHOD* yaX509_LOOKUP_hash_dir(void);
X509_LOOKUP_METHOD* yaX509_LOOKUP_file(void);

X509_LOOKUP* yaX509_STORE_add_lookup(X509_STORE*, X509_LOOKUP_METHOD*);
X509_STORE* yaX509_STORE_new(void);
int yaX509_STORE_get_by_subject(X509_STORE_CTX*, int, X509_NAME*,
                                       X509_OBJECT*);




enum {
    X509_V_OK = 0,
    X509_V_ERR_CERT_CHAIN_TOO_LONG = 1,
    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT = 2,
    X509_V_ERR_CERT_NOT_YET_VALID = 3,
    X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = 4,
    X509_V_ERR_CERT_HAS_EXPIRED = 5,
    X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = 6,
    X509_FILETYPE_PEM = 7,
    X509_LU_X509 = 8,
    X509_LU_CRL = 9,
    X509_V_ERR_CRL_SIGNATURE_FAILURE = 10,
    X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = 11,
    X509_V_ERR_CRL_HAS_EXPIRED = 12,
    X509_V_ERR_CERT_REVOKED = 13,
    X509_V_FLAG_CRL_CHECK = 14,
    X509_V_FLAG_CRL_CHECK_ALL = 15
};



unsigned long yaERR_get_error_line_data(const char**, int*, const char**, int *);
void yaERR_print_errors_fp(FILE*);
char* yaERR_error_string(unsigned long,char*);
void yaERR_remove_state(unsigned long);
unsigned long yaERR_get_error(void);
unsigned long yaERR_peek_error(void);
int yaERR_GET_REASON(int);


enum {
    ERR_TXT_STRING = 1,
    EVP_R_BAD_DECRYPT = 2
};
// # 201 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
SSL_CTX* yaSSL_CTX_new(SSL_METHOD*);
SSL* yaSSL_new(SSL_CTX*);
int yaSSL_set_fd (SSL*, YASSL_SOCKET_T);
YASSL_SOCKET_T yaSSL_get_fd(const SSL*);
int yaSSL_connect(SSL*);

int yaSSL_write(SSL*, const void*, int);
int yaSSL_read(SSL*, void*, int);
int yaSSL_accept(SSL*);
void yaSSL_CTX_free(SSL_CTX*);
void yaSSL_free(SSL*);
int yaSSL_clear(SSL*);
int yaSSL_shutdown(SSL*);

void yaSSL_set_connect_state(SSL*);
void yaSSL_set_accept_state(SSL*);
int yaSSL_do_handshake(SSL*);

const char* yaSSL_get_cipher(SSL*);
const char* yaSSL_get_cipher_name(SSL*);
char* yaSSL_get_shared_ciphers(SSL*, char*, int);
const char* yaSSL_get_cipher_list(SSL*, int);
const char* yaSSL_get_version(SSL*);
const char* yaSSLeay_version(int);

int yaSSL_get_error(SSL*, int);
void yaSSL_load_error_strings(void);

int yaSSL_set_session(SSL *ssl, SSL_SESSION *session);
SSL_SESSION* yaSSL_get_session(SSL* ssl);
void yaSSL_flush_sessions(SSL_CTX *ctx, long tm);
long yaSSL_SESSION_set_timeout(SSL_SESSION*, long);
long yaSSL_CTX_set_session_cache_mode(SSL_CTX* ctx, long mode);
X509* yaSSL_get_peer_certificate(SSL*);
long yaSSL_get_verify_result(SSL*);


typedef int (*VerifyCallback)(int, X509_STORE_CTX*);
typedef int (*pem_password_cb)(char*, int, int, void*);
int default_password_callback(char * buffer, int size_arg, int rwflag,
                              void * u);

void yaSSL_CTX_set_verify(SSL_CTX*, int, VerifyCallback verify_callback);
int yaSSL_CTX_load_verify_locations(SSL_CTX*, const char*, const char*);
int yaSSL_CTX_set_default_verify_paths(SSL_CTX*);
int yaSSL_CTX_check_private_key(SSL_CTX*);
int yaSSL_CTX_set_session_id_context(SSL_CTX*, const unsigned char*,
                                    unsigned int);

void yaSSL_CTX_set_tmp_rsa_callback(SSL_CTX*, RSA*(*)(SSL*, int, int));
long yaSSL_CTX_set_options(SSL_CTX*, long);
long yaSSL_CTX_set_session_cache_mode(SSL_CTX*, long);
long yaSSL_CTX_set_timeout(SSL_CTX*, long);
int yaSSL_CTX_use_certificate_chain_file(SSL_CTX*, const char*);
void yaSSL_CTX_set_default_passwd_cb(SSL_CTX*, pem_password_cb);
int yaSSL_CTX_use_RSAPrivateKey_file(SSL_CTX*, const char*, int);
void yaSSL_CTX_set_info_callback(SSL_CTX*, void (*)());

long yaSSL_CTX_sess_accept(SSL_CTX*);
long yaSSL_CTX_sess_connect(SSL_CTX*);
long yaSSL_CTX_sess_accept_good(SSL_CTX*);
long yaSSL_CTX_sess_connect_good(SSL_CTX*);
long yaSSL_CTX_sess_accept_renegotiate(SSL_CTX*);
long yaSSL_CTX_sess_connect_renegotiate(SSL_CTX*);
long yaSSL_CTX_sess_hits(SSL_CTX*);
long yaSSL_CTX_sess_cb_hits(SSL_CTX*);
long yaSSL_CTX_sess_cache_full(SSL_CTX*);
long yaSSL_CTX_sess_misses(SSL_CTX*);
long yaSSL_CTX_sess_timeouts(SSL_CTX*);
long yaSSL_CTX_sess_number(SSL_CTX*);
long yaSSL_CTX_sess_get_cache_size(SSL_CTX*);

int yaSSL_CTX_get_verify_mode(SSL_CTX*);
int yaSSL_get_verify_mode(SSL*);
int yaSSL_CTX_get_verify_depth(SSL_CTX*);
int yaSSL_get_verify_depth(SSL*);

long yaSSL_get_default_timeout(SSL*);
long yaSSL_CTX_get_session_cache_mode(SSL_CTX*);
int yaSSL_session_reused(SSL*);

int yaSSL_set_rfd(SSL*, int);
int yaSSL_set_wfd(SSL*, int);
void yaSSL_set_shutdown(SSL*, int);
void yaSSL_set_quiet_shutdown(SSL *ssl,int mode);
int yaSSL_get_quiet_shutdown(SSL *ssl);

int yaSSL_want_read(SSL*);
int yaSSL_want_write(SSL*);

int yaSSL_pending(SSL*);


enum {
    SSL_WOULD_BLOCK = -8,
    SSL_BAD_STAT = -7,
    SSL_BAD_PATH = -6,
    SSL_BAD_FILETYPE = -5,
    SSL_BAD_FILE = -4,
    SSL_NOT_IMPLEMENTED = -3,
    SSL_UNKNOWN = -2,
    SSL_FATAL_ERROR = -1,
    SSL_NORMAL_SHUTDOWN = 0,
    SSL_ERROR_NONE = 0,
    SSL_FAILURE = 0,
    SSL_SUCCESS = 1,

    SSL_FILETYPE_ASN1 = 10,
    SSL_FILETYPE_PEM = 11,
    SSL_FILETYPE_DEFAULT = 10,

    SSL_VERIFY_NONE = 0,
    SSL_VERIFY_PEER = 1,
    SSL_VERIFY_FAIL_IF_NO_PEER_CERT = 2,
    SSL_VERIFY_CLIENT_ONCE = 4,

    SSL_SESS_CACHE_OFF = 30,
    SSL_SESS_CACHE_CLIENT = 31,
    SSL_SESS_CACHE_SERVER = 32,
    SSL_SESS_CACHE_BOTH = 33,
    SSL_SESS_CACHE_NO_AUTO_CLEAR = 34,
    SSL_SESS_CACHE_NO_INTERNAL_LOOKUP = 35,

    SSL_OP_MICROSOFT_SESS_ID_BUG = 50,
    SSL_OP_NETSCAPE_CHALLENGE_BUG = 51,
    SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 52,
    SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 53,
    SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 54,
    SSL_OP_MSIE_SSLV2_RSA_PADDING = 55,
    SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 56,
    SSL_OP_TLS_D5_BUG = 57,
    SSL_OP_TLS_BLOCK_PADDING_BUG = 58,
    SSL_OP_TLS_ROLLBACK_BUG = 59,
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 60,
    SSL_OP_ALL = 61,
    SSL_OP_SINGLE_DH_USE = 62,
    SSL_OP_EPHEMERAL_RSA = 63,
    SSL_OP_PKCS1_CHECK_1 = 67,
    SSL_OP_PKCS1_CHECK_2 = 68,
    SSL_OP_NETSCAPE_CA_DN_BUG = 69,
    SSL_OP_NON_EXPORT_FIRST = 70,
    SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = 71,

    SSL_ERROR_WANT_READ = 80,
    SSL_ERROR_WANT_WRITE = 81,
    SSL_ERROR_SYSCALL = 82,
    SSL_ERROR_WANT_X509_LOOKUP = 83,
    SSL_ERROR_ZERO_RETURN = 84,
    SSL_ERROR_SSL = 85,

    SSL_ST_CONNECT = 90,
    SSL_ST_ACCEPT = 91,
    SSL_CB_LOOP = 92,
    SSL_SENT_SHUTDOWN = 93,
    SSL_RECEIVED_SHUTDOWN = 94,
    SSL_CB_ALERT = 95,
    SSL_CB_READ = 96,
    SSL_CB_HANDSHAKE_DONE = 97,

    SSL_OP_NO_SSLv2 = 128,
    SSL_OP_NO_SSLv3 = 256,
    SSL_OP_NO_TLSv1 = 512,
    SSL_OP_NO_TLSv1_1 = 1024,
};


SSL_METHOD *yaSSLv3_method(void);
SSL_METHOD *yaSSLv3_server_method(void);
SSL_METHOD *yaSSLv3_client_method(void);
SSL_METHOD *yaTLSv1_server_method(void);
SSL_METHOD *yaTLSv1_client_method(void);
SSL_METHOD *yaTLSv1_1_server_method(void);
SSL_METHOD *yaTLSv1_1_client_method(void);
SSL_METHOD *yaSSLv23_server_method(void);

int yaSSL_CTX_use_certificate_file(SSL_CTX*, const char*, int);
int yaSSL_CTX_use_PrivateKey_file(SSL_CTX*, const char*, int);
int yaSSL_CTX_set_cipher_list(SSL_CTX*, const char*);

long yaSSL_CTX_sess_set_cache_size(SSL_CTX*, long);
long yaSSL_CTX_set_tmp_dh(SSL_CTX*, DH*);

void yaOpenSSL_add_all_algorithms(void);
int yaSSL_library_init();
int yaSSLeay_add_ssl_algorithms(void);


SSL_CIPHER* yaSSL_get_current_cipher(SSL*);
char* yaSSL_CIPHER_description(SSL_CIPHER*, char*, int);


char* yaSSL_alert_type_string_long(int);
char* yaSSL_alert_desc_string_long(int);
char* yaSSL_state_string_long(SSL*);

X509* yaSSL_PEM_read_X509(FILE *fp, X509 *x, pem_password_cb cb, void *u);

typedef char EVP_MD;

typedef char EVP_CIPHER;

typedef struct EVP_PKEY EVP_PKEY;

typedef unsigned char DES_cblock[8];
typedef const DES_cblock const_DES_cblock;
typedef DES_cblock DES_key_schedule;

enum {
    DES_ENCRYPT = 1,
    DES_DECRYPT = 0
};

const EVP_MD* yaEVP_md5(void);
const EVP_CIPHER* yaEVP_des_ede3_cbc(void);

typedef unsigned char opaque;

int yaEVP_BytesToKey(const EVP_CIPHER*, const EVP_MD*, const opaque*,
                   const opaque*, int, int, opaque*, opaque*);

void yaDES_set_key_unchecked(const_DES_cblock*, DES_key_schedule*);
void yaDES_ede3_cbc_encrypt(const opaque*, opaque*, long, DES_key_schedule*,
                        DES_key_schedule*, DES_key_schedule*, DES_cblock*, int);



void yaRAND_screen(void);
const char* yaRAND_file_name(char*, size_t);
int yaRAND_write_file(const char*);
int yaRAND_load_file(const char*, long);



int yaRAND_status(void);
int yaRAND_bytes(unsigned char* buf, int num);

int yaDES_set_key(const_DES_cblock*, DES_key_schedule*);
void yaDES_set_odd_parity(DES_cblock*);
void yaDES_ecb_encrypt(DES_cblock*, DES_cblock*, DES_key_schedule*, int);

void yaSSL_CTX_set_default_passwd_cb_userdata(SSL_CTX*, void* userdata);
void yaSSL_SESSION_free(SSL_SESSION* session);
int yaSSL_peek(SSL* ssl, void* buf, int num);

X509* yaSSL_get_certificate(SSL* ssl);
EVP_PKEY* yaSSL_get_privatekey(SSL* ssl);
EVP_PKEY* yaX509_get_pubkey(X509* x);

int yaEVP_PKEY_copy_parameters(EVP_PKEY* to, const EVP_PKEY* from);
void yaEVP_PKEY_free(EVP_PKEY* pkey);
void yaERR_error_string_n(unsigned long e, char *buf, size_t len);
void yaERR_free_strings(void);
void yaEVP_cleanup(void);

void* yaX509_get_ext_d2i(X509* x, int nid, int* crit, int* idx);







typedef struct ASN1_STRING {
    int type;
    int length;
    unsigned char* data;
} ASN1_STRING;


typedef struct GENERAL_NAME {
    int type;
    union {
        ASN1_STRING* ia5;
    } d;
} GENERAL_NAME;

void yaGENERAL_NAMES_free(GENERAL_NAME *x);

int yask_GENERAL_NAME_num(GENERAL_NAME *x);
GENERAL_NAME* yask_GENERAL_NAME_value(GENERAL_NAME *x, int i);


unsigned char* yaASN1_STRING_data(ASN1_STRING* x);
int yaASN1_STRING_length(ASN1_STRING* x);
int yaASN1_STRING_type(ASN1_STRING *x);

typedef ASN1_STRING X509_NAME_ENTRY;

int yaX509_NAME_get_index_by_NID(X509_NAME* name,int nid, int lastpos);

ASN1_STRING* yaX509_NAME_ENTRY_get_data(X509_NAME_ENTRY* ne);
X509_NAME_ENTRY* yaX509_NAME_get_entry(X509_NAME* name, int loc);




int yaASN1_STRING_to_UTF8(unsigned char** out, ASN1_STRING* in);

SSL_METHOD* yaSSLv23_client_method(void);
SSL_METHOD* yaSSLv2_client_method(void);


SSL_SESSION* yaSSL_get1_session(SSL* ssl);





ASN1_STRING* yaX509_get_notBefore(X509* x);
ASN1_STRING* yaX509_get_notAfter(X509* x);
// # 521 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
typedef struct MD4_CTX {
    int buffer[32];
} MD4_CTX;

void yaMD4_Init(MD4_CTX*);
void yaMD4_Update(MD4_CTX*, const void*, unsigned long);
void yaMD4_Final(unsigned char*, MD4_CTX*);


typedef struct MD5_CTX {
    int buffer[32];
} MD5_CTX;

void yaMD5_Init(MD5_CTX*);
void yaMD5_Update(MD5_CTX*, const void*, unsigned long);
void yaMD5_Final(unsigned char*, MD5_CTX*);
// # 545 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
int yaSSL_set_compression(SSL*);
char *ya_SSL_ASN1_TIME_to_string(ASN1_STRING *time, char *buf, size_t len);

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/transport_types.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/transport_types.h"
typedef long (*yaSSL_recv_func_t) (void *, void *, size_t);
typedef long (*yaSSL_send_func_t) (void *, const void *, size_t);
// # 549 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h" 2
// # 558 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/ssl.h"
void yaSSL_transport_set_ptr(SSL *, void *);
void yaSSL_transport_set_recv_function(SSL *, yaSSL_recv_func_t);
void yaSSL_transport_set_send_function(SSL *, yaSSL_send_func_t);
// # 193 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/extra/yassl/include/openssl/err.h" 1
// # 194 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h" 2


enum enum_ssl_init_error
{
  SSL_INITERR_NOERROR= 0, SSL_INITERR_CERT, SSL_INITERR_KEY,
  SSL_INITERR_NOMATCH, SSL_INITERR_BAD_PATHS, SSL_INITERR_CIPHERS,
  SSL_INITERR_MEMFAIL, SSL_INITERR_NO_USABLE_CTX, SSL_INITERR_DHFAIL,
  SSL_TLS_VERSION_INVALID, SSL_INITERR_LASTERR
};
const char* sslGetErrString(enum enum_ssl_init_error err);

struct st_VioSSLFd
{
  SSL_CTX *ssl_context;
};

int sslaccept(struct st_VioSSLFd*, Vio *, long timeout, unsigned long *errptr);
int sslconnect(struct st_VioSSLFd*, Vio *, long timeout, unsigned long *errptr);

struct st_VioSSLFd
*new_VioSSLConnectorFd(const char *key_file, const char *cert_file,
                       const char *ca_file, const char *ca_path,
                       const char *cipher, enum enum_ssl_init_error *error,
                       const char *crl_file, const char *crl_path, const long ssl_ctx_flags);

long process_tls_version(const char *tls_version);

struct st_VioSSLFd
*new_VioSSLAcceptorFd(const char *key_file, const char *cert_file,
                      const char *ca_file,const char *ca_path,
                      const char *cipher, enum enum_ssl_init_error *error,
                      const char *crl_file, const char *crl_path, const long ssl_ctx_flags);
void free_vio_ssl_acceptor_fd(struct st_VioSSLFd *fd);

void vio_ssl_end();




void ssl_start(void);
void vio_end(void);


}
// # 256 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
enum SSL_type
{
  SSL_TYPE_NOT_SPECIFIED= -1,
  SSL_TYPE_NONE,
  SSL_TYPE_ANY,
  SSL_TYPE_X509,
  SSL_TYPE_SPECIFIED
};




struct st_vio
{
  MYSQL_SOCKET mysql_socket;
  my_bool localhost;
  struct sockaddr_storage local;
  struct sockaddr_storage remote;
  size_t addrLen;
  enum enum_vio_type type;
  my_bool inactive;
  char desc[30];




  char *read_buffer;
  char *read_pos;

  char *read_end;
  int read_timeout;
  int write_timeout;
// # 298 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
  void (*viodelete)(Vio*);
  int (*vioerrno)(Vio*);
  size_t (*read)(Vio*, uchar *, size_t);
  size_t (*write)(Vio*, const uchar *, size_t);
  int (*timeout)(Vio*, uint, my_bool);
  int (*viokeepalive)(Vio*, my_bool);
  int (*fastsend)(Vio*);
  my_bool (*peer_addr)(Vio*, char *, uint16*, size_t);
  void (*in_addr)(Vio*, struct sockaddr_storage*);
  my_bool (*should_retry)(Vio*);
  my_bool (*was_timeout)(Vio*);





  int (*vioshutdown)(Vio*);
  my_bool (*is_connected)(Vio*);
  my_bool (*has_data) (Vio*);
  int (*io_wait)(Vio*, enum enum_vio_io_event, int);
  my_bool (*connect)(Vio*, struct sockaddr *, socklen_t, int);





  void *ssl_arg;
// # 337 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/violite.h"
};
// # 32 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h" 2




extern "C" {


extern struct srv_session_info_service_st {
  THD* (*get_thd)(MYSQL_SESSION session);

  my_thread_id (*get_session_id)(MYSQL_SESSION session);

  LEX_CSTRING (*get_current_db)(MYSQL_SESSION session);

  uint16_t (*get_client_port)(MYSQL_SESSION session);
  int (*set_client_port)(MYSQL_SESSION session, uint16_t port);

  int (*set_connection_type)(MYSQL_SESSION session, enum enum_vio_type type);

  int (*killed)(MYSQL_SESSION session);

  unsigned int (*session_count)();
  unsigned int (*thread_count)(const void *plugin);
} *srv_session_info_service;
// # 171 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_srv_session_info.h"
}
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/com_data.h" 1
// # 31 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/com_data.h"
typedef struct st_com_init_db_data
{
  const char *db_name;
  unsigned long length;
} COM_INIT_DB_DATA;

typedef struct st_com_refresh_data
{
  unsigned char options;
} COM_REFRESH_DATA;

typedef struct st_com_shutdown_data
{
  enum mysql_enum_shutdown_level level;
} COM_SHUTDOWN_DATA;

typedef struct st_com_kill_data
{
  unsigned long id;
} COM_KILL_DATA;

typedef struct st_com_set_option_data
{
  unsigned int opt_command;
} COM_SET_OPTION_DATA;

typedef struct st_com_stmt_execute_data
{
  unsigned long stmt_id;
  unsigned long flags;
  unsigned char *params;
  unsigned long params_length;
} COM_STMT_EXECUTE_DATA;

typedef struct st_com_stmt_fetch_data
{
  unsigned long stmt_id;
  unsigned long num_rows;
} COM_STMT_FETCH_DATA;

typedef struct st_com_stmt_send_long_data_data
{
  unsigned long stmt_id;
  unsigned int param_number;
  unsigned char *longdata;
  unsigned long length;
} COM_STMT_SEND_LONG_DATA_DATA;

typedef struct st_com_stmt_prepare_data
{
  const char *query;
  unsigned int length;
} COM_STMT_PREPARE_DATA;

typedef struct st_stmt_close_data
{
  unsigned int stmt_id;
} COM_STMT_CLOSE_DATA;

typedef struct st_com_stmt_reset_data
{
  unsigned int stmt_id;
} COM_STMT_RESET_DATA;

typedef struct st_com_query_data
{
  const char *query;
  unsigned int length;
} COM_QUERY_DATA;

typedef struct st_com_field_list_data
{
  unsigned char *table_name;
  unsigned int table_name_length;
  const unsigned char *query;
  unsigned int query_length;
} COM_FIELD_LIST_DATA;

union COM_DATA {
  COM_INIT_DB_DATA com_init_db;
  COM_REFRESH_DATA com_refresh;
  COM_SHUTDOWN_DATA com_shutdown;
  COM_KILL_DATA com_kill;
  COM_SET_OPTION_DATA com_set_option;
  COM_STMT_EXECUTE_DATA com_stmt_execute;
  COM_STMT_FETCH_DATA com_stmt_fetch;
  COM_STMT_SEND_LONG_DATA_DATA com_stmt_send_long_data;
  COM_STMT_PREPARE_DATA com_stmt_prepare;
  COM_STMT_CLOSE_DATA com_stmt_close;
  COM_STMT_RESET_DATA com_stmt_reset;
  COM_QUERY_DATA com_query;
  COM_FIELD_LIST_DATA com_field_list;
};
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h" 2


extern "C" {


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_time.h" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_time.h"
enum enum_mysql_timestamp_type
{
  MYSQL_TIMESTAMP_NONE= -2, MYSQL_TIMESTAMP_ERROR= -1,
  MYSQL_TIMESTAMP_DATE= 0, MYSQL_TIMESTAMP_DATETIME= 1, MYSQL_TIMESTAMP_TIME= 2
};
// # 47 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql_time.h"
typedef struct st_mysql_time
{
  unsigned int year, month, day, hour, minute, second;
  unsigned long second_part;
  my_bool neg;
  enum enum_mysql_timestamp_type time_type;
} MYSQL_TIME;
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/decimal.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/decimal.h"
typedef enum
{TRUNCATE=0, HALF_EVEN, HALF_UP, CEILING, FLOOR}
  decimal_round_mode;
typedef int32 decimal_digit_t;
// # 33 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/decimal.h"
typedef struct st_decimal_t {
  int intg, frac, len;
  my_bool sign;
  decimal_digit_t *buf;
} decimal_t;


int internal_str2dec(const char *from, decimal_t *to, char **end,
                     my_bool fixed);
int decimal2string(const decimal_t *from, char *to, int *to_len,
                   int fixed_precision, int fixed_decimals,
                   char filler);
int decimal2ulonglong(decimal_t *from, ulonglong *to);
int ulonglong2decimal(ulonglong from, decimal_t *to);
int decimal2longlong(decimal_t *from, longlong *to);
int longlong2decimal(longlong from, decimal_t *to);
int decimal2double(const decimal_t *from, double *to);
int double2decimal(double from, decimal_t *to);
int decimal_actual_fraction(decimal_t *from);
int decimal2bin(decimal_t *from, uchar *to, int precision, int scale);
int bin2decimal(const uchar *from, decimal_t *to, int precision, int scale);
// # 64 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/decimal.h"
int decimal2lldiv_t(const decimal_t *from, lldiv_t *to);
// # 76 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/decimal.h"
int double2lldiv_t(double from, lldiv_t *to);
int decimal_size(int precision, int scale);
int decimal_bin_size(int precision, int scale);
int decimal_result_size(decimal_t *from1, decimal_t *from2, char op,
                        int param);

int decimal_intg(const decimal_t *from);
int decimal_add(const decimal_t *from1, const decimal_t *from2, decimal_t *to);
int decimal_sub(const decimal_t *from1, const decimal_t *from2, decimal_t *to);
int decimal_cmp(const decimal_t *from1, const decimal_t *from2);
int decimal_mul(const decimal_t *from1, const decimal_t *from2, decimal_t *to);
int decimal_div(const decimal_t *from1, const decimal_t *from2, decimal_t *to,
                int scale_incr);
int decimal_mod(const decimal_t *from1, const decimal_t *from2, decimal_t *to);
int decimal_round(const decimal_t *from, decimal_t *to, int new_scale,
                  decimal_round_mode mode);
int decimal_is_zero(const decimal_t *from);
void max_decimal(int precision, int frac, decimal_t *to);
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/m_ctype.h" 1
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h" 2




struct st_send_field
{
  const char *db_name;
  const char *table_name;
  const char *org_table_name;
  const char *col_name;
  const char *org_col_name;
  unsigned long length;
  unsigned int charsetnr;
  unsigned int flags;
  unsigned int decimals;
  enum_field_types type;
};


struct st_command_service_cbs
{
// # 110 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*start_result_metadata)(void *ctx, uint num_cols, uint flags,
                               const CHARSET_INFO *resultcs);
// # 124 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*field_metadata)(void *ctx, struct st_send_field *field,
                        const CHARSET_INFO *charset);
// # 138 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*end_result_metadata)(void *ctx, uint server_status,
                             uint warn_count);
// # 150 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*start_row)(void *ctx);
// # 161 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*end_row)(void *ctx);
// # 177 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  void (*abort_row)(void *ctx);
// # 186 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  ulong (*get_client_capabilities)(void *ctx);
// # 198 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_null)(void * ctx);
// # 213 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_integer)(void * ctx, longlong value);
// # 226 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_longlong)(void * ctx, longlong value, uint is_unsigned);
// # 238 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_decimal)(void * ctx, const decimal_t * value);
// # 254 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_double)(void * ctx, double value, uint32_t decimals);
// # 266 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_date)(void * ctx, const MYSQL_TIME * value);
// # 279 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_time)(void * ctx, const MYSQL_TIME * value, uint decimals);
// # 292 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_datetime)(void * ctx, const MYSQL_TIME * value, uint decimals);
// # 314 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  int (*get_string)(void * ctx, const char * value, size_t length,
                    const CHARSET_INFO * valuecs);
// # 329 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  void (*handle_ok)(void * ctx,
                    uint server_status, uint statement_warn_count,
                    ulonglong affected_rows, ulonglong last_insert_id,
                    const char * message);
// # 342 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  void (*handle_error)(void * ctx, uint sql_errno, const char * err_msg,
                       const char * sqlstate);
// # 352 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
  void (*shutdown)(void *ctx, int server_shutdown);
};

enum cs_text_or_binary
{
  CS_TEXT_REPRESENTATION= 1,
  CS_BINARY_REPRESENTATION= 2,
};

extern struct command_service_st {
  int (*run_command)(MYSQL_SESSION session,
                     enum enum_server_command command,
                     const union COM_DATA * data,
                     const CHARSET_INFO * client_cs,
                     const struct st_command_service_cbs * callbacks,
                     enum cs_text_or_binary text_or_binary,
                     void * service_callbacks_ctx);
} *command_service;
// # 433 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_command.h"
}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2




extern "C" {


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_snprintf.h" 1
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_alloc.h" 1
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_alloc.h"
class THD;






extern "C" {




extern struct thd_alloc_service_st {
  void *(*thd_alloc_func)(THD*, size_t);
  void *(*thd_calloc_func)(THD*, size_t);
  char *(*thd_strdup_func)(THD*, const char *);
  char *(*thd_strmake_func)(THD*, const char *, size_t);
  void *(*thd_memdup_func)(THD*, const void*, size_t);
  MYSQL_LEX_STRING *(*thd_make_lex_string_func)(THD*, MYSQL_LEX_STRING *,
                                        const char *, size_t, int);
} *thd_alloc_service;
// # 127 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_alloc.h"
}
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_wait.h" 1
// # 50 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_wait.h"
class THD;






extern "C" {
// # 77 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_wait.h"
typedef enum _thd_wait_type_e {
  THD_WAIT_SLEEP= 1,
  THD_WAIT_DISKIO= 2,
  THD_WAIT_ROW_LOCK= 3,
  THD_WAIT_GLOBAL_LOCK= 4,
  THD_WAIT_META_DATA_LOCK= 5,
  THD_WAIT_TABLE_LOCK= 6,
  THD_WAIT_USER_LOCK= 7,
  THD_WAIT_BINLOG= 8,
  THD_WAIT_GROUP_COMMIT= 9,
  THD_WAIT_SYNC= 10,
  THD_WAIT_LAST= 11
} thd_wait_type;

extern struct thd_wait_service_st {
  void (*thd_wait_begin_func)(THD*, int);
  void (*thd_wait_end_func)(THD*);
} *thd_wait_service;
// # 110 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thd_wait.h"
}
// # 38 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thread_scheduler.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thread_scheduler.h"
extern "C" {


struct Connection_handler_functions;
struct THD_event_functions;

extern struct my_thread_scheduler_service {
  int (*connection_handler_set)(struct Connection_handler_functions *,
                                struct THD_event_functions *);
  int (*connection_handler_reset)();
} *my_thread_scheduler_service;
// # 82 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_thread_scheduler.h"
}
// # 39 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_plugin_log.h" 1
// # 31 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_plugin_log.h"
enum plugin_log_level
{
  MY_ERROR_LEVEL,
  MY_WARNING_LEVEL,
  MY_INFORMATION_LEVEL
};



extern "C" {


extern struct my_plugin_log_service
{

  int (*my_plugin_log_message)(MYSQL_PLUGIN *, enum plugin_log_level, const char *, ...);
} *my_plugin_log_service;
// # 61 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_my_plugin_log.h"
}
// # 40 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_string.h" 1
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_string.h"
extern "C" {


typedef void *mysql_string_iterator_handle;
typedef void *mysql_string_handle;

extern struct mysql_string_service_st {
  int (*mysql_string_convert_to_char_ptr_type)
       (mysql_string_handle, const char *, char *, unsigned int, int *);
  mysql_string_iterator_handle (*mysql_string_get_iterator_type)
                                (mysql_string_handle);
  int (*mysql_string_iterator_next_type)(mysql_string_iterator_handle);
  int (*mysql_string_iterator_isupper_type)(mysql_string_iterator_handle);
  int (*mysql_string_iterator_islower_type)(mysql_string_iterator_handle);
  int (*mysql_string_iterator_isdigit_type)(mysql_string_iterator_handle);
  mysql_string_handle (*mysql_string_to_lowercase_type)(mysql_string_handle);
  void (*mysql_string_free_type)(mysql_string_handle);
  void (*mysql_string_iterator_free_type)(mysql_string_iterator_handle);
} *mysql_string_service;
// # 130 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_string.h"
}
// # 41 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_alloc.h" 1
// # 42 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_password_policy.h" 1
// # 40 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_password_policy.h"
extern "C" {


extern struct mysql_password_policy_service_st {
  int (*my_validate_password_policy_func)(const char *, unsigned int);
  int (*my_calculate_password_strength_func)(const char *, unsigned int);
} *mysql_password_policy_service;
// # 63 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_password_policy.h"
}
// # 43 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_md5_size.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h" 2







class THD;
class Item;

typedef Item* MYSQL_ITEM;






extern "C" {
// # 52 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
typedef
int (*parse_node_visit_function)(MYSQL_ITEM item, unsigned char* arg);


typedef
int (*sql_condition_handler_function)(int sql_errno,
                                      const char* sqlstate,
                                      const char* msg,
                                      void *state);

struct st_my_thread_handle;

extern struct mysql_parser_service_st {

  THD* (*mysql_current_session)();

  THD* (*mysql_open_session)();

  void (*mysql_start_thread)(THD* thd, void *(*callback_fun)(void*),
                             void *arg,
                             struct st_my_thread_handle *thread_handle);

  void (*mysql_join_thread)(struct st_my_thread_handle *thread_handle);

  void (*mysql_set_current_database)(THD* thd, const MYSQL_LEX_STRING db);
// # 99 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  int (*mysql_parse)(THD* thd, const MYSQL_LEX_STRING query,
                     unsigned char is_prepared,
                     sql_condition_handler_function handle_condition,
                     void *condition_handler_state);

  int (*mysql_get_statement_type)(THD* thd);
// # 117 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  int (*mysql_get_statement_digest)(THD* thd, unsigned char *digest);
// # 128 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  int (*mysql_get_number_params)(THD* thd);
// # 145 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  int (*mysql_extract_prepared_params)(THD* thd, int *positions);
// # 158 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  int (*mysql_visit_tree)(THD* thd, parse_node_visit_function processor,
                          unsigned char* arg);
// # 173 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  MYSQL_LEX_STRING (*mysql_item_string)(MYSQL_ITEM item);







  void (*mysql_free_string)(MYSQL_LEX_STRING string);
// # 192 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  MYSQL_LEX_STRING (*mysql_get_query)(THD* thd);
// # 203 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
  MYSQL_LEX_STRING (*mysql_get_normalized_query)(THD* thd);
} *mysql_parser_service;
// # 283 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_parser.h"
}
// # 44 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_ctx.h" 1
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_ctx.h"
extern "C" {


struct st_transaction_termination_ctx
{
  unsigned long m_thread_id;
  unsigned int m_flags;






  char m_rollback_transaction;






  char m_generated_gtid;
  int m_sidno;
  long long int m_gno;
};
typedef struct st_transaction_termination_ctx Transaction_termination_ctx;

extern struct rpl_transaction_ctx_service_st {
  int (*set_transaction_ctx)(Transaction_termination_ctx transaction_termination_ctx);
} *rpl_transaction_ctx_service;
// # 77 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_ctx.h"
}
// # 45 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_write_set.h" 1
// # 45 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_write_set.h"
extern "C" {






struct st_trans_write_set
{
  unsigned int m_flags;
  unsigned long write_set_size;
  unsigned long long* write_set;
};
typedef struct st_trans_write_set Transaction_write_set;

extern struct transaction_write_set_service_st {
  Transaction_write_set* (*get_transaction_write_set)(unsigned long m_thread_id);
} *transaction_write_set_service;
// # 76 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rpl_transaction_write_set.h"
}
// # 46 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_security_context.h" 1
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_security_context.h"
class Security_context;




typedef char my_svc_bool;


extern "C" {


extern struct security_context_service_st {
  my_svc_bool (*thd_get_security_context)(THD*, Security_context* *out_ctx);
  my_svc_bool (*thd_set_security_context)(THD*, Security_context* in_ctx);

  my_svc_bool (*security_context_create)(Security_context* *out_ctx);
  my_svc_bool (*security_context_destroy)(Security_context*);
  my_svc_bool (*security_context_copy)(Security_context* in_ctx, Security_context* *out_ctx);

  my_svc_bool (*security_context_lookup)(Security_context* ctx,
                                         const char *user, const char *host,
                                         const char *ip, const char *db);

  my_svc_bool (*security_context_get_option)(Security_context*, const char *name, void *inout_pvalue);
  my_svc_bool (*security_context_set_option)(Security_context*, const char *name, void *pvalue);
} *security_context_service;
// # 92 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_security_context.h"
}
// # 47 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_locking.h" 1
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_locking.h"
class THD;






extern "C" {







enum enum_locking_service_lock_type
{ LOCKING_SERVICE_READ, LOCKING_SERVICE_WRITE };

extern struct mysql_locking_service_st {
// # 69 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_locking.h"
  int (*mysql_acquire_locks)(THD* opaque_thd, const char* lock_namespace,
                             const char**lock_names, size_t lock_num,
                             enum enum_locking_service_lock_type lock_type,
                             unsigned long lock_timeout);
// # 84 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_locking.h"
  int (*mysql_release_locks)(THD* opaque_thd, const char* lock_namespace);
} *mysql_locking_service;
// # 111 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_locking.h"
}
// # 48 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_keyring.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_keyring.h"
extern "C" {


extern struct mysql_keyring_service_st
{
  int (*my_key_store_func)(const char *, const char *, const char *,
                           const void *, size_t);
  int (*my_key_fetch_func)(const char *, char **, const char *, void **,
                           size_t *);
  int (*my_key_remove_func)(const char *, const char *);
  int (*my_key_generate_func)(const char *, const char *, const char *,
                              size_t);
} *mysql_keyring_service;
// # 58 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_mysql_keyring.h"
}
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2


}



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 1 3
// # 36 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 3
       
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stringfwd.h" 1 3
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stringfwd.h" 3
       
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stringfwd.h" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/memoryfwd.h" 1 3
// # 46 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/memoryfwd.h" 3
       
// # 47 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

// # 63 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stringfwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;
// # 86 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stringfwd.h" 3

}
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 1 3
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 3
       
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 1 3
// # 60 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/functexcept.h" 1 3
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/functexcept.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/exception_defines.h" 1 3
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
// # 61 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 1 3
// # 35 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 3
       
// # 36 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 3
// # 68 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };
// # 198 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 3
  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_fundamental
    : public __traitor<__is_void<_Tp>, __is_arithmetic<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };
// # 421 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cpp_type_traits.h" 3

}
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/type_traits.h" 1 3
// # 32 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/type_traits.h" 3
       
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
// # 63 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/numeric_traits.h" 1 3
// # 32 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/numeric_traits.h" 3
       
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

// # 54 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
// # 99 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 64) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 18);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 4932);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
// # 64 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/move.h" 1 3
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/move.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/concept_check.h" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/concept_check.h" 3
       
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/concept_check.h" 3
// # 35 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r)
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}
// # 149 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 164 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)




    {

     

      _Tp __tmp = (__a);
      __a = (__b);
      __b = (__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])



    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
// # 60 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

// # 95 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      pair()
      : first(), second() { }


      pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }



      template<class _U1, class _U2>
 pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }
// # 209 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 3
    };


  template<class _T1, class _T2>
    inline bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }
// # 284 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    inline pair<_T1, _T2>
    make_pair(_T1 __x, _T2 __y)
    { return pair<_T1, _T2>(__x, __y); }





}
// # 65 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 1 3
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3
       
// # 63 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

// # 89 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
// # 116 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
// # 162 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3
  template<typename _Iterator>
    struct iterator_traits
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };



  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };
// # 232 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_types.h" 3

}
// # 66 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 1 3
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 3
       
// # 63 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/debug/debug.h" 1 3
// # 46 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
// # 66 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
// # 112 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
// # 171 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }
// # 202 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator_base_funcs.h" 3

}
// # 67 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 1 3
// # 67 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 95 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
// # 159 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
// # 289 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>







    inline typename reverse_iterator<_IteratorL>::difference_type
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)

    { return __y.base() - __x.base(); }
// # 401 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
// # 428 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_back(__value);
 return *this;
      }
// # 451 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
// # 477 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
// # 492 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
// # 518 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 container->push_front(__value);
 return *this;
      }
// # 541 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
// # 567 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
// # 586 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
// # 629 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(typename _Container::const_reference __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }
// # 655 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
// # 681 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

// # 705 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      __normal_iterator() : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i)
        : _M_current(__i.base()) { }


      reference
      operator*() const
      { return *_M_current; }

      pointer
      operator->() const
      { return _M_current; }

      __normal_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int)
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int)
      { return __normal_iterator(_M_current--); }


      reference
      operator[](const difference_type& __n) const
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(const difference_type& __n)
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(const difference_type& __n) const
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(const difference_type& __n)
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(const difference_type& __n) const
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const
      { return _M_current; }
    };
// # 803 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>







    inline typename __normal_iterator<_IteratorL, _Container>::difference_type
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)

    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}
// # 68 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{






  template<bool _BoolType>
    struct __iter_swap
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          typedef typename iterator_traits<_ForwardIterator1>::value_type
            _ValueType1;
          _ValueType1 __tmp = (*__a);
          *__a = (*__b);
          *__b = (__tmp);
 }
    };

  template<>
    struct __iter_swap<true>
    {
      template<typename _ForwardIterator1, typename _ForwardIterator2>
        static void
        iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
        {
          swap(*__a, *__b);
        }
    };
// # 117 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     



      typedef typename iterator_traits<_ForwardIterator1>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator2>::value_type
 _ValueType2;

     

     


      typedef typename iterator_traits<_ForwardIterator1>::reference
 _ReferenceType1;
      typedef typename iterator_traits<_ForwardIterator2>::reference
 _ReferenceType2;
      std::__iter_swap<__are_same<_ValueType1, _ValueType2>::__value
 && __are_same<_ValueType1&, _ReferenceType1>::__value
 && __are_same<_ValueType2&, _ReferenceType2>::__value>::
 iter_swap(__a, __b);



    }
// # 163 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
// # 191 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
// # 214 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
// # 237 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
// # 258 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };
// # 325 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };
// # 363 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
// # 448 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
// # 500 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };
// # 528 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };
// # 558 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {
   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
// # 617 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
// # 675 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
// # 719 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
// # 779 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }


  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 typedef typename iterator_traits<_II1>::iterator_category _Category1;
 typedef typename iterator_traits<_II2>::iterator_category _Category2;
 typedef std::__lc_rai<_Category1, _Category2> __rai_type;

 __last1 = __rai_type::__newlast1(__first1, __last1,
      __first2, __last2);
 for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
      ++__first1, ++__first2)
   {
     if (*__first1 < *__first2)
       return true;
     if (*__first2 < *__first1)
       return false;
   }
 return __first1 == __last1 && __first2 != __last2;
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }
// # 941 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {




      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;


     
     
      ;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (*__middle < __val)
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }



  inline int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




// # 1019 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
// # 1051 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
// # 1082 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
// # 1118 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;


     
     
      ;
      ;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(*__first1, *__first2))
     return true;
   if (__comp(*__first2, *__first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }
// # 1158 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      while (__first1 != __last1 && *__first1 == *__first2)
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
// # 1195 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      while (__first1 != __last1 && bool(__binary_pred(*__first1, *__first2)))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }


}
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 1 3
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
       
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3




// # 1 "/usr/include/wchar.h" 1 3 4
// # 51 "/usr/include/wchar.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 353 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 3 4
typedef unsigned int wint_t;
// # 52 "/usr/include/wchar.h" 2 3 4
// # 104 "/usr/include/wchar.h" 3 4


typedef __mbstate_t mbstate_t;






// # 132 "/usr/include/wchar.h" 3 4
extern "C" {




struct tm;









extern wchar_t *wcscpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern wchar_t *wcscat (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();

extern wchar_t *wcsncat (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();


extern int wcscmp (const wchar_t *__s1, const wchar_t *__s2)
     throw () __attribute__ ((__pure__));

extern int wcsncmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));




extern int wcscasecmp (const wchar_t *__s1, const wchar_t *__s2) throw ();


extern int wcsncasecmp (const wchar_t *__s1, const wchar_t *__s2,
   size_t __n) throw ();





extern int wcscasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
    __locale_t __loc) throw ();

extern int wcsncasecmp_l (const wchar_t *__s1, const wchar_t *__s2,
     size_t __n, __locale_t __loc) throw ();





extern int wcscoll (const wchar_t *__s1, const wchar_t *__s2) throw ();



extern size_t wcsxfrm (wchar_t *__restrict __s1,
         const wchar_t *__restrict __s2, size_t __n) throw ();








extern int wcscoll_l (const wchar_t *__s1, const wchar_t *__s2,
        __locale_t __loc) throw ();




extern size_t wcsxfrm_l (wchar_t *__s1, const wchar_t *__s2,
    size_t __n, __locale_t __loc) throw ();


extern wchar_t *wcsdup (const wchar_t *__s) throw () __attribute__ ((__malloc__));





extern "C++" wchar_t *wcschr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcschr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcschr") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsrchr (wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsrchr (const wchar_t *__wcs, wchar_t __wc)
     throw () __asm ("wcsrchr") __attribute__ ((__pure__));









extern wchar_t *wcschrnul (const wchar_t *__s, wchar_t __wc)
     throw () __attribute__ ((__pure__));





extern size_t wcscspn (const wchar_t *__wcs, const wchar_t *__reject)
     throw () __attribute__ ((__pure__));


extern size_t wcsspn (const wchar_t *__wcs, const wchar_t *__accept)
     throw () __attribute__ ((__pure__));


extern "C++" wchar_t *wcspbrk (wchar_t *__wcs, const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcspbrk (const wchar_t *__wcs,
         const wchar_t *__accept)
     throw () __asm ("wcspbrk") __attribute__ ((__pure__));






extern "C++" wchar_t *wcsstr (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcsstr (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcsstr") __attribute__ ((__pure__));






extern wchar_t *wcstok (wchar_t *__restrict __s,
   const wchar_t *__restrict __delim,
   wchar_t **__restrict __ptr) throw ();


extern size_t wcslen (const wchar_t *__s) throw () __attribute__ ((__pure__));





extern "C++" wchar_t *wcswcs (wchar_t *__haystack, const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
extern "C++" const wchar_t *wcswcs (const wchar_t *__haystack,
        const wchar_t *__needle)
     throw () __asm ("wcswcs") __attribute__ ((__pure__));
// # 306 "/usr/include/wchar.h" 3 4
extern size_t wcsnlen (const wchar_t *__s, size_t __maxlen)
     throw () __attribute__ ((__pure__));






extern "C++" wchar_t *wmemchr (wchar_t *__s, wchar_t __c, size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));
extern "C++" const wchar_t *wmemchr (const wchar_t *__s, wchar_t __c,
         size_t __n)
     throw () __asm ("wmemchr") __attribute__ ((__pure__));






extern int wmemcmp (const wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw () __attribute__ ((__pure__));


extern wchar_t *wmemcpy (wchar_t *__restrict __s1,
    const wchar_t *__restrict __s2, size_t __n) throw ();



extern wchar_t *wmemmove (wchar_t *__s1, const wchar_t *__s2, size_t __n)
     throw ();


extern wchar_t *wmemset (wchar_t *__s, wchar_t __c, size_t __n) throw ();





extern wchar_t *wmempcpy (wchar_t *__restrict __s1,
     const wchar_t *__restrict __s2, size_t __n)
     throw ();






extern wint_t btowc (int __c) throw ();



extern int wctob (wint_t __c) throw ();



extern int mbsinit (const mbstate_t *__ps) throw () __attribute__ ((__pure__));



extern size_t mbrtowc (wchar_t *__restrict __pwc,
         const char *__restrict __s, size_t __n,
         mbstate_t *__restrict __p) throw ();


extern size_t wcrtomb (char *__restrict __s, wchar_t __wc,
         mbstate_t *__restrict __ps) throw ();


extern size_t __mbrlen (const char *__restrict __s, size_t __n,
   mbstate_t *__restrict __ps) throw ();
extern size_t mbrlen (const char *__restrict __s, size_t __n,
        mbstate_t *__restrict __ps) throw ();








extern wint_t __btowc_alias (int __c) __asm ("btowc");
extern __inline __attribute__ ((__gnu_inline__)) wint_t
__attribute__ ((__leaf__)) btowc (int __c) throw ()
{ return (__builtin_constant_p (__c) && __c >= '\0' && __c <= '\x7f'
   ? (wint_t) __c : __btowc_alias (__c)); }

extern int __wctob_alias (wint_t __c) __asm ("wctob");
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__leaf__)) wctob (wint_t __wc) throw ()
{ return (__builtin_constant_p (__wc) && __wc >= L'\0' && __wc <= L'\x7f'
   ? (int) __wc : __wctob_alias (__wc)); }

extern __inline __attribute__ ((__gnu_inline__)) size_t
__attribute__ ((__leaf__)) mbrlen (const char *__restrict __s, size_t __n, mbstate_t *__restrict __ps) throw ()

{ return (__ps != __null
   ? mbrtowc (__null, __s, __n, __ps) : __mbrlen (__s, __n, __null)); }





extern size_t mbsrtowcs (wchar_t *__restrict __dst,
    const char **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();



extern size_t wcsrtombs (char *__restrict __dst,
    const wchar_t **__restrict __src, size_t __len,
    mbstate_t *__restrict __ps) throw ();






extern size_t mbsnrtowcs (wchar_t *__restrict __dst,
     const char **__restrict __src, size_t __nmc,
     size_t __len, mbstate_t *__restrict __ps) throw ();



extern size_t wcsnrtombs (char *__restrict __dst,
     const wchar_t **__restrict __src,
     size_t __nwc, size_t __len,
     mbstate_t *__restrict __ps) throw ();






extern int wcwidth (wchar_t __c) throw ();



extern int wcswidth (const wchar_t *__s, size_t __n) throw ();






extern double wcstod (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr) throw ();





extern float wcstof (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();
extern long double wcstold (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr) throw ();







extern long int wcstol (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, int __base) throw ();



extern unsigned long int wcstoul (const wchar_t *__restrict __nptr,
      wchar_t **__restrict __endptr, int __base)
     throw ();






__extension__
extern long long int wcstoll (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstoull (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr,
     int __base) throw ();






__extension__
extern long long int wcstoq (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr, int __base)
     throw ();



__extension__
extern unsigned long long int wcstouq (const wchar_t *__restrict __nptr,
           wchar_t **__restrict __endptr,
           int __base) throw ();
// # 530 "/usr/include/wchar.h" 3 4
extern long int wcstol_l (const wchar_t *__restrict __nptr,
     wchar_t **__restrict __endptr, int __base,
     __locale_t __loc) throw ();

extern unsigned long int wcstoul_l (const wchar_t *__restrict __nptr,
        wchar_t **__restrict __endptr,
        int __base, __locale_t __loc) throw ();

__extension__
extern long long int wcstoll_l (const wchar_t *__restrict __nptr,
    wchar_t **__restrict __endptr,
    int __base, __locale_t __loc) throw ();

__extension__
extern unsigned long long int wcstoull_l (const wchar_t *__restrict __nptr,
       wchar_t **__restrict __endptr,
       int __base, __locale_t __loc)
     throw ();

extern double wcstod_l (const wchar_t *__restrict __nptr,
   wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern float wcstof_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr, __locale_t __loc)
     throw ();

extern long double wcstold_l (const wchar_t *__restrict __nptr,
         wchar_t **__restrict __endptr,
         __locale_t __loc) throw ();






extern wchar_t *wcpcpy (wchar_t *__restrict __dest,
   const wchar_t *__restrict __src) throw ();



extern wchar_t *wcpncpy (wchar_t *__restrict __dest,
    const wchar_t *__restrict __src, size_t __n)
     throw ();






extern __FILE *open_wmemstream (wchar_t **__bufloc, size_t *__sizeloc) throw ();






extern int fwide (__FILE *__fp, int __mode) throw ();






extern int fwprintf (__FILE *__restrict __stream,
       const wchar_t *__restrict __format, ...)
                                                           ;




extern int wprintf (const wchar_t *__restrict __format, ...)
                                                           ;

extern int swprintf (wchar_t *__restrict __s, size_t __n,
       const wchar_t *__restrict __format, ...)
     throw () ;





extern int vfwprintf (__FILE *__restrict __s,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
                                                           ;




extern int vwprintf (const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                           ;


extern int vswprintf (wchar_t *__restrict __s, size_t __n,
        const wchar_t *__restrict __format,
        __gnuc_va_list __arg)
     throw () ;






extern int fwscanf (__FILE *__restrict __stream,
      const wchar_t *__restrict __format, ...)
                                                          ;




extern int wscanf (const wchar_t *__restrict __format, ...)
                                                          ;

extern int swscanf (const wchar_t *__restrict __s,
      const wchar_t *__restrict __format, ...)
     throw () ;
// # 680 "/usr/include/wchar.h" 3 4









extern int vfwscanf (__FILE *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
                                                          ;




extern int vwscanf (const wchar_t *__restrict __format,
      __gnuc_va_list __arg)
                                                          ;

extern int vswscanf (const wchar_t *__restrict __s,
       const wchar_t *__restrict __format,
       __gnuc_va_list __arg)
     throw () ;
// # 736 "/usr/include/wchar.h" 3 4









extern wint_t fgetwc (__FILE *__stream);
extern wint_t getwc (__FILE *__stream);





extern wint_t getwchar (void);






extern wint_t fputwc (wchar_t __wc, __FILE *__stream);
extern wint_t putwc (wchar_t __wc, __FILE *__stream);





extern wint_t putwchar (wchar_t __wc);







extern wchar_t *fgetws (wchar_t *__restrict __ws, int __n,
   __FILE *__restrict __stream);





extern int fputws (const wchar_t *__restrict __ws,
     __FILE *__restrict __stream);






extern wint_t ungetwc (wint_t __wc, __FILE *__stream);

// # 801 "/usr/include/wchar.h" 3 4
extern wint_t getwc_unlocked (__FILE *__stream);
extern wint_t getwchar_unlocked (void);







extern wint_t fgetwc_unlocked (__FILE *__stream);







extern wint_t fputwc_unlocked (wchar_t __wc, __FILE *__stream);
// # 827 "/usr/include/wchar.h" 3 4
extern wint_t putwc_unlocked (wchar_t __wc, __FILE *__stream);
extern wint_t putwchar_unlocked (wchar_t __wc);
// # 837 "/usr/include/wchar.h" 3 4
extern wchar_t *fgetws_unlocked (wchar_t *__restrict __ws, int __n,
     __FILE *__restrict __stream);







extern int fputws_unlocked (const wchar_t *__restrict __ws,
       __FILE *__restrict __stream);







extern size_t wcsftime (wchar_t *__restrict __s, size_t __maxsize,
   const wchar_t *__restrict __format,
   const struct tm *__restrict __tp) throw ();







extern size_t wcsftime_l (wchar_t *__restrict __s, size_t __maxsize,
     const wchar_t *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) throw ();
// # 891 "/usr/include/wchar.h" 3 4
}
// # 45 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 2 3
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
// # 135 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;

  using ::vfwscanf;


  using ::vswprintf;


  using ::vswscanf;

  using ::vwprintf;

  using ::vwscanf;

  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;

  using ::wcstof;

  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;
// # 232 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3

}







namespace __gnu_cxx
{





  using ::wcstold;
// # 257 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3
  using ::wcstoll;
  using ::wcstoull;

}

namespace std
{
  using ::__gnu_cxx::wcstold;
  using ::__gnu_cxx::wcstoll;
  using ::__gnu_cxx::wcstoull;
}
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 2 3
// # 68 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 88 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
  typedef long streamoff;
// # 98 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
  typedef ptrdiff_t streamsize;
// # 111 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
// # 133 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;
// # 239 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/postypes.h" 3

}
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 3




// # 1 "/usr/include/wchar.h" 1 3 4
// # 45 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cwchar" 2 3
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

// # 57 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
// # 82 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

// # 226 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }



      static int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>(-1); }

      static int_type
      not_eof(const int_type& __c)
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static char_type
      to_char_type(const int_type& __c)
      { return char_type(__c); }

      static int_type
      to_int_type(const char_type& __c)
      { return int_type(__c); }

      static bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static int_type
      eof()
      { return static_cast<int_type>((0xffffffffu)); }

      static int_type
      not_eof(const int_type& __c)
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/allocator.h" 1 3
// # 46 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/allocator.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++allocator.h" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++allocator.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/new_allocator.h" 1 3
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/new_allocator.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
// # 57 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };







      new_allocator() throw() { }

      new_allocator(const new_allocator&) throw() { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) throw() { }

      ~new_allocator() throw() { }

      pointer
      address(reference __x) const
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }


      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }

      size_type
      max_size() const throw()
      { return size_t(-1) / sizeof(_Tp); }
// # 128 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/new_allocator.h" 3
      void
      construct(pointer __p, const _Tp& __val)
      { ::new((void *)__p) _Tp(__val); }

      void
      destroy(pointer __p) { __p->~_Tp(); }

    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++allocator.h" 2 3
// # 47 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/allocator.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };






    };
// # 91 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __gnu_cxx::new_allocator<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };







      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __gnu_cxx::new_allocator<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two)
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };
// # 218 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/allocator.h" 3

}
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 1 3
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 3
       
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++locale.h" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++locale.h" 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/clocale" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/clocale" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/clocale" 3


// # 1 "/usr/include/locale.h" 1 3 4
// # 29 "/usr/include/locale.h" 3 4
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 30 "/usr/include/locale.h" 2 3 4
// # 1 "/usr/include/bits/locale.h" 1 3 4
// # 31 "/usr/include/locale.h" 2 3 4

extern "C" {
// # 51 "/usr/include/locale.h" 3 4



struct lconv
{


  char *decimal_point;
  char *thousands_sep;





  char *grouping;





  char *int_curr_symbol;
  char *currency_symbol;
  char *mon_decimal_point;
  char *mon_thousands_sep;
  char *mon_grouping;
  char *positive_sign;
  char *negative_sign;
  char int_frac_digits;
  char frac_digits;

  char p_cs_precedes;

  char p_sep_by_space;

  char n_cs_precedes;

  char n_sep_by_space;






  char p_sign_posn;
  char n_sign_posn;


  char int_p_cs_precedes;

  char int_p_sep_by_space;

  char int_n_cs_precedes;

  char int_n_sep_by_space;






  char int_p_sign_posn;
  char int_n_sign_posn;
// # 121 "/usr/include/locale.h" 3 4
};



extern char *setlocale (int __category, const char *__locale) throw ();


extern struct lconv *localeconv (void) throw ();


// # 152 "/usr/include/locale.h" 3 4
extern __locale_t newlocale (int __category_mask, const char *__locale,
        __locale_t __base) throw ();
// # 187 "/usr/include/locale.h" 3 4
extern __locale_t duplocale (__locale_t __dataset) throw ();



extern void freelocale (__locale_t __dataset) throw ();






extern __locale_t uselocale (__locale_t __dataset) throw ();







}
// # 43 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/clocale" 2 3
// # 51 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++locale.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  extern "C" __typeof(uselocale) __uselocale;


}


namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef __locale_t __c_locale;





  inline int
  __convert_from_v(const __c_locale& __cloc __attribute__ ((__unused__)),
     char* __out,
     const int __size __attribute__ ((__unused__)),
     const char* __fmt, ...)
  {

    __c_locale __old = __gnu_cxx::__uselocale(__cloc);
// # 88 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/c++locale.h" 3
    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);


    const int __ret = __builtin_vsnprintf(__out, __size, __fmt, __args);




    __builtin_va_end(__args);


    __gnu_cxx::__uselocale(__old);







    return __ret;
  }


}
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/iosfwd" 1 3
// # 36 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/iosfwd" 3
       
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

// # 74 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cctype" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cctype" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cctype" 3


// # 1 "/usr/include/ctype.h" 1 3 4
// # 29 "/usr/include/ctype.h" 3 4
extern "C" {
// # 47 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
// # 80 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     throw () __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     throw () __attribute__ ((__const__));
// # 105 "/usr/include/ctype.h" 3 4






extern int isalnum (int) throw ();
extern int isalpha (int) throw ();
extern int iscntrl (int) throw ();
extern int isdigit (int) throw ();
extern int islower (int) throw ();
extern int isgraph (int) throw ();
extern int isprint (int) throw ();
extern int ispunct (int) throw ();
extern int isspace (int) throw ();
extern int isupper (int) throw ();
extern int isxdigit (int) throw ();



extern int tolower (int __c) throw ();


extern int toupper (int __c) throw ();








extern int isblank (int) throw ();






extern int isctype (int __c, int __mask) throw ();






extern int isascii (int __c) throw ();



extern int toascii (int __c) throw ();



extern int _toupper (int) throw ();
extern int _tolower (int) throw ();
// # 272 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) throw ();
extern int isalpha_l (int, __locale_t) throw ();
extern int iscntrl_l (int, __locale_t) throw ();
extern int isdigit_l (int, __locale_t) throw ();
extern int islower_l (int, __locale_t) throw ();
extern int isgraph_l (int, __locale_t) throw ();
extern int isprint_l (int, __locale_t) throw ();
extern int ispunct_l (int, __locale_t) throw ();
extern int isspace_l (int, __locale_t) throw ();
extern int isupper_l (int, __locale_t) throw ();
extern int isxdigit_l (int, __locale_t) throw ();

extern int isblank_l (int, __locale_t) throw ();



extern int __tolower_l (int __c, __locale_t __l) throw ();
extern int tolower_l (int __c, __locale_t __l) throw ();


extern int __toupper_l (int __c, __locale_t __l) throw ();
extern int toupper_l (int __c, __locale_t __l) throw ();
// # 348 "/usr/include/ctype.h" 3 4
}
// # 43 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cctype" 2 3
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}
// # 43 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

// # 55 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
// # 44 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/ostream_insert.h" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/ostream_insert.h" 3
       
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/ostream_insert.h" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cxxabi_forced.h" 1 3
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cxxabi_forced.h" 3
       
// # 35 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
// # 45 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3



// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 100 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
// # 139 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
// # 203 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
// # 267 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };




  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };
// # 350 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
// # 421 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }
// # 508 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
// # 541 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/binders.h" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 103 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } ;


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
// # 732 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_function.h" 2 3
// # 49 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/range_access.h" 1 3
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/range_access.h" 3
       
// # 34 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/range_access.h" 3
// # 52 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 1 3
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
       
// # 38 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 1 3
// # 32 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 3
       
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr.h" 1 3
// # 30 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr.h" 3
#pragma GCC visibility push(default)
// # 148 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 1 3
// # 47 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
// # 101 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_once) __gthrw_pthread_once __attribute__ ((__weakref__("pthread_once")));
static __typeof(pthread_getspecific) __gthrw_pthread_getspecific __attribute__ ((__weakref__("pthread_getspecific")));
static __typeof(pthread_setspecific) __gthrw_pthread_setspecific __attribute__ ((__weakref__("pthread_setspecific")));

static __typeof(pthread_create) __gthrw_pthread_create __attribute__ ((__weakref__("pthread_create")));
static __typeof(pthread_join) __gthrw_pthread_join __attribute__ ((__weakref__("pthread_join")));
static __typeof(pthread_equal) __gthrw_pthread_equal __attribute__ ((__weakref__("pthread_equal")));
static __typeof(pthread_self) __gthrw_pthread_self __attribute__ ((__weakref__("pthread_self")));
static __typeof(pthread_detach) __gthrw_pthread_detach __attribute__ ((__weakref__("pthread_detach")));

static __typeof(pthread_cancel) __gthrw_pthread_cancel __attribute__ ((__weakref__("pthread_cancel")));

static __typeof(sched_yield) __gthrw_sched_yield __attribute__ ((__weakref__("sched_yield")));

static __typeof(pthread_mutex_lock) __gthrw_pthread_mutex_lock __attribute__ ((__weakref__("pthread_mutex_lock")));
static __typeof(pthread_mutex_trylock) __gthrw_pthread_mutex_trylock __attribute__ ((__weakref__("pthread_mutex_trylock")));

static __typeof(pthread_mutex_timedlock) __gthrw_pthread_mutex_timedlock __attribute__ ((__weakref__("pthread_mutex_timedlock")));

static __typeof(pthread_mutex_unlock) __gthrw_pthread_mutex_unlock __attribute__ ((__weakref__("pthread_mutex_unlock")));
static __typeof(pthread_mutex_init) __gthrw_pthread_mutex_init __attribute__ ((__weakref__("pthread_mutex_init")));
static __typeof(pthread_mutex_destroy) __gthrw_pthread_mutex_destroy __attribute__ ((__weakref__("pthread_mutex_destroy")));

static __typeof(pthread_cond_init) __gthrw_pthread_cond_init __attribute__ ((__weakref__("pthread_cond_init")));
static __typeof(pthread_cond_broadcast) __gthrw_pthread_cond_broadcast __attribute__ ((__weakref__("pthread_cond_broadcast")));
static __typeof(pthread_cond_signal) __gthrw_pthread_cond_signal __attribute__ ((__weakref__("pthread_cond_signal")));
static __typeof(pthread_cond_wait) __gthrw_pthread_cond_wait __attribute__ ((__weakref__("pthread_cond_wait")));
static __typeof(pthread_cond_timedwait) __gthrw_pthread_cond_timedwait __attribute__ ((__weakref__("pthread_cond_timedwait")));
static __typeof(pthread_cond_destroy) __gthrw_pthread_cond_destroy __attribute__ ((__weakref__("pthread_cond_destroy")));

static __typeof(pthread_key_create) __gthrw_pthread_key_create __attribute__ ((__weakref__("pthread_key_create")));
static __typeof(pthread_key_delete) __gthrw_pthread_key_delete __attribute__ ((__weakref__("pthread_key_delete")));
static __typeof(pthread_mutexattr_init) __gthrw_pthread_mutexattr_init __attribute__ ((__weakref__("pthread_mutexattr_init")));
static __typeof(pthread_mutexattr_settype) __gthrw_pthread_mutexattr_settype __attribute__ ((__weakref__("pthread_mutexattr_settype")));
static __typeof(pthread_mutexattr_destroy) __gthrw_pthread_mutexattr_destroy __attribute__ ((__weakref__("pthread_mutexattr_destroy")));
// # 236 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static __typeof(pthread_key_create) __gthrw___pthread_key_create __attribute__ ((__weakref__("__pthread_key_create")));
// # 246 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  static void *const __gthread_active_ptr
    = __extension__ (void *) &__gthrw___pthread_key_create;
  return __gthread_active_ptr != 0;
}
// # 658 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return __gthrw_pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return __gthrw_pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return __gthrw_pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return __gthrw_pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return __gthrw_pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return __gthrw_sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return __gthrw_pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return __gthrw_pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return __gthrw_pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return __gthrw_pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return __gthrw_pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    __gthrw_pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_trylock (__mutex);
  else
    return 0;
}


static inline int
__gthread_mutex_timedlock (__gthread_mutex_t *__mutex,
      const __gthread_time_t *__abs_timeout)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_timedlock (__mutex, __abs_timeout);
  else
    return 0;
}


static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return __gthrw_pthread_mutex_unlock (__mutex);
  else
    return 0;
}
// # 807 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}


static inline int
__gthread_recursive_mutex_timedlock (__gthread_recursive_mutex_t *__mutex,
         const __gthread_time_t *__abs_timeout)
{
  return __gthread_mutex_timedlock (__mutex, __abs_timeout);
}


static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
// # 849 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return __gthrw_pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return __gthrw_pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return __gthrw_pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return __gthrw_pthread_cond_destroy (__cond);
}
// # 149 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/gthr.h" 2 3


#pragma GCC visibility pop
// # 36 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/atomic_word.h" 1 3
// # 32 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/x86_64-unknown-linux-gnu/bits/atomic_word.h" 3
typedef int _Atomic_word;
// # 37 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
// # 64 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

// # 111 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
// # 148 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
// # 173 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep()
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked()
        { this->_M_refcount = -1; }

        void
 _M_set_sharable()
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a)
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a)
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p)
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const
      { return iterator(_M_data()); }

      iterator
      _M_iend() const
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range((__s));
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n)
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c)
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2)
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep()
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
// # 483 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
// # 531 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string()
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
// # 564 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
// # 604 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(this->begin()); }
// # 710 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
    public:



      size_type
      size() const
      { return _M_rep()->_M_length; }



      size_type
      length() const
      { return _M_rep()->_M_length; }


      size_type
      max_size() const
      { return _Rep::_S_max_size; }
// # 739 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
// # 752 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }
// # 775 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      capacity() const
      { return _M_rep()->_M_capacity; }
// # 796 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);




      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const
      { return this->size() == 0; }
// # 825 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const
      {
 ;
 return _M_data()[__pos];
      }
// # 842 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {

 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
// # 863 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("basic_string::at"));
 return _M_data()[__n];
      }
// # 882 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range(("basic_string::at"));
 _M_leak();
 return _M_data()[__n];
      }
// # 931 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }
// # 972 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str);
// # 988 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
// # 1020 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);
// # 1042 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
// # 1099 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
// # 1115 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
// # 1127 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
// # 1143 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
// # 1155 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }
// # 1184 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
// # 1200 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
// # 1232 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
// # 1254 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
// # 1277 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
// # 1295 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
// # 1318 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
// # 1336 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
// # 1361 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
// # 1377 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
// # 1397 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);
// # 1428 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
// # 1450 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
// # 1475 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
// # 1495 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
// # 1519 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
// # 1537 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
// # 1556 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
// # 1577 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
// # 1598 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
// # 1621 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
// # 1697 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
// # 1779 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
// # 1789 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
// # 1799 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      const _CharT*
      c_str() const
      { return _M_data(); }







      const _CharT*
      data() const
      { return _M_data(); }




      allocator_type
      get_allocator() const
      { return _M_dataplus; }
// # 1832 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
// # 1845 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const

      { return this->find(__str.data(), __pos, __str.size()); }
// # 1860 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
// # 1877 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const ;
// # 1890 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const

      { return this->rfind(__str.data(), __pos, __str.size()); }
// # 1907 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
// # 1920 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
// # 1937 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const ;
// # 1951 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_of(__str.data(), __pos, __str.size()); }
// # 1968 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
// # 1981 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
// # 2000 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const
      { return this->find(__c, __pos); }
// # 2015 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_of(__str.data(), __pos, __str.size()); }
// # 2032 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
// # 2045 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
// # 2064 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const
      { return this->rfind(__c, __pos); }
// # 2078 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const

      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
// # 2095 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
// # 2109 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
// # 2126 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 ;
// # 2141 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const

      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
// # 2158 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
// # 2172 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
// # 2189 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 ;
// # 2205 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
// # 2224 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
// # 2256 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
// # 2282 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
// # 2300 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
// # 2324 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
// # 2351 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
// # 2363 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }
// # 2484 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
// # 2530 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
// # 2567 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
// # 2604 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
// # 2641 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
// # 2678 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
// # 2715 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
// # 2733 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
// # 2751 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
// # 2774 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
// # 2791 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return getline(__is, __str, __is.widen('\n')); }

  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
// # 53 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.tcc" 1 3
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.tcc" 3
       
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }
// # 240 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.tcc" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
// # 577 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
// # 54 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/string" 2 3
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h" 2
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h"
class THD;
struct TABLE_LIST;
class Field;

namespace rules_table_service
{






int dummy_function_to_ensure_we_are_linked_into_the_server();






void free_string(const char *str);






class Cursor
{
public:
  typedef int column_id;

  static const column_id ILLEGAL_COLUMN_ID= -1;





  explicit Cursor(THD *thd);


  Cursor() :
    m_thd(__null), m_table_list(__null), m_is_finished(true)
  {}

  column_id pattern_column() const { return m_pattern_column; }
  column_id pattern_database_column() const
  {
    return m_pattern_database_column;
  }
  column_id replacement_column() const { return m_replacement_column; }
  column_id enabled_column() const { return m_enabled_column; }
  column_id message_column() const { return m_message_column; }
  column_id pattern_digest_column() const { return m_pattern_digest_column; }
  column_id normalized_pattern_column() const {
    return m_normalized_pattern_column;
  }






  bool table_is_malformed() { return m_table_is_malformed; }
// # 112 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h"
  const char *fetch_string(int fieldno);





  bool operator== (const Cursor &other)
  {
    return (m_is_finished == other.m_is_finished);
  }





  bool operator!= (const Cursor &other) { return !(*this == other); }





  Cursor &operator++ ()
  {
    if (!m_is_finished)
      read();
    return *this;
  }


  void make_writeable();
// # 150 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/service_rules_table.h"
  void set(int colno, const char* str, size_t length);


  int write();


  bool had_serious_read_error() const;


  ~Cursor();

private:
  int field_index(const char *field_name);

  int m_pattern_column;
  int m_pattern_database_column;
  int m_replacement_column;
  int m_enabled_column;
  int m_message_column;
  int m_pattern_digest_column;
  int m_normalized_pattern_column;

  THD *m_thd;
  TABLE_LIST *m_table_list;

  bool m_is_finished;
  bool m_table_is_malformed;
  int m_last_read_status;

  int read();
};






Cursor end();

}
// # 56 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/services.h" 2
// # 60 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h" 2
// # 71 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_xid {
  long formatID;
  long gtrid_length;
  long bqual_length;
  char data[128];
};
typedef struct st_mysql_xid MYSQL_XID;
// # 140 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
enum enum_mysql_show_type
{
  SHOW_UNDEF, SHOW_BOOL,
  SHOW_INT,
  SHOW_LONG,
  SHOW_LONGLONG,
  SHOW_CHAR, SHOW_CHAR_PTR,
  SHOW_ARRAY, SHOW_FUNC, SHOW_DOUBLE







};





enum enum_mysql_show_scope
{
  SHOW_SCOPE_UNDEF,
  SHOW_SCOPE_GLOBAL






};




struct st_mysql_show_var
{
  const char *name;
  char *value;
  enum enum_mysql_show_type type;
  enum enum_mysql_show_scope scope;
};



typedef int (*mysql_show_var_func)(THD*, struct st_mysql_show_var*, char *);
// # 221 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_sys_var;
struct st_mysql_value;
// # 243 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
typedef int (*mysql_var_check_func)(THD* thd,
                                    struct st_mysql_sys_var *var,
                                    void *save, struct st_mysql_value *value);
// # 261 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
typedef void (*mysql_var_update_func)(THD* thd,
                                      struct st_mysql_sys_var *var,
                                      void *var_ptr, const void *save);
// # 468 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_plugin
{
  int type;
  void *info;
  const char *name;
  const char *author;
  const char *descr;
  int license;
  int (*init)(MYSQL_PLUGIN);
  int (*deinit)(MYSQL_PLUGIN);
  unsigned int version;
  struct st_mysql_show_var *status_vars;
  struct st_mysql_sys_var **system_vars;
  void * __reserved1;
  unsigned long flags;
};
// # 509 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_daemon
{
  int interface_version;
};
// # 527 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_information_schema
{
  int interface_version;
};
// # 546 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_storage_engine
{
  int interface_version;
};

struct handlerton;
// # 562 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
 struct Mysql_replication {
   int interface_version;
 };
// # 580 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
struct st_mysql_value
{
  int (*value_type)(struct st_mysql_value *);
  const char *(*val_str)(struct st_mysql_value *, char *buffer, int *length);
  int (*val_real)(struct st_mysql_value *, double *realbuf);
  int (*val_int)(struct st_mysql_value *, long long *intbuf);
  int (*is_unsigned)(struct st_mysql_value *);
};







extern "C" {


int thd_in_lock_tables(const THD* thd);
int thd_tablespace_op(const THD* thd);
long long thd_test_options(const THD* thd, long long test_options);
int thd_sql_command(const THD* thd);
const char *set_thd_proc_info(THD* thd, const char *info,
                              const char *calling_func,
                              const char *calling_file,
                              const unsigned int calling_line);
void **thd_ha_data(const THD* thd, const struct handlerton *hton);
void thd_storage_lock_wait(THD* thd, long long value);
int thd_tx_isolation(const THD* thd);
int thd_tx_is_read_only(const THD* thd);
THD* thd_tx_arbitrate(THD* requestor, THD* holder);
int thd_tx_priority(const THD* thd);
int thd_tx_is_dd_trx(const THD* thd);
char *thd_security_context(THD* thd, char *buffer, size_t length,
                           size_t max_query_len);

void thd_inc_row_count(THD* thd);
int thd_allow_batch(THD* thd);
// # 628 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
void thd_mark_transaction_to_rollback(THD* thd, int all);
// # 642 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
int mysql_tmpfile(const char *prefix);
// # 658 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
int thd_killed(const THD* thd);






void thd_set_kill_status(const THD* thd);
// # 678 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
void thd_binlog_pos(const THD* thd,
                    const char **file_var,
                    unsigned long long *pos_var);







unsigned long thd_get_thread_id(const THD* thd);







void thd_get_xid(const THD* thd, MYSQL_XID *xid);
// # 706 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
void mysql_query_cache_invalidate4(THD* thd,
                                   const char *key, unsigned int key_length,
                                   int using_trx);





void *thd_get_ha_data(const THD* thd, const struct handlerton *hton);
// # 738 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin.h"
void thd_set_ha_data(THD* thd, const struct handlerton *hton,
                     const void *ha_data);

}
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h" 2







struct st_mysql_keyring
{
  int interface_version;
// # 52 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h"
  my_bool (*mysql_key_store)(const char *key_id, const char *key_type,
                             const char* user_id, const void *key, size_t key_len);
// # 73 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h"
  my_bool (*mysql_key_fetch)(const char *key_id, char **key_type,
                             const char *user_id, void **key, size_t *key_len);
// # 89 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h"
  my_bool (*mysql_key_remove)(const char *key_id, const char *user_id);
// # 106 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/mysql/plugin_keyring.h"
  my_bool (*mysql_key_generate)(const char *key_id, const char *key_type,
                                const char *user_id, size_t key_len);
};
// # 18 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_rnd.h" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_rnd.h"
extern "C" {


double my_rnd_ssl(struct rand_struct *rand_st);
int my_rand_buffer(unsigned char *buffer, size_t buffer_size);


}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_bitmap.h" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_bitmap.h"
typedef uint32 my_bitmap_map;

typedef struct st_bitmap
{
  my_bitmap_map *bitmap;
  uint n_bits;
  my_bitmap_map last_word_mask;
  my_bitmap_map *last_word_ptr;





  mysql_mutex_t *mutex;
} MY_BITMAP;


extern "C" {

extern void create_last_word_mask(MY_BITMAP *map);
extern my_bool bitmap_init(MY_BITMAP *map, my_bitmap_map *buf, uint n_bits,
                           my_bool thread_safe);
extern my_bool bitmap_is_clear_all(const MY_BITMAP *map);
extern my_bool bitmap_is_prefix(const MY_BITMAP *map, uint prefix_size);
extern my_bool bitmap_is_set_all(const MY_BITMAP *map);
extern my_bool bitmap_is_subset(const MY_BITMAP *map1, const MY_BITMAP *map2);
extern my_bool bitmap_is_overlapping(const MY_BITMAP *map1,
                                     const MY_BITMAP *map2);
extern my_bool bitmap_test_and_set(MY_BITMAP *map, uint bitmap_bit);
extern my_bool bitmap_test_and_clear(MY_BITMAP *map, uint bitmap_bit);
extern my_bool bitmap_fast_test_and_set(MY_BITMAP *map, uint bitmap_bit);
extern uint bitmap_set_next(MY_BITMAP *map);
extern uint bitmap_get_first(const MY_BITMAP *map);
extern uint bitmap_get_first_set(const MY_BITMAP *map);
extern uint bitmap_get_next_set(const MY_BITMAP *map, uint bitmap_bit);
extern uint bitmap_bits_set(const MY_BITMAP *map);
extern void bitmap_free(MY_BITMAP *map);
extern void bitmap_set_above(MY_BITMAP *map, uint from_byte, uint use_bit);
extern void bitmap_set_prefix(MY_BITMAP *map, uint prefix_size);
extern void bitmap_intersect(MY_BITMAP *map, const MY_BITMAP *map2);
extern void bitmap_subtract(MY_BITMAP *map, const MY_BITMAP *map2);
extern void bitmap_union(MY_BITMAP *map, const MY_BITMAP *map2);
extern void bitmap_xor(MY_BITMAP *map, const MY_BITMAP *map2);
extern void bitmap_invert(MY_BITMAP *map);
extern void bitmap_copy(MY_BITMAP *map, const MY_BITMAP *map2);

extern uint bitmap_lock_set_next(MY_BITMAP *map);
extern void bitmap_lock_clear_bit(MY_BITMAP *map, uint bitmap_bit);





static inline void bitmap_set_bit(MY_BITMAP *map, uint bit)
{
  do { } while(0);
  ((uchar*)map->bitmap)[bit / 8] |= (1 << (bit & 7));
}


static inline void bitmap_flip_bit(MY_BITMAP *map, uint bit)
{
  do { } while(0);
  ((uchar*)map->bitmap)[bit / 8] ^= (1 << (bit & 7));
}


static inline void bitmap_clear_bit(MY_BITMAP *map, uint bit)
{
  do { } while(0);
  ((uchar*)map->bitmap)[bit / 8] &= ~(1 << (bit & 7));
}


static inline my_bool bitmap_is_set(const MY_BITMAP *map, uint bit)
{
  do { } while(0);
  return ((uchar*)map->bitmap)[bit / 8] & (1 << (bit & 7));
}
// # 113 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_bitmap.h"
static inline my_bool bitmap_cmp(const MY_BITMAP *map1, const MY_BITMAP *map2)
{
  do { } while(0);
  do { } while(0);

  if (memcmp(map1->bitmap, map2->bitmap, 4*((((map1)->n_bits + 31)/32)-1)) != 0)
    return (0);
  return ((*map1->last_word_ptr | map1->last_word_mask) ==
          (*map2->last_word_ptr | map2->last_word_mask));
}




static inline void bitmap_clear_all(MY_BITMAP *map)
{
  memset(map->bitmap, 0, 4 * (((map)->n_bits + 31)/32));
}




static inline void bitmap_set_all(MY_BITMAP *map)
{
  memset(map->bitmap, 0xFF, 4 * (((map)->n_bits + 31)/32));
}


}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h" 1
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
extern "C" {

}

class String;
typedef struct st_mysql_time MYSQL_TIME;
// # 75 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
inline uint my_decimal_size(uint precision, uint scale)
{




  return decimal_size(precision, scale) + 1;
}


inline int my_decimal_int_part(uint precision, uint decimals)
{
  return precision - ((decimals == 31) ? 0 : decimals);
}
// # 99 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
class my_decimal :public decimal_t
{
// # 111 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
  decimal_digit_t buffer[9];






public:

  my_decimal(const my_decimal &rhs) : decimal_t(rhs)
  {
    rhs.sanity_check();




    for (uint i= 0; i < 9; i++)
      buffer[i]= rhs.buffer[i];
    buf= buffer;
  }

  my_decimal& operator=(const my_decimal &rhs)
  {
    sanity_check();
    rhs.sanity_check();
    if (this == &rhs)
      return *this;
    decimal_t::operator=(rhs);
    for (uint i= 0; i < 9; i++)
      buffer[i]= rhs.buffer[i];
    buf= buffer;
    return *this;
  }

  void init()
  {
// # 155 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
    len= 9;
    buf= buffer;
  }

  my_decimal()
  {
    init();
  }
  ~my_decimal()
  {
    sanity_check();
  }

  void sanity_check() const
  {
    do { } while(0);
    do { } while(0);
    do { } while(0);
  }

  bool sign() const { return decimal_t::sign; }
  void sign(bool s) { decimal_t::sign= s; }
  uint precision() const { return intg + frac; }


  void swap(my_decimal &rhs)
  {
    { my_decimal dummy; dummy= *this; *this= rhs; rhs= dummy; };
  }


  int check_result(uint mask, int result) const





  ;
};
// # 204 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
bool str_set_decimal(uint mask, const my_decimal *val, uint fixed_prec,
                     uint fixed_dec, char filler, String *str,
                     const CHARSET_INFO *cs);

extern my_decimal decimal_zero;


inline
void max_my_decimal(my_decimal *to, int precision, int frac)
{
  do { } while(0)
                                          ;
  max_decimal(precision, frac, to);
}

inline void max_internal_decimal(my_decimal *to)
{
  max_my_decimal(to, ((9 * 9) - 8*2), 0);
}

inline int check_result_and_overflow(uint mask, int result, my_decimal *val)
{
  if (val->check_result(mask, result) & 2)
  {
    bool sign= val->sign();
    val->sanity_check();
    max_internal_decimal(val);
    val->sign(sign);
  }




  if (result != 4 && val->sign() && decimal_is_zero(val))
    val->sign(false);
  return result;
}

inline uint my_decimal_length_to_precision(uint length, uint scale,
                                           bool unsigned_flag)
{

  do { } while(0);
  uint retval= (uint) (length - (scale>0 ? 1:0) -
                 (unsigned_flag || !length ? 0:1));
  return retval;
}

inline uint32 my_decimal_precision_to_length_no_truncation(uint precision,
                                                           uint8 scale,
                                                           bool unsigned_flag)
{




  do { } while(0);
  uint32 retval= (uint32)(precision + (scale > 0 ? 1 : 0) +
                  (unsigned_flag || !precision ? 0 : 1));
  return retval;
}

inline uint32 my_decimal_precision_to_length(uint precision, uint8 scale,
                                             bool unsigned_flag)
{




  do { } while(0);
  do { if ((precision) > (((9 * 9) - 8*2))) (precision)=(((9 * 9) - 8*2)); } while(0);
  return my_decimal_precision_to_length_no_truncation(precision, scale,
                                                      unsigned_flag);
}

inline
int my_decimal_string_length(const my_decimal *d)
{

  return (((d)->intg ? (d)->intg : 1) + (d)->frac + ((d)->frac > 0) + 2);
}


inline
int my_decimal_max_length(const my_decimal *d)
{

  return (((d)->intg ? (d)->intg : 1) + (d)->frac + ((d)->frac > 0) + 2) - 1;
}


inline
int my_decimal_get_binary_size(uint precision, uint scale)
{
  return decimal_bin_size((int)precision, (int)scale);
}


inline
void my_decimal2decimal(const my_decimal *from, my_decimal *to)
{
  *to= *from;
}


int my_decimal2binary(uint mask, const my_decimal *d, uchar *bin, int prec,
        int scale);


inline
int binary2my_decimal(uint mask, const uchar *bin, my_decimal *d, int prec,
        int scale)
{
  return d->check_result(mask, bin2decimal(bin, d, prec, scale));
}


inline
int my_decimal_set_zero(my_decimal *d)
{





  do { (static_cast<decimal_t*>(d))->buf[0]=0; (static_cast<decimal_t*>(d))->intg=1; (static_cast<decimal_t*>(d))->frac=0; (static_cast<decimal_t*>(d))->sign=0; } while(0);
  return 0;
}


inline
bool my_decimal_is_zero(const my_decimal *decimal_value)
{
  return decimal_is_zero(decimal_value);
}


inline
int my_decimal_round(uint mask, const my_decimal *from, int scale,
                     bool truncate, my_decimal *to)
{
  return
    from->check_result(mask, decimal_round(from, to, scale,
                                           (truncate ? TRUNCATE : HALF_UP)));
}


inline
int my_decimal_floor(uint mask, const my_decimal *from, my_decimal *to)
{
  return from->check_result(mask, decimal_round(from, to, 0, FLOOR));
}


inline
int my_decimal_ceiling(uint mask, const my_decimal *from, my_decimal *to)
{
  return from->check_result(mask, decimal_round(from, to, 0, CEILING));
}


inline bool str_set_decimal(const my_decimal *val, String *str,
                            const CHARSET_INFO *cs)
{
  return str_set_decimal(30, val, 0, 0, 0, str, cs);
}


class String;
int my_decimal2string(uint mask, const my_decimal *d, uint fixed_prec,
        uint fixed_dec, char filler, String *str);


inline
int my_decimal2int(uint mask, const my_decimal *d, my_bool unsigned_flag,
     longlong *l)
{
  my_decimal rounded;

  decimal_round(d, &rounded, 0, HALF_UP);
  return d->check_result(mask, (unsigned_flag ?
                                decimal2ulonglong(&rounded, (ulonglong *)l) :
                                decimal2longlong(&rounded, l)));
}


inline
int my_decimal2double(uint, const my_decimal *d, double *result)
{

  return decimal2double(d, result);
}


inline int my_decimal2lldiv_t(uint mask, const my_decimal *d, lldiv_t *to)
{
  return d->check_result(mask, decimal2lldiv_t(d, to));
}


inline int str2my_decimal(uint mask, const char *str,
                          my_decimal *d, char **end)
{
  return check_result_and_overflow(mask, internal_str2dec((str), (d), (end), 0), d);
}


int str2my_decimal(uint mask, const char *from, size_t length,
                   const CHARSET_INFO *charset, my_decimal *decimal_value);
// # 428 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/my_decimal.h"
inline
int double2my_decimal(uint mask, double val, my_decimal *d)
{
  return check_result_and_overflow(mask, double2decimal(val, d), d);
}


inline
int int2my_decimal(uint mask, longlong i, my_bool unsigned_flag, my_decimal *d)
{
  return d->check_result(mask, (unsigned_flag ?
                                ulonglong2decimal((ulonglong)i, d) :
                                longlong2decimal(i, d)));
}


inline
void my_decimal_neg(decimal_t *arg)
{

  if (decimal_is_zero(arg))
  {
    arg->sign= 0;
    return;
  }
  arg->sign^= 1;
}


inline
int my_decimal_add(uint mask, my_decimal *res, const my_decimal *a,
     const my_decimal *b)
{
  return check_result_and_overflow(mask,
                                   decimal_add(a, b, res),
                                   res);
}


inline
int my_decimal_sub(uint mask, my_decimal *res, const my_decimal *a,
     const my_decimal *b)
{
  return check_result_and_overflow(mask,
                                   decimal_sub(a, b, res),
                                   res);
}


inline
int my_decimal_mul(uint mask, my_decimal *res, const my_decimal *a,
     const my_decimal *b)
{
  return check_result_and_overflow(mask,
                                   decimal_mul(a, b, res),
                                   res);
}


inline
int my_decimal_div(uint mask, my_decimal *res, const my_decimal *a,
     const my_decimal *b, int div_scale_inc)
{
  return check_result_and_overflow(mask,
                                   decimal_div(a, b, res, div_scale_inc),
                                   res);
}


inline
int my_decimal_mod(uint mask, my_decimal *res, const my_decimal *a,
     const my_decimal *b)
{
  return check_result_and_overflow(mask,
                                   decimal_mod(a, b, res),
                                   res);
}






inline
int my_decimal_cmp(const my_decimal *a, const my_decimal *b)
{
  return decimal_cmp(a, b);
}

inline
bool operator<(const my_decimal &lhs, const my_decimal &rhs)
{
  return my_decimal_cmp(&lhs, &rhs) < 0;
}

inline
bool operator!=(const my_decimal &lhs, const my_decimal &rhs)
{
  return my_decimal_cmp(&lhs, &rhs) != 0;
}

inline
int my_decimal_intg(const my_decimal *a)
{
  return decimal_intg(a);
}


void my_decimal_trim(ulong *precision, uint *scale);
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_atomic.h" 1
// # 60 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_atomic.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/atomic/gcc_sync.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/atomic/gcc_sync.h"
static inline int my_atomic_cas32(int32 volatile *a, int32 *cmp, int32 set)
{
  int32 cmp_val= *cmp;
  int32 sav= __sync_val_compare_and_swap(a, cmp_val, set);
  int ret= (sav == cmp_val);
  if (!ret)
    *cmp = sav;
  return ret;
}

static inline int my_atomic_cas64(int64 volatile *a, int64 *cmp, int64 set)
{
  int64 cmp_val= *cmp;
  int64 sav= __sync_val_compare_and_swap(a, cmp_val, set);
  int ret= (sav == cmp_val);
  if (!ret)
    *cmp = sav;
  return ret;
}

static inline int my_atomic_casptr(void * volatile *a, void **cmp, void *set)
{
  void *cmp_val= *cmp;
  void *sav= __sync_val_compare_and_swap(a, cmp_val, set);
  int ret= (sav == cmp_val);
  if (!ret)
    *cmp = sav;
  return ret;
}

static inline int32 my_atomic_add32(int32 volatile *a, int32 v)
{
  return __sync_fetch_and_add(a, v);
}

static inline int64 my_atomic_add64(int64 volatile *a, int64 v)
{
  return __sync_fetch_and_add(a, v);
}

static inline int32 my_atomic_fas32(int32 volatile *a, int32 v)
{
  return __sync_lock_test_and_set(a, v);
}

static inline int64 my_atomic_fas64(int64 volatile *a, int64 v)
{
  return __sync_lock_test_and_set(a, v);
}

static inline void * my_atomic_fasptr(void * volatile *a, void * v)
{
  return __sync_lock_test_and_set(a, v);
}

static inline int32 my_atomic_load32(int32 volatile *a)
{
  return __sync_fetch_and_or(a, 0);
}

static inline int64 my_atomic_load64(int64 volatile *a)
{
  return __sync_fetch_and_or(a, 0);
}

static inline void* my_atomic_loadptr(void * volatile *a)
{
  return __sync_fetch_and_or(a, 0);
}

static inline void my_atomic_store32(int32 volatile *a, int32 v)
{
  (void) __sync_lock_test_and_set(a, v);
}

static inline void my_atomic_store64(int64 volatile *a, int64 v)
{
  (void) __sync_lock_test_and_set(a, v);
}

static inline void my_atomic_storeptr(void * volatile *a, void *v)
{
  (void) __sync_lock_test_and_set(a, v);
}
// # 61 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_atomic.h" 2
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sqlcommand.h" 1
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sqlcommand.h"
enum enum_sql_command {
  SQLCOM_SELECT,
  SQLCOM_CREATE_TABLE,
  SQLCOM_CREATE_INDEX,
  SQLCOM_ALTER_TABLE,
  SQLCOM_UPDATE,
  SQLCOM_INSERT,
  SQLCOM_INSERT_SELECT,
  SQLCOM_DELETE,
  SQLCOM_TRUNCATE,
  SQLCOM_DROP_TABLE,
  SQLCOM_DROP_INDEX,
  SQLCOM_SHOW_DATABASES,
  SQLCOM_SHOW_TABLES,
  SQLCOM_SHOW_FIELDS,
  SQLCOM_SHOW_KEYS,
  SQLCOM_SHOW_VARIABLES,
  SQLCOM_SHOW_STATUS,
  SQLCOM_SHOW_ENGINE_LOGS,
  SQLCOM_SHOW_ENGINE_STATUS,
  SQLCOM_SHOW_ENGINE_MUTEX,
  SQLCOM_SHOW_PROCESSLIST,
  SQLCOM_SHOW_MASTER_STAT,
  SQLCOM_SHOW_SLAVE_STAT,
  SQLCOM_SHOW_GRANTS,
  SQLCOM_SHOW_CREATE,
  SQLCOM_SHOW_CHARSETS,
  SQLCOM_SHOW_COLLATIONS,
  SQLCOM_SHOW_CREATE_DB,
  SQLCOM_SHOW_TABLE_STATUS,
  SQLCOM_SHOW_TRIGGERS,
  SQLCOM_LOAD,
  SQLCOM_SET_OPTION,
  SQLCOM_LOCK_TABLES,
  SQLCOM_UNLOCK_TABLES,
  SQLCOM_GRANT,
  SQLCOM_CHANGE_DB,
  SQLCOM_CREATE_DB,
  SQLCOM_DROP_DB,
  SQLCOM_ALTER_DB,
  SQLCOM_REPAIR,
  SQLCOM_REPLACE,
  SQLCOM_REPLACE_SELECT,
  SQLCOM_CREATE_FUNCTION,
  SQLCOM_DROP_FUNCTION,
  SQLCOM_REVOKE,
  SQLCOM_OPTIMIZE,
  SQLCOM_CHECK,
  SQLCOM_ASSIGN_TO_KEYCACHE,
  SQLCOM_PRELOAD_KEYS,
  SQLCOM_FLUSH,
  SQLCOM_KILL,
  SQLCOM_ANALYZE,
  SQLCOM_ROLLBACK,
  SQLCOM_ROLLBACK_TO_SAVEPOINT,
  SQLCOM_COMMIT,
  SQLCOM_SAVEPOINT,
  SQLCOM_RELEASE_SAVEPOINT,
  SQLCOM_SLAVE_START,
  SQLCOM_SLAVE_STOP,
  SQLCOM_START_GROUP_REPLICATION,
  SQLCOM_STOP_GROUP_REPLICATION,
  SQLCOM_BEGIN,
  SQLCOM_CHANGE_MASTER,
  SQLCOM_CHANGE_REPLICATION_FILTER,
  SQLCOM_RENAME_TABLE,
  SQLCOM_RESET,
  SQLCOM_PURGE,
  SQLCOM_PURGE_BEFORE,
  SQLCOM_SHOW_BINLOGS,
  SQLCOM_SHOW_OPEN_TABLES,
  SQLCOM_HA_OPEN,
  SQLCOM_HA_CLOSE,
  SQLCOM_HA_READ,
  SQLCOM_SHOW_SLAVE_HOSTS,
  SQLCOM_DELETE_MULTI,
  SQLCOM_UPDATE_MULTI,
  SQLCOM_SHOW_BINLOG_EVENTS,
  SQLCOM_DO,
  SQLCOM_SHOW_WARNS,
  SQLCOM_EMPTY_QUERY,
  SQLCOM_SHOW_ERRORS,
  SQLCOM_SHOW_STORAGE_ENGINES,
  SQLCOM_SHOW_PRIVILEGES,
  SQLCOM_HELP,
  SQLCOM_CREATE_USER,
  SQLCOM_DROP_USER,
  SQLCOM_RENAME_USER,
  SQLCOM_REVOKE_ALL,
  SQLCOM_CHECKSUM,
  SQLCOM_CREATE_PROCEDURE,
  SQLCOM_CREATE_SPFUNCTION,
  SQLCOM_CALL,
  SQLCOM_DROP_PROCEDURE,
  SQLCOM_ALTER_PROCEDURE,
  SQLCOM_ALTER_FUNCTION,
  SQLCOM_SHOW_CREATE_PROC,
  SQLCOM_SHOW_CREATE_FUNC,
  SQLCOM_SHOW_STATUS_PROC,
  SQLCOM_SHOW_STATUS_FUNC,
  SQLCOM_PREPARE,
  SQLCOM_EXECUTE,
  SQLCOM_DEALLOCATE_PREPARE,
  SQLCOM_CREATE_VIEW,
  SQLCOM_DROP_VIEW,
  SQLCOM_CREATE_TRIGGER,
  SQLCOM_DROP_TRIGGER,
  SQLCOM_XA_START,
  SQLCOM_XA_END,
  SQLCOM_XA_PREPARE,
  SQLCOM_XA_COMMIT,
  SQLCOM_XA_ROLLBACK,
  SQLCOM_XA_RECOVER,
  SQLCOM_SHOW_PROC_CODE,
  SQLCOM_SHOW_FUNC_CODE,
  SQLCOM_ALTER_TABLESPACE,
  SQLCOM_INSTALL_PLUGIN,
  SQLCOM_UNINSTALL_PLUGIN,
  SQLCOM_BINLOG_BASE64_EVENT,
  SQLCOM_SHOW_PLUGINS,
  SQLCOM_CREATE_SERVER,
  SQLCOM_DROP_SERVER,
  SQLCOM_ALTER_SERVER,
  SQLCOM_CREATE_EVENT,
  SQLCOM_ALTER_EVENT,
  SQLCOM_DROP_EVENT,
  SQLCOM_SHOW_CREATE_EVENT,
  SQLCOM_SHOW_EVENTS,
  SQLCOM_SHOW_CREATE_TRIGGER,
  SQLCOM_ALTER_DB_UPGRADE,
  SQLCOM_SHOW_PROFILE,
  SQLCOM_SHOW_PROFILES,
  SQLCOM_SIGNAL,
  SQLCOM_RESIGNAL,
  SQLCOM_SHOW_RELAYLOG_EVENTS,
  SQLCOM_GET_DIAGNOSTICS,
  SQLCOM_ALTER_USER,
  SQLCOM_EXPLAIN_OTHER,
  SQLCOM_SHOW_CREATE_USER,
  SQLCOM_SHUTDOWN,
  SQLCOM_ALTER_INSTANCE,

  SQLCOM_END
};
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_alloc.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_alloc.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/thr_malloc.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/thr_malloc.h"
typedef struct charset_info_st CHARSET_INFO;
typedef struct st_mem_root MEM_ROOT;
typedef unsigned int PSI_memory_key;

void init_sql_alloc(PSI_memory_key key,
                    MEM_ROOT *root, size_t block_size, size_t pre_alloc_size);

void *sql_alloc(size_t);
void *sql_calloc(size_t);
char *sql_strdup(const char *str);
char *sql_strmake(const char *str, size_t len);
void *sql_memdup(const void * ptr, size_t size);
char *sql_strmake_with_convert(const char *str, size_t arg_length,
          const CHARSET_INFO *from_cs,
          size_t max_res_length,
          const CHARSET_INFO *to_cs, size_t *result_length);
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_alloc.h" 2





class Sql_alloc
{
public:
  static void *operator new(size_t size) throw ()
  {
    return sql_alloc(size);
  }
  static void *operator new[](size_t size) throw ()
  {
    return sql_alloc(size);
  }
  static void *operator new[](size_t size, MEM_ROOT *mem_root) throw ()
  { return alloc_root(mem_root, size); }
  static void *operator new(size_t size, MEM_ROOT *mem_root) throw ()
  { return alloc_root(mem_root, size); }
  static void operator delete(void *ptr, size_t size) { do {} while(0); }
  static void operator delete(void *ptr, MEM_ROOT *mem_root)
  { }
  static void operator delete[](void *ptr, MEM_ROOT *mem_root)
  { }
  static void operator delete[](void *ptr, size_t size) { do {} while(0); }

  inline Sql_alloc() {}
  inline ~Sql_alloc() {}
};
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h" 2
class THD;
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h"
class Sql_cmd : public Sql_alloc
{
private:
  Sql_cmd(const Sql_cmd &);
  void operator=(Sql_cmd &);

public:



  virtual enum_sql_command sql_command_code() const = 0;







  virtual bool execute(THD *thd) = 0;
// # 78 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_cmd.h"
  virtual void cleanup(THD *thd) {}

protected:
  Sql_cmd()
  {}

  virtual ~Sql_cmd()
  {






    do { } while(0);
  }
};
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 2


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/atomic_class.h" 1
// # 113 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/atomic_class.h"
class Atomic_int32 { public: Atomic_int32(int32 n= 0) { my_atomic_store32(&value, n); } int32 atomic_get() { return my_atomic_load32(&value); } void atomic_set(int32 n) { my_atomic_store32(&value, n); } int32 atomic_add(int32 n) { return my_atomic_add32(&value, n); } int32 atomic_get_and_set(int32 n) { return my_atomic_fas32(&value, n); } bool atomic_compare_and_swap(int32 *old, int32 n) { return my_atomic_cas32(&value, old, n); } int32 non_atomic_get() { return value; } void non_atomic_set(int32 n) { value= n; } int32 non_atomic_add(int32 n) { int32 ret= value; value+= n; return ret; } bool atomic_set_to_max(int32 n, int32 *guess= __null) { int32 _guess; if (guess == __null) { _guess= n - 1; guess= &_guess; } else do { } while(0); bool ret; do { ret= atomic_compare_and_swap(guess, n); } while (!ret && *guess < n); return ret; } private: int32 value; };
class Atomic_int64 { public: Atomic_int64(int64 n= 0) { my_atomic_store64(&value, n); } int64 atomic_get() { return my_atomic_load64(&value); } void atomic_set(int64 n) { my_atomic_store64(&value, n); } int64 atomic_add(int64 n) { return my_atomic_add64(&value, n); } int64 atomic_get_and_set(int64 n) { return my_atomic_fas64(&value, n); } bool atomic_compare_and_swap(int64 *old, int64 n) { return my_atomic_cas64(&value, old, n); } int64 non_atomic_get() { return value; } void non_atomic_set(int64 n) { value= n; } int64 non_atomic_add(int64 n) { int64 ret= value; value+= n; return ret; } bool atomic_set_to_max(int64 n, int64 *guess= __null) { int64 _guess; if (guess == __null) { _guess= n - 1; guess= &_guess; } else do { } while(0); bool ret; do { ret= atomic_compare_and_swap(guess, n); } while (!ret && *guess < n); return ret; } private: int64 value; };
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h" 2

class THD;
struct handlerton;
class Time_zone;
template <uint default_width> class Bitmap;

typedef struct st_mysql_const_lex_string LEX_CSTRING;
typedef struct st_mysql_show_var SHOW_VAR;
// # 48 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h"
typedef Bitmap<64> key_map;
// # 84 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h"
void kill_mysql(void);

void refresh_status(THD *thd);
bool is_secure_file_path(char *path);
int handle_early_options();
void adjust_related_options(ulong *requested_open_files);
ulong sql_rnd_with_mutex();


void set_remaining_args(int argc, char **argv);
int init_common_variables();
void my_init_signals();
bool gtid_server_init();
void gtid_server_cleanup();
const char *fixup_enforce_gtid_consistency_command_line(char *value_arg);

extern "C" CHARSET_INFO *system_charset_info;
extern CHARSET_INFO *files_charset_info ;
extern CHARSET_INFO *national_charset_info;
extern CHARSET_INFO *table_alias_charset;

enum enum_server_operational_state
{
  SERVER_BOOTING,
  SERVER_OPERATING,
  SERVER_SHUTTING_DOWN
};
enum_server_operational_state get_server_state();




extern CHARSET_INFO *error_message_charset_info;

extern CHARSET_INFO *character_set_filesystem;

extern MY_BITMAP temp_pool;
extern bool opt_large_files, server_id_supplied;
extern bool opt_update_log, opt_bin_log;
extern my_bool opt_log_slave_updates;
extern my_bool opt_log_unsafe_statements;
extern bool opt_general_log, opt_slow_log, opt_general_log_raw;
extern my_bool opt_backup_history_log;
extern my_bool opt_backup_progress_log;
extern ulonglong log_output_options;
extern ulong log_backup_output_options;
extern my_bool opt_log_queries_not_using_indexes;
extern ulong opt_log_throttle_queries_not_using_indexes;
extern bool opt_disable_networking, opt_skip_show_db;
extern bool opt_skip_name_resolve;
extern my_bool opt_help;
extern my_bool opt_verbose;
extern bool opt_ignore_builtin_innodb;
extern my_bool opt_character_set_client_handshake;
extern bool volatile abort_loop;
extern my_bool opt_bootstrap, opt_initialize;
extern my_bool opt_safe_user_create;
extern my_bool opt_safe_show_db, opt_local_infile, opt_myisam_use_mmap;
extern my_bool opt_slave_compressed_protocol, use_temp_pool;
extern ulong slave_exec_mode_options;
extern ulonglong slave_type_conversions_options;
extern my_bool read_only, opt_readonly;
extern my_bool super_read_only, opt_super_readonly;
extern my_bool lower_case_file_system;
extern ulonglong slave_rows_search_algorithms_options;
extern my_bool opt_require_secure_transport;
// # 158 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h"
extern ulong mts_parallel_option;
extern my_bool opt_enable_named_pipe, opt_sync_frm, opt_allow_suspicious_udfs;
extern my_bool opt_secure_auth;
extern char* opt_secure_file_priv;
extern char* opt_secure_backup_file_priv;
extern size_t opt_secure_backup_file_priv_len;
extern my_bool opt_log_slow_admin_statements, opt_log_slow_slave_statements;
extern my_bool sp_automatic_privileges, opt_noacl;
extern my_bool opt_old_style_user_limits, trust_function_creators;
extern my_bool check_proxy_users, mysql_native_password_proxy_users, sha256_password_proxy_users;
extern uint opt_crash_binlog_innodb;
extern char *shared_memory_base_name, *mysqld_unix_port;
extern my_bool opt_enable_shared_memory;
extern char *default_tz_name;
extern Time_zone *default_tz;
extern char *default_storage_engine;
extern char *default_tmp_storage_engine;
extern ulong internal_tmp_disk_storage_engine;
extern bool opt_endinfo, using_udf_functions;
extern my_bool locked_in_memory;
extern bool opt_using_transactions;
extern ulong max_long_data_size;
extern ulong current_pid;
extern ulong expire_logs_days;
extern my_bool relay_log_recovery;
extern uint sync_binlog_period, sync_relaylog_period,
            sync_relayloginfo_period, sync_masterinfo_period,
            opt_mts_checkpoint_period, opt_mts_checkpoint_group;
extern ulong opt_tc_log_size, tc_log_max_pages_used, tc_log_page_size;
extern ulong tc_log_page_waits;
extern my_bool relay_log_purge, opt_innodb_safe_binlog, opt_innodb;
extern my_bool relay_log_recovery;
extern my_bool offline_mode;
extern my_bool opt_log_builtin_as_identified_by_password;
extern uint test_flags,select_errors,ha_open_options;
extern uint protocol_version, mysqld_port, dropping_tables;
extern ulong delay_key_write_options;
extern ulong opt_log_timestamps;
extern const char *timestamp_type_names[];
extern char *opt_general_logname, *opt_slow_logname, *opt_bin_logname,
            *opt_relay_logname;
extern char *opt_backup_history_logname, *opt_backup_progress_logname,
            *opt_backup_settings_name;
extern const char *log_output_str;
extern const char *log_backup_output_str;
extern char *mysql_home_ptr, *pidfile_name_ptr;
extern char *default_auth_plugin;
extern uint default_password_lifetime;
extern char *my_bind_addr_str;
extern char glob_hostname[512], mysql_home[512];
extern char pidfile_name[512], system_time_zone[30], *opt_init_file;
extern char default_logfile_name[512];
extern char *opt_tc_log_file;


extern char server_uuid[(8+1+4+1+4+1+4+1+12)+1];
extern const char *server_uuid_ptr;
extern const double log_10[309];
extern ulonglong keybuff_size;
extern ulonglong thd_startup_options;
extern ulong binlog_cache_use, binlog_cache_disk_use;
extern ulong binlog_stmt_cache_use, binlog_stmt_cache_disk_use;
extern ulong aborted_threads;
extern ulong delayed_insert_timeout;
extern ulong delayed_insert_limit, delayed_queue_size;
extern ulong delayed_insert_threads, delayed_insert_writes;
extern ulong delayed_rows_in_use,delayed_insert_errors;
extern Atomic_int32 slave_open_temp_tables;
extern ulong query_cache_size, query_cache_min_res_unit;
extern ulong slow_launch_time;
extern ulong table_cache_size, table_def_size;
extern ulong table_cache_size_per_instance, table_cache_instances;
extern ulong max_connections;
extern ulong max_digest_length;
extern ulong max_connect_errors, connect_timeout;
extern my_bool opt_slave_allow_batching;
extern my_bool allow_slave_start;
extern LEX_CSTRING reason_slave_blocked;
extern ulong slave_trans_retries;
extern uint slave_net_timeout;
extern ulong opt_mts_slave_parallel_workers;
extern ulonglong opt_mts_pending_jobs_size_max;
extern uint max_user_connections;
extern ulong rpl_stop_slave_timeout;
extern my_bool log_bin_use_v1_row_events;
extern ulong what_to_log,flush_time;
extern ulong max_prepared_stmt_count, prepared_stmt_count;
extern ulong open_files_limit;
extern ulong binlog_cache_size, binlog_stmt_cache_size;
extern ulonglong max_binlog_cache_size, max_binlog_stmt_cache_size;
extern int32 opt_binlog_max_flush_queue_time;
extern ulong opt_binlog_group_commit_sync_delay;
extern ulong opt_binlog_group_commit_sync_no_delay_count;
extern ulong max_binlog_size, max_relay_log_size;
extern ulong slave_max_allowed_packet;
extern ulong opt_binlog_rows_event_max_size;
extern ulong binlog_checksum_options;
extern const char *binlog_checksum_type_names[];
extern my_bool opt_master_verify_checksum;
extern my_bool opt_slave_sql_verify_checksum;
extern uint32 gtid_executed_compression_period;
extern my_bool binlog_gtid_simple_recovery;
extern ulong binlog_error_action;
extern ulong locked_account_connection_count;
enum enum_binlog_error_action
{

  IGNORE_ERROR= 0,

  ABORT_SERVER= 1
};
extern const char *binlog_error_action_list[];

extern ulong stored_program_cache_size;
extern ulong back_log;
extern char language[512];
extern "C" ulong server_id;
extern time_t server_start_time, flush_status_time;
extern char *opt_mysql_tmpdir, mysql_charsets_dir[];
extern size_t mysql_unpacked_real_data_home_len;
extern MY_TMPDIR mysql_tmpdir_list;
extern const char *show_comp_option_name[];
extern const char *first_keyword, *binary_keyword;
extern const char *my_localhost;
extern const char *myisam_recover_options_str;
extern const char *in_left_expr_name, *in_additional_cond, *in_having_cond;
extern SHOW_VAR status_vars[];
extern struct system_variables max_system_variables;
extern struct system_status_var global_status_var;
extern struct rand_struct sql_rand;
extern const char *opt_date_time_formats[];
extern handlerton *myisam_hton;
extern handlerton *heap_hton;
extern handlerton *innodb_hton;
extern uint opt_server_id_bits;
extern ulong opt_server_id_mask;





extern const char *load_default_groups[];
extern struct my_option my_long_options[];
extern struct my_option my_long_early_options[];
extern bool mysqld_server_started;
extern "C" int orig_argc;
extern "C" char **orig_argv;
extern my_thread_attr_t connection_attrib;
extern my_bool old_mode;
extern my_bool avoid_temporal_upgrade;
extern LEX_STRING opt_init_connect, opt_init_slave;
extern char err_shared_dir[];
extern my_decimal decimal_zero;

extern ulong connection_errors_internal;
extern ulong connection_errors_peer_addr;

extern ulong log_warnings;
extern bool opt_log_syslog_enable;
extern char *opt_log_syslog_tag;

extern bool opt_log_syslog_include_pid;
extern char *opt_log_syslog_facility;


extern uint host_cache_size;
extern ulong log_error_verbosity;


extern my_bool show_compatibility_56;






extern LEX_CSTRING sql_statement_names[(uint) SQLCOM_END + 1];





extern thread_local_key_t THR_MALLOC;
extern bool THR_MALLOC_initialized;

static inline MEM_ROOT ** my_thread_get_THR_MALLOC()
{
  do { } while(0);
  return (MEM_ROOT**) my_get_thread_local(THR_MALLOC);
}

static inline int my_thread_set_THR_MALLOC(MEM_ROOT ** hdl)
{
  do { } while(0);
  return my_set_thread_local(THR_MALLOC, hdl);
}





extern thread_local_key_t THR_THD;
extern bool THR_THD_initialized;

static inline THD * my_thread_get_THR_THD()
{
  do { } while(0);
  return (THD*)my_get_thread_local(THR_THD);
}

static inline int my_thread_set_THR_THD(THD *thd)
{
  do { } while(0);
  return my_set_thread_local(THR_THD, thd);
}



extern "C" {

extern PSI_mutex_key key_LOCK_tc;


extern PSI_mutex_key key_LOCK_des_key_file;


extern PSI_mutex_key key_BINLOG_LOCK_commit;
extern PSI_mutex_key key_BINLOG_LOCK_commit_queue;
extern PSI_mutex_key key_BINLOG_LOCK_done;
extern PSI_mutex_key key_BINLOG_LOCK_flush_queue;
extern PSI_mutex_key key_BINLOG_LOCK_index;
extern PSI_mutex_key key_BINLOG_LOCK_log;
extern PSI_mutex_key key_BINLOG_LOCK_binlog_end_pos;
extern PSI_mutex_key key_BINLOG_LOCK_sync;
extern PSI_mutex_key key_BINLOG_LOCK_sync_queue;
extern PSI_mutex_key key_BINLOG_LOCK_xids;
extern PSI_mutex_key
  key_hash_filo_lock,
  key_LOCK_crypt, key_LOCK_error_log,
  key_LOCK_gdl, key_LOCK_global_system_variables,
  key_LOCK_lock_db, key_LOCK_logger, key_LOCK_manager,
  key_LOCK_prepared_stmt_count,
  key_LOCK_server_started, key_LOCK_status,
  key_LOCK_sql_slave_skip_counter,
  key_LOCK_slave_net_timeout,
  key_LOCK_table_share, key_LOCK_thd_data, key_LOCK_thd_sysvar,
  key_LOCK_user_conn, key_LOCK_uuid_generator, key_LOG_LOCK_log,
  key_master_info_data_lock, key_master_info_run_lock,
  key_master_info_sleep_lock, key_master_info_thd_lock,
  key_mutex_slave_reporting_capability_err_lock, key_relay_log_info_data_lock,
  key_relay_log_info_sleep_lock, key_relay_log_info_thd_lock,
  key_relay_log_info_log_space_lock, key_relay_log_info_run_lock,
  key_mutex_slave_parallel_pend_jobs, key_mutex_mts_temp_tables_lock,
  key_mutex_slave_parallel_worker,
  key_mutex_slave_parallel_worker_count,
  key_structure_guard_mutex, key_TABLE_SHARE_LOCK_ha_data,
  key_LOCK_error_messages,
  key_LOCK_log_throttle_qni, key_LOCK_query_plan, key_LOCK_thd_query,
  key_LOCK_cost_const, key_LOCK_current_cond;
extern PSI_mutex_key key_RELAYLOG_LOCK_commit;
extern PSI_mutex_key key_RELAYLOG_LOCK_commit_queue;
extern PSI_mutex_key key_RELAYLOG_LOCK_done;
extern PSI_mutex_key key_RELAYLOG_LOCK_flush_queue;
extern PSI_mutex_key key_RELAYLOG_LOCK_index;
extern PSI_mutex_key key_RELAYLOG_LOCK_log;
extern PSI_mutex_key key_RELAYLOG_LOCK_sync;
extern PSI_mutex_key key_RELAYLOG_LOCK_sync_queue;
extern PSI_mutex_key key_RELAYLOG_LOCK_xids;
extern PSI_mutex_key key_LOCK_sql_rand;
extern PSI_mutex_key key_gtid_ensure_index_mutex;
extern PSI_mutex_key key_mts_temp_table_LOCK;
extern PSI_mutex_key key_LOCK_reset_gtid_table;
extern PSI_mutex_key key_LOCK_compress_gtid_table;
extern PSI_mutex_key key_mts_gaq_LOCK;
extern PSI_mutex_key key_thd_timer_mutex;
extern PSI_mutex_key key_LOCK_offline_mode;
extern PSI_mutex_key key_LOCK_default_password_lifetime;
extern PSI_mutex_key key_LOCK_group_replication_handler;






extern PSI_rwlock_key key_rwlock_LOCK_grant, key_rwlock_LOCK_logger,
  key_rwlock_LOCK_sys_init_connect, key_rwlock_LOCK_sys_init_slave,
  key_rwlock_LOCK_system_variables_hash, key_rwlock_query_cache_query_lock,
  key_rwlock_global_sid_lock, key_rwlock_gtid_mode_lock,
  key_rwlock_channel_map_lock, key_rwlock_channel_lock;

extern PSI_cond_key key_PAGE_cond, key_COND_active, key_COND_pool;
extern PSI_cond_key key_BINLOG_update_cond,
  key_COND_cache_status_changed, key_COND_manager,
  key_COND_server_started,
  key_item_func_sleep_cond, key_master_info_data_cond,
  key_master_info_start_cond, key_master_info_stop_cond,
  key_master_info_sleep_cond,
  key_relay_log_info_data_cond, key_relay_log_info_log_space_cond,
  key_relay_log_info_start_cond, key_relay_log_info_stop_cond,
  key_relay_log_info_sleep_cond, key_cond_slave_parallel_pend_jobs,
  key_cond_slave_parallel_worker, key_cond_mts_gaq,
  key_TABLE_SHARE_cond, key_user_level_lock_cond;
extern PSI_cond_key key_BINLOG_COND_done;
extern PSI_cond_key key_RELAYLOG_COND_done;
extern PSI_cond_key key_RELAYLOG_update_cond;
extern PSI_cond_key key_BINLOG_prep_xids_cond;
extern PSI_cond_key key_RELAYLOG_prep_xids_cond;
extern PSI_cond_key key_gtid_ensure_index_cond;
extern PSI_cond_key key_COND_compress_gtid_table;
extern PSI_cond_key key_COND_thr_lock;





extern PSI_thread_key key_thread_bootstrap,
  key_thread_handle_manager, key_thread_main,
  key_thread_one_connection, key_thread_signal_hand,
  key_thread_compress_gtid_table, key_thread_parser_service;
extern PSI_thread_key key_thread_timer_notifier;

extern PSI_file_key key_file_map;
extern PSI_file_key key_file_binlog, key_file_binlog_cache,
  key_file_binlog_index, key_file_binlog_index_cache, key_file_casetest,
  key_file_dbopt, key_file_des_key_file, key_file_ERRMSG, key_select_to_file,
  key_file_fileparser, key_file_frm, key_file_global_ddl_log, key_file_load,
  key_file_loadfile, key_file_log_event_data, key_file_log_event_info,
  key_file_master_info, key_file_misc, key_file_partition_ddl_log,
  key_file_pid, key_file_relay_log_info, key_file_send_file, key_file_tclog,
  key_file_trg, key_file_trn, key_file_init;
extern PSI_file_key key_file_general_log, key_file_slow_log;
extern PSI_file_key key_file_relaylog, key_file_relaylog_cache, key_file_relaylog_index, key_file_relaylog_index_cache;
extern PSI_socket_key key_socket_tcpip, key_socket_unix, key_socket_client_connection;

void init_server_psi_keys();

}



extern "C" {

extern PSI_memory_key key_memory_locked_table_list;
extern PSI_memory_key key_memory_locked_thread_list;
extern PSI_memory_key key_memory_thd_transactions;
extern PSI_memory_key key_memory_delegate;
extern PSI_memory_key key_memory_acl_mem;
extern PSI_memory_key key_memory_acl_memex;
extern PSI_memory_key key_memory_acl_cache;
extern PSI_memory_key key_memory_thd_main_mem_root;
extern PSI_memory_key key_memory_help;
extern PSI_memory_key key_memory_frm;
extern PSI_memory_key key_memory_table_share;
extern PSI_memory_key key_memory_gdl;
extern PSI_memory_key key_memory_table_triggers_list;
extern PSI_memory_key key_memory_prepared_statement_map;
extern PSI_memory_key key_memory_prepared_statement_main_mem_root;
extern PSI_memory_key key_memory_protocol_rset_root;
extern PSI_memory_key key_memory_warning_info_warn_root;
extern PSI_memory_key key_memory_sp_cache;
extern PSI_memory_key key_memory_sp_head_main_root;
extern PSI_memory_key key_memory_sp_head_execute_root;
extern PSI_memory_key key_memory_sp_head_call_root;
extern PSI_memory_key key_memory_table_mapping_root;
extern PSI_memory_key key_memory_quick_range_select_root;
extern PSI_memory_key key_memory_quick_index_merge_root;
extern PSI_memory_key key_memory_quick_ror_intersect_select_root;
extern PSI_memory_key key_memory_quick_ror_union_select_root;
extern PSI_memory_key key_memory_quick_group_min_max_select_root;
extern PSI_memory_key key_memory_test_quick_select_exec;
extern PSI_memory_key key_memory_prune_partitions_exec;
extern PSI_memory_key key_memory_binlog_recover_exec;
extern PSI_memory_key key_memory_blob_mem_storage;

extern PSI_memory_key key_memory_Sys_var_charptr_value;
extern PSI_memory_key key_memory_THD_db;
extern PSI_memory_key key_memory_user_var_entry;
extern PSI_memory_key key_memory_user_var_entry_value;
extern PSI_memory_key key_memory_Slave_job_group_group_relay_log_name;
extern PSI_memory_key key_memory_Relay_log_info_group_relay_log_name;
extern PSI_memory_key key_memory_binlog_cache_mngr;
extern PSI_memory_key key_memory_Row_data_memory_memory;
extern PSI_memory_key key_memory_errmsgs;
extern PSI_memory_key key_memory_Event_queue_element_for_exec_names;
extern PSI_memory_key key_memory_Event_scheduler_scheduler_param;
extern PSI_memory_key key_memory_Gis_read_stream_err_msg;
extern PSI_memory_key key_memory_Geometry_objects_data;
extern PSI_memory_key key_memory_host_cache_hostname;
extern PSI_memory_key key_memory_User_level_lock;
extern PSI_memory_key key_memory_Filesort_info_record_pointers;
extern PSI_memory_key key_memory_Sort_param_tmp_buffer;
extern PSI_memory_key key_memory_Filesort_info_merge;
extern PSI_memory_key key_memory_Filesort_buffer_sort_keys;
extern PSI_memory_key key_memory_handler_errmsgs;
extern PSI_memory_key key_memory_handlerton;
extern PSI_memory_key key_memory_XID;
extern PSI_memory_key key_memory_MYSQL_LOCK;
extern PSI_memory_key key_memory_MYSQL_LOG_name;
extern PSI_memory_key key_memory_TC_LOG_MMAP_pages;
extern PSI_memory_key key_memory_my_str_malloc;
extern PSI_memory_key key_memory_MYSQL_BIN_LOG_basename;
extern PSI_memory_key key_memory_MYSQL_BIN_LOG_index;
extern PSI_memory_key key_memory_MYSQL_RELAY_LOG_basename;
extern PSI_memory_key key_memory_MYSQL_RELAY_LOG_index;
extern PSI_memory_key key_memory_rpl_filter;
extern PSI_memory_key key_memory_Security_context;
extern PSI_memory_key key_memory_NET_buff;
extern PSI_memory_key key_memory_NET_compress_packet;
extern PSI_memory_key key_memory_my_bitmap_map;
extern PSI_memory_key key_memory_QUICK_RANGE_SELECT_mrr_buf_desc;
extern PSI_memory_key key_memory_TABLE_RULE_ENT;
extern PSI_memory_key key_memory_Mutex_cond_array_Mutex_cond;
extern PSI_memory_key key_memory_Owned_gtids_sidno_to_hash;
extern PSI_memory_key key_memory_Sid_map_Node;
extern PSI_memory_key key_memory_bison_stack;
extern PSI_memory_key key_memory_TABLE_sort_io_cache;
extern PSI_memory_key key_memory_DATE_TIME_FORMAT;
extern PSI_memory_key key_memory_DDL_LOG_MEMORY_ENTRY;
extern PSI_memory_key key_memory_ST_SCHEMA_TABLE;
extern PSI_memory_key key_memory_ignored_db;
extern PSI_memory_key key_memory_SLAVE_INFO;
extern PSI_memory_key key_memory_log_event_old;
extern PSI_memory_key key_memory_HASH_ROW_ENTRY;
extern PSI_memory_key key_memory_table_def_memory;
extern PSI_memory_key key_memory_MPVIO_EXT_auth_info;
extern PSI_memory_key key_memory_LOG_POS_COORD;
extern PSI_memory_key key_memory_XID_STATE;
extern PSI_memory_key key_memory_Rpl_info_file_buffer;
extern PSI_memory_key key_memory_Rpl_info_table;
extern PSI_memory_key key_memory_binlog_pos;
extern PSI_memory_key key_memory_db_worker_hash_entry;
extern PSI_memory_key key_memory_rpl_slave_command_buffer;
extern PSI_memory_key key_memory_binlog_ver_1_event;
extern PSI_memory_key key_memory_rpl_slave_check_temp_dir;
extern PSI_memory_key key_memory_TABLE;
extern PSI_memory_key key_memory_binlog_statement_buffer;
extern PSI_memory_key key_memory_user_conn;
extern PSI_memory_key key_memory_dboptions_hash;
extern PSI_memory_key key_memory_hash_index_key_buffer;
extern PSI_memory_key key_memory_THD_handler_tables_hash;
extern PSI_memory_key key_memory_JOIN_CACHE;
extern PSI_memory_key key_memory_READ_INFO;
extern PSI_memory_key key_memory_partition_syntax_buffer;
extern PSI_memory_key key_memory_global_system_variables;
extern PSI_memory_key key_memory_THD_variables;
extern PSI_memory_key key_memory_PROFILE;
extern PSI_memory_key key_memory_LOG_name;
extern PSI_memory_key key_memory_string_iterator;
extern PSI_memory_key key_memory_frm_extra_segment_buff;
extern PSI_memory_key key_memory_frm_form_pos;
extern PSI_memory_key key_memory_frm_string;
extern PSI_memory_key key_memory_Unique_sort_buffer;
extern PSI_memory_key key_memory_Unique_merge_buffer;
extern PSI_memory_key key_memory_shared_memory_name;
extern PSI_memory_key key_memory_opt_bin_logname;
extern PSI_memory_key key_memory_Query_cache;
extern PSI_memory_key key_memory_READ_RECORD_cache;
extern PSI_memory_key key_memory_Quick_ranges;
extern PSI_memory_key key_memory_File_query_log_name;
extern PSI_memory_key key_memory_Table_trigger_dispatcher;
extern PSI_memory_key key_memory_show_slave_status_io_gtid_set;
extern PSI_memory_key key_memory_write_set_extraction;
extern PSI_memory_key key_memory_thd_timer;
extern PSI_memory_key key_memory_THD_Session_tracker;
extern PSI_memory_key key_memory_THD_Session_sysvar_resource_manager;
extern PSI_memory_key key_memory_get_all_tables;
extern PSI_memory_key key_memory_fill_schema_schemata;
extern PSI_memory_key key_memory_native_functions;
extern PSI_memory_key key_memory_JSON;

}





extern PSI_stage_info stage_after_create;
extern PSI_stage_info stage_allocating_local_table;
extern PSI_stage_info stage_alter_inplace_prepare;
extern PSI_stage_info stage_alter_inplace;
extern PSI_stage_info stage_alter_inplace_commit;
extern PSI_stage_info stage_changing_master;
extern PSI_stage_info stage_checking_master_version;
extern PSI_stage_info stage_checking_permissions;
extern PSI_stage_info stage_checking_privileges_on_cached_query;
extern PSI_stage_info stage_checking_query_cache_for_query;
extern PSI_stage_info stage_cleaning_up;
extern PSI_stage_info stage_closing_tables;
extern PSI_stage_info stage_compressing_gtid_table;
extern PSI_stage_info stage_connecting_to_master;
extern PSI_stage_info stage_converting_heap_to_ondisk;
extern PSI_stage_info stage_copying_to_group_table;
extern PSI_stage_info stage_copying_to_tmp_table;
extern PSI_stage_info stage_copy_to_tmp_table;
extern PSI_stage_info stage_creating_sort_index;
extern PSI_stage_info stage_creating_table;
extern PSI_stage_info stage_creating_tmp_table;
extern PSI_stage_info stage_deleting_from_main_table;
extern PSI_stage_info stage_deleting_from_reference_tables;
extern PSI_stage_info stage_discard_or_import_tablespace;
extern PSI_stage_info stage_end;
extern PSI_stage_info stage_executing;
extern PSI_stage_info stage_execution_of_init_command;
extern PSI_stage_info stage_explaining;
extern PSI_stage_info stage_finished_reading_one_binlog_switching_to_next_binlog;
extern PSI_stage_info stage_flushing_relay_log_and_master_info_repository;
extern PSI_stage_info stage_flushing_relay_log_info_file;
extern PSI_stage_info stage_freeing_items;
extern PSI_stage_info stage_fulltext_initialization;
extern PSI_stage_info stage_got_handler_lock;
extern PSI_stage_info stage_got_old_table;
extern PSI_stage_info stage_init;
extern PSI_stage_info stage_insert;
extern PSI_stage_info stage_invalidating_query_cache_entries_table;
extern PSI_stage_info stage_invalidating_query_cache_entries_table_list;
extern PSI_stage_info stage_killing_slave;
extern PSI_stage_info stage_logging_slow_query;
extern PSI_stage_info stage_making_temp_file_append_before_load_data;
extern PSI_stage_info stage_making_temp_file_create_before_load_data;
extern PSI_stage_info stage_manage_keys;
extern PSI_stage_info stage_master_has_sent_all_binlog_to_slave;
extern PSI_stage_info stage_opening_tables;
extern PSI_stage_info stage_optimizing;
extern PSI_stage_info stage_preparing;
extern PSI_stage_info stage_purging_old_relay_logs;
extern PSI_stage_info stage_query_end;
extern PSI_stage_info stage_queueing_master_event_to_the_relay_log;
extern PSI_stage_info stage_reading_event_from_the_relay_log;
extern PSI_stage_info stage_registering_slave_on_master;
extern PSI_stage_info stage_removing_duplicates;
extern PSI_stage_info stage_removing_tmp_table;
extern PSI_stage_info stage_rename;
extern PSI_stage_info stage_rename_result_table;
extern PSI_stage_info stage_requesting_binlog_dump;
extern PSI_stage_info stage_reschedule;
extern PSI_stage_info stage_searching_rows_for_update;
extern PSI_stage_info stage_sending_binlog_event_to_slave;
extern PSI_stage_info stage_sending_cached_result_to_client;
extern PSI_stage_info stage_sending_data;
extern PSI_stage_info stage_setup;
extern PSI_stage_info stage_slave_has_read_all_relay_log;
extern PSI_stage_info stage_slave_waiting_event_from_coordinator;
extern PSI_stage_info stage_slave_waiting_for_workers_to_process_queue;
extern PSI_stage_info stage_slave_waiting_worker_queue;
extern PSI_stage_info stage_slave_waiting_worker_to_free_events;
extern PSI_stage_info stage_slave_waiting_worker_to_release_partition;
extern PSI_stage_info stage_slave_waiting_workers_to_exit;
extern PSI_stage_info stage_sorting_for_group;
extern PSI_stage_info stage_sorting_for_order;
extern PSI_stage_info stage_sorting_result;
extern PSI_stage_info stage_sql_thd_waiting_until_delay;
extern PSI_stage_info stage_statistics;
extern PSI_stage_info stage_storing_result_in_query_cache;
extern PSI_stage_info stage_storing_row_into_queue;
extern PSI_stage_info stage_system_lock;
extern PSI_stage_info stage_update;
extern PSI_stage_info stage_updating;
extern PSI_stage_info stage_updating_main_table;
extern PSI_stage_info stage_updating_reference_tables;
extern PSI_stage_info stage_upgrading_lock;
extern PSI_stage_info stage_user_sleep;
extern PSI_stage_info stage_verifying_table;
extern PSI_stage_info stage_waiting_for_gtid_to_be_committed;
extern PSI_stage_info stage_waiting_for_handler_insert;
extern PSI_stage_info stage_waiting_for_handler_lock;
extern PSI_stage_info stage_waiting_for_handler_open;
extern PSI_stage_info stage_waiting_for_insert;
extern PSI_stage_info stage_waiting_for_master_to_send_event;
extern PSI_stage_info stage_waiting_for_master_update;
extern PSI_stage_info stage_waiting_for_relay_log_space;
extern PSI_stage_info stage_waiting_for_slave_mutex_on_exit;
extern PSI_stage_info stage_waiting_for_slave_thread_to_start;
extern PSI_stage_info stage_waiting_for_query_cache_lock;
extern PSI_stage_info stage_waiting_for_table_flush;
extern PSI_stage_info stage_waiting_for_the_next_event_in_relay_log;
extern PSI_stage_info stage_waiting_for_the_slave_thread_to_advance_position;
extern PSI_stage_info stage_waiting_to_finalize_termination;
extern PSI_stage_info stage_worker_waiting_for_its_turn_to_commit;
extern PSI_stage_info stage_worker_waiting_for_commit_parent;
extern PSI_stage_info stage_suspending;
extern PSI_stage_info stage_starting;
extern PSI_stage_info stage_waiting_for_no_channel_reference;





extern PSI_statement_info sql_statement_info[(uint) SQLCOM_END + 1];





extern PSI_statement_info com_statement_info[(uint) COM_END + 1];




extern PSI_statement_info stmt_info_rpl;

void init_sql_statement_info();
void init_com_statement_info();



extern my_thread_t signal_thread;



extern struct st_VioSSLFd * ssl_acceptor_fd;





extern my_bool opt_large_pages;
extern uint opt_large_page_size;
extern char lc_messages_dir[512];
extern char *lc_messages_dir_ptr;
extern const char *log_error_dest;
extern char reg_ext[20];
extern uint reg_ext_length;
extern uint lower_case_table_names;
extern bool mysqld_embedded;

extern long tc_heuristic_recover;

extern ulong specialflag;
extern size_t mysql_data_home_len;
extern size_t mysql_real_data_home_len;
extern const char *mysql_real_data_home_ptr;
extern char *mysql_data_home;
extern "C" char server_version[60];
extern char mysql_real_data_home[];
extern char mysql_unpacked_real_data_home[];
extern struct system_variables global_system_variables;
extern char default_logfile_name[512];



extern const key_map key_map_empty;
extern key_map key_map_full;




extern mysql_mutex_t
       LOCK_item_func_sleep, LOCK_status,
       LOCK_uuid_generator,
       LOCK_crypt, LOCK_timezone,
       LOCK_slave_list, LOCK_manager,
       LOCK_global_system_variables, LOCK_user_conn, LOCK_log_throttle_qni,
       LOCK_prepared_stmt_count, LOCK_error_messages,
       LOCK_sql_slave_skip_counter, LOCK_slave_net_timeout,
       LOCK_offline_mode, LOCK_default_password_lifetime;

extern char* des_key_file;
extern mysql_mutex_t LOCK_des_key_file;

extern mysql_mutex_t LOCK_server_started;
extern mysql_cond_t COND_server_started;
extern mysql_mutex_t LOCK_reset_gtid_table;
extern mysql_mutex_t LOCK_compress_gtid_table;
extern mysql_cond_t COND_compress_gtid_table;
extern mysql_rwlock_t LOCK_sys_init_connect, LOCK_sys_init_slave;
extern mysql_rwlock_t LOCK_system_variables_hash;
extern mysql_cond_t COND_manager;
extern int32 thread_running;
extern mysql_mutex_t LOCK_group_replication_handler;

extern char *opt_ssl_ca, *opt_ssl_capath, *opt_ssl_cert, *opt_ssl_cipher,
            *opt_ssl_key, *opt_ssl_crl, *opt_ssl_crlpath, *opt_tls_version;


extern char *opt_disabled_storage_engines;




enum options_mysqld
{
  OPT_to_set_the_start_number=256,
  OPT_BIND_ADDRESS,
  OPT_BINLOG_CHECKSUM,
  OPT_BINLOG_DO_DB,
  OPT_BINLOG_FORMAT,
  OPT_BINLOG_MAX_FLUSH_QUEUE_TIME,
  OPT_BINLOG_IGNORE_DB,
  OPT_BIN_LOG,
  OPT_BOOTSTRAP,
  OPT_CONSOLE,
  OPT_DEBUG_SYNC_TIMEOUT,
  OPT_DELAY_KEY_WRITE_ALL,
  OPT_ISAM_LOG,
  OPT_IGNORE_DB_DIRECTORY,
  OPT_KEY_BUFFER_SIZE,
  OPT_KEY_CACHE_AGE_THRESHOLD,
  OPT_KEY_CACHE_BLOCK_SIZE,
  OPT_KEY_CACHE_DIVISION_LIMIT,
  OPT_LC_MESSAGES_DIRECTORY,
  OPT_LOWER_CASE_TABLE_NAMES,
  OPT_MASTER_RETRY_COUNT,
  OPT_MASTER_VERIFY_CHECKSUM,
  OPT_POOL_OF_THREADS,
  OPT_REPLICATE_DO_DB,
  OPT_REPLICATE_DO_TABLE,
  OPT_REPLICATE_IGNORE_DB,
  OPT_REPLICATE_IGNORE_TABLE,
  OPT_REPLICATE_REWRITE_DB,
  OPT_REPLICATE_WILD_DO_TABLE,
  OPT_REPLICATE_WILD_IGNORE_TABLE,
  OPT_SERVER_ID,
  OPT_SKIP_HOST_CACHE,
  OPT_SKIP_LOCK,
  OPT_SKIP_NEW,
  OPT_SKIP_RESOLVE,
  OPT_SKIP_STACK_TRACE,
  OPT_SKIP_SYMLINKS,
  OPT_SLAVE_SQL_VERIFY_CHECKSUM,
  OPT_SSL_CA,
  OPT_SSL_CAPATH,
  OPT_SSL_CERT,
  OPT_SSL_CIPHER,
  OPT_TLS_VERSION,
  OPT_SSL_KEY,
  OPT_UPDATE_LOG,
  OPT_WANT_CORE,
  OPT_LOG_ERROR,
  OPT_MAX_LONG_DATA_SIZE,
  OPT_EARLY_PLUGIN_LOAD,
  OPT_PLUGIN_LOAD,
  OPT_PLUGIN_LOAD_ADD,
  OPT_SSL_CRL,
  OPT_SSL_CRLPATH,
  OPT_PFS_INSTRUMENT,
  OPT_DEFAULT_AUTH,
  OPT_SECURE_AUTH,
  OPT_THREAD_CACHE_SIZE,
  OPT_HOST_CACHE_SIZE,
  OPT_TABLE_DEFINITION_CACHE,
  OPT_MDL_CACHE_SIZE,
  OPT_MDL_HASH_INSTANCES,
  OPT_SKIP_INNODB,
  OPT_AVOID_TEMPORAL_UPGRADE,
  OPT_SHOW_OLD_TEMPORALS,
  OPT_ENFORCE_GTID_CONSISTENCY
};





enum enum_query_type
{

  QT_ORDINARY= 0,

  QT_TO_SYSTEM_CHARSET= (1 << 0),

  QT_WITHOUT_INTRODUCERS= (1 << 1),

  QT_SHOW_SELECT_NUMBER= (1 << 2),

  QT_NO_DEFAULT_DB= (1 << 3),

  QT_DERIVED_TABLE_ONLY_ALIAS= (1 << 4),

  QT_TO_ARGUMENT_CHARSET= (1 << 5),

  QT_NO_DB= (1 << 6),

  QT_NO_TABLE= (1 << 7),




  QT_NORMALIZED_FORMAT= (1 << 8),





  QT_NO_DATA_EXPANSION= (1 << 9),
};


typedef int64 query_id_t;
extern query_id_t global_query_id;


inline __attribute__((warn_unused_result)) query_id_t next_query_id()
{
  query_id_t id= my_atomic_add64(&global_query_id, 1);
  return (id+1);
}





extern "C" void unireg_abort(int exit_code) __attribute__((noreturn));
// # 968 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/mysqld.h"
static inline THD *_current_thd(void)
{
  return my_thread_get_THR_THD();
}
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/hash.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/hash.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_sys.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/hash.h" 2
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/hash.h"
extern "C" {
// # 48 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/hash.h"
struct st_hash;
typedef uint my_hash_value_type;
typedef uchar *(*my_hash_get_key)(const uchar *,size_t*,my_bool);
typedef void (*my_hash_free_key)(void *);






typedef my_hash_value_type (*my_hash_function)(const struct st_hash *,
                                               const uchar *,
                                               size_t);

typedef struct st_hash {
  size_t key_offset,key_length;
  size_t blength;
  ulong records;
  uint flags;
  DYNAMIC_ARRAY array;
  my_hash_get_key get_key;
  void (*free)(void *);
  CHARSET_INFO *charset;
  my_hash_function hash_function;
  PSI_memory_key m_psi_key;
} HASH;


typedef uint HASH_SEARCH_STATE;







my_bool _my_hash_init(HASH *hash, uint growth_size, CHARSET_INFO *charset,
                      my_hash_function hash_function,
                      ulong default_array_elements, size_t key_offset,
                      size_t key_length, my_hash_get_key get_key,
                      void (*free_element)(void*),
                      uint flags,
                      PSI_memory_key psi_key);
void my_hash_claim(HASH *tree);
void my_hash_free(HASH *tree);
void my_hash_reset(HASH *hash);
uchar *my_hash_element(HASH *hash, ulong idx);
uchar *my_hash_search(const HASH *info, const uchar *key, size_t length);
uchar *my_hash_search_using_hash_value(const HASH *info,
                                       my_hash_value_type hash_value,
                                       const uchar *key, size_t length);
my_hash_value_type my_calc_hash(const HASH *info,
                                const uchar *key, size_t length);
uchar *my_hash_first(const HASH *info, const uchar *key, size_t length,
                     HASH_SEARCH_STATE *state);
uchar *my_hash_first_from_hash_value(const HASH *info,
                                     my_hash_value_type hash_value,
                                     const uchar *key,
                                     size_t length,
                                     HASH_SEARCH_STATE *state);
uchar *my_hash_next(const HASH *info, const uchar *key, size_t length,
                    HASH_SEARCH_STATE *state);
my_bool my_hash_insert(HASH *info, const uchar *data);
my_bool my_hash_delete(HASH *hash, uchar *record);
my_bool my_hash_update(HASH *hash, uchar *record, uchar *old_key,
                       size_t old_key_length);
void my_hash_replace(HASH *hash, HASH_SEARCH_STATE *state, uchar *new_row);
my_bool my_hash_check(HASH *hash);







}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_key.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_key.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_key.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_key.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_memory.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_memory.h"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 1 3
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
       
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
// # 147 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
// # 191 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
  struct __numeric_limits_base
  {


    static const bool is_specialized = false;




    static const int digits = 0;


    static const int digits10 = 0;
// # 212 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
    static const bool is_signed = false;


    static const bool is_integer = false;




    static const bool is_exact = false;



    static const int radix = 0;



    static const int min_exponent = 0;



    static const int min_exponent10 = 0;




    static const int max_exponent = 0;



    static const int max_exponent10 = 0;


    static const bool has_infinity = false;



    static const bool has_quiet_NaN = false;



    static const bool has_signaling_NaN = false;


    static const float_denorm_style has_denorm = denorm_absent;



    static const bool has_denorm_loss = false;



    static const bool is_iec559 = false;




    static const bool is_bounded = false;
// # 277 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
    static const bool is_modulo = false;


    static const bool traps = false;


    static const bool tinyness_before = false;




    static const float_round_style round_style =
          round_toward_zero;
  };
// # 303 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static _Tp
      min() throw() { return _Tp(); }


      static _Tp
      max() throw() { return _Tp(); }
// # 324 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
      static _Tp
      epsilon() throw() { return _Tp(); }


      static _Tp
      round_error() throw() { return _Tp(); }


      static _Tp
      infinity() throw() { return _Tp(); }



      static _Tp
      quiet_NaN() throw() { return _Tp(); }



      static _Tp
      signaling_NaN() throw() { return _Tp(); }




      static _Tp
      denorm_min() throw() { return _Tp(); }
    };
// # 370 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
  template<>
    struct numeric_limits<bool>
    {
      static const bool is_specialized = true;

      static bool
      min() throw() { return false; }

      static bool
      max() throw() { return true; }





      static const int digits = 1;
      static const int digits10 = 0;



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static bool
      epsilon() throw() { return false; }

      static bool
      round_error() throw() { return false; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static bool
      infinity() throw() { return false; }

      static bool
      quiet_NaN() throw() { return false; }

      static bool
      signaling_NaN() throw() { return false; }

      static bool
      denorm_min() throw() { return false; }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;




      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static const bool is_specialized = true;

      static char
      min() throw() { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static char
      max() throw() { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }






      static const int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static const int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((char)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static char
      epsilon() throw() { return 0; }

      static char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static
      char infinity() throw() { return char(); }

      static char
      quiet_NaN() throw() { return char(); }

      static char
      signaling_NaN() throw() { return char(); }

      static char
      denorm_min() throw() { return static_cast<char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static const bool is_specialized = true;

      static signed char
      min() throw() { return -127 - 1; }

      static signed char
      max() throw() { return 127; }






      static const int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static const int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static signed char
      epsilon() throw() { return 0; }

      static signed char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static signed char
      infinity() throw() { return static_cast<signed char>(0); }

      static signed char
      quiet_NaN() throw() { return static_cast<signed char>(0); }

      static signed char
      signaling_NaN() throw()
      { return static_cast<signed char>(0); }

      static signed char
      denorm_min() throw()
      { return static_cast<signed char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static const bool is_specialized = true;

      static unsigned char
      min() throw() { return 0; }

      static unsigned char
      max() throw() { return 127 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned char
      epsilon() throw() { return 0; }

      static unsigned char
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned char
      infinity() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      quiet_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      signaling_NaN() throw()
      { return static_cast<unsigned char>(0); }

      static unsigned char
      denorm_min() throw()
      { return static_cast<unsigned char>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static const bool is_specialized = true;

      static wchar_t
      min() throw() { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static wchar_t
      max() throw() { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }






      static const int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static const int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = ((wchar_t)(-1) < 0);
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static wchar_t
      epsilon() throw() { return 0; }

      static wchar_t
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static wchar_t
      infinity() throw() { return wchar_t(); }

      static wchar_t
      quiet_NaN() throw() { return wchar_t(); }

      static wchar_t
      signaling_NaN() throw() { return wchar_t(); }

      static wchar_t
      denorm_min() throw() { return wchar_t(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = !is_signed;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };
// # 841 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/limits" 3
  template<>
    struct numeric_limits<short>
    {
      static const bool is_specialized = true;

      static short
      min() throw() { return -32767 - 1; }

      static short
      max() throw() { return 32767; }






      static const int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static const int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static short
      epsilon() throw() { return 0; }

      static short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static short
      infinity() throw() { return short(); }

      static short
      quiet_NaN() throw() { return short(); }

      static short
      signaling_NaN() throw() { return short(); }

      static short
      denorm_min() throw() { return short(); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static const bool is_specialized = true;

      static unsigned short
      min() throw() { return 0; }

      static unsigned short
      max() throw() { return 32767 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned short
      epsilon() throw() { return 0; }

      static unsigned short
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned short
      infinity() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      quiet_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      signaling_NaN() throw()
      { return static_cast<unsigned short>(0); }

      static unsigned short
      denorm_min() throw()
      { return static_cast<unsigned short>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static const bool is_specialized = true;

      static int
      min() throw() { return -2147483647 - 1; }

      static int
      max() throw() { return 2147483647; }






      static const int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static const int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static int
      epsilon() throw() { return 0; }

      static int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static int
      infinity() throw() { return static_cast<int>(0); }

      static int
      quiet_NaN() throw() { return static_cast<int>(0); }

      static int
      signaling_NaN() throw() { return static_cast<int>(0); }

      static int
      denorm_min() throw() { return static_cast<int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static const bool is_specialized = true;

      static unsigned int
      min() throw() { return 0; }

      static unsigned int
      max() throw() { return 2147483647 * 2U + 1; }






      static const int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned int
      epsilon() throw() { return 0; }

      static unsigned int
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned int
      infinity() throw() { return static_cast<unsigned int>(0); }

      static unsigned int
      quiet_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      signaling_NaN() throw()
      { return static_cast<unsigned int>(0); }

      static unsigned int
      denorm_min() throw()
      { return static_cast<unsigned int>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static const bool is_specialized = true;

      static long
      min() throw() { return -9223372036854775807L - 1; }

      static long
      max() throw() { return 9223372036854775807L; }






      static const int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static const int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long
      epsilon() throw() { return 0; }

      static long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long
      infinity() throw() { return static_cast<long>(0); }

      static long
      quiet_NaN() throw() { return static_cast<long>(0); }

      static long
      signaling_NaN() throw() { return static_cast<long>(0); }

      static long
      denorm_min() throw() { return static_cast<long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static const bool is_specialized = true;

      static unsigned long
      min() throw() { return 0; }

      static unsigned long
      max() throw() { return 9223372036854775807L * 2UL + 1; }






      static const int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long
      epsilon() throw() { return 0; }

      static unsigned long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long
      infinity() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      quiet_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      signaling_NaN() throw()
      { return static_cast<unsigned long>(0); }

      static unsigned long
      denorm_min() throw()
      { return static_cast<unsigned long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static const bool is_specialized = true;

      static long long
      min() throw() { return -9223372036854775807LL - 1; }

      static long long
      max() throw() { return 9223372036854775807LL; }






      static const int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static const int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static long long
      epsilon() throw() { return 0; }

      static long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static long long
      infinity() throw() { return static_cast<long long>(0); }

      static long long
      quiet_NaN() throw() { return static_cast<long long>(0); }

      static long long
      signaling_NaN() throw()
      { return static_cast<long long>(0); }

      static long long
      denorm_min() throw() { return static_cast<long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static const bool is_specialized = true;

      static unsigned long long
      min() throw() { return 0; }

      static unsigned long long
      max() throw() { return 9223372036854775807LL * 2ULL + 1; }






      static const int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned long long
      epsilon() throw() { return 0; }

      static unsigned long long
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned long long
      infinity() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      quiet_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      signaling_NaN() throw()
      { return static_cast<unsigned long long>(0); }

      static unsigned long long
      denorm_min() throw()
      { return static_cast<unsigned long long>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<__int128>
    {
      static const bool is_specialized = true;

      static __int128
      min() throw() { return (((__int128)(-1) < 0) ? -(((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0) - 1 : (__int128)0); }

      static __int128
      max() throw() { return (((__int128)(-1) < 0) ? (((((__int128)1 << ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(__int128)0); }






      static const int digits
       = (sizeof(__int128) * 8 - ((__int128)(-1) < 0));
      static const int digits10
       = ((sizeof(__int128) * 8 - ((__int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = true;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static __int128
      epsilon() throw() { return 0; }

      static __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static __int128
      infinity() throw()
      { return static_cast<__int128>(0); }

      static __int128
      quiet_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      signaling_NaN() throw()
      { return static_cast<__int128>(0); }

      static __int128
      denorm_min() throw()
      { return static_cast<__int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps
       = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned __int128>
    {
      static const bool is_specialized = true;

      static unsigned __int128
      min() throw() { return 0; }

      static unsigned __int128
      max() throw() { return (((unsigned __int128)(-1) < 0) ? (((((unsigned __int128)1 << ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(unsigned __int128)0); }






      static const int digits
       = (sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0));
      static const int digits10
       = ((sizeof(unsigned __int128) * 8 - ((unsigned __int128)(-1) < 0)) * 643L / 2136);



      static const bool is_signed = false;
      static const bool is_integer = true;
      static const bool is_exact = true;
      static const int radix = 2;

      static unsigned __int128
      epsilon() throw() { return 0; }

      static unsigned __int128
      round_error() throw() { return 0; }

      static const int min_exponent = 0;
      static const int min_exponent10 = 0;
      static const int max_exponent = 0;
      static const int max_exponent10 = 0;

      static const bool has_infinity = false;
      static const bool has_quiet_NaN = false;
      static const bool has_signaling_NaN = false;
      static const float_denorm_style has_denorm
       = denorm_absent;
      static const bool has_denorm_loss = false;

      static unsigned __int128
      infinity() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      quiet_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      signaling_NaN() throw()
      { return static_cast<unsigned __int128>(0); }

      static unsigned __int128
      denorm_min() throw()
      { return static_cast<unsigned __int128>(0); }

      static const bool is_iec559 = false;
      static const bool is_bounded = true;
      static const bool is_modulo = true;

      static const bool traps = true;
      static const bool tinyness_before = false;
      static const float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<float>
    {
      static const bool is_specialized = true;

      static float
      min() throw() { return 1.17549435082228750797e-38F; }

      static float
      max() throw() { return 3.40282346638528859812e+38F; }






      static const int digits = 24;
      static const int digits10 = 6;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static float
      epsilon() throw() { return 1.19209289550781250000e-7F; }

      static float
      round_error() throw() { return 0.5F; }

      static const int min_exponent = (-125);
      static const int min_exponent10 = (-37);
      static const int max_exponent = 128;
      static const int max_exponent10 = 38;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
       = false;

      static float
      infinity() throw() { return __builtin_huge_valf(); }

      static float
      quiet_NaN() throw() { return __builtin_nanf(""); }

      static float
      signaling_NaN() throw() { return __builtin_nansf(""); }

      static float
      denorm_min() throw() { return 1.40129846432481707092e-45F; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static const bool is_specialized = true;

      static double
      min() throw() { return double(2.22507385850720138309e-308L); }

      static double
      max() throw() { return double(1.79769313486231570815e+308L); }






      static const int digits = 53;
      static const int digits10 = 15;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static double
      epsilon() throw() { return double(2.22044604925031308085e-16L); }

      static double
      round_error() throw() { return 0.5; }

      static const int min_exponent = (-1021);
      static const int min_exponent10 = (-307);
      static const int max_exponent = 1024;
      static const int max_exponent10 = 308;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
        = false;

      static double
      infinity() throw() { return __builtin_huge_val(); }

      static double
      quiet_NaN() throw() { return __builtin_nan(""); }

      static double
      signaling_NaN() throw() { return __builtin_nans(""); }

      static double
      denorm_min() throw() { return double(4.94065645841246544177e-324L); }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before
       = false;
      static const float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static const bool is_specialized = true;

      static long double
      min() throw() { return 3.36210314311209350626e-4932L; }

      static long double
      max() throw() { return 1.18973149535723176502e+4932L; }






      static const int digits = 64;
      static const int digits10 = 18;




      static const bool is_signed = true;
      static const bool is_integer = false;
      static const bool is_exact = false;
      static const int radix = 2;

      static long double
      epsilon() throw() { return 1.08420217248550443401e-19L; }

      static long double
      round_error() throw() { return 0.5L; }

      static const int min_exponent = (-16381);
      static const int min_exponent10 = (-4931);
      static const int max_exponent = 16384;
      static const int max_exponent10 = 4932;

      static const bool has_infinity = 1;
      static const bool has_quiet_NaN = 1;
      static const bool has_signaling_NaN = has_quiet_NaN;
      static const float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static const bool has_denorm_loss
 = false;

      static long double
      infinity() throw() { return __builtin_huge_vall(); }

      static long double
      quiet_NaN() throw() { return __builtin_nanl(""); }

      static long double
      signaling_NaN() throw() { return __builtin_nansl(""); }

      static long double
      denorm_min() throw() { return 3.64519953188247460253e-4951L; }

      static const bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static const bool is_bounded = true;
      static const bool is_modulo = false;

      static const bool traps = false;
      static const bool tinyness_before =
      false;
      static const float_round_style round_style =
            round_to_nearest;
    };






}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_memory.h" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 1 3
// # 46 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 3
       
// # 47 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 3
// # 64 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_construct.h" 1 3
// # 61 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_construct.h" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 1 3
// # 32 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 3
       
// # 33 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 3
// # 41 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

// # 120 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 3
template<typename _Alloc>
  struct __alloc_traits



  {
    typedef _Alloc allocator_type;
// # 199 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/ext/alloc_traits.h" 3
    typedef typename _Alloc::pointer pointer;
    typedef typename _Alloc::const_pointer const_pointer;
    typedef typename _Alloc::value_type value_type;
    typedef typename _Alloc::reference reference;
    typedef typename _Alloc::const_reference const_reference;
    typedef typename _Alloc::size_type size_type;
    typedef typename _Alloc::difference_type difference_type;

    static pointer
    allocate(_Alloc& __a, size_type __n)
    { return __a.allocate(__n); }

    static void deallocate(_Alloc& __a, pointer __p, size_type __n)
    { __a.deallocate(__p, __n); }

    template<typename _Tp>
      static void construct(_Alloc& __a, pointer __p, const _Tp& __arg)
      { __a.construct(__p, __arg); }

    static void destroy(_Alloc& __a, pointer __p)
    { __a.destroy(__p); }

    static size_type max_size(const _Alloc& __a)
    { return __a.max_size(); }

    static const _Alloc& _S_select_on_copy(const _Alloc& __a) { return __a; }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    {


      std::__alloc_swap<_Alloc>::_S_do_it(__a, __b);
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Alloc::template rebind<_Tp>::other other; };

  };


}
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_construct.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

// # 77 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_construct.h" 3
  template<typename _T1, typename _T2>
    inline void
    _Construct(_T1* __p, const _T2& __value)
    {


      ::new(static_cast<void*>(__p)) _T1(__value);
    }





  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
// # 65 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
// # 105 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;

      return std::__uninitialized_copy<(__is_trivial(_ValueType1)
     && __is_trivial(_ValueType2))>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
// # 162 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill<__is_trivial(_ValueType)>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
// # 216 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      std::__uninitialized_fill_n<__is_trivial(_ValueType)>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a((__first),
      (__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 ((__first),
  (__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
// # 346 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }
// # 653 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_uninitialized.h" 3

}
// # 66 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_tempbuf.h" 1 3
// # 62 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 83 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len)
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
// # 110 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         (*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    (*__prev));
       *__seed = (*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
// # 229 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
// # 67 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_raw_storage_iter.h" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}
// # 68 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 2 3
// # 87 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 1 3
// # 36 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

// # 47 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } ;
// # 86 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
// # 112 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
// # 124 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
// # 135 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
// # 152 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
// # 170 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
// # 180 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
// # 210 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
// # 224 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
// # 239 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
// # 260 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } ;



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } ;
// # 326 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/backward/auto_ptr.h" 3

}
// # 88 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/memory" 2 3
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_memory.h" 2

namespace keyring {

  extern PSI_memory_key key_memory_KEYRING;

  template <class T>
  T keyring_malloc(size_t size)
  {
    void *allocated_memory= mysql_malloc_service->mysql_malloc(key_memory_KEYRING, size, (myf) (16));
    return allocated_memory ? reinterpret_cast<T>(allocated_memory) : __null;
  }

  class Keyring_alloc
  {
    public:
      static void *operator new(size_t size) throw ()
      {
        return keyring_malloc<void*>(size);
      }
      static void *operator new[](size_t size) throw ()
      {
        return keyring_malloc<void*>(size);
      }
      static void operator delete(void* ptr, std::size_t sz)
      {
          mysql_malloc_service->mysql_free(ptr);
      }
      static void operator delete[](void* ptr, std::size_t sz)
      {
          mysql_malloc_service->mysql_free(ptr);
      }
  };
}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_key.h" 2

namespace keyring {

struct IKey : public Keyring_alloc
{

  virtual std::string* get_key_signature() const= 0;
  virtual std::string* get_key_type()= 0;
  virtual uchar* get_key_data() = 0;
  virtual size_t get_key_data_size()= 0;
  virtual size_t get_key_pod_size() const = 0;
  virtual uchar* release_key_data()= 0;
  virtual void xor_data()= 0;
  virtual void set_key_data(uchar *key_data, size_t key_data_size)= 0;
  virtual void set_key_type(const std::string *key_type)= 0;
  virtual my_bool load_from_buffer(uchar* buffer, size_t *buffer_position,
                                   size_t input_buffer_size)= 0;
  virtual void store_in_buffer(uchar* buffer, size_t *buffer_position) const = 0;
  virtual my_bool is_key_type_valid()= 0;
  virtual my_bool is_key_id_valid()= 0;
  virtual my_bool is_key_valid()= 0;

  virtual ~IKey() {}
};

}
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_key.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 1
// # 15 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/user.hpp" 1
// # 31 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2




// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/select_compiler_config.hpp" 1
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/compiler/gcc.hpp" 1
// # 40 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2




// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/select_stdlib_config.hpp" 1
// # 18 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/select_stdlib_config.hpp"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/select_stdlib_config.hpp" 2
// # 45 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/stdlib/libstdcpp3.hpp" 1
// # 49 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2




// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/select_platform_config.hpp" 1
// # 54 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/platform/linux.hpp" 1
// # 15 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/platform/linux.hpp"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 3
// # 114 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::div_t;
  using ::ldiv_t;

  using ::abort;
  using ::abs;
  using ::atexit;





  using ::atof;
  using ::atoi;
  using ::atol;
  using ::bsearch;
  using ::calloc;
  using ::div;
  using ::exit;
  using ::free;
  using ::getenv;
  using ::labs;
  using ::ldiv;
  using ::malloc;

  using ::mblen;
  using ::mbstowcs;
  using ::mbtowc;

  using ::qsort;





  using ::rand;
  using ::realloc;
  using ::srand;
  using ::strtod;
  using ::strtol;
  using ::strtoul;
  using ::system;

  using ::wcstombs;
  using ::wctomb;



  inline long
  abs(long __i) { return __builtin_labs(__i); }

  inline ldiv_t
  div(long __i, long __j) { return ldiv(__i, __j); }



  inline long long
  abs(long long __x) { return __builtin_llabs (__x); }



  inline __int128
  abs(__int128 __x) { return __x >= 0 ? __x : -__x; }



}
// # 196 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  using ::lldiv_t;





  using ::_Exit;



  using ::llabs;

  inline lldiv_t
  div(long long __n, long long __d)
  { lldiv_t __q; __q.quot = __n / __d; __q.rem = __n % __d; return __q; }

  using ::lldiv;
// # 228 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstdlib" 3
  using ::atoll;
  using ::strtoll;
  using ::strtoull;

  using ::strtof;
  using ::strtold;


}

namespace std
{

  using ::__gnu_cxx::lldiv_t;

  using ::__gnu_cxx::_Exit;

  using ::__gnu_cxx::llabs;
  using ::__gnu_cxx::div;
  using ::__gnu_cxx::lldiv;

  using ::__gnu_cxx::atoll;
  using ::__gnu_cxx::strtof;
  using ::__gnu_cxx::strtoll;
  using ::__gnu_cxx::strtoull;
  using ::__gnu_cxx::strtold;
}
// # 16 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/platform/linux.hpp" 2
// # 74 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/platform/linux.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/posix_features.hpp" 1
// # 75 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/platform/linux.hpp" 2
// # 58 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/suffix.hpp" 1
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/suffix.hpp"
       
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/suffix.hpp" 3
// # 482 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config/suffix.hpp" 3
namespace boost{

   __extension__ typedef long long long_long_type;
   __extension__ typedef unsigned long long ulong_long_type;




}



namespace boost{

   __extension__ typedef __int128 int128_type;
   __extension__ typedef unsigned __int128 uint128_type;




}
// # 62 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/config.hpp" 2


       
// # 16 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2



         


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_begin.hpp" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/workaround.hpp" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/workaround.hpp"
         
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
         


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp" 2



namespace boost {

namespace movelib {

template <class T>
struct default_delete;

}



template <class T> class rv;


namespace move_upmu {




struct nat{};




template <class T> struct natify{};




template<bool C, typename T1, typename T2>
struct if_c
{
   typedef T1 type;
};

template<typename T1, typename T2>
struct if_c<false,T1,T2>
{
   typedef T2 type;
};




template<typename T1, typename T2, typename T3>
struct if_ : if_c<0 != T1::value, T2, T3>
{};


template <bool B, class T = nat>
struct enable_if_c
{
   typedef T type;
};




template <class T>
struct enable_if_c<false, T> {};




template <class Cond, class T = nat>
struct enable_if : public enable_if_c<Cond::value, T> {};




template<class T>
struct remove_reference
{
   typedef T type;
};

template<class T>
struct remove_reference<T&>
{
   typedef T type;
};
// # 121 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template<class T>
struct remove_reference< rv<T> >
{
   typedef T type;
};

template<class T>
struct remove_reference< rv<T> &>
{
   typedef T type;
};

template<class T>
struct remove_reference< const rv<T> &>
{
   typedef T type;
};







template< class T >
struct remove_const
{
   typedef T type;
};

template< class T >
struct remove_const<const T>
{
   typedef T type;
};




template< class T >
struct remove_volatile
{
   typedef T type;
};

template< class T >
struct remove_volatile<volatile T>
{
   typedef T type;
};




template< class T >
struct remove_cv
{
    typedef typename remove_volatile
      <typename remove_const<T>::type>::type type;
};




template<class T>
struct remove_extent
{
   typedef T type;
};

template<class T>
struct remove_extent<T[]>
{
   typedef T type;
};

template<class T, std::size_t N>
struct remove_extent<T[N]>
{
   typedef T type;
};





template<class T, unsigned N = 0>
struct extent
{
   static const std::size_t value = 0;
};

template<class T>
struct extent<T[], 0>
{
   static const std::size_t value = 0;
};

template<class T, unsigned N>
struct extent<T[], N>
{
   static const std::size_t value = extent<T, N-1>::value;
};

template<class T, std::size_t N>
struct extent<T[N], 0>
{
   static const std::size_t value = N;
};

template<class T, std::size_t I, unsigned N>
struct extent<T[I], N>
{
   static const std::size_t value = extent<T, N-1>::value;
};




template<class T>
struct add_lvalue_reference
{
   typedef T& type;
};

template<class T>
struct add_lvalue_reference<T&>
{
   typedef T& type;
};

template<>
struct add_lvalue_reference<void>
{
   typedef void type;
};

template<>
struct add_lvalue_reference<const void>
{
   typedef const void type;
};

template<>
struct add_lvalue_reference<volatile void>
{
   typedef volatile void type;
};

template<>
struct add_lvalue_reference<const volatile void>
{
   typedef const volatile void type;
};

template<class T>
struct add_const_lvalue_reference
{
   typedef typename remove_reference<T>::type t_unreferenced;
   typedef const t_unreferenced t_unreferenced_const;
   typedef typename add_lvalue_reference
      <t_unreferenced_const>::type type;
};




template<class T, class U>
struct is_same
{
   static const bool value = false;
};

template<class T>
struct is_same<T, T>
{
   static const bool value = true;
};




template< class T >
struct is_pointer
{
    static const bool value = false;
};

template< class T >
struct is_pointer<T*>
{
    static const bool value = true;
};




template< class T >
struct is_reference
{
    static const bool value = false;
};

template< class T >
struct is_reference<T&>
{
    static const bool value = true;
};
// # 343 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template<class T>
struct is_lvalue_reference
{
    static const bool value = false;
};

template<class T>
struct is_lvalue_reference<T&>
{
    static const bool value = true;
};




template<class T>
struct is_array
{
   static const bool value = false;
};

template<class T>
struct is_array<T[]>
{
   static const bool value = true;
};

template<class T, std::size_t N>
struct is_array<T[N]>
{
   static const bool value = true;
};




template <class T>
struct has_pointer_type
{
   struct two { char c[2]; };
   template <class U> static two test(...);
   template <class U> static char test(typename U::pointer* = 0);
   static const bool value = sizeof(test<T>(0)) == 1;
};




template <class T, class D, bool = has_pointer_type<D>::value>
struct pointer_type_imp
{
    typedef typename D::pointer type;
};

template <class T, class D>
struct pointer_type_imp<T, D, false>
{
    typedef typename remove_extent<T>::type* type;
};

template <class T, class D>
struct pointer_type
{
    typedef typename pointer_type_imp
      <typename remove_extent<T>::type, typename remove_reference<D>::type>::type type;
};
// # 425 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template <class T, class U>
class is_convertible
{
   typedef typename add_lvalue_reference<T>::type t_reference;
   typedef char true_t;
   class false_t { char dummy[2]; };
   static false_t dispatch(...);
   static true_t dispatch(U);
   static t_reference trigger();
   public:
   static const bool value = sizeof(dispatch(trigger())) == sizeof(true_t);
};
// # 453 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template <typename T>
struct is_unary_function_impl
{ static const bool value = false; };




template <typename R>
struct is_unary_function_impl<R (*)()>
{ static const bool value = true; };

template <typename R>
struct is_unary_function_impl<R (*)(...)>
{ static const bool value = true; };
// # 495 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template <typename R, class T0>
struct is_unary_function_impl<R (*)(T0)>
{ static const bool value = true; };

template <typename R, class T0>
struct is_unary_function_impl<R (*)(T0...)>
{ static const bool value = true; };
// # 527 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template <typename T>
struct is_unary_function_impl<T&>
{ static const bool value = false; };

template<typename T>
struct is_unary_function
{ static const bool value = is_unary_function_impl<T>::value; };
// # 554 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
   template<class T>
   struct has_virtual_destructor{ static const bool value = __has_virtual_destructor(T); };
// # 566 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/unique_ptr_meta_utils.hpp"
template< class T, class U
        , bool enable = is_convertible< U*, T*>::value &&
                        !is_array<T>::value &&
                        !is_same<typename remove_cv<T>::type, void>::value &&
                        !is_same<typename remove_cv<U>::type, typename remove_cv<T>::type>::value
        >
struct missing_virtual_destructor_default_delete
{ static const bool value = !has_virtual_destructor<T>::value; };

template<class T, class U>
struct missing_virtual_destructor_default_delete<T, U, false>
{ static const bool value = false; };

template<class Deleter, class U>
struct missing_virtual_destructor
{ static const bool value = false; };

template<class T, class U>
struct missing_virtual_destructor< ::boost::movelib::default_delete<T>, U >
   : missing_virtual_destructor_default_delete<T, U>
{};

}
}
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp"
         


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_begin.hpp" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp" 2


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp" 1
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp"
         


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_begin.hpp" 1
// # 29 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
         


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_begin.hpp" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp" 2
// # 54 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
         


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_begin.hpp" 1
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2



// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
         

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils_core.hpp" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils_core.hpp"
         




namespace boost {
namespace move_detail {




template<bool C, typename T1, typename T2>
struct if_c
{
   typedef T1 type;
};

template<typename T1, typename T2>
struct if_c<false,T1,T2>
{
   typedef T2 type;
};




template<typename T1, typename T2, typename T3>
struct if_ : if_c<0 != T1::value, T2, T3>
{};




template <bool B, class T = void>
struct enable_if_c
{
   typedef T type;
};

template <class T>
struct enable_if_c<false, T> {};




template <class Cond, class T = void>
struct enable_if : enable_if_c<Cond::value, T> {};




template <bool B, class T = void>
struct disable_if_c
   : enable_if_c<!B, T>
{};




template <class Cond, class T = void>
struct disable_if : enable_if_c<!Cond::value, T> {};




template<class T, T v>
struct integral_constant
{
   static const T value = v;
   typedef T value_type;
   typedef integral_constant<T, v> type;

     operator T() const { return value; }
   T operator()() const { return value; }
};

typedef integral_constant<bool, true > true_type;
typedef integral_constant<bool, false > false_type;





template<class T, class U>
struct is_same
{
   static const bool value = false;
};

template<class T>
struct is_same<T, T>
{
   static const bool value = true;
};

}
}
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp" 2
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp" 2



namespace boost {


template <class T> class rv;

namespace move_detail {




template<class T, class U>
struct is_different
{
   static const bool value = !is_same<T, U>::value;
};




template<class F, class Param>
struct apply
{
   typedef typename F::template apply<Param>::type type;
};





template< bool C_ >
struct bool_ : integral_constant<bool, C_>
{
     operator bool() const { return C_; }
   bool operator()() const { return C_; }
};

typedef bool_<true> true_;
typedef bool_<false> false_;




struct nat{};




typedef char yes_type;

struct no_type
{
   char _[2];
};




template <class T> struct natify{};




template<class T>
struct remove_reference
{
   typedef T type;
};

template<class T>
struct remove_reference<T&>
{
   typedef T type;
};
// # 113 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
template<class T>
struct remove_reference< rv<T> >
{
   typedef T type;
};

template<class T>
struct remove_reference< rv<T> &>
{
   typedef T type;
};

template<class T>
struct remove_reference< const rv<T> &>
{
   typedef T type;
};







template< class T > struct remove_pointer { typedef T type; };
template< class T > struct remove_pointer<T*> { typedef T type; };
template< class T > struct remove_pointer<T* const> { typedef T type; };
template< class T > struct remove_pointer<T* volatile> { typedef T type; };
template< class T > struct remove_pointer<T* const volatile> { typedef T type; };




template< class T >
struct add_pointer
{
   typedef typename remove_reference<T>::type* type;
};




template<class T>
struct add_const
{
   typedef const T type;
};

template<class T>
struct add_const<T&>
{
   typedef const T& type;
};
// # 180 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
template<class T>
struct add_lvalue_reference
{ typedef T& type; };

template<class T> struct add_lvalue_reference<T&> { typedef T& type; };
template<> struct add_lvalue_reference<void> { typedef void type; };
template<> struct add_lvalue_reference<const void> { typedef const void type; };
template<> struct add_lvalue_reference<volatile void> { typedef volatile void type; };
template<> struct add_lvalue_reference<const volatile void>{ typedef const volatile void type; };

template<class T>
struct add_const_lvalue_reference
{
   typedef typename remove_reference<T>::type t_unreferenced;
   typedef typename add_const<t_unreferenced>::type t_unreferenced_const;
   typedef typename add_lvalue_reference
      <t_unreferenced_const>::type type;
};




template<class T>
struct is_lvalue_reference
{
    static const bool value = false;
};

template<class T>
struct is_lvalue_reference<T&>
{
    static const bool value = true;
};





template <class T>
struct identity
{
   typedef T type;
   typedef typename add_const_lvalue_reference<T>::type reference;
   reference operator()(reference t)
   { return t; }
};




template<class T>
struct is_class_or_union
{
   struct twochar { char dummy[2]; };
   template <class U>
   static char is_class_or_union_tester(void(U::*)(void));
   template <class U>
   static twochar is_class_or_union_tester(...);
   static const bool value = sizeof(is_class_or_union_tester<T>(0)) == sizeof(char);
};




template<class T>
struct addr_impl_ref
{
   T & v_;
   inline addr_impl_ref( T & v ): v_( v ) {}
   inline operator T& () const { return v_; }

   private:
   addr_impl_ref & operator=(const addr_impl_ref &);
};

template<class T>
struct addressof_impl
{
   static inline T * f( T & v, long )
   {
      return reinterpret_cast<T*>(
         &const_cast<char&>(reinterpret_cast<const volatile char &>(v)));
   }

   static inline T * f( T * v, int )
   { return v; }
};

template<class T>
inline T * addressof( T & v )
{
   return ::boost::move_detail::addressof_impl<T>::f
      ( ::boost::move_detail::addr_impl_ref<T>( v ), 0 );
}




template <class T>
struct has_pointer_type
{
   struct two { char c[2]; };
   template <class U> static two test(...);
   template <class U> static char test(typename U::pointer* = 0);
   static const bool value = sizeof(test<T>(0)) == 1;
};
// # 302 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
template <class T, class U>
class is_convertible
{
   typedef typename add_lvalue_reference<T>::type t_reference;
   typedef char true_t;
   class false_t { char dummy[2]; };
   static false_t dispatch(...);
   static true_t dispatch(U);
   static t_reference trigger();
   public:
   static const bool value = sizeof(dispatch(trigger())) == sizeof(true_t);
};



template<
      bool C
    , typename F1
    , typename F2
    >
struct eval_if_c
    : if_c<C,F1,F2>::type
{};

template<
      typename C
    , typename T1
    , typename T2
    >
struct eval_if
    : if_<C,T1,T2>::type
{};

template<class T, class U, class R = void>
struct enable_if_convertible
   : enable_if< is_convertible<T, U>, R>
{};

template<class T, class U, class R = void>
struct disable_if_convertible
   : disable_if< is_convertible<T, U>, R>
{};






template<bool, class B = true_, class C = true_, class D = true_>
struct and_impl
   : and_impl<B::value, C, D>
{};

template<>
struct and_impl<true, true_, true_, true_>
{
   static const bool value = true;
};

template<class B, class C, class D>
struct and_impl<false, B, C, D>
{
   static const bool value = false;
};

template<class A, class B, class C = true_, class D = true_>
struct and_
   : and_impl<A::value, B, C, D>
{};






template<bool, class B = false_, class C = false_, class D = false_>
struct or_impl
   : or_impl<B::value, C, D>
{};

template<>
struct or_impl<false, false_, false_, false_>
{
   static const bool value = false;
};

template<class B, class C, class D>
struct or_impl<true, B, C, D>
{
   static const bool value = true;
};

template<class A, class B, class C = false_, class D = false_>
struct or_
   : or_impl<A::value, B, C, D>
{};






template<class T>
struct not_
{
   static const bool value = !T::value;
};







template<class R, class A, class B, class C = true_, class D = true_>
struct enable_if_and
   : enable_if_c< and_<A, B, C, D>::value, R>
{};

template<class R, class A, class B, class C = true_, class D = true_>
struct disable_if_and
   : disable_if_c< and_<A, B, C, D>::value, R>
{};

template<class R, class A, class B, class C = false_, class D = false_>
struct enable_if_or
   : enable_if_c< or_<A, B, C, D>::value, R>
{};

template<class R, class A, class B, class C = false_, class D = false_>
struct disable_if_or
   : disable_if_c< or_<A, B, C, D>::value, R>
{};






template<class T>
struct has_move_emulation_enabled_impl
   : is_convertible< T, ::boost::rv<T>& >
{};

template<class T>
struct has_move_emulation_enabled_impl<T&>
{ static const bool value = false; };

template<class T>
struct has_move_emulation_enabled_impl< ::boost::rv<T> >
{ static const bool value = false; };







template <class T>
struct is_rv_impl
{ static const bool value = false; };

template <class T>
struct is_rv_impl< rv<T> >
{ static const bool value = true; };

template <class T>
struct is_rv_impl< const rv<T> >
{ static const bool value = true; };



template< class T >
struct is_rvalue_reference
{ static const bool value = false; };
// # 486 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
template< class T >
struct is_rvalue_reference< boost::rv<T>& >
{ static const bool value = true; };

template< class T >
struct is_rvalue_reference< const boost::rv<T>& >
{ static const bool value = true; };
// # 504 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
namespace detail_add_rvalue_reference
{
   template< class T
            , bool emulation = has_move_emulation_enabled_impl<T>::value
            , bool rv = is_rv_impl<T>::value >
   struct add_rvalue_reference_impl { typedef T type; };

   template< class T, bool emulation>
   struct add_rvalue_reference_impl< T, emulation, true > { typedef T & type; };

   template< class T, bool rv >
   struct add_rvalue_reference_impl< T, true, rv > { typedef ::boost::rv<T>& type; };
}

template< class T >
struct add_rvalue_reference
   : detail_add_rvalue_reference::add_rvalue_reference_impl<T>
{ };

template< class T >
struct add_rvalue_reference<T &>
{ typedef T & type; };



template< class T > struct remove_rvalue_reference { typedef T type; };




   template< class T > struct remove_rvalue_reference< rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< volatile rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const volatile rv<T> > { typedef T type; };
   template< class T > struct remove_rvalue_reference< rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< volatile rv<T>& > { typedef T type; };
   template< class T > struct remove_rvalue_reference< const volatile rv<T>& >{ typedef T type; };
// # 556 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/meta_utils.hpp"
}
}
// # 32 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp" 1
// # 54 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp"
// # 1 "/usr/include/assert.h" 1 3 4
// # 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
// # 55 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp" 2
// # 34 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/static_assert.hpp" 1
// # 18 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/static_assert.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/detail/workaround.hpp" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/static_assert.hpp" 2







       
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/static_assert.hpp" 3
// # 84 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/static_assert.hpp" 3
namespace boost{


template <bool x> struct STATIC_ASSERTION_FAILURE;

template <> struct STATIC_ASSERTION_FAILURE<true> { enum { value = 1 }; };


template<int x> struct static_assert_test{};

}
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 37 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2
// # 315 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
namespace boost {
namespace move_detail {




template<class T>
struct is_reference
{ static const bool value = false; };

template<class T>
struct is_reference<T&>
{ static const bool value = true; };
// # 338 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template<class T>
struct is_pointer
{ static const bool value = false; };

template<class T>
struct is_pointer<T*>
{ static const bool value = true; };




template<class T>
struct is_const
{ static const bool value = false; };

template<class T>
struct is_const<const T>
{ static const bool value = true; };




template <typename T> struct unvoid_ref : add_lvalue_reference<T>{};
template <> struct unvoid_ref<void> { typedef unvoid_ref & type; };
template <> struct unvoid_ref<const void> { typedef unvoid_ref & type; };
template <> struct unvoid_ref<volatile void> { typedef unvoid_ref & type; };
template <> struct unvoid_ref<const volatile void> { typedef unvoid_ref & type; };

template <typename T>
struct add_reference : add_lvalue_reference<T>
{};




template <class T>
struct add_const_reference
{ typedef const T &type; };

template <class T>
struct add_const_reference<T&>
{ typedef T& type; };




template<class T, bool Add>
struct add_const_if_c
   : if_c<Add, typename add_const<T>::type, T>
{};




template<class T>
struct remove_const
{ typedef T type; };

template<class T>
struct remove_const< const T>
{ typedef T type; };




template<typename T> struct remove_cv { typedef T type; };
template<typename T> struct remove_cv<const T> { typedef T type; };
template<typename T> struct remove_cv<const volatile T> { typedef T type; };
template<typename T> struct remove_cv<volatile T> { typedef T type; };




template <class T>
struct make_unsigned_impl { typedef T type; };
template <> struct make_unsigned_impl<signed char> { typedef unsigned char type; };
template <> struct make_unsigned_impl<signed short> { typedef unsigned short type; };
template <> struct make_unsigned_impl<signed int> { typedef unsigned int type; };
template <> struct make_unsigned_impl<signed long> { typedef unsigned long type; };

template <> struct make_unsigned_impl< ::boost::long_long_type > { typedef ::boost::ulong_long_type type; };


template <class T>
struct make_unsigned
   : make_unsigned_impl<typename remove_cv<T>::type>
{};




template<class T> struct is_floating_point_cv { static const bool value = false; };
template<> struct is_floating_point_cv<float> { static const bool value = true; };
template<> struct is_floating_point_cv<double> { static const bool value = true; };
template<> struct is_floating_point_cv<long double> { static const bool value = true; };

template<class T>
struct is_floating_point
   : is_floating_point_cv<typename remove_cv<T>::type>
{};




template<class T> struct is_integral_cv { static const bool value = false; };
template<> struct is_integral_cv< bool>{ static const bool value = true; };
template<> struct is_integral_cv< char>{ static const bool value = true; };
template<> struct is_integral_cv< unsigned char>{ static const bool value = true; };
template<> struct is_integral_cv< signed char>{ static const bool value = true; };







template<> struct is_integral_cv< wchar_t>{ static const bool value = true; };

template<> struct is_integral_cv< short>{ static const bool value = true; };
template<> struct is_integral_cv< unsigned short>{ static const bool value = true; };
template<> struct is_integral_cv< int>{ static const bool value = true; };
template<> struct is_integral_cv< unsigned int>{ static const bool value = true; };
template<> struct is_integral_cv< long>{ static const bool value = true; };
template<> struct is_integral_cv< unsigned long>{ static const bool value = true; };

template<> struct is_integral_cv< ::boost:: long_long_type>{ static const bool value = true; };
template<> struct is_integral_cv< ::boost::ulong_long_type>{ static const bool value = true; };


template<class T>
struct is_integral
   : public is_integral_cv<typename remove_cv<T>::type>
{};




template <class T>
struct remove_all_extents
{ typedef T type;};

template <class T>
struct remove_all_extents<T[]>
{ typedef typename remove_all_extents<T>::type type; };

template <class T, size_t N>
struct remove_all_extents<T[N]>
{ typedef typename remove_all_extents<T>::type type;};




template<class T>
struct is_scalar
{ static const bool value = is_integral<T>::value || is_floating_point<T>::value; };




template<class T>
struct is_void_cv
{ static const bool value = false; };

template<>
struct is_void_cv<void>
{ static const bool value = true; };

template<class T>
struct is_void
   : is_void_cv<typename remove_cv<T>::type>
{};




template<class T>
struct is_array
{ static const bool value = false; };

template<class T>
struct is_array<T[]>
{ static const bool value = true; };

template<class T, std::size_t N>
struct is_array<T[N]>
{ static const bool value = true; };




template <class T> struct is_member_pointer_cv { static const bool value = false; };
template <class T, class U>struct is_member_pointer_cv<T U::*> { static const bool value = true; };

template <class T>
struct is_member_pointer
    : is_member_pointer_cv<typename remove_cv<T>::type>
{};




template <class T>
struct is_nullptr_t_cv
{ static const bool value = false; };
// # 554 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template <class T>
struct is_nullptr_t
   : is_nullptr_t_cv<typename remove_cv<T>::type>
{};
// # 566 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template <class T>
struct is_reference_convertible_to_pointer
{
   struct twochar { char dummy[2]; };
   template <class U> static char test(U*);
   template <class U> static twochar test(...);
   static T& source();
   static const bool value = sizeof(char) == sizeof(test<T>(source()));
};





template < class T
         , bool Filter = is_class_or_union<T>::value ||
                         is_void<T>::value ||
                         is_reference<T>::value ||
                         is_nullptr_t<T>::value >
struct is_function_impl
{ static const bool value = is_reference_convertible_to_pointer<T>::value; };

template <class T>
struct is_function_impl<T, true>
{ static const bool value = false; };

template <class T>
struct is_function
   : is_function_impl<T>
{};




template<class T>
struct is_union_noextents_cv
{ static const bool value = __is_union(T); };

template<class T>
struct is_union
   : is_union_noextents_cv<typename remove_cv<typename remove_all_extents<T>::type>::type>
{};




template <class T>
struct is_class
{
   static const bool value = is_class_or_union<T>::value && ! is_union<T>::value;
};





template <class T>
struct is_arithmetic
{
   static const bool value = is_floating_point<T>::value ||
                             is_integral<T>::value;
};




template <class T>
struct is_member_function_pointer_cv
{
   static const bool value = false;
};

template <class T, class C>
struct is_member_function_pointer_cv<T C::*>
   : is_function<T>
{};

template <class T>
struct is_member_function_pointer
    : is_member_function_pointer_cv<typename remove_cv<T>::type>
{};
// # 668 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template <class T>
struct is_enum
{ static const bool value = __is_enum(T); };




template<class T>
struct is_pod_noextents_cv
{ static const bool value = (::boost::move_detail::is_scalar<T>::value || ::boost::move_detail::is_void<T>::value || __is_pod(T)); };

template<class T>
struct is_pod
   : is_pod_noextents_cv<typename remove_cv<typename remove_all_extents<T>::type>::type>
{};
// # 715 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template <class T>
struct is_empty
{ static const bool value = __is_empty(T); };


template<class T>
struct has_boost_move_no_copy_constructor_or_assign_type
{
   template <class U>
   static yes_type test(typename U::boost_move_no_copy_constructor_or_assign*);

   template <class U>
   static no_type test(...);

   static const bool value = sizeof(test<T>(0)) == sizeof(yes_type);
};
// # 741 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template<class T>
struct is_copy_constructible
{
// # 763 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
   static const bool value = !has_boost_move_no_copy_constructor_or_assign_type<T>::value;

};
// # 777 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template <class T>
struct is_copy_assignable
{
// # 798 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
   static const bool value = !has_boost_move_no_copy_constructor_or_assign_type<T>::value;

};




template<class T>
struct is_trivially_destructible
{ static const bool value = (__has_trivial_destructor(T) ); };




template<class T>
struct is_trivially_default_constructible
{ static const bool value = ((__has_trivial_constructor(T) )); };




template<class T>
struct is_trivially_copy_constructible
{


   static const bool value = ::boost::move_detail::is_pod<T>::value ||
                             ( ::boost::move_detail::is_copy_constructible<T>::value &&
                               ((__has_trivial_copy(T) )) );
};




template<class T>
struct is_trivially_move_constructible
{ static const bool value = ::boost::move_detail::is_pod<T>::value; };




template<class T>
struct is_trivially_copy_assignable
{


   static const bool value = ::boost::move_detail::is_pod<T>::value ||
                             ( ::boost::move_detail::is_copy_assignable<T>::value &&
                               ((__has_trivial_assign(T) ) ) );
};




template<class T>
struct is_trivially_move_assignable
{ static const bool value = ::boost::move_detail::is_pod<T>::value; };




template<class T>
struct is_nothrow_default_constructible
   : is_pod<T>
{ static const bool value = (__has_nothrow_constructor(T) ); };




template<class T>
struct is_nothrow_copy_constructible
{ static const bool value = ((__has_nothrow_copy(T) )); };




template<class T>
struct is_nothrow_move_constructible
{ static const bool value = ::boost::move_detail::is_pod<T>::value; };




template<class T>
struct is_nothrow_copy_assignable
{ static const bool value = ((__has_nothrow_assign(T) )); };




template<class T>
struct is_nothrow_move_assignable
{ static const bool value = ::boost::move_detail::is_pod<T>::value; };




template<class T>
struct is_nothrow_swappable
{
   static const bool value = is_empty<T>::value || is_pod<T>::value;
};




template <typename T>
struct alignment_of_hack
{
   T t1;
   char c;
   T t2;
   alignment_of_hack();
};

template <unsigned A, unsigned S>
struct alignment_logic
{ static const std::size_t value = A < S ? A : S; };

template< typename T >
struct alignment_of_impl
// # 929 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
{ static const std::size_t value = __alignof__(T); };


template< typename T >
struct alignment_of
   : alignment_of_impl<T>
{};

class alignment_dummy;
typedef void (*function_ptr)();
typedef int (alignment_dummy::*member_ptr);
typedef int (alignment_dummy::*member_function_ptr)();
struct alignment_struct
{ long double dummy[4]; };





union max_align
{
   char char_;
   short short_;
   int int_;
   long long_;

   ::boost::long_long_type long_long_;

   float float_;
   double double_;
   void * void_ptr_;
   long double long_double_[4];
   alignment_dummy *unknown_class_ptr_;
   function_ptr function_ptr_;
   member_function_ptr member_function_ptr_;
   alignment_struct alignment_struct_;
};

typedef union max_align max_align_t;







template<std::size_t Len, std::size_t Align>
struct aligned_storage_impl;
// # 988 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template<std::size_t Len>struct __attribute__ ((__aligned__(0x1))) aligned_storage_impl<Len, 0x1>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x1> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x2))) aligned_storage_impl<Len, 0x2>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x2> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x4))) aligned_storage_impl<Len, 0x4>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x4> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x8))) aligned_storage_impl<Len, 0x8>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x8> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x10))) aligned_storage_impl<Len, 0x10>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x10> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x20))) aligned_storage_impl<Len, 0x20>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x20> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x40))) aligned_storage_impl<Len, 0x40>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x40> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x80))) aligned_storage_impl<Len, 0x80>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x80> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x100))) aligned_storage_impl<Len, 0x100>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x100> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x200))) aligned_storage_impl<Len, 0x200>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x200> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x400))) aligned_storage_impl<Len, 0x400>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x400> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x800))) aligned_storage_impl<Len, 0x800>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x800> type;};
template<std::size_t Len>struct __attribute__ ((__aligned__(0x1000))) aligned_storage_impl<Len, 0x1000>{ char dummy[Len]; typedef aligned_storage_impl<Len, 0x1000> type;};
// # 1055 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp"
template<std::size_t Len, std::size_t Align = alignment_of<max_align_t>::value>
struct aligned_storage
{

   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((Align > 0) == 0 ? false : true) >)> boost_static_assert_typedef_1059 __attribute__((unused));


   typedef typename aligned_storage_impl<Len ? Len : 1, Align>::type type;
   static const std::size_t value = alignment_of<type>::value;
   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((value >= Align) == 0 ? false : true) >)> boost_static_assert_typedef_1064 __attribute__((unused));
   typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((value % Align) == 0) == 0 ? false : true) >)> boost_static_assert_typedef_1065 __attribute__((unused));



   private:
   aligned_storage();
};

}
}

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_end.hpp" 1
// # 1077 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/type_traits.hpp" 2
// # 55 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp" 2
// # 73 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
   namespace boost {






   template <class T>
   class rv
      : public ::boost::move_detail::if_c
         < ::boost::move_detail::is_class<T>::value
         , T
         , ::boost::move_detail::nat
         >::type
   {
      rv();
      ~rv() throw();
      rv(rv const&);
      void operator=(rv const&);
   } __attribute__((__may_alias__));
// # 101 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
   namespace move_detail {

   template <class T>
   struct is_rv


      : integral_constant<bool, ::boost::move_detail::is_rv_impl<T>::value >
   {};

   template <class T>
   struct is_not_rv
   {
      static const bool value = !is_rv<T>::value;
   };

   }






   template<class T>
   struct has_move_emulation_enabled
      : ::boost::move_detail::has_move_emulation_enabled_impl<T>
   {};

   template<class T>
   struct has_move_emulation_disabled
   {
      static const bool value = !::boost::move_detail::has_move_emulation_enabled_impl<T>::value;
   };

   }
// # 192 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
   namespace boost {
   namespace move_detail {

   template <class Ret, class T>
   inline typename ::boost::move_detail::enable_if_c
      < ::boost::move_detail::is_lvalue_reference<Ret>::value ||
        !::boost::has_move_emulation_enabled<T>::value
      , T&>::type
         move_return(T& x)
   {
      return x;
   }

   template <class Ret, class T>
   inline typename ::boost::move_detail::enable_if_c
      < !::boost::move_detail::is_lvalue_reference<Ret>::value &&
         ::boost::has_move_emulation_enabled<T>::value
      , ::boost::rv<T>&>::type
         move_return(T& x)
   {
      return *static_cast< ::boost::rv<T>*>(::boost::move_detail::addressof(x));
   }

   template <class Ret, class T>
   inline typename ::boost::move_detail::enable_if_c
      < !::boost::move_detail::is_lvalue_reference<Ret>::value &&
         ::boost::has_move_emulation_enabled<T>::value
      , ::boost::rv<T>&>::type
         move_return(::boost::rv<T>& x)
   {
      return x;
   }

   }
   }
// # 278 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
   namespace boost{
   namespace move_detail{

   template< class T>
   struct forward_type
   { typedef const T &type; };

   template< class T>
   struct forward_type< boost::rv<T> >
   { typedef T type; };

   }}
// # 495 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_end.hpp" 1
// # 496 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/core.hpp" 2
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp" 2





   namespace boost {

   template<class T>
   struct enable_move_utility_emulation
   {
      static const bool value = true;
   };







   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < T &
      , enable_move_utility_emulation<T>
      , has_move_emulation_disabled<T>
      >::type
         move(T& x)
   {
      return x;
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < rv<T>&
      , enable_move_utility_emulation<T>
      , has_move_emulation_enabled<T>
      >::type
         move(T& x)
   {
      return *static_cast< ::boost::rv<T>*>(::boost::move_detail::addressof(x));
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < rv<T>&
      , enable_move_utility_emulation<T>
      , has_move_emulation_enabled<T>
      >::type
         move(rv<T>& x)
   {
      return x;
   }







   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < T &
      , enable_move_utility_emulation<T>
      , ::boost::move_detail::is_rv<T>
      >::type
         forward(const typename ::boost::move_detail::identity<T>::type &x)
   {
      return const_cast<T&>(x);
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < const T &
      , enable_move_utility_emulation<T>
      , ::boost::move_detail::is_not_rv<T>
      >::type
         forward(const typename ::boost::move_detail::identity<T>::type &x)
   {
      return x;
   }







   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < T &
      , enable_move_utility_emulation<T>
      , ::boost::move_detail::is_rv<T>
      >::type
         move_if_not_lvalue_reference(const typename ::boost::move_detail::identity<T>::type &x)
   {
      return const_cast<T&>(x);
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < typename ::boost::move_detail::add_lvalue_reference<T>::type
      , enable_move_utility_emulation<T>
      , ::boost::move_detail::is_not_rv<T>
      , ::boost::move_detail::or_
         < ::boost::move_detail::is_lvalue_reference<T>
         , has_move_emulation_disabled<T>
         >
      >::type
         move_if_not_lvalue_reference(typename ::boost::move_detail::remove_reference<T>::type &x)
   {
      return x;
   }

   template <class T>
   inline typename ::boost::move_detail::enable_if_and
      < rv<T>&
      , enable_move_utility_emulation<T>
      , ::boost::move_detail::is_not_rv<T>
      , ::boost::move_detail::and_
         < ::boost::move_detail::not_< ::boost::move_detail::is_lvalue_reference<T> >
         , has_move_emulation_enabled<T>
         >
      >::type
         move_if_not_lvalue_reference(typename ::boost::move_detail::remove_reference<T>::type &x)
   {
      return move(x);
   }

   }
// # 301 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp"
namespace boost{
namespace move_detail{

template <typename T>
typename boost::move_detail::add_rvalue_reference<T>::type declval();

}
}




// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_end.hpp" 1
// # 314 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/utility_core.hpp" 2
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp" 2


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 29 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp" 2




namespace boost{
namespace move_upd {

namespace bmupmu = ::boost::move_upmu;
// # 45 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp"
template<class U, class T>
struct def_del_compatible_cond
   : bmupmu::is_convertible<U*, T*>
{};

template<class U, class T, std::size_t N>
struct def_del_compatible_cond<U[N], T[]>
   : def_del_compatible_cond<U[], T[]>
{};

template<class U, class T, class Type = bmupmu::nat>
struct enable_def_del
   : bmupmu::enable_if_c<def_del_compatible_cond<U, T>::value, Type>
{};
// # 68 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp"
template<class U, class T, class Type = bmupmu::nat>
struct enable_defdel_call
   : public enable_def_del<U, T, Type>
{};

template<class U, class T, class Type>
struct enable_defdel_call<U, T[], Type>
   : public enable_def_del<U[], T[], Type>
{};

template<class U, class T, class Type, std::size_t N>
struct enable_defdel_call<U, T[N], Type>
   : public enable_def_del<U[N], T[N], Type>
{};





struct bool_conversion {int for_bool; int for_arg(); };
typedef int bool_conversion::* explicit_bool_arg;






   typedef int (bool_conversion::*nullptr_type)();


}

namespace movelib {

namespace bmupd = boost::move_upd;
namespace bmupmu = ::boost::move_upmu;





template <class T>
struct default_delete
{


   default_delete()







   {};






   typedef typename bmupmu::remove_extent<T>::type element_type;







   template <class U>
   default_delete(const default_delete<U>&
      , typename bmupd::enable_def_del<U , T>::type* =0
      )
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor<default_delete, U>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_144 __attribute__((unused));
   }






   template <class U>
   typename bmupd::enable_def_del<U , T , default_delete &>::type

      operator=(const default_delete<U>&)
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor<default_delete, U>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_159 __attribute__((unused));
      return *this;
   }
// # 171 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp"
   template <class U>
   typename bmupd::enable_defdel_call<U , T , void>::type
      operator()(U* ptr) const
   {

      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(U) > 0) == 0 ? false : true) >)> boost_static_assert_typedef_176 __attribute__((unused));


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor<default_delete, U>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_179 __attribute__((unused));
      element_type * const p = static_cast<element_type*>(ptr);
      bmupmu::is_array<T>::value ? delete [] p : delete p;
   }



   void operator()(bmupd::nullptr_type) const
   { typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((sizeof(element_type) > 0) == 0 ? false : true) >)> boost_static_assert_typedef_187 __attribute__((unused)); }
};

}
}

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_end.hpp" 1
// # 194 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/default_delete.hpp" 2
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp"
         






// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp" 2
// # 57 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp"
namespace boost_move_member_swap {

struct dont_care
{
   dont_care(...);
};

struct private_type
{
   static private_type p;
   private_type const &operator,(int) const;
};

typedef char yes_type;
struct no_type{ char dummy[2]; };

template<typename T>
no_type is_private_type(T const &);

yes_type is_private_type(private_type const &);

template <typename Type>
class has_member_function_named_swap
{
   struct BaseMixin
   {
      void swap();
   };

   struct Base : public Type, public BaseMixin { Base(); };
   template <typename T, T t> class Helper{};

   template <typename U>
   static no_type deduce(U*, Helper<void (BaseMixin::*)(), &U::swap>* = 0);
   static yes_type deduce(...);

   public:
   static const bool value = sizeof(yes_type) == sizeof(deduce((Base*)(0)));
};

template<typename Fun, bool HasFunc>
struct has_member_swap_impl
{
   static const bool value = false;
};

template<typename Fun>
struct has_member_swap_impl<Fun, true>
{
   struct FunWrap : Fun
   {
      FunWrap();

      using Fun::swap;
      private_type swap(dont_care) const;
   };

   static Fun &declval_fun();
   static FunWrap declval_wrap();

   static bool const value =
      sizeof(no_type) == sizeof(is_private_type( (declval_wrap().swap(declval_fun()), 0)) );
};

template<typename Fun>
struct has_member_swap : public has_member_swap_impl
      <Fun, has_member_function_named_swap<Fun>::value>
{};

}

namespace boost_move_adl_swap{

template<class P1, class P2, bool = P1::value>
struct and_op_impl
{ static const bool value = false; };

template<class P1, class P2>
struct and_op_impl<P1, P2, true>
{ static const bool value = P2::value; };

template<class P1, class P2>
struct and_op
   : and_op_impl<P1, P2>
{};



template<class P1, class P2, bool = P1::value>
struct and_op_not_impl
{ static const bool value = false; };

template<class P1, class P2>
struct and_op_not_impl<P1, P2, true>
{ static const bool value = !P2::value; };

template<class P1, class P2>
struct and_op_not
   : and_op_not_impl<P1, P2>
{};

template<class T>
void swap_proxy(T& x, T& y, typename boost::move_detail::enable_if_c<!boost::move_detail::has_move_emulation_enabled_impl<T>::value>::type* = 0)
{



   using namespace std;
   swap(x, y);
}

template<class T>
void swap_proxy(T& x, T& y
               , typename boost::move_detail::enable_if< and_op_not_impl<boost::move_detail::has_move_emulation_enabled_impl<T>
                                                                        , boost_move_member_swap::has_member_swap<T> >
                                                       >::type* = 0)
{ T t(::boost::move(x)); x = ::boost::move(y); y = ::boost::move(t); }

template<class T>
void swap_proxy(T& x, T& y
               , typename boost::move_detail::enable_if< and_op_impl< boost::move_detail::has_move_emulation_enabled_impl<T>
                                                                    , boost_move_member_swap::has_member_swap<T> >
                                                       >::type* = 0)
{ x.swap(y); }

}
// # 199 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp"
namespace boost_move_adl_swap{

template<class T, std::size_t N>
void swap_proxy(T (& x)[N], T (& y)[N])
{
   for (std::size_t i = 0; i < N; ++i){
      ::boost_move_adl_swap::swap_proxy(x[i], y[i]);
   }
}

}



namespace boost{
// # 225 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/adl_move_swap.hpp"
template<class T>
void adl_move_swap(T& x, T& y)
{
   ::boost_move_adl_swap::swap_proxy(x, y);
}

}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp" 1
// # 54 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp"
// # 1 "/usr/include/assert.h" 1 3 4
// # 65 "/usr/include/assert.h" 3 4
extern "C" {


extern void __assert_fail (const char *__assertion, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));


extern void __assert_perror_fail (int __errnum, const char *__file,
      unsigned int __line, const char *__function)
     throw () __attribute__ ((__noreturn__));




extern void __assert (const char *__assertion, const char *__file, int __line)
     throw () __attribute__ ((__noreturn__));


}
// # 55 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/assert.hpp" 2
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2

// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 1 3
// # 39 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3
       
// # 40 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 3


// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/lib/gcc/x86_64-unknown-linux-gnu/4.8.4/include/stddef.h" 1 3 4
// # 42 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/cstddef" 2 3
// # 32 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2
// # 48 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
namespace boost{
namespace move_upd {





template <class T>
class is_noncopyable
{
   typedef char true_t;
   class false_t { char dummy[2]; };
   template<class U> static false_t dispatch(...);
   template<class U> static true_t dispatch(typename U::boost_move_no_copy_constructor_or_assign*);
   public:
   static const bool value = sizeof(dispatch<T>(0)) == sizeof(true_t);
};


template <class D>
struct deleter_types
{
   typedef typename bmupmu::add_lvalue_reference<D>::type del_ref;
   typedef typename bmupmu::add_const_lvalue_reference<D>::type del_cref;





   typedef typename bmupmu::if_c
      < is_noncopyable<D>::value, bmupmu::nat, del_cref>::type non_ref_deleter_arg1;
   typedef typename bmupmu::if_c< bmupmu::is_lvalue_reference<D>::value
                       , D, non_ref_deleter_arg1 >::type deleter_arg_type1;
   typedef ::boost::rv<D> & deleter_arg_type2;

};




template <class P, class D, bool = bmupmu::is_unary_function<D>::value || bmupmu::is_reference<D>::value >
struct unique_ptr_data
{
   typedef typename deleter_types<D>::deleter_arg_type1 deleter_arg_type1;
   typedef typename deleter_types<D>::del_ref del_ref;
   typedef typename deleter_types<D>::del_cref del_cref;

   unique_ptr_data()
      : m_p(), d()
   {}

   explicit unique_ptr_data(P p)
      : m_p(p), d()
   {}

   unique_ptr_data(P p, deleter_arg_type1 d1)
      : m_p(p), d(d1)
   {}

   template <class U>
   unique_ptr_data(P p, const U & d1)
      : m_p(p), d(::boost::forward<U>(d1))
   {}

   del_ref deleter() { return d; }
   del_cref deleter() const{ return d; }

   P m_p;
   D d;

   private:
   unique_ptr_data& operator=(const unique_ptr_data&);
   unique_ptr_data(const unique_ptr_data&);
};

template <class P, class D>
struct unique_ptr_data<P, D, false>
   : private D
{
   typedef typename deleter_types<D>::deleter_arg_type1 deleter_arg_type1;
   typedef typename deleter_types<D>::del_ref del_ref;
   typedef typename deleter_types<D>::del_cref del_cref;

   unique_ptr_data()
      : D(), m_p()
   {}

   explicit unique_ptr_data(P p)
      : D(), m_p(p)
   {}

   unique_ptr_data(P p, deleter_arg_type1 d1)
      : D(d1), m_p(p)
   {}

   template <class U>
   unique_ptr_data(P p, const U & d)
      : D(::boost::forward<U>(d)), m_p(p)
   {}

   del_ref deleter() { return static_cast<del_ref>(*this); }
   del_cref deleter() const { return static_cast<del_cref>(*this); }

   P m_p;

   private:
   unique_ptr_data& operator=(const unique_ptr_data&);
   unique_ptr_data(const unique_ptr_data&);
};







template <typename T>
struct get_element_type
{
   struct DefaultWrap { typedef bmupmu::natify<T> element_type; };
   template <typename X> static char test(int, typename X::element_type*);
   template <typename X> static int test(...);
   static const bool value = (1 == sizeof(test<T>(0, 0)));
   typedef typename bmupmu::if_c<value, T, DefaultWrap>::type::element_type type;
};

template<class T>
struct get_element_type<T*>
{
   typedef T type;
};

template<class T>
struct get_cvelement
   : bmupmu::remove_cv<typename get_element_type<T>::type>
{};

template <class P1, class P2>
struct is_same_cvelement_and_convertible
{
   typedef typename bmupmu::remove_reference<P1>::type arg1;
   typedef typename bmupmu::remove_reference<P2>::type arg2;
   static const bool same_cvless =
      bmupmu::is_same<typename get_cvelement<arg1>::type,typename get_cvelement<arg2>::type>::value;
   static const bool value = same_cvless && bmupmu::is_convertible<arg1, arg2>::value;
};

template<bool IsArray, class FromPointer, class ThisPointer>
struct is_unique_ptr_convertible
   : is_same_cvelement_and_convertible<FromPointer, ThisPointer>
{};

template<class FromPointer, class ThisPointer>
struct is_unique_ptr_convertible<false, FromPointer, ThisPointer>
   : bmupmu::is_convertible<FromPointer, ThisPointer>
{};





template<class T, class FromPointer, class ThisPointer, class Type = bmupmu::nat>
struct enable_up_ptr
   : bmupmu::enable_if_c< is_unique_ptr_convertible
      < bmupmu::is_array<T>::value, FromPointer, ThisPointer>::value, Type>
{};





template<class T, class D, class U, class E>
struct unique_moveconvert_assignable
{
   static const bool t_is_array = bmupmu::is_array<T>::value;
   static const bool value =
      t_is_array == bmupmu::is_array<U>::value &&
      bmupmu::extent<T>::value == bmupmu::extent<U>::value &&
      is_unique_ptr_convertible
         < t_is_array
         , typename bmupmu::pointer_type<U, E>::type, typename bmupmu::pointer_type<T, D>::type
         >::value;
};

template<class T, class D, class U, class E, std::size_t N>
struct unique_moveconvert_assignable<T[], D, U[N], E>
   : unique_moveconvert_assignable<T[], D, U[], E>
{};

template<class T, class D, class U, class E, class Type = bmupmu::nat>
struct enable_up_moveconv_assign
   : bmupmu::enable_if_c<unique_moveconvert_assignable<T, D, U, E>::value, Type>
{};





template<class D, class E, bool IsReference = bmupmu::is_reference<D>::value>
struct unique_deleter_is_initializable
   : bmupmu::is_same<D, E>
{};

template <class T, class U>
class is_rvalue_convertible
{



   typedef typename bmupmu::if_c
      < ::boost::has_move_emulation_enabled<T>::value && !bmupmu::is_reference<T>::value
      , ::boost::rv<T>&
      , typename bmupmu::add_lvalue_reference<T>::type
      >::type t_from;


   typedef char true_t;
   class false_t { char dummy[2]; };
   static false_t dispatch(...);
   static true_t dispatch(U);
   static t_from trigger();
   public:
   static const bool value = sizeof(dispatch(trigger())) == sizeof(true_t);
};

template<class D, class E>
struct unique_deleter_is_initializable<D, E, false>
{
// # 292 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   static const bool value = true;

};

template<class T, class D, class U, class E, class Type = bmupmu::nat>
struct enable_up_moveconv_constr
   : bmupmu::enable_if_c
      < unique_moveconvert_assignable<T, D, U, E>::value && unique_deleter_is_initializable<D, E>::value
      , Type>
{};

}

namespace movelib {
// # 351 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
template <class T, class D = default_delete<T> >
class unique_ptr
{






   private: unique_ptr(unique_ptr &); unique_ptr& operator=(unique_ptr &); public: typedef int boost_move_no_copy_constructor_or_assign; private: public: operator ::boost::rv<unique_ptr>&() { return *static_cast< ::boost::rv<unique_ptr>*>(this); } operator const ::boost::rv<unique_ptr>&() const { return *static_cast<const ::boost::rv<unique_ptr>*>(this); } private:

   typedef bmupmu::pointer_type<T, D > pointer_type_obtainer;
   typedef bmupd::unique_ptr_data
      <typename pointer_type_obtainer::type, D> data_type;
   typedef typename bmupd::deleter_types<D>::deleter_arg_type1 deleter_arg_type1;
   typedef typename bmupd::deleter_types<D>::deleter_arg_type2 deleter_arg_type2;
   data_type m_data;


   public:



   typedef typename pointer_type_obtainer::type pointer;


   typedef typename bmupmu::remove_extent<T>::type element_type;
   typedef D deleter_type;
// # 390 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   unique_ptr()
      : m_data()
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_pointer<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_395 __attribute__((unused));
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_reference<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_396 __attribute__((unused));
   }



   unique_ptr(bmupd::nullptr_type)
      : m_data()
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_pointer<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_406 __attribute__((unused));
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_reference<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_407 __attribute__((unused));
   }
// # 423 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template<class Pointer>
   explicit unique_ptr(Pointer p
      , typename bmupd::enable_up_ptr<T , Pointer , pointer>::type* =0
                 )
      : m_data(p)
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor <D, typename bmupd::get_element_type<Pointer>::type>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_432 __attribute__((unused))
                                                                                          ;


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_pointer<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_435 __attribute__((unused));
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((!bmupmu::is_reference<D>::value) == 0 ? false : true) >)> boost_static_assert_typedef_436 __attribute__((unused));
   }
// # 461 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template<class Pointer>
   unique_ptr(Pointer p, deleter_arg_type1 d1
      , typename bmupd::enable_up_ptr<T , Pointer , pointer>::type* =0
              )
      : m_data(p, d1)
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor <D, typename bmupd::get_element_type<Pointer>::type>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_470 __attribute__((unused))
                                                                                          ;
   }



   unique_ptr(bmupd::nullptr_type, deleter_arg_type1 d1)
      : m_data(pointer(), d1)
   {}
// # 499 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template<class Pointer>
   unique_ptr(Pointer p, deleter_arg_type2 d2
      , typename bmupd::enable_up_ptr<T , Pointer , pointer>::type* =0
             )
      : m_data(p, ::boost::move(d2))
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor <D, typename bmupd::get_element_type<Pointer>::type>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_508 __attribute__((unused))
                                                                                          ;
   }



   unique_ptr(bmupd::nullptr_type, deleter_arg_type2 d2)
      : m_data(pointer(), ::boost::move(d2))
   {}
// # 527 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   unique_ptr(::boost::rv< unique_ptr >& u)
      : m_data(u.release(), ::boost::move_if_not_lvalue_reference<D>(u.get_deleter()))
   {}
// # 546 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template <class U, class E>
   unique_ptr( unique_ptr<U, E> u
      , typename bmupd::enable_up_moveconv_constr<T , D , U , E>::type* =0
      )
      : m_data(u.release(), ::boost::move_if_not_lvalue_reference<E>(u.get_deleter()))
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor <D, typename unique_ptr<U, E>::pointer>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_555 __attribute__((unused))
                                                                             ;
   }







   ~unique_ptr()
   { if(m_data.m_p) m_data.deleter()(m_data.m_p); }
// # 576 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   unique_ptr& operator=(::boost::rv< unique_ptr >& u)
   {
      this->reset(u.release());
      m_data.deleter() = ::boost::move_if_not_lvalue_reference<D>(u.get_deleter());
      return *this;
   }
// # 595 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template <class U, class E>
   typename bmupd::enable_up_moveconv_assign <T , D , U , E , unique_ptr &>::type

      operator=(::boost::rv< unique_ptr<U, E> >& u)
   {
      this->reset(u.release());
      m_data.deleter() = ::boost::move_if_not_lvalue_reference<E>(u.get_deleter());
      return *this;
   }






   unique_ptr& operator=(bmupd::nullptr_type)
   { this->reset(); return *this; }






   typename bmupmu::add_lvalue_reference<element_type>::type
      operator*() const
   {
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((!bmupmu::is_array<T>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_621 __attribute__((unused));
      return *m_data.m_p;
   }






   typename bmupmu::add_lvalue_reference<element_type>::type
      operator[](std::size_t i) const
   {
      ((bmupmu::extent<T>::value == 0 || i < bmupmu::extent<T>::value) ? static_cast<void> (0) : __assert_fail ("bmupmu::extent<T>::value == 0 || i < bmupmu::extent<T>::value", "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp", 633, __PRETTY_FUNCTION__));
      ((m_data.m_p) ? static_cast<void> (0) : __assert_fail ("m_data.m_p", "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp", 634, __PRETTY_FUNCTION__));
      return m_data.m_p[i];
   }
// # 645 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   pointer operator->() const
   {
      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< (((!bmupmu::is_array<T>::value)) == 0 ? false : true) >)> boost_static_assert_typedef_647 __attribute__((unused));
      ((m_data.m_p) ? static_cast<void> (0) : __assert_fail ("m_data.m_p", "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp", 648, __PRETTY_FUNCTION__));
      return m_data.m_p;
   }



   pointer get() const
   { return m_data.m_p; }



   typename bmupmu::add_lvalue_reference<D>::type
      get_deleter()
   { return m_data.deleter(); }



   typename bmupmu::add_const_lvalue_reference<D>::type
      get_deleter() const
   { return m_data.deleter(); }






   operator bmupd::explicit_bool_arg

      ()const
   {
      return m_data.m_p
         ? &bmupd::bool_conversion::for_bool
         : bmupd::explicit_bool_arg(0);
   }




   pointer release()
   {
      const pointer tmp = m_data.m_p;
      m_data.m_p = pointer();
      return tmp;
   }
// # 706 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   template<class Pointer>
   typename bmupd::enable_up_ptr<T , Pointer , pointer , void>::type
      reset(Pointer p)
   {


      typedef ::boost::static_assert_test< sizeof(::boost::STATIC_ASSERTION_FAILURE< ((( !::boost::move_upmu::missing_virtual_destructor <D, typename bmupd::get_element_type<Pointer>::type>::value )) == 0 ? false : true) >)> boost_static_assert_typedef_713 __attribute__((unused))
                                                                                          ;
      pointer tmp = m_data.m_p;
      m_data.m_p = p;
      if(tmp) m_data.deleter()(tmp);
   }
// # 728 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp"
   void reset()
   { this->reset(pointer()); }



   void reset(bmupd::nullptr_type)
   { this->reset(); }




   void swap(unique_ptr& u)
   {
      ::boost::adl_move_swap(m_data.m_p, u.m_data.m_p);
      ::boost::adl_move_swap(m_data.deleter(), u.m_data.deleter());
   }
};



template <class T, class D>
inline void swap(unique_ptr<T, D> &x, unique_ptr<T, D> &y)
{ x.swap(y); }



template <class T1, class D1, class T2, class D2>
inline bool operator==(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return x.get() == y.get(); }



template <class T1, class D1, class T2, class D2>
inline bool operator!=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return x.get() != y.get(); }





template <class T1, class D1, class T2, class D2>
inline bool operator<(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return x.get() < y.get(); }



template <class T1, class D1, class T2, class D2>
inline bool operator<=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return !(y < x); }



template <class T1, class D1, class T2, class D2>
inline bool operator>(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return y < x; }



template <class T1, class D1, class T2, class D2>
inline bool operator>=(const unique_ptr<T1, D1> &x, const unique_ptr<T2, D2> &y)
{ return !(x < y); }



template <class T, class D>
inline bool operator==(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return !x; }



template <class T, class D>
inline bool operator==(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return !x; }



template <class T, class D>
inline bool operator!=(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return !!x; }



template <class T, class D>
inline bool operator!=(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return !!x; }




template <class T, class D>
inline bool operator<(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return x.get() < typename unique_ptr<T, D>::pointer(); }




template <class T, class D>
inline bool operator<(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return typename unique_ptr<T, D>::pointer() < x.get(); }



template <class T, class D>
inline bool operator>(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return x.get() > typename unique_ptr<T, D>::pointer(); }



template <class T, class D>
inline bool operator>(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return typename unique_ptr<T, D>::pointer() > x.get(); }



template <class T, class D>
inline bool operator<=(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return !(bmupd::nullptr_type() < x); }



template <class T, class D>
inline bool operator<=(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return !(x < bmupd::nullptr_type()); }



template <class T, class D>
inline bool operator>=(const unique_ptr<T, D> &x, bmupd::nullptr_type)
{ return !(x < bmupd::nullptr_type()); }



template <class T, class D>
inline bool operator>=(bmupd::nullptr_type, const unique_ptr<T, D> &x)
{ return !(bmupd::nullptr_type() < x); }

}
}

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/detail/config_end.hpp" 1
// # 868 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/boost_1_59_0/boost/move/unique_ptr.hpp" 2
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_key.h" 2

namespace keyring {

struct Key : IKey
{
  Key(const char *a_key_id, const char *a_key_type, const char *a_user_id,
      const void *a_key, size_t a_key_len);
  Key();

  ~Key();

  my_bool load_from_buffer(uchar* buffer, size_t *buffer_position,
                           size_t input_buffer_size);
  void store_in_buffer(uchar* buffer, size_t *buffer_position) const;
  std::string* get_key_signature() const;
  std::string* get_key_type();
  uchar* get_key_data();
  size_t get_key_data_size();
  size_t get_key_pod_size() const;
  uchar* release_key_data();
  void xor_data();
  void set_key_data(uchar *key_data, size_t key_data_size);
  void set_key_type(const std::string *key_type);
  my_bool is_key_type_valid();
  my_bool is_key_id_valid();
  my_bool is_key_valid();

private:
  Key(const Key& other);
  void create_key_signature() const;
  my_bool load_string_from_buffer(const uchar *buffer, size_t *buffer_position,
                                  size_t key_pod_size, std::string *string,
                                  size_t string_length);
  inline void store_field_length(uchar *buffer, size_t *buffer_position,
                                 size_t length) const;
  inline void store_field(uchar *buffer, size_t *buffer_position,
                          const char *field, size_t field_length) const;
  my_bool load_field_size(const uchar *buffer, size_t *buffer_position,
                          size_t key_pod_size, size_t *field_length);
protected:
  std::string key_id;
  std::string key_type;
  std::string user_id;
  boost::movelib::unique_ptr<uchar[]> key;
  size_t key_len;
  mutable std::string key_signature;
};

}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_io.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_io.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serializer.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serializer.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serialized_object.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serialized_object.h"
namespace keyring
{
  enum Key_operation
  {
    STORE_KEY,
    REMOVE_KEY,
    NONE
  };

  class ISerialized_object
  {
  public:
    ISerialized_object() : key_operation(NONE)
    {}

    virtual my_bool get_next_key(IKey **key)= 0;
    virtual my_bool has_next_key()= 0;
    virtual Key_operation get_key_operation()
    {
      return key_operation;
    }
    virtual void set_key_operation(Key_operation key_operation)
    {
      this->key_operation= key_operation;
    }

    virtual ~ISerialized_object()
    {}

  protected:
    Key_operation key_operation;
  };
}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serializer.h" 2

namespace keyring
{

  class ISerializer
  {
  public:
// # 43 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serializer.h"
    virtual ISerialized_object* serialize(HASH *keys_hash, IKey *key,
                                          Key_operation operation)= 0;
    virtual ~ISerializer()
    {}
  };
}
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_io.h" 2

namespace keyring {


class IKeyring_io : public Keyring_alloc
{
public:
  virtual my_bool init(std::string *keyring_storage_url)= 0;
  virtual my_bool flush_to_backup(ISerialized_object *serialized_object)= 0;
  virtual my_bool flush_to_storage(ISerialized_object *serialized_object)=0;

  virtual ISerializer *get_serializer()= 0;
  virtual my_bool get_serialized_object(ISerialized_object **serialized_object)= 0;
  virtual my_bool has_next_serialized_object()= 0;

  virtual ~IKeyring_io() {}
};

}
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/logger.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/logger.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h"
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 1 3
// # 58 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 3
       
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 3





// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 1 3
// # 66 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename _Tp, typename _Alloc>
    struct _Vector_base
    {
      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
        rebind<_Tp>::other _Tp_alloc_type;
      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
        pointer;

      struct _Vector_impl
      : public _Tp_alloc_type
      {
 pointer _M_start;
 pointer _M_finish;
 pointer _M_end_of_storage;

 _Vector_impl()
 : _Tp_alloc_type(), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }

 _Vector_impl(_Tp_alloc_type const& __a)
 : _Tp_alloc_type(__a), _M_start(0), _M_finish(0), _M_end_of_storage(0)
 { }
// # 101 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
 void _M_swap_data(_Vector_impl& __x)
 {
   std::swap(_M_start, __x._M_start);
   std::swap(_M_finish, __x._M_finish);
   std::swap(_M_end_of_storage, __x._M_end_of_storage);
 }
      };

    public:
      typedef _Alloc allocator_type;

      _Tp_alloc_type&
      _M_get_Tp_allocator()
      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }

      const _Tp_alloc_type&
      _M_get_Tp_allocator() const
      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Tp_allocator()); }

      _Vector_base()
      : _M_impl() { }

      _Vector_base(const allocator_type& __a)
      : _M_impl(__a) { }

      _Vector_base(size_t __n)
      : _M_impl()
      { _M_create_storage(__n); }

      _Vector_base(size_t __n, const allocator_type& __a)
      : _M_impl(__a)
      { _M_create_storage(__n); }
// # 159 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      ~_Vector_base()
      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
        - this->_M_impl._M_start); }

    public:
      _Vector_impl _M_impl;

      pointer
      _M_allocate(size_t __n)
      { return __n != 0 ? _M_impl.allocate(__n) : 0; }

      void
      _M_deallocate(pointer __p, size_t __n)
      {
 if (__p)
   _M_impl.deallocate(__p, __n);
      }

    private:
      void
      _M_create_storage(size_t __n)
      {
 this->_M_impl._M_start = this->_M_allocate(__n);
 this->_M_impl._M_finish = this->_M_impl._M_start;
 this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
      }
    };
// # 209 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class vector : protected _Vector_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _Vector_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Alloc_traits;

    public:
      typedef _Tp value_type;
      typedef typename _Base::pointer pointer;
      typedef typename _Alloc_traits::const_pointer const_pointer;
      typedef typename _Alloc_traits::reference reference;
      typedef typename _Alloc_traits::const_reference const_reference;
      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
      const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:
      using _Base::_M_allocate;
      using _Base::_M_deallocate;
      using _Base::_M_impl;
      using _Base::_M_get_Tp_allocator;

    public:





      vector()
      : _Base() { }





      explicit
      vector(const allocator_type& __a)
      : _Base(__a) { }
// # 294 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      explicit
      vector(size_type __n, const value_type& __value = value_type(),
      const allocator_type& __a = allocator_type())
      : _Base(__n, __a)
      { _M_fill_initialize(__n, __value); }
// # 310 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      vector(const vector& __x)
      : _Base(__x.size(),
        _Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
      { this->_M_impl._M_finish =
   std::__uninitialized_copy_a(__x.begin(), __x.end(),
          this->_M_impl._M_start,
          _M_get_Tp_allocator());
      }
// # 397 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        vector(_InputIterator __first, _InputIterator __last,
        const allocator_type& __a = allocator_type())
 : _Base(__a)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_initialize_dispatch(__first, __last, _Integral());
 }
// # 414 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      ~vector()
      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
        _M_get_Tp_allocator()); }
// # 426 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      vector&
      operator=(const vector& __x);
// # 478 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
// # 501 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        assign(_InputIterator __first, _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_assign_dispatch(__first, __last, _Integral());
 }
// # 529 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      using _Base::get_allocator;







      iterator
      begin()
      { return iterator(this->_M_impl._M_start); }






      const_iterator
      begin() const
      { return const_iterator(this->_M_impl._M_start); }






      iterator
      end()
      { return iterator(this->_M_impl._M_finish); }






      const_iterator
      end() const
      { return const_iterator(this->_M_impl._M_finish); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const
      { return const_reverse_iterator(begin()); }
// # 644 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      size_type
      size() const
      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }


      size_type
      max_size() const
      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
// # 703 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      resize(size_type __new_size, value_type __x = value_type())
      {
 if (__new_size > size())
   insert(end(), __new_size - size(), __x);
 else if (__new_size < size())
   _M_erase_at_end(this->_M_impl._M_start + __new_size);
      }
// # 724 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      size_type
      capacity() const
      { return size_type(this->_M_impl._M_end_of_storage
    - this->_M_impl._M_start); }





      bool
      empty() const
      { return begin() == end(); }
// # 754 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      reserve(size_type __n);
// # 769 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      reference
      operator[](size_type __n)
      { return *(this->_M_impl._M_start + __n); }
// # 784 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      const_reference
      operator[](size_type __n) const
      { return *(this->_M_impl._M_start + __n); }

    protected:

      void
      _M_range_check(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range(("vector::_M_range_check"));
      }

    public:
// # 809 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      reference
      at(size_type __n)
      {
 _M_range_check(__n);
 return (*this)[__n];
      }
// # 827 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      const_reference
      at(size_type __n) const
      {
 _M_range_check(__n);
 return (*this)[__n];
      }





      reference
      front()
      { return *begin(); }





      const_reference
      front() const
      { return *begin(); }





      reference
      back()
      { return *(end() - 1); }





      const_reference
      back() const
      { return *(end() - 1); }
// # 876 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      pointer

      data()
      { return std::__addressof(front()); }




      const_pointer

      data() const
      { return std::__addressof(front()); }
// # 900 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      push_back(const value_type& __x)
      {
 if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
   {
     _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
                              __x);
     ++this->_M_impl._M_finish;
   }
 else



   _M_insert_aux(end(), __x);

      }
// # 936 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      pop_back()
      {
 --this->_M_impl._M_finish;
 _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      }
// # 972 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      iterator
      insert(iterator __position, const value_type& __x);
// # 1022 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      insert(iterator __position, size_type __n, const value_type& __x)
      { _M_fill_insert(__position, __n, __x); }
// # 1048 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _InputIterator>
        void
        insert(iterator __position, _InputIterator __first,
        _InputIterator __last)
        {

   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   _M_insert_dispatch(__position, __first, __last, _Integral());
 }
// # 1074 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __position);
// # 1095 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      iterator
      erase(iterator __first, iterator __last);
// # 1107 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      swap(vector& __x)



      {
 this->_M_impl._M_swap_data(__x._M_impl);
 _Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
                           __x._M_get_Tp_allocator());
      }







      void
      clear()
      { _M_erase_at_end(this->_M_impl._M_start); }

    protected:




      template<typename _ForwardIterator>
        pointer
        _M_allocate_and_copy(size_type __n,
        _ForwardIterator __first, _ForwardIterator __last)
        {
   pointer __result = this->_M_allocate(__n);
   try
     {
       std::__uninitialized_copy_a(__first, __last, __result,
       _M_get_Tp_allocator());
       return __result;
     }
   catch(...)
     {
       _M_deallocate(__result, __n);
       throw;
     }
 }
// # 1159 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
        {
   this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
   this->_M_impl._M_end_of_storage =
     this->_M_impl._M_start + static_cast<size_type>(__n);
   _M_fill_initialize(static_cast<size_type>(__n), __value);
 }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_initialize(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_initialize(_InputIterator __first,
       _InputIterator __last, std::input_iterator_tag)
        {
   for (; __first != __last; ++__first)



     push_back(*__first);

 }


      template<typename _ForwardIterator>
        void
        _M_range_initialize(_ForwardIterator __first,
       _ForwardIterator __last, std::forward_iterator_tag)
        {
   const size_type __n = std::distance(__first, __last);
   this->_M_impl._M_start = this->_M_allocate(__n);
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
   this->_M_impl._M_finish =
     std::__uninitialized_copy_a(__first, __last,
     this->_M_impl._M_start,
     _M_get_Tp_allocator());
 }



      void
      _M_fill_initialize(size_type __n, const value_type& __value)
      {
 std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
          _M_get_Tp_allocator());
 this->_M_impl._M_finish = this->_M_impl._M_end_of_storage;
      }
// # 1237 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_assign_aux(__first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_assign_aux(_InputIterator __first, _InputIterator __last,
        std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
        std::forward_iterator_tag);



      void
      _M_fill_assign(size_type __n, const value_type& __val);
// # 1277 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      template<typename _Integer>
        void
        _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
      __true_type)
        { _M_fill_insert(__pos, __n, __val); }


      template<typename _InputIterator>
        void
        _M_insert_dispatch(iterator __pos, _InputIterator __first,
      _InputIterator __last, __false_type)
        {
   typedef typename std::iterator_traits<_InputIterator>::
     iterator_category _IterCategory;
   _M_range_insert(__pos, __first, __last, _IterCategory());
 }


      template<typename _InputIterator>
        void
        _M_range_insert(iterator __pos, _InputIterator __first,
   _InputIterator __last, std::input_iterator_tag);


      template<typename _ForwardIterator>
        void
        _M_range_insert(iterator __pos, _ForwardIterator __first,
   _ForwardIterator __last, std::forward_iterator_tag);



      void
      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
// # 1322 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      void
      _M_insert_aux(iterator __position, const value_type& __x);
// # 1335 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
      size_type
      _M_check_len(size_type __n, const char* __s) const
      {
 if (max_size() - size() < __n)
   __throw_length_error((__s));

 const size_type __len = size() + std::max(size(), __n);
 return (__len < size() || __len > max_size()) ? max_size() : __len;
      }





      void
      _M_erase_at_end(pointer __pos)
      {
 std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
 this->_M_impl._M_finish = __pos;
      }
// # 1389 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
    };
// # 1402 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return (__x.size() == __y.size()
       && std::equal(__x.begin(), __x.end(), __y.begin())); }
// # 1419 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_vector.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
// # 65 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 2 3
// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 1 3
// # 63 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef unsigned long _Bit_type;
  enum { _S_word_bit = int(8 * sizeof(_Bit_type)) };

  struct _Bit_reference
  {
    _Bit_type * _M_p;
    _Bit_type _M_mask;

    _Bit_reference(_Bit_type * __x, _Bit_type __y)
    : _M_p(__x), _M_mask(__y) { }

    _Bit_reference() : _M_p(0), _M_mask(0) { }

    operator bool() const
    { return !!(*_M_p & _M_mask); }

    _Bit_reference&
    operator=(bool __x)
    {
      if (__x)
 *_M_p |= _M_mask;
      else
 *_M_p &= ~_M_mask;
      return *this;
    }

    _Bit_reference&
    operator=(const _Bit_reference& __x)
    { return *this = bool(__x); }

    bool
    operator==(const _Bit_reference& __x) const
    { return bool(*this) == bool(__x); }

    bool
    operator<(const _Bit_reference& __x) const
    { return !bool(*this) && bool(__x); }

    void
    flip()
    { *_M_p ^= _M_mask; }
  };
// # 136 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
  struct _Bit_iterator_base
  : public std::iterator<std::random_access_iterator_tag, bool>
  {
    _Bit_type * _M_p;
    unsigned int _M_offset;

    _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
    : _M_p(__x), _M_offset(__y) { }

    void
    _M_bump_up()
    {
      if (_M_offset++ == int(_S_word_bit) - 1)
 {
   _M_offset = 0;
   ++_M_p;
 }
    }

    void
    _M_bump_down()
    {
      if (_M_offset-- == 0)
 {
   _M_offset = int(_S_word_bit) - 1;
   --_M_p;
 }
    }

    void
    _M_incr(ptrdiff_t __i)
    {
      difference_type __n = __i + _M_offset;
      _M_p += __n / int(_S_word_bit);
      __n = __n % int(_S_word_bit);
      if (__n < 0)
 {
   __n += int(_S_word_bit);
   --_M_p;
 }
      _M_offset = static_cast<unsigned int>(__n);
    }

    bool
    operator==(const _Bit_iterator_base& __i) const
    { return _M_p == __i._M_p && _M_offset == __i._M_offset; }

    bool
    operator<(const _Bit_iterator_base& __i) const
    {
      return _M_p < __i._M_p
      || (_M_p == __i._M_p && _M_offset < __i._M_offset);
    }

    bool
    operator!=(const _Bit_iterator_base& __i) const
    { return !(*this == __i); }

    bool
    operator>(const _Bit_iterator_base& __i) const
    { return __i < *this; }

    bool
    operator<=(const _Bit_iterator_base& __i) const
    { return !(__i < *this); }

    bool
    operator>=(const _Bit_iterator_base& __i) const
    { return !(*this < __i); }
  };

  inline ptrdiff_t
  operator-(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
  {
    return (int(_S_word_bit) * (__x._M_p - __y._M_p)
     + __x._M_offset - __y._M_offset);
  }

  struct _Bit_iterator : public _Bit_iterator_base
  {
    typedef _Bit_reference reference;
    typedef _Bit_reference* pointer;
    typedef _Bit_iterator iterator;

    _Bit_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    reference
    operator*() const
    { return reference(_M_p, 1UL << _M_offset); }

    iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    iterator
    operator++(int)
    {
      iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    iterator
    operator--(int)
    {
      iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    iterator
    operator+(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp += __i;
    }

    iterator
    operator-(difference_type __i) const
    {
      iterator __tmp = *this;
      return __tmp -= __i;
    }

    reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_iterator
  operator+(ptrdiff_t __n, const _Bit_iterator& __x)
  { return __x + __n; }

  struct _Bit_const_iterator : public _Bit_iterator_base
  {
    typedef bool reference;
    typedef bool const_reference;
    typedef const bool* pointer;
    typedef _Bit_const_iterator const_iterator;

    _Bit_const_iterator() : _Bit_iterator_base(0, 0) { }

    _Bit_const_iterator(_Bit_type * __x, unsigned int __y)
    : _Bit_iterator_base(__x, __y) { }

    _Bit_const_iterator(const _Bit_iterator& __x)
    : _Bit_iterator_base(__x._M_p, __x._M_offset) { }

    const_reference
    operator*() const
    { return _Bit_reference(_M_p, 1UL << _M_offset); }

    const_iterator&
    operator++()
    {
      _M_bump_up();
      return *this;
    }

    const_iterator
    operator++(int)
    {
      const_iterator __tmp = *this;
      _M_bump_up();
      return __tmp;
    }

    const_iterator&
    operator--()
    {
      _M_bump_down();
      return *this;
    }

    const_iterator
    operator--(int)
    {
      const_iterator __tmp = *this;
      _M_bump_down();
      return __tmp;
    }

    const_iterator&
    operator+=(difference_type __i)
    {
      _M_incr(__i);
      return *this;
    }

    const_iterator&
    operator-=(difference_type __i)
    {
      *this += -__i;
      return *this;
    }

    const_iterator
    operator+(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp += __i;
    }

    const_iterator
    operator-(difference_type __i) const
    {
      const_iterator __tmp = *this;
      return __tmp -= __i;
    }

    const_reference
    operator[](difference_type __i) const
    { return *(*this + __i); }
  };

  inline _Bit_const_iterator
  operator+(ptrdiff_t __n, const _Bit_const_iterator& __x)
  { return __x + __n; }

  inline void
  __fill_bvector(_Bit_iterator __first, _Bit_iterator __last, bool __x)
  {
    for (; __first != __last; ++__first)
      *__first = __x;
  }

  inline void
  fill(_Bit_iterator __first, _Bit_iterator __last, const bool& __x)
  {
    if (__first._M_p != __last._M_p)
      {
 std::fill(__first._M_p + 1, __last._M_p, __x ? ~0 : 0);
 __fill_bvector(__first, _Bit_iterator(__first._M_p + 1, 0), __x);
 __fill_bvector(_Bit_iterator(__last._M_p, 0), __last, __x);
      }
    else
      __fill_bvector(__first, __last, __x);
  }

  template<typename _Alloc>
    struct _Bvector_base
    {
      typedef typename _Alloc::template rebind<_Bit_type>::other
        _Bit_alloc_type;

      struct _Bvector_impl
      : public _Bit_alloc_type
      {
 _Bit_iterator _M_start;
 _Bit_iterator _M_finish;
 _Bit_type* _M_end_of_storage;

 _Bvector_impl()
 : _Bit_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }

 _Bvector_impl(const _Bit_alloc_type& __a)
 : _Bit_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage(0)
 { }







      };

    public:
      typedef _Alloc allocator_type;

      _Bit_alloc_type&
      _M_get_Bit_allocator()
      { return *static_cast<_Bit_alloc_type*>(&this->_M_impl); }

      const _Bit_alloc_type&
      _M_get_Bit_allocator() const
      { return *static_cast<const _Bit_alloc_type*>(&this->_M_impl); }

      allocator_type
      get_allocator() const
      { return allocator_type(_M_get_Bit_allocator()); }

      _Bvector_base()
      : _M_impl() { }

      _Bvector_base(const allocator_type& __a)
      : _M_impl(__a) { }
// # 465 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
      ~_Bvector_base()
      { this->_M_deallocate(); }

    protected:
      _Bvector_impl _M_impl;

      _Bit_type*
      _M_allocate(size_t __n)
      { return _M_impl.allocate(_S_nword(__n)); }

      void
      _M_deallocate()
      {
 if (_M_impl._M_start._M_p)
   _M_impl.deallocate(_M_impl._M_start._M_p,
        _M_impl._M_end_of_storage - _M_impl._M_start._M_p);
      }

      static size_t
      _S_nword(size_t __n)
      { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    };


}




namespace std __attribute__ ((__visibility__ ("default")))
{

// # 517 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
template<typename _Alloc>
  class vector<bool, _Alloc> : protected _Bvector_base<_Alloc>
  {
    typedef _Bvector_base<_Alloc> _Base;





  public:
    typedef bool value_type;
    typedef size_t size_type;
    typedef ptrdiff_t difference_type;
    typedef _Bit_reference reference;
    typedef bool const_reference;
    typedef _Bit_reference* pointer;
    typedef const bool* const_pointer;
    typedef _Bit_iterator iterator;
    typedef _Bit_const_iterator const_iterator;
    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
    typedef std::reverse_iterator<iterator> reverse_iterator;
    typedef _Alloc allocator_type;

    allocator_type get_allocator() const
    { return _Base::get_allocator(); }

  protected:
    using _Base::_M_allocate;
    using _Base::_M_deallocate;
    using _Base::_S_nword;
    using _Base::_M_get_Bit_allocator;

  public:
    vector()
    : _Base() { }

    explicit
    vector(const allocator_type& __a)
    : _Base(__a) { }
// # 572 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    explicit
    vector(size_type __n, const bool& __value = bool(),
    const allocator_type& __a = allocator_type())
    : _Base(__a)
    {
      _M_initialize(__n);
      std::fill(this->_M_impl._M_start._M_p, this->_M_impl._M_end_of_storage,
  __value ? ~0 : 0);
    }


    vector(const vector& __x)
    : _Base(__x._M_get_Bit_allocator())
    {
      _M_initialize(__x.size());
      _M_copy_aligned(__x.begin(), __x.end(), this->_M_impl._M_start);
    }
// # 611 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      vector(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
      : _Base(__a)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_initialize_dispatch(__first, __last, _Integral());
      }


    ~vector() { }

    vector&
    operator=(const vector& __x)
    {
      if (&__x == this)
 return *this;
      if (__x.size() > capacity())
 {
   this->_M_deallocate();
   _M_initialize(__x.size());
 }
      this->_M_impl._M_finish = _M_copy_aligned(__x.begin(), __x.end(),
      begin());
      return *this;
    }
// # 661 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    void
    assign(size_type __n, const bool& __x)
    { _M_fill_assign(__n, __x); }
// # 672 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      assign(_InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_assign_dispatch(__first, __last, _Integral());
      }
// # 687 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    iterator
    begin()
    { return this->_M_impl._M_start; }

    const_iterator
    begin() const
    { return this->_M_impl._M_start; }

    iterator
    end()
    { return this->_M_impl._M_finish; }

    const_iterator
    end() const
    { return this->_M_impl._M_finish; }

    reverse_iterator
    rbegin()
    { return reverse_iterator(end()); }

    const_reverse_iterator
    rbegin() const
    { return const_reverse_iterator(end()); }

    reverse_iterator
    rend()
    { return reverse_iterator(begin()); }

    const_reverse_iterator
    rend() const
    { return const_reverse_iterator(begin()); }
// # 737 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    size_type
    size() const
    { return size_type(end() - begin()); }

    size_type
    max_size() const
    {
      const size_type __isize =
 __gnu_cxx::__numeric_traits<difference_type>::__max
 - int(_S_word_bit) + 1;
      const size_type __asize = _M_get_Bit_allocator().max_size();
      return (__asize <= __isize / int(_S_word_bit)
       ? __asize * int(_S_word_bit) : __isize);
    }

    size_type
    capacity() const
    { return size_type(const_iterator(this->_M_impl._M_end_of_storage, 0)
         - begin()); }

    bool
    empty() const
    { return begin() == end(); }

    reference
    operator[](size_type __n)
    {
      return *iterator(this->_M_impl._M_start._M_p
         + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

    const_reference
    operator[](size_type __n) const
    {
      return *const_iterator(this->_M_impl._M_start._M_p
        + __n / int(_S_word_bit), __n % int(_S_word_bit));
    }

  protected:
    void
    _M_range_check(size_type __n) const
    {
      if (__n >= this->size())
        __throw_out_of_range(("vector<bool>::_M_range_check"));
    }

  public:
    reference
    at(size_type __n)
    { _M_range_check(__n); return (*this)[__n]; }

    const_reference
    at(size_type __n) const
    { _M_range_check(__n); return (*this)[__n]; }

    void
    reserve(size_type __n)
    {
      if (__n > max_size())
 __throw_length_error(("vector::reserve"));
      if (capacity() < __n)
 _M_reallocate(__n);
    }

    reference
    front()
    { return *begin(); }

    const_reference
    front() const
    { return *begin(); }

    reference
    back()
    { return *(end() - 1); }

    const_reference
    back() const
    { return *(end() - 1); }






    void
    data() { }

    void
    push_back(bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(end(), __x);
    }

    void
    swap(vector& __x)
    {
      std::swap(this->_M_impl._M_start, __x._M_impl._M_start);
      std::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);
      std::swap(this->_M_impl._M_end_of_storage,
  __x._M_impl._M_end_of_storage);



      std::__alloc_swap<typename _Base::_Bit_alloc_type>::
 _S_do_it(_M_get_Bit_allocator(), __x._M_get_Bit_allocator());
    }


    static void
    swap(reference __x, reference __y)
    {
      bool __tmp = __x;
      __x = __y;
      __y = __tmp;
    }

    iterator
    insert(iterator __position, const bool& __x = bool())
    {
      const difference_type __n = __position - begin();
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage
   && __position == end())
        *this->_M_impl._M_finish++ = __x;
      else
        _M_insert_aux(__position, __x);
      return begin() + __n;
    }
// # 877 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    template<typename _InputIterator>
      void
      insert(iterator __position,
      _InputIterator __first, _InputIterator __last)
      {
 typedef typename std::__is_integer<_InputIterator>::__type _Integral;
 _M_insert_dispatch(__position, __first, __last, _Integral());
      }


    void
    insert(iterator __position, size_type __n, const bool& __x)
    { _M_fill_insert(__position, __n, __x); }






    void
    pop_back()
    { --this->_M_impl._M_finish; }

    iterator
    erase(iterator __position)
    {
      if (__position + 1 != end())
        std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      return __position;
    }

    iterator
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 _M_erase_at_end(std::copy(__last, end(), __first));
      return __first;
    }

    void
    resize(size_type __new_size, bool __x = bool())
    {
      if (__new_size < size())
        _M_erase_at_end(begin() + difference_type(__new_size));
      else
        insert(end(), __new_size - size(), __x);
    }







    void
    flip()
    {
      for (_Bit_type * __p = this->_M_impl._M_start._M_p;
    __p != this->_M_impl._M_end_of_storage; ++__p)
        *__p = ~*__p;
    }

    void
    clear()
    { _M_erase_at_end(begin()); }


  protected:

    iterator
    _M_copy_aligned(const_iterator __first, const_iterator __last,
      iterator __result)
    {
      _Bit_type* __q = std::copy(__first._M_p, __last._M_p, __result._M_p);
      return std::copy(const_iterator(__last._M_p, 0), __last,
         iterator(__q, 0));
    }

    void
    _M_initialize(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_finish = this->_M_impl._M_start + difference_type(__n);
    }

    void
    _M_reallocate(size_type __n);
// # 977 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/stl_bvector.h" 3
    template<typename _Integer>
      void
      _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
      {
 _M_initialize(static_cast<size_type>(__n));
 std::fill(this->_M_impl._M_start._M_p,
    this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
      }

    template<typename _InputIterator>
      void
      _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
        __false_type)
      { _M_initialize_range(__first, __last,
       std::__iterator_category(__first)); }

    template<typename _InputIterator>
      void
      _M_initialize_range(_InputIterator __first, _InputIterator __last,
     std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   push_back(*__first);
      }

    template<typename _ForwardIterator>
      void
      _M_initialize_range(_ForwardIterator __first, _ForwardIterator __last,
     std::forward_iterator_tag)
      {
 const size_type __n = std::distance(__first, __last);
 _M_initialize(__n);
 std::copy(__first, __last, this->_M_impl._M_start);
      }



    template<typename _Integer>
      void
      _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
      { _M_fill_assign(__n, __val); }

    template<class _InputIterator>
      void
      _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_assign_aux(__first, __last, std::__iterator_category(__first)); }

    void
    _M_fill_assign(size_t __n, bool __x)
    {
      if (__n > size())
 {
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
   insert(end(), __n - size(), __x);
 }
      else
 {
   _M_erase_at_end(begin() + __n);
   std::fill(this->_M_impl._M_start._M_p,
      this->_M_impl._M_end_of_storage, __x ? ~0 : 0);
 }
    }

    template<typename _InputIterator>
      void
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 iterator __cur = begin();
 for (; __first != __last && __cur != end(); ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

    template<typename _ForwardIterator>
      void
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);
 if (__len < size())
   _M_erase_at_end(std::copy(__first, __last, begin()));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, begin());
     insert(end(), __mid, __last);
   }
      }





    template<typename _Integer>
      void
      _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,
    __true_type)
      { _M_fill_insert(__pos, __n, __x); }

    template<typename _InputIterator>
      void
      _M_insert_dispatch(iterator __pos,
    _InputIterator __first, _InputIterator __last,
    __false_type)
      { _M_insert_range(__pos, __first, __last,
   std::__iterator_category(__first)); }

    void
    _M_fill_insert(iterator __position, size_type __n, bool __x);

    template<typename _InputIterator>
      void
      _M_insert_range(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

    template<typename _ForwardIterator>
      void
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag);

    void
    _M_insert_aux(iterator __position, bool __x);

    size_type
    _M_check_len(size_type __n, const char* __s) const
    {
      if (max_size() - size() < __n)
 __throw_length_error((__s));

      const size_type __len = size() + std::max(size(), __n);
      return (__len < size() || __len > max_size()) ? max_size() : __len;
    }

    void
    _M_erase_at_end(iterator __pos)
    { this->_M_impl._M_finish = __pos; }
  };


}
// # 66 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 2 3



// # 1 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 1 3
// # 59 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    reserve(size_type __n)
    {
      if (__n > this->max_size())
 __throw_length_error(("vector::reserve"));
      if (this->capacity() < __n)
 {
   const size_type __old_size = size();
   pointer __tmp = _M_allocate_and_copy(__n,
     (this->_M_impl._M_start),
     (this->_M_impl._M_finish));
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __tmp;
   this->_M_impl._M_finish = __tmp + __old_size;
   this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
 }
    }
// # 105 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    insert(iterator __position, const value_type& __x)
    {
      const size_type __n = __position - begin();
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage
   && __position == end())
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish, __x);
   ++this->_M_impl._M_finish;
 }
      else
 {
// # 127 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
     _M_insert_aux(__position, __x);
 }
      return iterator(this->_M_impl._M_start + __n);
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __position)
    {
      if (__position + 1 != end())
 std::copy(__position + 1, end(), __position);
      --this->_M_impl._M_finish;
      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
      return __position;
    }

  template<typename _Tp, typename _Alloc>
    typename vector<_Tp, _Alloc>::iterator
    vector<_Tp, _Alloc>::
    erase(iterator __first, iterator __last)
    {
      if (__first != __last)
 {
   if (__last != end())
     std::copy(__last, end(), __first);
   _M_erase_at_end(__first.base() + (end() - __last));
 }
      return __first;
    }

  template<typename _Tp, typename _Alloc>
    vector<_Tp, _Alloc>&
    vector<_Tp, _Alloc>::
    operator=(const vector<_Tp, _Alloc>& __x)
    {
      if (&__x != this)
 {
// # 184 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
   const size_type __xlen = __x.size();
   if (__xlen > capacity())
     {
       pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
         __x.end());
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __tmp;
       this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
     }
   else if (size() >= __xlen)
     {
       std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
       end(), _M_get_Tp_allocator());
     }
   else
     {
       std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
   this->_M_impl._M_start);
       std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
       __x._M_impl._M_finish,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
     }
   this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_assign(size_t __n, const value_type& __val)
    {
      if (__n > capacity())
 {
   vector __tmp(__n, __val, _M_get_Tp_allocator());
   __tmp.swap(*this);
 }
      else if (__n > size())
 {
   std::fill(begin(), end(), __val);
   std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
     __n - size(), __val,
     _M_get_Tp_allocator());
   this->_M_impl._M_finish += __n - size();
 }
      else
        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_InputIterator __first, _InputIterator __last,
      std::input_iterator_tag)
      {
 pointer __cur(this->_M_impl._M_start);
 for (; __first != __last && __cur != this->_M_impl._M_finish;
      ++__cur, ++__first)
   *__cur = *__first;
 if (__first == __last)
   _M_erase_at_end(__cur);
 else
   insert(end(), __first, __last);
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
      std::forward_iterator_tag)
      {
 const size_type __len = std::distance(__first, __last);

 if (__len > capacity())
   {
     pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
     std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
     _M_get_Tp_allocator());
     _M_deallocate(this->_M_impl._M_start,
     this->_M_impl._M_end_of_storage
     - this->_M_impl._M_start);
     this->_M_impl._M_start = __tmp;
     this->_M_impl._M_finish = this->_M_impl._M_start + __len;
     this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
   }
 else if (size() >= __len)
   _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
 else
   {
     _ForwardIterator __mid = __first;
     std::advance(__mid, size());
     std::copy(__first, __mid, this->_M_impl._M_start);
     this->_M_impl._M_finish =
       std::__uninitialized_copy_a(__mid, __last,
       this->_M_impl._M_finish,
       _M_get_Tp_allocator());
   }
      }
// # 316 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_insert_aux(iterator __position, const _Tp& __x)

    {
      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
 {
   _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
              (*(this->_M_impl._M_finish - 1))
                            );
   ++this->_M_impl._M_finish;

   _Tp __x_copy = __x;

   std::copy_backward(__position.base(), this->_M_impl._M_finish - 2, this->_M_impl._M_finish - 1)

                                  ;

   *__position = __x_copy;



 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector::_M_insert_aux");
   const size_type __elems_before = __position - begin();
   pointer __new_start(this->_M_allocate(__len));
   pointer __new_finish(__new_start);
   try
     {




       _Alloc_traits::construct(this->_M_impl,
                         __new_start + __elems_before,



                                __x);

       __new_finish = 0;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (this->_M_impl._M_start, __position.base(),
   __new_start, _M_get_Tp_allocator());

       ++__new_finish;

       __new_finish
  = std::__uninitialized_move_if_noexcept_a
  (__position.base(), this->_M_impl._M_finish,
   __new_finish, _M_get_Tp_allocator());
     }
          catch(...)
     {
       if (!__new_finish)
  _Alloc_traits::destroy(this->_M_impl,
                         __new_start + __elems_before);
       else
  std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
       _M_deallocate(__new_start, __len);
       throw;
     }
   std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
   _M_get_Tp_allocator());
   _M_deallocate(this->_M_impl._M_start,
   this->_M_impl._M_end_of_storage
   - this->_M_impl._M_start);
   this->_M_impl._M_start = __new_start;
   this->_M_impl._M_finish = __new_finish;
   this->_M_impl._M_end_of_storage = __new_start + __len;
 }
    }
// # 439 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    void
    vector<_Tp, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
    {
      if (__n != 0)
 {
   if (size_type(this->_M_impl._M_end_of_storage
   - this->_M_impl._M_finish) >= __n)
     {
       value_type __x_copy = __x;
       const size_type __elems_after = end() - __position;
       pointer __old_finish(this->_M_impl._M_finish);
       if (__elems_after > __n)
  {
    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
           this->_M_impl._M_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n;
    std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                        ;
    std::fill(__position.base(), __position.base() + __n,
       __x_copy);
  }
       else
  {
    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
      __n - __elems_after,
      __x_copy,
      _M_get_Tp_allocator());
    this->_M_impl._M_finish += __n - __elems_after;
    std::__uninitialized_move_a(__position.base(), __old_finish,
           this->_M_impl._M_finish,
           _M_get_Tp_allocator());
    this->_M_impl._M_finish += __elems_after;
    std::fill(__position.base(), __old_finish, __x_copy);
  }
     }
   else
     {
       const size_type __len =
  _M_check_len(__n, "vector::_M_fill_insert");
       const size_type __elems_before = __position - begin();
       pointer __new_start(this->_M_allocate(__len));
       pointer __new_finish(__new_start);
       try
  {

    std::__uninitialized_fill_n_a(__new_start + __elems_before,
      __n, __x,
      _M_get_Tp_allocator());
    __new_finish = 0;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (this->_M_impl._M_start, __position.base(),
       __new_start, _M_get_Tp_allocator());

    __new_finish += __n;

    __new_finish
      = std::__uninitialized_move_if_noexcept_a
      (__position.base(), this->_M_impl._M_finish,
       __new_finish, _M_get_Tp_allocator());
  }
       catch(...)
  {
    if (!__new_finish)
      std::_Destroy(__new_start + __elems_before,
      __new_start + __elems_before + __n,
      _M_get_Tp_allocator());
    else
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
    _M_deallocate(__new_start, __len);
    throw;
  }
       std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
       _M_get_Tp_allocator());
       _M_deallocate(this->_M_impl._M_start,
       this->_M_impl._M_end_of_storage
       - this->_M_impl._M_start);
       this->_M_impl._M_start = __new_start;
       this->_M_impl._M_finish = __new_finish;
       this->_M_impl._M_end_of_storage = __new_start + __len;
     }
 }
    }
// # 591 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3
  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __pos, _InputIterator __first,
        _InputIterator __last, std::input_iterator_tag)
      {
 for (; __first != __last; ++__first)
   {
     __pos = insert(__pos, *__first);
     ++__pos;
   }
      }

  template<typename _Tp, typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<_Tp, _Alloc>::
      _M_range_insert(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     const size_type __n = std::distance(__first, __last);
     if (size_type(this->_M_impl._M_end_of_storage
     - this->_M_impl._M_finish) >= __n)
       {
  const size_type __elems_after = end() - __position;
  pointer __old_finish(this->_M_impl._M_finish);
  if (__elems_after > __n)
    {
      std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
      this->_M_impl._M_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n;
      std::copy_backward(__position.base(), __old_finish - __n, __old_finish)
                                          ;
      std::copy(__first, __last, __position);
    }
  else
    {
      _ForwardIterator __mid = __first;
      std::advance(__mid, __elems_after);
      std::__uninitialized_copy_a(__mid, __last,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __n - __elems_after;
      std::__uninitialized_move_a(__position.base(),
      __old_finish,
      this->_M_impl._M_finish,
      _M_get_Tp_allocator());
      this->_M_impl._M_finish += __elems_after;
      std::copy(__first, __mid, __position);
    }
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector::_M_range_insert");
  pointer __new_start(this->_M_allocate(__len));
  pointer __new_finish(__new_start);
  try
    {
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (this->_M_impl._M_start, __position.base(),
         __new_start, _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_copy_a(__first, __last,
          __new_finish,
          _M_get_Tp_allocator());
      __new_finish
        = std::__uninitialized_move_if_noexcept_a
        (__position.base(), this->_M_impl._M_finish,
         __new_finish, _M_get_Tp_allocator());
    }
  catch(...)
    {
      std::_Destroy(__new_start, __new_finish,
      _M_get_Tp_allocator());
      _M_deallocate(__new_start, __len);
      throw;
    }
  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
         _M_get_Tp_allocator());
  _M_deallocate(this->_M_impl._M_start,
         this->_M_impl._M_end_of_storage
         - this->_M_impl._M_start);
  this->_M_impl._M_start = __new_start;
  this->_M_impl._M_finish = __new_finish;
  this->_M_impl._M_end_of_storage = __new_start + __len;
       }
   }
      }



  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_reallocate(size_type __n)
    {
      _Bit_type* __q = this->_M_allocate(__n);
      this->_M_impl._M_finish = _M_copy_aligned(begin(), end(),
      iterator(__q, 0));
      this->_M_deallocate();
      this->_M_impl._M_start = iterator(__q, 0);
      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_fill_insert(iterator __position, size_type __n, bool __x)
    {
      if (__n == 0)
 return;
      if (capacity() - size() >= __n)
 {
   std::copy_backward(__position, end(),
        this->_M_impl._M_finish + difference_type(__n));
   std::fill(__position, __position + difference_type(__n), __x);
   this->_M_impl._M_finish += difference_type(__n);
 }
      else
 {
   const size_type __len =
     _M_check_len(__n, "vector<bool>::_M_fill_insert");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   std::fill(__i, __i + difference_type(__n), __x);
   this->_M_impl._M_finish = std::copy(__position, end(),
           __i + difference_type(__n));
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }

  template<typename _Alloc>
    template<typename _ForwardIterator>
      void
      vector<bool, _Alloc>::
      _M_insert_range(iterator __position, _ForwardIterator __first,
        _ForwardIterator __last, std::forward_iterator_tag)
      {
 if (__first != __last)
   {
     size_type __n = std::distance(__first, __last);
     if (capacity() - size() >= __n)
       {
  std::copy_backward(__position, end(),
       this->_M_impl._M_finish
       + difference_type(__n));
  std::copy(__first, __last, __position);
  this->_M_impl._M_finish += difference_type(__n);
       }
     else
       {
  const size_type __len =
    _M_check_len(__n, "vector<bool>::_M_insert_range");
  _Bit_type * __q = this->_M_allocate(__len);
  iterator __i = _M_copy_aligned(begin(), __position,
            iterator(__q, 0));
  __i = std::copy(__first, __last, __i);
  this->_M_impl._M_finish = std::copy(__position, end(), __i);
  this->_M_deallocate();
  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
  this->_M_impl._M_start = iterator(__q, 0);
       }
   }
      }

  template<typename _Alloc>
    void
    vector<bool, _Alloc>::
    _M_insert_aux(iterator __position, bool __x)
    {
      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_of_storage)
 {
   std::copy_backward(__position, this->_M_impl._M_finish,
        this->_M_impl._M_finish + 1);
   *__position = __x;
   ++this->_M_impl._M_finish;
 }
      else
 {
   const size_type __len =
     _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
   _Bit_type * __q = this->_M_allocate(__len);
   iterator __i = _M_copy_aligned(begin(), __position,
      iterator(__q, 0));
   *__i++ = __x;
   this->_M_impl._M_finish = std::copy(__position, end(), __i);
   this->_M_deallocate();
   this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
   this->_M_impl._M_start = iterator(__q, 0);
 }
    }
// # 811 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/bits/vector.tcc" 3

}
// # 70 "/nfs/casc/overture/ROSE/opt/rhel7/x86_64/gcc/4.8.4/mpc/1.0/mpfr/3.1.2/gmp/5.1.2/include/c++/4.8.4/vector" 2 3
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 2




// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_getopt.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_getopt.h"
extern "C" {
// # 61 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_getopt.h"
enum get_opt_arg_type { NO_ARG, OPT_ARG, REQUIRED_ARG };

struct st_typelib;

struct my_option
{
  const char *name;



  int id;
// # 86 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/include/my_getopt.h"
  const char *comment;



  void *value;
  void *u_max_value;
  struct st_typelib *typelib;
  ulong var_type;
  enum get_opt_arg_type arg_type;
  longlong def_value;
  longlong min_value;
  ulonglong max_value;
  longlong sub_size;
  long block_size;
  void *app_type;
};


typedef my_bool (*my_get_one_option)(int, const struct my_option *, char *);






typedef void *(*my_getopt_value)(const char *, size_t, const struct my_option *,
                                 int *);


extern char *disabled_my_option;
extern my_bool my_getopt_print_errors;
extern my_bool my_getopt_skip_unknown;
extern my_error_reporter my_getopt_error_reporter;

extern int handle_options (int *argc, char ***argv,
      const struct my_option *longopts, my_get_one_option);
extern int my_handle_options (int *argc, char ***argv,
                              const struct my_option *longopts,
                              my_get_one_option,
                              const char **command_list, my_bool ignore_unknown_option);
extern void print_cmdline_password_warning();
extern void my_cleanup_options(const struct my_option *options);
extern void my_cleanup_options(const struct my_option *options);
extern void my_print_help(const struct my_option *options);
extern void my_print_variables(const struct my_option *options);
extern void my_print_variables_ex(const struct my_option *options, FILE* file);
extern void my_getopt_register_get_addr(my_getopt_value);

ulonglong getopt_ull_limit_value(ulonglong num, const struct my_option *optp,
                                 my_bool *fix);
longlong getopt_ll_limit_value(longlong, const struct my_option *,
                               my_bool *fix);
double getopt_double_limit_value(double num, const struct my_option *optp,
                                 my_bool *fix);
my_bool getopt_compare_strings(const char *s, const char *t, uint length);
ulonglong max_of_int_range(int var_type);

ulonglong getopt_double2ulonglong(double);
double getopt_ulonglong2double(ulonglong);

}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_const.h" 1
// # 325 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_const.h"
enum SHOW_COMP_OPTION { SHOW_OPTION_YES, SHOW_OPTION_NO, SHOW_OPTION_DISABLED};

enum enum_mark_columns
{ MARK_COLUMNS_NONE, MARK_COLUMNS_READ, MARK_COLUMNS_WRITE, MARK_COLUMNS_TEMP};
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 2

extern const char *global_plugin_typelib_names[];
extern mysql_mutex_t LOCK_plugin_delete;


// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h" 1
// # 36 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
template <typename T>
class SQL_I_List :public Sql_alloc
{
public:
  uint elements;

  T *first;

  T **next;

  SQL_I_List() { empty(); }

  SQL_I_List(const SQL_I_List &tmp) : Sql_alloc()
  {
    elements= tmp.elements;
    first= tmp.first;
    next= elements ? tmp.next : &first;
  }

  inline void empty()
  {
    elements= 0;
    first= __null;
    next= &first;
  }

  inline void link_in_list(T *element, T **next_ptr)
  {
    elements++;
    (*next)= element;
    next= next_ptr;
    *next= __null;
  }

  inline void save_and_clear(SQL_I_List<T> *save)
  {
    *save= *this;
    empty();
  }

  inline void push_front(SQL_I_List<T> *save)
  {

    *save->next= first;
    first= save->first;
    elements+= save->elements;
  }

  inline void push_back(SQL_I_List<T> *save)
  {
    if (save->first)
    {
      *next= save->first;
      next= save->next;
      elements+= save->elements;
    }
  }
};
// # 112 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
struct list_node :public Sql_alloc
{
  list_node *next;
  void *info;
  list_node(void *info_par,list_node *next_par)
    :next(next_par),info(info_par)
  {}
  list_node()
  {
    info= 0;
    next= this;
  }
};


extern list_node end_of_list;
// # 142 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
typedef int (*Node_cmp_func)(void *n1, void *n2, void *arg);

class base_list :public Sql_alloc
{
protected:
  list_node *first,**last;

public:
  uint elements;

  bool operator==(const base_list &rhs) const
  {
    return
      elements == rhs.elements &&
      first == rhs.first &&
      last == rhs.last;
  }

  inline void empty() { elements=0; first= &end_of_list; last=&first;}
  inline base_list() { empty(); }
// # 171 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
  base_list(const base_list &tmp)
    : Sql_alloc(),
      first(tmp.first),
      last(tmp.elements ? tmp.last : &first),
      elements(tmp.elements)
  {
  }
  base_list &operator=(const base_list &tmp)
  {
    elements= tmp.elements;
    first= tmp.first;
    last= elements ? tmp.last : &first;
    return *this;
  }






  base_list(const base_list &rhs, MEM_ROOT *mem_root);
  inline base_list(bool error) { }
  inline bool push_back(void *info)
  {
    if (((*last)=new list_node(info, &end_of_list)))
    {
      last= &(*last)->next;
      elements++;
      return 0;
    }
    return 1;
  }
  inline bool push_back(void *info, MEM_ROOT *mem_root)
  {
    if (((*last)=new (mem_root) list_node(info, &end_of_list)))
    {
      last= &(*last)->next;
      elements++;
      return 0;
    }
    return 1;
  }
  inline bool push_front(void *info)
  {
    list_node *node=new list_node(info,first);
    if (node)
    {
      if (last == &first)
 last= &node->next;
      first=node;
      elements++;
      return 0;
    }
    return 1;
  }
  inline bool push_front(void *info, MEM_ROOT *mem_root)
  {
    list_node *node=new (mem_root) list_node(info, first);
    if (node)
    {
      if (last == &first)
        last= &node->next;
      first=node;
      elements++;
      return false;
    }
    return true;
  }

  void remove(list_node **prev)
  {
    list_node *node=(*prev)->next;
    if (!--elements)
      last= &first;
    else if (last == &(*prev)->next)
      last= prev;
    delete *prev;
    *prev=node;
  }
  inline void concat(base_list *list)
  {
    if (!list->is_empty())
    {
      *last= list->first;
      last= list->last;
      elements+= list->elements;
    }
  }
  inline void *pop(void)
  {
    if (first == &end_of_list) return 0;
    list_node *tmp=first;
    first=first->next;
    if (!--elements)
      last= &first;
    return tmp->info;
  }
  inline void disjoin(base_list *list)
  {
    list_node **prev= &first;
    list_node *node= first;
    list_node *list_first= list->first;
    elements=0;
    while (node && node != list_first)
    {
      prev= &node->next;
      node= node->next;
      elements++;
    }
    *prev= *last;
    last= prev;
  }
  inline void prepand(base_list *list)
  {
    if (!list->is_empty())
    {
      *list->last= first;
      first= list->first;
      elements+= list->elements;
    }
  }
// # 307 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
  void sort(Node_cmp_func cmp, void *arg)
  {
    if (elements < 2)
      return;
    for (list_node *n1= first; n1 && n1 != &end_of_list; n1= n1->next)
    {
      for (list_node *n2= n1->next; n2 && n2 != &end_of_list; n2= n2->next)
      {
        if ((*cmp)(n1->info, n2->info, arg) > 0)
        {
          void *tmp= n1->info;
          n1->info= n2->info;
          n2->info= tmp;
        }
      }
    }
  }



  inline void swap(base_list &rhs)
  {
    { list_node * dummy; dummy= first; first= rhs.first; rhs.first= dummy; };
    { list_node ** dummy; dummy= last; last= rhs.last; rhs.last= dummy; };
    { uint dummy; dummy= elements; elements= rhs.elements; rhs.elements= dummy; };
  }
  inline list_node* last_node() { return *last; }
  inline list_node* first_node() { return first;}
  inline void *head() { return first->info; }
  inline void **head_ref() { return first != &end_of_list ? &first->info : 0; }
  inline bool is_empty() const { return first == &end_of_list ; }
  inline list_node *last_ref() { return &end_of_list; }
  friend class base_list_iterator;
  friend class error_list;
  friend class error_list_iterator;
// # 391 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
protected:
  void after(void *info,list_node *node)
  {
    list_node *new_node=new list_node(info,node->next);
    node->next=new_node;
    elements++;
    if (last == &(node->next))
      last= &new_node->next;
  }
  bool after(void *info,list_node *node, MEM_ROOT *mem_root)
  {
    list_node *new_node=new (mem_root) list_node(info,node->next);
    if (!new_node)
      return true;

    node->next=new_node;
    elements++;
    if (last == &(node->next))
      last= &new_node->next;

    return false;
  }
};

class base_list_iterator
{
protected:
  base_list *list;
  list_node **el,**prev,*current;
  void sublist(base_list &ls, uint elm)
  {
    ls.first= *el;
    ls.last= list->last;
    ls.elements= elm;
  }
public:
  base_list_iterator()
    :list(0), el(0), prev(0), current(0)
  {}

  base_list_iterator(base_list &list_par)
  { init(list_par); }

  inline void init(base_list &list_par)
  {
    list= &list_par;
    el= &list_par.first;
    prev= 0;
    current= 0;
  }

  inline void *next(void)
  {
    prev=el;
    current= *el;
    el= &current->next;
    return current->info;
  }
  inline void *next_fast(void)
  {
    list_node *tmp;
    tmp= *el;
    el= &tmp->next;
    return tmp->info;
  }
  inline void rewind(void)
  {
    el= &list->first;
  }
  inline void *replace(void *element)
  {
    void *tmp=current->info;
    do { } while(0);
    current->info=element;
    return tmp;
  }
  void *replace(base_list &new_list)
  {
    void *ret_value=current->info;
    if (!new_list.is_empty())
    {
      *new_list.last=current->next;
      current->info=new_list.first->info;
      current->next=new_list.first->next;
      if ((list->last == &current->next) && (new_list.elements > 1))
 list->last= new_list.last;
      list->elements+=new_list.elements-1;
    }
    return ret_value;
  }
  inline void remove(void)
  {
    list->remove(prev);
    el=prev;
    current=0;
  }
  void after(void *element)
  {
    list->after(element,current);
    current=current->next;
    el= &current->next;
  }
  bool after(void *a, MEM_ROOT *mem_root)
  {
    if (list->after(a, current, mem_root))
      return true;

    current=current->next;
    el= &current->next;
    return false;
  }
  inline void **ref(void)
  {
    return &current->info;
  }
  inline bool is_last(void)
  {
    return el == &list->last_ref()->next;
  }
  inline bool is_before_first() const
  {
    return current == __null;
  }
  bool prepend(void *a, MEM_ROOT *mem_root)
  {
    if (list->push_front(a, mem_root))
      return true;

    el= &list->first;
    prev=el;
    el= &(*el)->next;

    return false;
  }
  friend class error_list_iterator;
};


template <class T> class List :public base_list
{
public:
  List() :base_list() {}
  inline List(const List<T> &tmp) :base_list(tmp) {}
  List &operator=(const List &tmp)
  {
    return static_cast<List &>(base_list::operator=(tmp));
  }
  inline List(const List<T> &tmp, MEM_ROOT *mem_root) :
    base_list(tmp, mem_root) {}





  inline bool push_back(T *a) { return base_list::push_back((void *) a); }
  inline bool push_back(T *a, MEM_ROOT *mem_root)
  { return base_list::push_back((void *) a, mem_root); }
  inline bool push_front(T *a) { return base_list::push_front((void *) a); }
  inline bool push_front(T *a, MEM_ROOT *mem_root)
  {
    return base_list::push_front((void *) a, mem_root);
  }
  inline T* head() {return (T*) base_list::head(); }
  inline T** head_ref() {return (T**) base_list::head_ref(); }
  inline T* pop() {return (T*) base_list::pop(); }
  inline void concat(List<T> *list) { base_list::concat(list); }
  inline void disjoin(List<T> *list) { base_list::disjoin(list); }
  inline void prepand(List<T> *list) { base_list::prepand(list); }
  void delete_elements(void)
  {
    list_node *element,*next;
    for (element=first; element != &end_of_list; element=next)
    {
      next=element->next;
      delete (T*) element->info;
    }
    empty();
  }

  using base_list::sort;
};


template <class T> class List_iterator :public base_list_iterator
{
public:
  List_iterator(List<T> &a) : base_list_iterator(a) {}
  List_iterator() : base_list_iterator() {}
  inline void init(List<T> &a) { base_list_iterator::init(a); }
  inline T* operator++(int) { return (T*) base_list_iterator::next(); }
  inline T *replace(T *a) { return (T*) base_list_iterator::replace(a); }
  inline T *replace(List<T> &a) { return (T*) base_list_iterator::replace(a); }
  inline void rewind(void) { base_list_iterator::rewind(); }
  inline void remove() { base_list_iterator::remove(); }
  inline void after(T *a) { base_list_iterator::after(a); }
  inline bool after(T *a, MEM_ROOT *mem_root)
  {
    return base_list_iterator::after(a, mem_root);
  }
  inline T** ref(void) { return (T**) base_list_iterator::ref(); }
};


template <class T> class List_iterator_fast :public base_list_iterator
{
protected:
  inline T *replace(T *a) { return (T*) 0; }
  inline T *replace(List<T> &a) { return (T*) 0; }
  inline void remove(void) { }
  inline void after(T *a) { }
  inline T** ref(void) { return (T**) 0; }

public:
  inline List_iterator_fast(List<T> &a) : base_list_iterator(a) {}
  inline List_iterator_fast() : base_list_iterator() {}
  inline void init(List<T> &a) { base_list_iterator::init(a); }
  inline T* operator++(int) { return (T*) base_list_iterator::next_fast(); }
  inline void rewind(void) { base_list_iterator::rewind(); }
  void sublist(List<T> &list_arg, uint el_arg)
  {
    base_list_iterator::sublist(list_arg, el_arg);
  }
};


template <typename T> class base_ilist;
template <typename T> class base_ilist_iterator;
// # 627 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
template <typename T>
class ilink
{
  T **prev, *next;
public:
  ilink() : prev(__null), next(__null) {}

  void unlink()
  {

    if (prev) *prev= next;
    if (next) next->prev=prev;
    prev= __null;
    next= __null;
  }

  virtual ~ilink() { unlink(); }

  friend class base_ilist<T>;
  friend class base_ilist_iterator<T>;
};




class i_string: public ilink<i_string>
{
public:
  const char* ptr;
  i_string():ptr(0) { }
  i_string(const char* s) : ptr(s) {}
};


class i_string_pair: public ilink<i_string_pair>
{
public:
  const char* key;
  const char* val;
  i_string_pair():key(0),val(0) { }
  i_string_pair(const char* key_arg, const char* val_arg) :
    key(key_arg),val(val_arg) {}
};


template <class T> class I_List_iterator;


template<typename T>
class base_ilist
{
  T *first;
  ilink<T> sentinel;
public:
  void empty() {
    first= static_cast<T*>(&sentinel);
    sentinel.prev= &first;
  }
  base_ilist() { empty(); }
  bool is_empty() const { return first == static_cast<const T*>(&sentinel); }


  void push_front(T *a)
  {
    first->prev= &a->next;
    a->next= first;
    a->prev= &first;
    first= a;
  }


  void push_back(T *a)
  {
    *sentinel.prev= a;
    a->next= static_cast<T*>(&sentinel);
    a->prev= sentinel.prev;
    sentinel.prev= &a->next;
  }


  T *get()
  {
    if (is_empty())
      return __null;
    T *first_link= first;
    first_link->unlink();
    return first_link;
  }

  T *head() { return is_empty() ? __null : first; }
// # 725 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
  void move_elements_to(base_ilist *new_owner)
  {
    do { } while(0);
    new_owner->first= first;
    new_owner->sentinel= sentinel;
    empty();
  }

  friend class base_ilist_iterator<T>;
 private:





  base_ilist(const base_ilist&);
  void operator=(const base_ilist&);
};


template<typename T>
class base_ilist_iterator
{
  base_ilist<T> *list;
  T **el, *current;
public:
  base_ilist_iterator(base_ilist<T> &list_par) :
    list(&list_par),
    el(&list_par.first),
    current(__null)
  {}

  T *next(void)
  {

    current= *el;
    if (current == static_cast<T*>(&list->sentinel))
      return __null;
    el= &current->next;
    return current;
  }
};


template <class T>
class I_List :private base_ilist<T>
{
public:
  using base_ilist<T>::empty;
  using base_ilist<T>::is_empty;
  using base_ilist<T>::get;
  using base_ilist<T>::push_front;
  using base_ilist<T>::push_back;
  using base_ilist<T>::head;
  void move_elements_to(I_List<T>* new_owner) {
    base_ilist<T>::move_elements_to(new_owner);
  }
  friend class I_List_iterator<T>;
};


template <class T>
class I_List_iterator :public base_ilist_iterator<T>
{
public:
  I_List_iterator(I_List<T> &a) : base_ilist_iterator<T>(a) {}
  inline T* operator++(int) { return base_ilist_iterator<T>::next(); }
};
// # 809 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_list.h"
template <typename T>
inline
void
list_copy_and_replace_each_value(List<T> &list, MEM_ROOT *mem_root)
{

  List_iterator<T> it(list);
  T *el;
  while ((el= it++))
    it.replace(el->clone(mem_root));
}

void free_list(I_List <i_string_pair> *list);
void free_list(I_List <i_string> *list);


template <class T>
List<T> *List_merge(T *head, List<T> *tail)
{
  tail->push_front(head);
  return tail;
}
// # 33 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 2

// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin_ref.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin_ref.h"
typedef struct st_mysql_lex_string LEX_STRING;

class sys_var;
struct st_mysql_plugin;
struct st_plugin_dl;

enum enum_plugin_load_option {
  PLUGIN_OFF,
  PLUGIN_ON,
  PLUGIN_FORCE,
  PLUGIN_FORCE_PLUS_PERMANENT
};



struct st_plugin_int
{
  LEX_STRING name;
  st_mysql_plugin *plugin;
  st_plugin_dl *plugin_dl;
  uint state;
  uint ref_count;
  void *data;
  MEM_ROOT mem_root;
  sys_var *system_vars;
  enum_plugin_load_option load_option;
};







typedef struct st_plugin_int *plugin_ref;

inline st_mysql_plugin *plugin_decl(st_plugin_int *ref)
{
  return ref->plugin;
}
inline st_plugin_dl *plugin_dlib(st_plugin_int *ref)
{
  return ref->plugin_dl;
}
template<typename T>
inline T plugin_data(st_plugin_int *ref)
{
  return static_cast<T>(ref->data);
}
inline LEX_STRING *plugin_name(st_plugin_int *ref)
{
  return &(ref->name);
}
inline uint plugin_state(st_plugin_int *ref)
{
  return ref->state;
}
inline enum_plugin_load_option plugin_load_option(st_plugin_int *ref)
{
  return ref->load_option;
}
inline bool plugin_equals(st_plugin_int *ref1, st_plugin_int *ref2)
{
  return ref1 == ref2;
}
// # 35 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h" 2
// # 51 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h"
typedef struct st_mysql_show_var SHOW_VAR;
typedef struct st_mysql_lex_string LEX_STRING;
// # 72 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h"
struct st_plugin_dl
{
  LEX_STRING dl;
  void *handle;
  struct st_mysql_plugin *plugins;
  int version;
  uint ref_count;
};






class Sql_cmd_install_plugin : public Sql_cmd
{
public:
  Sql_cmd_install_plugin(const LEX_STRING& comment,
                         const LEX_STRING& ident)
  : m_comment(comment), m_ident(ident)
  { }

  virtual enum_sql_command sql_command_code() const
  { return SQLCOM_INSTALL_PLUGIN; }
// # 106 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h"
  virtual bool execute(THD *thd);

private:
  LEX_STRING m_comment;
  LEX_STRING m_ident;
};






class Sql_cmd_uninstall_plugin : public Sql_cmd
{
public:
  explicit Sql_cmd_uninstall_plugin(const LEX_STRING& comment)
  : m_comment(comment)
  { }

  virtual enum_sql_command sql_command_code() const
  { return SQLCOM_UNINSTALL_PLUGIN; }
// # 137 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sql_plugin.h"
  virtual bool execute(THD *thd);

private:
  LEX_STRING m_comment;
};


typedef int (*plugin_type_init)(struct st_plugin_int *);

extern I_List<i_string> *opt_plugin_load_list_ptr;
extern I_List<i_string> *opt_early_plugin_load_list_ptr;
extern char *opt_plugin_dir_ptr;
extern char opt_plugin_dir[512];
extern const LEX_STRING plugin_type_names[];

extern int plugin_init(int *argc, char **argv, int init_flags);
extern void plugin_shutdown(void);
extern void memcached_shutdown(void);
void add_plugin_options(std::vector<my_option> *options, MEM_ROOT *mem_root);
extern bool plugin_is_ready(const LEX_CSTRING &name, int type);




extern plugin_ref plugin_lock(THD *thd, plugin_ref *ptr);
extern plugin_ref plugin_lock_by_name(THD *thd, const LEX_CSTRING &name,
                                      int type);
extern void plugin_unlock(THD *thd, plugin_ref plugin);
extern void plugin_unlock_list(THD *thd, plugin_ref *list, size_t count);
extern bool plugin_register_builtin(struct st_mysql_plugin *plugin);
extern void plugin_thdvar_init(THD *thd, bool enable_plugins);
extern void plugin_thdvar_cleanup(THD *thd, bool enable_plugins);
extern SHOW_COMP_OPTION plugin_status(const char *name, size_t len, int type);
extern bool check_valid_path(const char *path, size_t length);
extern void alloc_and_copy_thd_dynamic_variables(THD *thd, bool global_lock);

typedef my_bool (plugin_foreach_func)(THD *thd,
                                      plugin_ref plugin,
                                      void *arg);

extern bool plugin_foreach_with_mask(THD *thd, plugin_foreach_func *func,
                                     int type, uint state_mask, void *arg);
int lock_plugin_data();
int unlock_plugin_data();
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/logger.h" 2

namespace keyring {

class ILogger
{
public:
  virtual void log(plugin_log_level level, const char *message)= 0;
  virtual ~ILogger() {}
};

class Logger : public ILogger
{
public:
  Logger(MYSQL_PLUGIN plugin_info_ptr)
    : plugin_info_ptr(plugin_info_ptr)
  {}
  ~Logger() {}
  void log(plugin_log_level level, const char *message)
  {
    my_plugin_log_service->my_plugin_log_message(&plugin_info_ptr, level, "%s", message);
  }
private:
  MYSQL_PLUGIN plugin_info_ptr;
};

}
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h" 1
// # 30 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h"
class THD;
class sys_var;

extern bool throw_bounds_warning(THD *thd, const char *name,
                                 bool fixed, bool is_unsigned, longlong v);
extern bool throw_bounds_warning(THD *thd, const char *name, bool fixed,
                                 double v);
extern sys_var *intern_find_sys_var(const char *str, size_t length);


class PolyLock
{
public:
  virtual void rdlock()= 0;
  virtual void wrlock()= 0;
  virtual void unlock()= 0;
  virtual ~PolyLock() {}
};

class PolyLock_mutex: public PolyLock
{
  mysql_mutex_t *mutex;
public:
  PolyLock_mutex(mysql_mutex_t *arg): mutex(arg) {}
  void rdlock() { inline_mysql_mutex_lock(mutex, "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h", 54); }
  void wrlock() { inline_mysql_mutex_lock(mutex, "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h", 55); }
  void unlock() { inline_mysql_mutex_unlock(mutex); }
};

class PolyLock_rwlock: public PolyLock
{
  mysql_rwlock_t *rwlock;
public:
  PolyLock_rwlock(mysql_rwlock_t *arg): rwlock(arg) {}
  void rdlock() { inline_mysql_rwlock_rdlock(rwlock, "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h", 64); }
  void wrlock() { inline_mysql_rwlock_wrlock(rwlock, "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/sql/sys_vars_shared.h", 65); }
  void unlock() { inline_mysql_rwlock_unlock(rwlock); }
};

class AutoWLock
{
  PolyLock *lock;
public:
  AutoWLock(PolyLock *l) : lock(l) { if (lock) lock->wrlock(); }
  ~AutoWLock() { if (lock) lock->unlock(); }
};

class AutoRLock
{
  PolyLock *lock;
public:
  AutoRLock(PolyLock *l) : lock(l) { if (lock) lock->rdlock(); }
  ~AutoRLock() { if (lock) lock->unlock(); }
};
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keys_container.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keys_container.h"
namespace keyring {

class IKeys_container : public Keyring_alloc
{
public:
  virtual my_bool init(IKeyring_io* keyring_io, std::string keyring_storage_url)= 0;
  virtual my_bool store_key(IKey *key)= 0;
  virtual IKey* fetch_key(IKey *key)= 0;
  virtual my_bool remove_key(IKey *key)= 0;
  virtual std::string get_keyring_storage_url()= 0;

  virtual ~IKeys_container() {};
};

}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keys_container.h" 2


namespace keyring {

extern "C" CHARSET_INFO *system_charset_info;

class Keys_container : public IKeys_container
{
public:
  Keys_container(ILogger* logger);
  my_bool init(IKeyring_io* keyring_io, std::string keyring_storage_url);
  my_bool store_key(IKey *key);
  IKey* fetch_key(IKey *key);
  my_bool remove_key(IKey *key);
  std::string get_keyring_storage_url();

  ~Keys_container();

  ulong get_number_of_keys()
  {
    return keys_hash.records;
  };
protected:
  Keys_container(const Keys_container &);

  my_bool load_keys_from_keyring_storage();
  void free_keys_hash();
  IKey *get_key_from_hash(IKey *key);
  my_bool store_key_in_hash(IKey *key);
  my_bool remove_key_from_hash(IKey *key);
  virtual my_bool flush_to_backup();
  virtual my_bool flush_to_storage(IKey *key, Key_operation operation);

  HASH keys_hash;
  ILogger* logger;
  IKeyring_io *keyring_io;
  std::string keyring_storage_url;
};

}
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring.h" 2


using keyring::IKeys_container;
using keyring::IKeyring_io;
using keyring::ILogger;
using keyring::IKey;

namespace keyring
{

  extern PSI_memory_key key_memory_KEYRING;
  extern PSI_rwlock_key key_LOCK_keyring;
}

extern mysql_rwlock_t LOCK_keyring;

extern boost::movelib::unique_ptr<IKeys_container> keys;
extern my_bool is_keys_container_initialized;
extern boost::movelib::unique_ptr<ILogger> logger;
extern boost::movelib::unique_ptr<char[]> keyring_file_data;


void keyring_init_psi_keys(void);


my_bool init_keyring_locks();

void update_keyring_file_data(THD* thd __attribute__((unused)),
                              struct st_mysql_sys_var *var __attribute__((unused)),
                              void *var_ptr __attribute__((unused)),
                              const void *save_ptr);

my_bool mysql_key_fetch(boost::movelib::unique_ptr<IKey> key_to_fetch, char **key_type,
                        void **key, size_t *key_len);
my_bool mysql_key_store(boost::movelib::unique_ptr<IKey> key_to_store);
my_bool mysql_key_remove(boost::movelib::unique_ptr<IKey> key_to_remove);

my_bool check_key_for_writting(IKey* key, std::string error_for);

template <typename T>
my_bool mysql_key_fetch(const char *key_id, char **key_type, const char *user_id,
                        void **key, size_t *key_len)
{
  try
  {
    boost::movelib::unique_ptr<IKey> key_to_fetch(new T(key_id, __null, user_id, __null, 0));
    return mysql_key_fetch(::boost::move(key_to_fetch), key_type, key, key_len);
  }
  catch (...)
  {
    if (logger != __null)
      logger->log(MY_ERROR_LEVEL, "Failed to fetch a key due to internal exception inside keyring_okv plugin");
    return (1);
  }
}

template <typename T>
my_bool mysql_key_store(const char *key_id, const char *key_type,
                        const char *user_id, const void *key, size_t key_len)
{
  try
  {
    boost::movelib::unique_ptr<IKey> key_to_store(new T(key_id, key_type, user_id, key, key_len));
    return mysql_key_store(::boost::move(key_to_store));
  }
  catch (...)
  {
    if (logger != __null)
      logger->log(MY_ERROR_LEVEL, "Failed to store a key due to internal exception inside keyring_okv plugin");
    return (1);
  }
}

template <typename T>
my_bool mysql_key_remove(const char *key_id, const char *user_id)
{
  try
  {
    boost::movelib::unique_ptr<IKey> key_to_remove(new T(key_id, __null, user_id, __null, 0));
    return mysql_key_remove(::boost::move(key_to_remove));
  }
  catch (...)
  {
    if (logger != __null)
      logger->log(MY_ERROR_LEVEL, "Failed to remove a key due to internal exception inside keyring_okv plugin");
    return (1);
  }
}
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_io.h" 1
// # 22 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/logger.h" 1
// # 23 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/keyring_memory.h" 1
// # 24 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffer.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffer.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serialized_object.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffer.h" 2

namespace keyring
{

class Buffer : public ISerialized_object
{
public:
  Buffer() : data(__null)
  {
    mark_as_empty();
  }
  Buffer(size_t memory_size) : data(__null)
  {
    reserve(memory_size);
  }
  ~Buffer()
  {
    if(data != __null)
      delete[] data;
  }

  inline void free();
  my_bool get_next_key(IKey **key);
  my_bool has_next_key();
  void reserve(size_t memory_size);

  uchar *data;
  size_t size;
  size_t position;
private:
  Buffer(const Buffer&);
  Buffer& operator=(const Buffer&);

  inline void mark_as_empty()
  {
    size= position= 0;
  }
};

}
// # 25 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/hash_to_buffer_serializer.h" 1
// # 19 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/hash_to_buffer_serializer.h"
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_serializer.h" 1
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/hash_to_buffer_serializer.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/common/i_keyring_key.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/hash_to_buffer_serializer.h" 2


namespace keyring
{
  class Hash_to_buffer_serializer : public ISerializer
  {
  public:
    ISerialized_object* serialize(HASH *keys_hash, IKey *key,
                                  const Key_operation operation);

    void set_memory_needed_for_buffer(size_t memory_needed_for_buffer)
    {
      this->memory_needed_for_buffer= memory_needed_for_buffer;
    }
  protected:
    size_t memory_needed_for_buffer;

    my_bool store_keys_in_buffer(HASH *keys_hash, Buffer *buffer);
    my_bool store_key_in_buffer(const IKey* key, Buffer *buffer);
  };
}
// # 26 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring_stat.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring_stat.h"
namespace keyring
{

typedef struct stat My_stat;
struct Keyring_stat : public My_stat
{
  Keyring_stat() : is_initialized((0))
  {}

  my_bool operator==(const struct stat& stat)
  {
    return st_dev == stat.st_dev &&
           st_ino == stat.st_ino &&
           st_mode == stat.st_mode &&
           st_uid == stat.st_uid &&
           st_gid == stat.st_gid &&
           st_rdev == stat.st_rdev &&
           st_size == stat.st_size &&
           st_mtim.tv_sec == stat.st_mtim.tv_sec;
  }

  my_bool operator!=(const struct stat& stat)
  {
    return !(*this == stat);
  }

  my_bool is_initialized;
};

}
// # 27 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2
// # 1 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/file_io.h" 1
// # 21 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/file_io.h"
namespace keyring
{
  class File_io
  {
  public:
    File_io(ILogger *logger) : logger(logger)
    {}

    File open(PSI_file_key file_data_key, const char *filename, int flags,
              myf myFlags);
    int close(File file, myf myFlags);
    size_t read(File file, uchar *buffer, size_t count, myf myFlags);
    size_t write(File file, const uchar *buffer, size_t count, myf myFlags);
    my_off_t seek(File file, my_off_t pos, int whence, myf flags);
    my_off_t tell(File file, myf flags);
    int fstat(File file, struct stat *stat_area, myf myFlags);
    int sync(File file, myf myFlags);
    my_bool truncate(File file, myf myFlags);
    my_bool remove(const char *filename, myf myFlags);
  protected:
    ILogger *logger;

    void my_warning(int nr, ...);
  };
}
// # 28 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/buffered_file_io.h" 2

namespace keyring {

class Buffered_file_io : public IKeyring_io
{
public:
  Buffered_file_io(ILogger *logger)
    : eofTAG("EOF")
    , file_version("Keyring file version:1.0")
    , logger(logger)
    , backup_exists((0))
    , memory_needed_for_buffer(0)
    , file_io(logger)
  {
    memset(&saved_keyring_stat, 0, sizeof(struct stat));
  }

  my_bool init(std::string *keyring_filename);

  my_bool flush_to_backup(ISerialized_object *serialized_object);
  my_bool flush_to_storage(ISerialized_object *serialized_object);

  ISerializer* get_serializer();
  my_bool get_serialized_object(ISerialized_object **serialized_object);
  my_bool has_next_serialized_object();
protected:
  virtual my_bool remove_backup(myf myFlags);
  virtual my_bool read_keyring_stat(File file);
  virtual my_bool check_keyring_file_stat(File file);
private:
  my_bool recreate_keyring_from_backup_if_backup_exists();

  std::string* get_backup_filename();
  my_bool open_backup_file(File *backup_file);
  my_bool load_file_into_buffer(File file, Buffer *buffer);
  my_bool flush_buffer_to_storage(Buffer *buffer, File file);
  my_bool flush_buffer_to_file(Buffer *buffer, File file);
  inline my_bool check_file_structure(File file, size_t file_size);
  my_bool check_if_keyring_file_can_be_opened_or_created();
  my_bool is_file_tag_correct(File file);
  my_bool is_file_version_correct(File file);

  Keyring_stat saved_keyring_stat;
  std::string keyring_filename;
  std::string backup_filename;
  const std::string eofTAG;
  const std::string file_version;
  ILogger *logger;
  my_bool backup_exists;
  Hash_to_buffer_serializer hash_to_buffer_serializer;
  size_t memory_needed_for_buffer;
  File_io file_io;
};

}
// # 20 "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc" 2







using keyring::Buffered_file_io;
using keyring::Keys_container;
using keyring::Logger;

my_bool create_keyring_dir_if_does_not_exist(const char *keyring_file_path)
{
  if (!keyring_file_path || strlen(keyring_file_path) == 0)
    return (1);
  char keyring_dir[512];
  size_t keyring_dir_length;
  dirname_part(keyring_dir, keyring_file_path, &keyring_dir_length);
  if (keyring_dir_length > 1 &&
      is_directory_separator(keyring_dir[keyring_dir_length-1]))
  {
    keyring_dir[keyring_dir_length-1]= '\0';
    --keyring_dir_length;
  }
  int flags=



    (0400|0200|0100) | (0400 >> 3) | (0100 >> 3)

    ;
  if (strlen(keyring_dir) == 0)
    return (1);
  my_mkdir(keyring_dir, flags, (myf) (0));
  return (0);
}

int check_keyring_file_data(THD* thd __attribute__((unused)),
                            struct st_mysql_sys_var *var __attribute__((unused)),
                            void *save, st_mysql_value *value)
{
  char buff[512 +1];
  const char *keyring_filename;
  int len = sizeof(buff);
  boost::movelib::unique_ptr<IKeys_container> new_keys(new Keys_container(logger.get()));

  (*(const char **) save)= __null;
  keyring_filename= value->val_str(value, buff, &len);
  inline_mysql_rwlock_wrlock(&LOCK_keyring, "/home/quinlan1/ROSE/APPLICATION_TESTS/rose-sh/workspace/mysql/phase_1/mysql-5.7.17/plugin/keyring/keyring.cc", 68);
  if (create_keyring_dir_if_does_not_exist(keyring_filename))
  {
    inline_mysql_rwlock_unlock(&LOCK_keyring);
    logger->log(MY_ERROR_LEVEL, "keyring_file_data cannot be set to new value"
      " as the keyring file cannot be created/accessed in the provided path");
    return 1;
  }
  try
  {
    IKeyring_io *keyring_io(new Buffered_file_io(logger.get()));
    if (new_keys->init(keyring_io, keyring_filename))
    {
      inline_mysql_rwlock_unlock(&LOCK_keyring);
      return 1;
    }
    *reinterpret_cast<IKeys_container **>(save)= new_keys.get();
    new_keys.release();
    inline_mysql_rwlock_unlock(&LOCK_keyring);
  }
  catch (...)
  {
    inline_mysql_rwlock_unlock(&LOCK_keyring);
    return 1;
  }
  return(0);
}

static char *keyring_file_data_value= __null;
static struct { int flags; const char *name; const char *comment; mysql_var_check_func check; mysql_var_update_func update; char * *value; const char * def_val; } mysql_sysvar_data = { 0x0005 | ((0x0000) & (0x0200 | 0x0400 | 0x0800 | 0x1000 | 0x2000 | 0x0000 | 0x8000 | 0x4000)), "data", "The path to the keyring file. Must be specified", check_keyring_file_data, update_keyring_file_data, &keyring_file_data_value, "/usr/local/mysql/keyring""/keyring"}







 ;

static struct st_mysql_sys_var *keyring_file_system_variables[]= {
  ((struct st_mysql_sys_var *)&(mysql_sysvar_data)),
  __null
};

static int keyring_init(MYSQL_PLUGIN plugin_info)
{
  try
  {

    keyring_init_psi_keys();


    if (init_keyring_locks())
      return (1);

    logger.reset(new Logger(plugin_info));
    if (create_keyring_dir_if_does_not_exist(keyring_file_data_value))
    {
      logger->log(MY_ERROR_LEVEL, "Could not create keyring directory "
        "The keyring_file will stay unusable until correct path to the keyring "
        "directory gets provided");
      return (0);
    }
    keys.reset(new Keys_container(logger.get()));
    IKeyring_io *keyring_io= new Buffered_file_io(logger.get());
    if (keys->init(keyring_io, keyring_file_data_value))
    {
      is_keys_container_initialized = (0);
      logger->log(MY_ERROR_LEVEL, "keyring_file initialization failure. Please check"
        " if the keyring_file_data points to readable keyring file or keyring file"
        " can be created in the specified location. "
        "The keyring_file will stay unusable until correct path to the keyring file "
        "gets provided");
      return (0);
    }
    is_keys_container_initialized = (1);
    return (0);
  }
  catch (...)
  {
    if (logger != __null)
      logger->log(MY_ERROR_LEVEL, "keyring_file initialization failure due to internal"
                                  " exception inside the plugin");
    return (1);
  }
}

int keyring_deinit(void *arg __attribute__((unused)))
{


  keys.reset();
  logger.reset();
  keyring_file_data.reset();
  inline_mysql_rwlock_destroy(&LOCK_keyring);
  return 0;
}

my_bool mysql_key_fetch(const char *key_id, char **key_type, const char *user_id,
                        void **key, size_t *key_len)
{
  return mysql_key_fetch<keyring::Key>(key_id, key_type, user_id, key, key_len);
}

my_bool mysql_key_store(const char *key_id, const char *key_type,
                        const char *user_id, const void *key, size_t key_len)
{
  return mysql_key_store<keyring::Key>(key_id, key_type, user_id, key, key_len);
}

my_bool mysql_key_remove(const char *key_id, const char *user_id)
{
  return mysql_key_remove<keyring::Key>(key_id, user_id);
}


my_bool mysql_key_generate(const char *key_id, const char *key_type,
                           const char *user_id, size_t key_len)
{
  try
  {
    boost::movelib::unique_ptr<IKey> key_candidate(new keyring::Key(key_id, key_type, user_id, __null, 0));

    boost::movelib::unique_ptr<uchar[]> key(new uchar[key_len]);
    if (key.get() == __null)
      return (1);
    memset(key.get(), 0, key_len);
    if (is_keys_container_initialized == (0) || check_key_for_writting(key_candidate.get(), "generating") ||
        my_rand_buffer(key.get(), key_len))
      return (1);

    return mysql_key_store(key_id, key_type, user_id, key.get(), key_len) == (1);
  }
  catch (...)
  {
    if (logger != __null)
      logger->log(MY_ERROR_LEVEL, "Failed to generate a key due to internal exception inside keyring_file plugin");
    return (1);
  }
}


static struct st_mysql_keyring keyring_descriptor=
{
  0x0100,
  mysql_key_store,
  mysql_key_fetch,
  mysql_key_remove,
  mysql_key_generate
};

 int _mysql_plugin_interface_version_= 0x0107; int _mysql_sizeof_struct_st_plugin_= sizeof(struct st_mysql_plugin); struct st_mysql_plugin _mysql_plugin_declarations_[]= {
{
  10,
  &keyring_descriptor,
  "keyring_file",
  "Oracle Corporation",
  "store/fetch authentication data to/from a flat file",
  1,
  keyring_init,
  keyring_deinit,
  0x0100,
  __null,
  keyring_file_system_variables,
  __null,
  0,
}
,{0,0,0,0,0,0,0,0,0,0,0,0,0}};
